From 2c41f464e2572066720943e1984e2a24fd1139db Mon Sep 17 00:00:00 2001
From: Stephan Linz <linz@li-pro.net>
Date: Thu, 10 Jun 2010 17:56:05 +0200
Subject: [PATCH] Merge with latest U-BOOT code from PetaLinux v1.1 (2009.08-rc2)

Signed-off-by: Stephan Linz <linz@li-pro.net>
---
 Makefile                                           |    7 +-
 board/petalogix/microblaze-auto/Makefile           |   52 ++
 board/petalogix/microblaze-auto/microblaze-auto.c  |   85 +++
 board/petalogix/microblaze-auto/u-boot.lds         |   71 +++
 board/xilinx/microblaze-generic/config.mk          |   21 +-
 .../xilinx/microblaze-generic/microblaze-generic.c |   16 +
 board/xilinx/microblaze-generic/u-boot.lds         |    3 +
 board/xilinx/microblaze-generic/xparameters.h      |   60 ++-
 common/Makefile                                    |    1 +
 common/cmd_romfs.c                                 |  212 ++++++++
 drivers/net/Makefile                               |    1 +
 drivers/net/xilinx_emaclite.c                      |   42 ++-
 drivers/net/xilinx_ll_temac.c                      |  553 ++++++++++++++++++++
 fs/Makefile                                        |    3 +
 fs/romfs/Makefile                                  |   47 ++
 fs/romfs/romfs.c                                   |  294 +++++++++++
 include/config_cmd_all.h                           |    1 +
 include/configs/microblaze-generic.h               |   15 +
 .../configs/petalogix-microblaze-auto.h.template   |  355 +++++++++++++
 include/image.h                                    |    2 +-
 include/netdev.h                                   |    2 +
 lib_microblaze/board.c                             |   21 +-
 lib_microblaze/bootm.c                             |  100 +++-
 net/bootp.c                                        |    3 +-
 net/eth.c                                          |    3 +-
 petalinux-uboot-config                             |  376 +++++++++++++
 petalinux_config.mk                                |   77 +++
 xmd.ini                                            |    4 +
 28 files changed, 2353 insertions(+), 74 deletions(-)
 create mode 100644 board/petalogix/microblaze-auto/Makefile
 create mode 100644 board/petalogix/microblaze-auto/microblaze-auto.c
 create mode 100644 board/petalogix/microblaze-auto/u-boot.lds
 create mode 100644 common/cmd_romfs.c
 create mode 100644 drivers/net/xilinx_ll_temac.c
 create mode 100644 fs/romfs/Makefile
 create mode 100644 fs/romfs/romfs.c
 create mode 100644 include/configs/petalogix-microblaze-auto.h.template
 create mode 100644 petalinux-uboot-config
 create mode 100644 petalinux_config.mk
 create mode 100644 xmd.ini

diff --git a/Makefile b/Makefile
index 329e0f5..f118cce 100644
--- a/Makefile
+++ b/Makefile
@@ -197,8 +197,8 @@ LIBS += cpu/ixp/npe/libnpe.a
 endif
 LIBS += lib_$(ARCH)/lib$(ARCH).a
 LIBS += fs/cramfs/libcramfs.a fs/fat/libfat.a fs/fdos/libfdos.a fs/jffs2/libjffs2.a \
-	fs/reiserfs/libreiserfs.a fs/ext2/libext2fs.a fs/yaffs2/libyaffs2.a \
-	fs/ubifs/libubifs.a
+	fs/reiserfs/libreiserfs.a fs/romfs/libromfs.a fs/ext2/libext2fs.a \
+	fs/yaffs2/libyaffs2.a fs/ubifs/libubifs.a
 LIBS += net/libnet.a
 LIBS += disk/libdisk.a
 LIBS += drivers/bios_emulator/libatibiosemu.a
@@ -3457,6 +3457,9 @@ suzaku_config:	unconfig
 	@echo "#define CONFIG_SUZAKU 1" > $(obj)include/config.h
 	@$(MKCONFIG) -a $(@:_config=) microblaze microblaze suzaku AtmarkTechno
 
+petalogix-microblaze-auto_config:	unconfig
+	@./mkconfig $(@:_config=) microblaze microblaze microblaze-auto petalogix
+
 #========================================================================
 # Blackfin
 #========================================================================
diff --git a/board/petalogix/microblaze-auto/Makefile b/board/petalogix/microblaze-auto/Makefile
new file mode 100644
index 0000000..00fca7b
--- /dev/null
+++ b/board/petalogix/microblaze-auto/Makefile
@@ -0,0 +1,52 @@
+#
+# (C) Copyright 2000-2006
+# Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+include $(TOPDIR)/config.mk
+
+CONF_FILES=xparameters.h flash-partition.h config.mk
+
+LIB	= $(obj)lib$(BOARD).a
+
+COBJS	= $(BOARD).o
+
+SRCS	:= $(SOBJS:.o=.S) $(COBJS:.o=.c)
+OBJS	:= $(addprefix $(obj),$(COBJS))
+SOBJS	:= $(addprefix $(obj),$(SOBJS))
+
+$(LIB):	$(OBJS) $(SOBJS)
+	$(AR) $(ARFLAGS) $@ $^
+
+clean:
+	rm -f $(SOBJS) $(OBJS) $(CONF_FILES)
+
+distclean:	clean
+	rm -f $(LIB) core *.bak $(obj).depend
+
+#########################################################################
+
+# defines $(obj).depend target
+include $(SRCTREE)/rules.mk
+
+sinclude $(obj).depend
+
+#########################################################################
diff --git a/board/petalogix/microblaze-auto/microblaze-auto.c b/board/petalogix/microblaze-auto/microblaze-auto.c
new file mode 100644
index 0000000..4ad9eb6
--- /dev/null
+++ b/board/petalogix/microblaze-auto/microblaze-auto.c
@@ -0,0 +1,85 @@
+/*
+ * (C) Copyright 2007 Michal Simek
+ *
+ * Michal  SIMEK <monstr@monstr.eu>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+/* This is a board specific file.  It's OK to include board specific
+ * header files */
+
+#include <common.h>
+#include <config.h>
+#include <netdev.h>
+#include <asm/microblaze_intc.h>
+#include <asm/asm.h>
+
+void do_reset (void)
+{
+#ifdef CONFIG_SYS_GPIO_0
+	*((unsigned long *)(CONFIG_SYS_GPIO_0_ADDR)) =
+	    ++(*((unsigned long *)(CONFIG_SYS_GPIO_0_ADDR)));
+#endif
+#ifdef CONFIG_SYS_RESET_ADDRESS
+	puts ("Reseting board\n");
+	asm ("bra r0");
+#endif
+}
+
+int gpio_init (void)
+{
+#ifdef CONFIG_SYS_GPIO_0
+	*((unsigned long *)(CONFIG_SYS_GPIO_0_ADDR)) = 0xFFFFFFFF;
+#endif
+	return 0;
+}
+
+#ifdef CONFIG_SYS_FSL_2
+void fsl_isr2 (void *arg) {
+	volatile int num;
+	*((unsigned int *)(CONFIG_SYS_GPIO_0_ADDR + 0x4)) =
+	    ++(*((unsigned int *)(CONFIG_SYS_GPIO_0_ADDR + 0x4)));
+	GET (num, 2);
+	NGET (num, 2);
+	puts("*");
+}
+
+void fsl_init2 (void) {
+	puts("fsl_init2\n");
+	install_interrupt_handler (FSL_INTR_2,\
+ fsl_isr2,\
+ NULL);
+}
+#endif
+
+int board_eth_init(bd_t *bis)
+{
+	/*
+	 * This board either has PCI NICs or uses the CPU's TSECs
+	 * pci_eth_init() will return 0 if no NICs found, so in that case
+	 * returning -1 will force cpu_eth_init() to be called.
+	 */
+#ifdef CONFIG_XILINX_EMACLITE
+	return xilinx_emaclite_initialize(bis);
+#endif
+#ifdef CONFIG_XILINX_LL_TEMAC
+	return xilinx_ll_temac_initialize(bis);
+#endif
+}
diff --git a/board/petalogix/microblaze-auto/u-boot.lds b/board/petalogix/microblaze-auto/u-boot.lds
new file mode 100644
index 0000000..c20c6dd
--- /dev/null
+++ b/board/petalogix/microblaze-auto/u-boot.lds
@@ -0,0 +1,71 @@
+/*
+ * (C) Copyright 2004 Atmark Techno, Inc.
+ *
+ * Yasushi SHOJI <yashi@atmark-techno.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+OUTPUT_ARCH(microblaze)
+ENTRY(_start)
+
+SECTIONS
+{
+	.text ALIGN(0x4):
+	{
+		__text_start = .;
+		cpu/microblaze/start.o (.text)
+		*(.text)
+		__text_end = .;
+	}
+
+	.rodata ALIGN(0x4):
+	{
+		__rodata_start = .;
+		*(SORT_BY_ALIGNMENT(SORT_BY_NAME(.rodata*)))
+		__rodata_end = .;
+	}
+
+	.data ALIGN(0x4):
+	{
+		__data_start = .;
+		*(.data)
+		__data_end = .;
+	}
+
+	.u_boot_cmd ALIGN(0x4):
+	{
+		. = .;
+		__u_boot_cmd_start = .;
+		*(.u_boot_cmd)
+		__u_boot_cmd_end = .;
+	}
+
+	.bss ALIGN(0x4):
+	{
+		__bss_start = .;
+		*(.sbss)
+		*(.scommon)
+		*(.bss)
+		*(COMMON)
+		. = ALIGN(4);
+		__bss_end = .;
+	}
+	__end = . ;
+}
diff --git a/board/xilinx/microblaze-generic/config.mk b/board/xilinx/microblaze-generic/config.mk
index c75daaf..10b0516 100644
--- a/board/xilinx/microblaze-generic/config.mk
+++ b/board/xilinx/microblaze-generic/config.mk
@@ -1,10 +1,7 @@
 #
-# (C) Copyright 2007 Michal Simek
+# (C) Copyright 2007-2008 Michal Simek
 #
-# Michal  SIMEK <monstr@monstr.eu>
-#
-# See file CREDITS for list of people who contributed to this
-# project.
+# Michal SIMEK <monstr@monstr.eu>
 #
 # This program is free software; you can redistribute it and/or
 # modify it under the terms of the GNU General Public License as
@@ -22,11 +19,15 @@
 # MA 02111-1307 USA
 #
 # CAUTION: This file is automatically generated by libgen.
-# Version: Xilinx EDK 6.3 EDK_Gmm.12.3
+# Version: Xilinx EDK 10.1.03 EDK_K_SP3.6
+# Generate by U-BOOT v4.00.c
 #
 
-TEXT_BASE = 0x29000000
-
-PLATFORM_CPPFLAGS += -mno-xl-soft-mul
-PLATFORM_CPPFLAGS += -mno-xl-soft-div
+PLATFORM_CPPFLAGS += -mxl-pattern-compare
 PLATFORM_CPPFLAGS += -mxl-barrel-shift
+PLATFORM_CPPFLAGS += -mno-xl-soft-div
+PLATFORM_CPPFLAGS += -mxl-soft-mul
+PLATFORM_CPPFLAGS += -mcpu=v7.10.d
+
+TEXT_BASE = 0x91800000
+
diff --git a/board/xilinx/microblaze-generic/microblaze-generic.c b/board/xilinx/microblaze-generic/microblaze-generic.c
index f388b77..4ad9eb6 100644
--- a/board/xilinx/microblaze-generic/microblaze-generic.c
+++ b/board/xilinx/microblaze-generic/microblaze-generic.c
@@ -27,6 +27,7 @@
 
 #include <common.h>
 #include <config.h>
+#include <netdev.h>
 #include <asm/microblaze_intc.h>
 #include <asm/asm.h>
 
@@ -67,3 +68,18 @@ void fsl_init2 (void) {
  NULL);
 }
 #endif
+
+int board_eth_init(bd_t *bis)
+{
+	/*
+	 * This board either has PCI NICs or uses the CPU's TSECs
+	 * pci_eth_init() will return 0 if no NICs found, so in that case
+	 * returning -1 will force cpu_eth_init() to be called.
+	 */
+#ifdef CONFIG_XILINX_EMACLITE
+	return xilinx_emaclite_initialize(bis);
+#endif
+#ifdef CONFIG_XILINX_LL_TEMAC
+	return xilinx_ll_temac_initialize(bis);
+#endif
+}
diff --git a/board/xilinx/microblaze-generic/u-boot.lds b/board/xilinx/microblaze-generic/u-boot.lds
index 5a08680..c20c6dd 100644
--- a/board/xilinx/microblaze-generic/u-boot.lds
+++ b/board/xilinx/microblaze-generic/u-boot.lds
@@ -60,7 +60,10 @@ SECTIONS
 	.bss ALIGN(0x4):
 	{
 		__bss_start = .;
+		*(.sbss)
+		*(.scommon)
 		*(.bss)
+		*(COMMON)
 		. = ALIGN(4);
 		__bss_end = .;
 	}
diff --git a/board/xilinx/microblaze-generic/xparameters.h b/board/xilinx/microblaze-generic/xparameters.h
index fae03bf..6fe1fc7 100644
--- a/board/xilinx/microblaze-generic/xparameters.h
+++ b/board/xilinx/microblaze-generic/xparameters.h
@@ -1,10 +1,7 @@
 /*
- * (C) Copyright 2007 Michal Simek
+ * (C) Copyright 2007-2008 Michal Simek
  *
- * Michal  SIMEK <monstr@monstr.eu>
- *
- * See file CREDITS for list of people who contributed to this
- * project.
+ * Michal SIMEK <monstr@monstr.eu>
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the GNU General Public License as
@@ -22,50 +19,55 @@
  * MA 02111-1307 USA
  *
  * CAUTION: This file is automatically generated by libgen.
- * Version: Xilinx EDK 8.2.02 EDK_Im_Sp2.4
+ * Version: Xilinx EDK 10.1.03 EDK_K_SP3.6
+ * Generate by U-BOOT v4.00.c
+ * Project description at http://www.monstr.eu/uboot/
  */
 
-#define XILINX_BOARD_NAME	microblaze-generic
+#define XILINX_BOARD_NAME	Xilinx-ML505-ll_temac-sgdma-MMU-FDT-edk101
 
 /* System Clock Frequency */
 #define XILINX_CLOCK_FREQ	100000000
 
 /* Microblaze is microblaze_0 */
 #define XILINX_USE_MSR_INSTR	1
-#define XILINX_FSL_NUMBER	3
+#define XILINX_PVR		2
+#define XILINX_FSL_NUMBER	0
+#define XILINX_USE_ICACHE	1
+#define XILINX_USE_DCACHE	1
 
-/* Interrupt controller is opb_intc_0 */
-#define XILINX_INTC_BASEADDR	0x41200000
-#define XILINX_INTC_NUM_INTR_INPUTS	6
+/* Interrupt controller is xps_intc_0 */
+#define XILINX_INTC_BASEADDR		0x81800000
+#define XILINX_INTC_NUM_INTR_INPUTS	9
 
-/* Timer pheriphery is opb_timer_1 */
-#define XILINX_TIMER_BASEADDR	0x41c00000
-#define XILINX_TIMER_IRQ	0
+/* Timer pheriphery is xps_timer_1 */
+#define XILINX_TIMER_BASEADDR	0x83c00000
+#define XILINX_TIMER_IRQ	3
 
-/* Uart pheriphery is RS232_Uart */
-#define XILINX_UARTLITE_BASEADDR	0x40600000
+/* Uart pheriphery is RS232_Uart_1 */
+#define XILINX_UARTLITE_BASEADDR	0x84000000
 #define XILINX_UARTLITE_BAUDRATE	115200
 
 /* IIC pheriphery is IIC_EEPROM */
-#define XILINX_IIC_0_BASEADDR	0x40800000
+#define XILINX_IIC_0_BASEADDR	0x81600000
 #define XILINX_IIC_0_FREQ	100000
 #define XILINX_IIC_0_BIT	0
 
-/* GPIO is LEDs_4Bit*/
-#define XILINX_GPIO_BASEADDR	0x40000000
+/* GPIO is LEDs_8Bit*/
+#define XILINX_GPIO_BASEADDR	0x81400000
 
-/* Flash Memory is FLASH_2Mx32 */
-#define XILINX_FLASH_START	0x2c000000
-#define XILINX_FLASH_SIZE	0x00800000
+/* Main Memory is DDR2_SDRAM */
+#define XILINX_RAM_START	0x90000000
+#define XILINX_RAM_SIZE		0x10000000
 
-/* Main Memory is DDR_SDRAM_64Mx32 */
-#define XILINX_RAM_START	0x28000000
-#define XILINX_RAM_SIZE	0x04000000
+/* Flash Memory is FLASH */
+#define XILINX_FLASH_START	0xa0000000
+#define XILINX_FLASH_SIZE	0x02000000
 
 /* Sysace Controller is SysACE_CompactFlash */
-#define XILINX_SYSACE_BASEADDR	0x41800000
-#define XILINX_SYSACE_HIGHADDR	0x4180ffff
+#define XILINX_SYSACE_BASEADDR	0x83600000
 #define XILINX_SYSACE_MEM_WIDTH	16
 
-/* Ethernet controller is Ethernet_MAC */
-#define XILINX_EMACLITE_BASEADDR       0x40C00000
+/* Ethernet controller is Hard_Ethernet_MAC */
+#define XILINX_LLTEMAC_BASEADDR			0x81c00000
+#define XILINX_LLTEMAC_SDMA_CTRL_BASEADDR	0x84600180
diff --git a/common/Makefile b/common/Makefile
index 3781738..cb11d3c 100644
--- a/common/Makefile
+++ b/common/Makefile
@@ -127,6 +127,7 @@ COBJS-y += cmd_pcmcia.o
 COBJS-$(CONFIG_CMD_PORTIO) += cmd_portio.o
 COBJS-$(CONFIG_CMD_REGINFO) += cmd_reginfo.o
 COBJS-$(CONFIG_CMD_REISER) += cmd_reiser.o
+COBJS-$(CONFIG_CMD_ROMFS) += cmd_romfs.o
 COBJS-$(CONFIG_CMD_SATA) += cmd_sata.o
 COBJS-$(CONFIG_CMD_SF) += cmd_sf.o
 COBJS-$(CONFIG_CMD_SCSI) += cmd_scsi.o
diff --git a/common/cmd_romfs.c b/common/cmd_romfs.c
new file mode 100644
index 0000000..6cdd2bf
--- /dev/null
+++ b/common/cmd_romfs.c
@@ -0,0 +1,212 @@
+/*
+ * (C) Copyright 2008-2009 Michal Simek
+ *
+ * Michal SIMEK <monstr@monstr.eu>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <command.h>
+
+int romfs_check (int info);
+int romfs_load (int *loadoffset, int info, char *filename);
+int romfs_ls (int info, char *filename);
+int romfs_info (int info);
+int romfs_cat (int info, char *filename);
+
+u32 address; /* physical address of fs */
+
+/**
+ * Routine implementing fsload u-boot command. This routine tries to load
+ * a requested file from jffs2/cramfs filesystem on a current partition.
+ *
+ * @param cmdtp command internal data
+ * @param flag command flag
+ * @param argc number of arguments supplied to the command
+ * @param argv arguments list
+ * @return 0 on success, 1 otherwise
+ */
+/* FIXME here is not clean handling with load_addr */
+int do_romfs_fsload(cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
+{
+	char *fsname = NULL;
+	char *filename = NULL;
+	int size = 0;
+
+	ulong offset = 0;
+
+	switch (argc) {
+	case 4:
+		address = simple_strtoul(argv[3], NULL, 16);
+	case 3:
+		filename = argv[2];
+		offset = simple_strtoul(argv[1], NULL, 16);
+		break;
+	default:
+		cmd_usage(cmdtp);
+		return 1;
+	}
+
+	/* check partition type for romfs */
+	if (romfs_check(address))
+		fsname = "ROMFS";
+	else
+		puts ("error\n");
+
+	printf("### %s loading '%s' to 0x%lx\n", fsname, filename, offset);
+
+	if (romfs_check(address))
+		size = romfs_load ((int *) offset, address, filename);
+
+	if (size > 0) {
+		char buf[10];
+		printf("### %s load complete: %d bytes loaded to 0x%lx\n",
+			fsname, size, offset);
+		sprintf(buf, "%x", size);
+		setenv("filesize", buf);
+	} else
+		printf("### %s LOAD ERROR<%x> for %s!\n",
+					fsname, size, filename);
+
+	return !(size > 0);
+}
+
+/**
+ * Routine implementing u-boot ls command which lists content of a given
+ * directory on a current partition.
+ *
+ * @param cmdtp command internal data
+ * @param flag command flag
+ * @param argc number of arguments supplied to the command
+ * @param argv arguments list
+ * @return 0 on success, 1 otherwise
+ */
+int do_romfs_ls (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
+{
+	char *filename = "/";
+	int loc_addr = 0;
+
+	if (argc >= 2)
+		filename = argv[1];
+
+	if (argc > 2)
+		loc_addr = simple_strtoul (argv[2], NULL, 16);
+	else
+		loc_addr = address;
+
+	/* check partition type for cramfs */
+	if (romfs_check (loc_addr)) {
+		address = loc_addr;
+		return (romfs_ls (loc_addr, filename) ? 0 : 1);
+	}
+	return 1;
+}
+
+
+
+/**
+ * Routine implementing u-boot cat command which lists content of a given
+ * directory on a current partition.
+ *
+ * @param cmdtp command internal data
+ * @param flag command flag
+ * @param argc number of arguments supplied to the command
+ * @param argv arguments list
+ * @return 0 on success, 1 otherwise
+ */
+int do_romfs_cat (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
+{
+	char *filename = "/";
+	int loc_addr = 0;
+
+	if (argc >= 2)
+		filename = argv[1];
+
+	if (argc > 2)
+		loc_addr = simple_strtoul (argv[2], NULL, 16);
+	else
+		loc_addr = address;
+
+	/* check partition type for cramfs */
+	if (romfs_check (loc_addr)) {
+		address = loc_addr;
+		return (romfs_cat (loc_addr, filename) ? 0 : 1);
+	}
+	return 1;
+}
+
+
+/**
+ * Routine implementing u-boot fsinfo command. This routine prints out
+ * miscellaneous filesystem informations/statistics.
+ *
+ * @param cmdtp command internal data
+ * @param flag command flag
+ * @param argc number of arguments supplied to the command
+ * @param argv arguments list
+ * @return 0 on success, 1 otherwise
+ */
+int do_romfs_fsinfo(cmd_tbl_t *cmdtp, int flag, int argc, char *argv[])
+{
+	int loc_addr;
+
+	if (argc == 2)
+		loc_addr = simple_strtoul(argv[1], NULL, 16);
+	else
+		loc_addr = address;
+
+	/* check partition type for romfs */
+	if (romfs_check(loc_addr))
+		if (romfs_info (loc_addr)) {
+			address = loc_addr;
+			return 1;
+		}
+	return 0;
+}
+
+/***************************************************/
+U_BOOT_CMD(
+	rload,	4,	0,	do_romfs_fsload,
+	"ROMFS: load binary file from a filesystem image",
+	"[ off filename [fs_addr]]\n"
+	"    - ROMFS: load binary file from flash bank\n"
+	"      with offset 'off'"
+);
+U_BOOT_CMD(
+	rls,	3,	1,	do_romfs_ls,
+	"ROMFS: list files in a directory (default /)",
+	"[directory [fs_addr]]\n"
+	"    - ROMFS: list files in a directory"
+);
+
+U_BOOT_CMD(
+	rcat,	3,	1,	do_romfs_cat,
+	"ROMFS: cat text file (default /)",
+	"[directory [fs_addr]]\n"
+	"    - ROMFS: list files in a directory"
+);
+
+U_BOOT_CMD(
+	rinfo,	2,	1,	do_romfs_fsinfo,
+	"ROMFS: print information about filesystems",
+	"[fs_addr]\n"
+	"    - ROMFS: print information about filesystems"
+);
+/***************************************************/
diff --git a/drivers/net/Makefile b/drivers/net/Makefile
index 34b56d8..53fb739 100644
--- a/drivers/net/Makefile
+++ b/drivers/net/Makefile
@@ -73,6 +73,7 @@ COBJS-$(CONFIG_ULI526X) += uli526x.o
 COBJS-$(CONFIG_VSC7385_ENET) += vsc7385.o
 COBJS-$(CONFIG_XILINX_EMAC) += xilinx_emac.o
 COBJS-$(CONFIG_XILINX_EMACLITE) += xilinx_emaclite.o
+COBJS-$(CONFIG_XILINX_LL_TEMAC) += xilinx_ll_temac.o
 
 COBJS	:= $(COBJS-y)
 SRCS	:= $(COBJS:.o=.c)
diff --git a/drivers/net/xilinx_emaclite.c b/drivers/net/xilinx_emaclite.c
index cf39573..e437d16 100644
--- a/drivers/net/xilinx_emaclite.c
+++ b/drivers/net/xilinx_emaclite.c
@@ -25,6 +25,7 @@
 #include <common.h>
 #include <net.h>
 #include <config.h>
+#include <malloc.h>
 #include <asm/io.h>
 
 #undef DEBUG
@@ -79,7 +80,7 @@ static u8 emacaddr[ENET_ADDR_LENGTH] = { 0x00, 0x0a, 0x35, 0x00, 0x22, 0x01 };
 static u8 emacaddr[ENET_ADDR_LENGTH];
 #endif
 
-void xemaclite_alignedread (u32 * srcptr, void *destptr, unsigned bytecount)
+static void xemaclite_alignedread (u32 * srcptr, void *destptr, unsigned bytecount)
 {
 	unsigned int i;
 	u32 alignbuffer;
@@ -106,7 +107,7 @@ void xemaclite_alignedread (u32 * srcptr, void *destptr, unsigned bytecount)
 	}
 }
 
-void xemaclite_alignedwrite (void *srcptr, u32 destptr, unsigned bytecount)
+static void xemaclite_alignedwrite (void *srcptr, u32 destptr, unsigned bytecount)
 {
 	unsigned i;
 	u32 alignbuffer;
@@ -133,12 +134,12 @@ void xemaclite_alignedwrite (void *srcptr, u32 destptr, unsigned bytecount)
 	*to32ptr++ = alignbuffer;
 }
 
-void eth_halt (void)
+static void emaclite_halt(struct eth_device *dev)
 {
 	debug ("eth_halt\n");
 }
 
-int eth_init (bd_t * bis)
+static int emaclite_init(struct eth_device *dev, bd_t *bis)
 {
 	uchar enetaddr[6];
 
@@ -193,7 +194,7 @@ int eth_init (bd_t * bis)
 	return 0;
 }
 
-int xemaclite_txbufferavailable (xemaclite * instanceptr)
+static int xemaclite_txbufferavailable (xemaclite * instanceptr)
 {
 	u32 reg;
 	u32 txpingbusy;
@@ -215,8 +216,8 @@ int xemaclite_txbufferavailable (xemaclite * instanceptr)
 	return (!(txpingbusy && txpongbusy));
 }
 
-int eth_send (volatile void *ptr, int len) {
-
+static int emaclite_send (struct eth_device *dev, volatile void *ptr, int len)
+{
 	unsigned int reg;
 	unsigned int baseaddress;
 
@@ -292,7 +293,8 @@ int eth_send (volatile void *ptr, int len) {
 	return 0;
 }
 
-int eth_rx (void)
+
+static int emaclite_recv(struct eth_device *dev)
 {
 	unsigned int length;
 	unsigned int reg;
@@ -352,3 +354,27 @@ int eth_rx (void)
 	return 1;
 
 }
+
+
+int xilinx_emaclite_initialize (bd_t *bis)
+{
+	struct eth_device *dev;
+
+	dev = malloc(sizeof(*dev));
+	if (dev == NULL)
+		hang();
+
+	memset(dev, 0, sizeof(*dev));
+	sprintf(dev->name, "Xilinx Emaclite");
+
+	dev->iobase = 0;
+	dev->priv = 0;
+	dev->init = emaclite_init;
+	dev->halt = emaclite_halt;
+	dev->send = emaclite_send;
+	dev->recv = emaclite_recv;
+
+	eth_register(dev);
+
+	return 0;
+}
diff --git a/drivers/net/xilinx_ll_temac.c b/drivers/net/xilinx_ll_temac.c
new file mode 100644
index 0000000..2d08e1a
--- /dev/null
+++ b/drivers/net/xilinx_ll_temac.c
@@ -0,0 +1,553 @@
+/*
+ *
+ * Xilinx xps_ll_temac ethernet driver for u-boot
+ *
+ * Author: Yoshio Kashiwagi kashiwagi@co-nss.co.jp
+ *
+ * Copyright (C) 2008 Nissin Systems Co.,Ltd.
+ * March 2008 created
+ *
+ * Copyright (C) 2008 - 2009 Michal Simek <monstr@monstr.eu>
+ * June 2008 Microblaze optimalization, FIFO mode support
+ * September 2009 Support versions new 2.00 versions
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ *
+ */
+
+#include <config.h>
+#include <common.h>
+#include <net.h>
+#include <malloc.h>
+#include <asm/processor.h>
+#include <asm/io.h>
+
+#ifdef XILINX_LLTEMAC_FIFO_BASEADDR
+# define FIFO_MODE	1
+#elif XILINX_LLTEMAC_SDMA_CTRL_BASEADDR
+# define SDMA_MODE	1
+#else
+# error Xilinx LL Temac: Unsupported mode - Please setup SDMA or FIFO mode
+#endif
+
+#undef ETH_HALTING
+
+#ifdef SDMA_MODE
+/* XPS_LL_TEMAC SDMA registers definition */
+# define TX_NXTDESC_PTR		(((struct ll_priv *)(dev->priv))->sdma + 0x00)
+# define TX_CURBUF_ADDR		(((struct ll_priv *)(dev->priv))->sdma + 0x04)
+# define TX_CURBUF_LENGTH	(((struct ll_priv *)(dev->priv))->sdma + 0x08)
+# define TX_CURDESC_PTR		(((struct ll_priv *)(dev->priv))->sdma + 0x0c)
+# define TX_TAILDESC_PTR	(((struct ll_priv *)(dev->priv))->sdma + 0x10)
+# define TX_CHNL_CTRL		(((struct ll_priv *)(dev->priv))->sdma + 0x14)
+# define TX_IRQ_REG		(((struct ll_priv *)(dev->priv))->sdma + 0x18)
+# define TX_CHNL_STS		(((struct ll_priv *)(dev->priv))->sdma + 0x1c)
+
+# define RX_NXTDESC_PTR		(((struct ll_priv *)(dev->priv))->sdma + 0x20)
+# define RX_CURBUF_ADDR		(((struct ll_priv *)(dev->priv))->sdma + 0x24)
+# define RX_CURBUF_LENGTH	(((struct ll_priv *)(dev->priv))->sdma + 0x28)
+# define RX_CURDESC_PTR		(((struct ll_priv *)(dev->priv))->sdma + 0x2c)
+# define RX_TAILDESC_PTR	(((struct ll_priv *)(dev->priv))->sdma + 0x30)
+# define RX_CHNL_CTRL		(((struct ll_priv *)(dev->priv))->sdma + 0x34)
+# define RX_IRQ_REG		(((struct ll_priv *)(dev->priv))->sdma + 0x38)
+# define RX_CHNL_STS		(((struct ll_priv *)(dev->priv))->sdma + 0x3c)
+
+# define DMA_CONTROL_REG	(((struct ll_priv *)(dev->priv))->sdma + 0x40)
+#endif
+
+/* XPS_LL_TEMAC direct registers definition */
+#define TEMAC_RAF0		(dev->iobase + 0x00)
+#define TEMAC_TPF0		(dev->iobase + 0x04)
+#define TEMAC_IFGP0		(dev->iobase + 0x08)
+#define TEMAC_IS0		(dev->iobase + 0x0c)
+#define TEMAC_IP0		(dev->iobase + 0x10)
+#define TEMAC_IE0		(dev->iobase + 0x14)
+
+#define TEMAC_MSW0		(dev->iobase + 0x20)
+#define TEMAC_LSW0		(dev->iobase + 0x24)
+#define TEMAC_CTL0		(dev->iobase + 0x28)
+#define TEMAC_RDY0		(dev->iobase + 0x2c)
+
+#define XTE_RSE_MIIM_RR_MASK	0x0002
+#define XTE_RSE_MIIM_WR_MASK	0x0004
+#define XTE_RSE_CFG_RR_MASK	0x0020
+#define XTE_RSE_CFG_WR_MASK	0x0040
+
+/* XPS_LL_TEMAC indirect registers offset definition */
+
+#define RCW0	0x200
+#define RCW1	0x240
+#define TC	0x280
+#define FCC	0x2c0
+#define EMMC	0x300
+#define PHYC	0x320
+#define MC	0x340
+#define UAW0	0x380
+#define UAW1	0x384
+#define MAW0	0x388
+#define MAW1	0x38c
+#define AFM	0x390
+#define TIS	0x3a0
+#define TIE	0x3a4
+#define MIIMWD	0x3b0
+#define MIIMAI	0x3b4
+
+#define CNTLREG_WRITE_ENABLE_MASK	0x8000
+#define CNTLREG_EMAC1SEL_MASK		0x0400
+#define CNTLREG_ADDRESSCODE_MASK	0x03ff
+
+#define MDIO_ENABLE_MASK	0x40
+#define MDIO_CLOCK_DIV_MASK	0x3F
+#define MDIO_CLOCK_DIV_100MHz	0x28
+
+#define ETHER_MTU		1520
+
+#ifdef SDMA_MODE
+/* CDMAC descriptor status bit definitions */
+# define BDSTAT_ERROR_MASK		0x80
+# define BDSTAT_INT_ON_END_MASK		0x40
+# define BDSTAT_STOP_ON_END_MASK	0x20
+# define BDSTAT_COMPLETED_MASK		0x10
+# define BDSTAT_SOP_MASK		0x08
+# define BDSTAT_EOP_MASK		0x04
+# define BDSTAT_CHANBUSY_MASK		0x02
+# define BDSTAT_CHANRESET_MASK		0x01
+
+/* SDMA Buffer Descriptor */
+
+typedef struct cdmac_bd_t {
+	struct cdmac_bd_t *next_p;
+	unsigned char *phys_buf_p;
+	unsigned long buf_len;
+	unsigned char stat;
+	unsigned char app1_1;
+	unsigned short app1_2;
+	unsigned long app2;
+	unsigned long app3;
+	unsigned long app4;
+	unsigned long app5;
+} cdmac_bd __attribute((aligned(32))) ;
+
+static cdmac_bd	tx_bd;
+static cdmac_bd	rx_bd;
+#endif
+
+#ifdef FIFO_MODE
+typedef struct ll_fifo_s {
+	int isr; /* Interrupt Status Register 0x0 */
+	int ier; /* Interrupt Enable Register 0x4 */
+	int tdfr; /* Transmit data FIFO reset 0x8 */
+	int tdfv; /* Transmit data FIFO Vacancy 0xC */
+	int tdfd; /* Transmit data FIFO 32bit wide data write port 0x10 */
+	int tlf; /* Write Transmit Length FIFO 0x14 */
+	int rdfr; /* Read Receive data FIFO reset 0x18 */
+	int rdfo; /* Receive data FIFO Occupancy 0x1C */
+	int rdfd; /* Read Receive data FIFO 32bit wide data read port 0x20 */
+	int rlf; /* Read Receive Length FIFO 0x24 */
+	int llr; /* Read LocalLink reset 0x28 */
+} ll_fifo_s;
+
+ll_fifo_s *ll_fifo = (ll_fifo_s *) (XILINX_LLTEMAC_FIFO_BASEADDR);
+#endif
+
+static unsigned char tx_buffer[ETHER_MTU] __attribute((aligned(32)));
+static unsigned char rx_buffer[ETHER_MTU] __attribute((aligned(32)));
+
+struct ll_priv {
+	unsigned int sdma;
+};
+
+#ifdef DEBUG
+/* undirect hostif write to ll_temac */
+static void xps_ll_temac_hostif_set(struct eth_device *dev, int emac,
+			int phy_addr, int reg_addr, int phy_data)
+{
+	out_be32((u32 *)TEMAC_LSW0, phy_data);
+	out_be32((u32 *)TEMAC_CTL0, CNTLREG_WRITE_ENABLE_MASK | MIIMWD);
+	out_be32((u32 *)TEMAC_LSW0, (phy_addr << 5) | (reg_addr));
+	out_be32((u32 *)TEMAC_CTL0, \
+			CNTLREG_WRITE_ENABLE_MASK | MIIMAI | (emac << 10));
+	while(! (in_be32((u32 *)TEMAC_RDY0) & XTE_RSE_MIIM_WR_MASK));
+}
+#endif
+
+/* undirect hostif read from ll_temac */
+static unsigned int xps_ll_temac_hostif_get(struct eth_device *dev,
+			int emac, int phy_addr, int reg_addr)
+{
+	out_be32((u32 *)TEMAC_LSW0, (phy_addr << 5) | (reg_addr));
+	out_be32((u32 *)TEMAC_CTL0, MIIMAI | (emac << 10));
+	while(! (in_be32((u32 *)TEMAC_RDY0) & XTE_RSE_MIIM_RR_MASK));
+	return in_be32((u32 *)TEMAC_LSW0);
+}
+
+/* undirect write to ll_temac */
+static void xps_ll_temac_indirect_set(struct eth_device *dev,
+				int emac, int reg_offset, int reg_data)
+{
+	out_be32((u32 *)TEMAC_LSW0, reg_data);
+	out_be32((u32 *)TEMAC_CTL0, \
+			CNTLREG_WRITE_ENABLE_MASK | (emac << 10) | reg_offset);
+	while(! (in_be32((u32 *)TEMAC_RDY0) & XTE_RSE_CFG_WR_MASK));
+}
+
+#if DEBUG
+/* undirect read from ll_temac */
+static int xps_ll_temac_indirect_get(struct eth_device *dev,
+			int emac, int reg_offset)
+{
+	out_be32((u32 *)TEMAC_CTL0, (emac << 10) | reg_offset);
+	while(! (in_be32((u32 *)TEMAC_RDY0) & XTE_RSE_CFG_RR_MASK));
+	return in_be32((u32 *)TEMAC_LSW0);
+}
+#endif
+
+#ifdef DEBUG
+/* read from phy */
+static void read_phy_reg (struct eth_device *dev, int phy_addr)
+{
+	int j, result;
+	debug ("phy%d ",phy_addr);
+	for ( j = 0; j < 32; j++) {
+		result = xps_ll_temac_hostif_get(dev, 0, phy_addr, j);
+		debug ("%d: 0x%x ", j, result);
+	}
+	debug ("\n");
+}
+#endif
+
+static int phy_addr = -1;
+static int link = 0;
+
+/* setting ll_temac and phy to proper setting */
+static int xps_ll_temac_phy_ctrl(struct eth_device *dev)
+{
+	int i;
+	unsigned int result;
+	unsigned retries = 10;
+
+	if(link == 1)
+		return 1; /* link is setup */
+
+	/* wait for link up */
+	while (retries-- &&
+		((xps_ll_temac_hostif_get(dev, 0, phy_addr, 1) & 0x24) == 0x24))
+		;
+
+	if(phy_addr == -1) {
+		for(i = 31; i >= 0; i--) {
+			result = xps_ll_temac_hostif_get(dev, 0, i, 1);
+			if((result & 0x0ffff) != 0x0ffff) {
+				debug ("phy %x result %x\n", i, result);
+				phy_addr = i;
+				break;
+			}
+		}
+	}
+
+	/* get PHY id */
+	i = (xps_ll_temac_hostif_get(dev, 0, phy_addr, 2) << 16) | \
+		xps_ll_temac_hostif_get(dev, 0, phy_addr, 3);
+	debug ("LL_TEMAC: Phy ID 0x%x\n", i);
+
+#ifdef DEBUG
+	xps_ll_temac_hostif_set(dev, 0, 0, 0, 0x8000); /* phy reset */
+#endif
+	/* FIXME this part will be replaced by PHY lib */
+	/* s3e boards */
+	if (i == 0x7c0a3) {
+		/* 100BASE-T/FD */
+		xps_ll_temac_indirect_set(dev, 0, EMMC, 0x40000000);
+		link = 1;
+		return 1;
+	}
+
+	result = xps_ll_temac_hostif_get(dev, 0, phy_addr, 5);
+	if((result & 0x8000) == 0x8000) {
+		xps_ll_temac_indirect_set(dev, 0, EMMC, 0x80000000);
+		printf("1000BASE-T/FD\n");
+		link = 1;
+	} else if((result & 0x4000) == 0x4000) {
+		xps_ll_temac_indirect_set(dev, 0, EMMC, 0x40000000);
+		printf("100BASE-T/FD\n");
+		link = 1;
+	} else {
+		printf("Unsupported mode\n");
+		link = 0;
+		return 0;
+	}
+	return 1;
+}
+
+#ifdef SDMA_MODE
+/* bd init */
+static void xps_ll_temac_bd_init(struct eth_device *dev)
+{
+	memset((void *)&tx_bd, 0, sizeof(cdmac_bd));
+	memset((void *)&rx_bd, 0, sizeof(cdmac_bd));
+
+	rx_bd.phys_buf_p = &rx_buffer[0];
+
+	rx_bd.next_p = &rx_bd;
+	rx_bd.buf_len = ETHER_MTU;
+	flush_cache((u32)&rx_bd, sizeof(cdmac_bd));
+
+	out_be32((u32 *)RX_CURDESC_PTR, (u32)&rx_bd);
+	out_be32((u32 *)RX_TAILDESC_PTR, (u32)&rx_bd);
+	out_be32((u32 *)RX_NXTDESC_PTR, (u32)&rx_bd); /* setup first fd */
+
+	tx_bd.phys_buf_p = &tx_buffer[0];
+	tx_bd.next_p = &tx_bd;
+
+	flush_cache((u32)&tx_bd, sizeof(cdmac_bd));
+	out_be32((u32 *)TX_CURDESC_PTR, (u32)&tx_bd);
+}
+
+static int xps_ll_temac_send_sdma(struct eth_device *dev,
+				unsigned char *buffer, int length)
+{
+	if( xps_ll_temac_phy_ctrl(dev) == 0)
+		return 0;
+
+	memcpy (tx_buffer, buffer, length);
+	flush_cache ((u32)tx_buffer, length);
+
+	tx_bd.stat = BDSTAT_SOP_MASK | BDSTAT_EOP_MASK | \
+			BDSTAT_STOP_ON_END_MASK;
+	tx_bd.buf_len = length;
+	flush_cache ((u32)&tx_bd, sizeof(cdmac_bd));
+
+	out_be32((u32 *)TX_CURDESC_PTR, (u32)&tx_bd);
+	out_be32((u32 *)TX_TAILDESC_PTR, (u32)&tx_bd); /* DMA start */
+
+	do {
+		flush_cache ((u32)&tx_bd, sizeof(cdmac_bd));
+	} while(!(((volatile int)tx_bd.stat) & BDSTAT_COMPLETED_MASK));
+
+	return length;
+}
+
+
+static int xps_ll_temac_recv_sdma(struct eth_device *dev)
+{
+	int length;
+
+	flush_cache ((u32)&rx_bd, sizeof(cdmac_bd));
+
+	if(!(rx_bd.stat & BDSTAT_COMPLETED_MASK)) {
+		return 0;
+	}
+
+	length = rx_bd.app5 & 0x3FFF;
+	flush_cache ((u32)rx_bd.phys_buf_p, length);
+
+	rx_bd.buf_len = ETHER_MTU;
+	rx_bd.stat = 0;
+	rx_bd.app5 = 0;
+
+	flush_cache ((u32)&rx_bd, sizeof(cdmac_bd));
+	out_be32((u32 *)RX_TAILDESC_PTR, (u32)&rx_bd);
+
+	if(length > 0) {
+		NetReceive(rx_bd.phys_buf_p, length);
+	}
+
+	return length;
+}
+#endif
+
+#ifdef FIFO_MODE
+static void debugll(int count)
+{
+	printf ("%d fifo isr 0x%08x, fifo_ier 0x%08x, fifo_rdfr 0x%08x, "
+		"fifo_rdfo 0x%08x fifo_rlr 0x%08x\n",count, ll_fifo->isr, \
+		ll_fifo->ier, ll_fifo->rdfr, ll_fifo->rdfo, ll_fifo->rlf);
+}
+
+static int xps_ll_temac_send_fifo(unsigned char *buffer, int length)
+{
+	u32 *buf = buffer;
+	u32 len, i, val;
+
+	len = (length / 4) + 1;
+
+	for (i = 0; i < len; i++) {
+		val = *buf++;
+		ll_fifo->tdfd = val;
+	}
+
+	ll_fifo->tlf = length;
+
+	return length;
+}
+
+static int xps_ll_temac_recv_fifo()
+{
+	int len, len2, i, val;
+	int *buf;
+	buf = &rx_buffer;
+
+	if (ll_fifo->isr & 0x04000000 ) {
+		ll_fifo->isr = 0xffffffff; /* reset isr */
+
+		/* while (ll_fifo->isr); */
+		len = ll_fifo->rlf & 0x7FF;
+		len2 = (len / 4) + 1;
+
+		for (i = 0; i < len2; i++) {
+			val = ll_fifo->rdfd;
+			*buf++ = val ;
+		}
+
+		/* debugll(1); */
+		NetReceive (&rx_buffer, len);
+	}
+	return 0;
+}
+#endif
+
+/* setup mac addr */
+static int xps_ll_temac_addr_setup(struct eth_device *dev)
+{
+	int val;
+
+	/* set up unicast MAC address filter */
+	val = ((dev->enetaddr[3] << 24) | (dev->enetaddr[2] << 16) |
+		(dev->enetaddr[1] << 8) | (dev->enetaddr[0] ));
+	xps_ll_temac_indirect_set(dev, 0, UAW0, val);
+	val = (dev->enetaddr[5] << 8) | dev->enetaddr[4] ;
+	xps_ll_temac_indirect_set(dev, 0, UAW1, val);
+
+	return 0;
+}
+
+static int xps_ll_temac_init(struct eth_device *dev, bd_t *bis)
+{
+#ifdef SDMA_MODE
+	xps_ll_temac_bd_init(dev);
+#endif
+#ifdef FIFO_MODE
+	ll_fifo->tdfr = 0x000000a5; /* set fifo length */
+	ll_fifo->rdfr = 0x000000a5;
+
+	/* ll_fifo->isr = 0x0; */
+	/* ll_fifo->ier = 0x0; */
+#endif
+	xps_ll_temac_indirect_set(dev, 0, MC,
+				MDIO_ENABLE_MASK | MDIO_CLOCK_DIV_100MHz);
+
+	xps_ll_temac_addr_setup(dev);
+	/* Promiscuous mode disable */
+	xps_ll_temac_indirect_set(dev, 0, AFM, 0x00000000);
+	/* Enable Receiver */
+	xps_ll_temac_indirect_set(dev, 0, RCW1, 0x10000000);
+	/* Enable Transmitter */
+	xps_ll_temac_indirect_set(dev, 0, TC, 0x10000000);
+	return 0;
+}
+
+
+static void xps_ll_temac_halt(struct eth_device *dev)
+{
+#ifdef ETH_HALTING
+	/* Disable Receiver */
+	xps_ll_temac_indirect_set(dev, 0, RCW1, 0x00000000);
+	/* Disable Transmitter */
+	xps_ll_temac_indirect_set(dev, 0, TC, 0x00000000);
+
+#ifdef SDMA_MODE
+	out_be32((u32 *)DMA_CONTROL_REG, 0x00000001);
+	while(in_be32((u32 *)DMA_CONTROL_REG) & 1);
+#endif
+#ifdef FIFO_MODE
+	/* reset fifos */
+#endif
+#endif
+}
+
+
+/* halt device */
+static void ll_temac_halt(struct eth_device *dev)
+{
+	link = 0;
+	xps_ll_temac_halt(dev);
+}
+
+static int ll_temac_init(struct eth_device *dev, bd_t *bis)
+{
+	static int first = 1;
+#if DEBUG
+	int i;
+#endif
+	if(!first)
+		return 0;
+	first = 0;
+
+	xps_ll_temac_init(dev, bis);
+
+	printf("%s: Xilinx XPS LocalLink Tri-Mode Ether MAC #%d at 0x%08X.\n",
+		dev->name, 0, XILINX_LLTEMAC_BASEADDR);
+
+#if DEBUG
+	for(i = 0; i < 32; i++) {
+		read_phy_reg(dev, i);
+	}
+#endif
+	xps_ll_temac_phy_ctrl(dev);
+	return 1;
+}
+
+
+static int ll_temac_send(struct eth_device *dev, volatile void *packet,
+		int length)
+{
+#ifdef SDMA_MODE
+	return xps_ll_temac_send_sdma(dev, (unsigned char *)packet, length);
+#endif
+#ifdef FIFO_MODE
+	return xps_ll_temac_send_fifo((unsigned char *)packet, length);
+#endif
+}
+
+static int ll_temac_recv(struct eth_device *dev)
+{
+#ifdef SDMA_MODE
+	return xps_ll_temac_recv_sdma(dev);
+#endif
+#ifdef FIFO_MODE
+	return xps_ll_temac_recv_fifo();
+#endif
+}
+
+int xilinx_ll_temac_initialize (bd_t *bis)
+{
+	struct eth_device *dev;
+
+	dev = calloc(1, sizeof(*dev));
+	if (dev == NULL)
+		hang();
+
+	dev->priv = (struct ll_priv *)
+			calloc(1, sizeof(struct ll_priv));
+
+	if (dev->priv == NULL)
+		hang();
+
+	sprintf(dev->name, "Xilinx LL TEMAC");
+
+	dev->iobase = XILINX_LLTEMAC_BASEADDR;
+	((struct ll_priv *)(dev->priv))->sdma =
+					XILINX_LLTEMAC_SDMA_CTRL_BASEADDR;
+
+	dev->init = ll_temac_init;
+	dev->halt = ll_temac_halt;
+	dev->send = ll_temac_send;
+	dev->recv = ll_temac_recv;
+
+	eth_register(dev);
+
+	return 0;
+}
diff --git a/fs/Makefile b/fs/Makefile
index 22aad12..7980678 100644
--- a/fs/Makefile
+++ b/fs/Makefile
@@ -30,9 +30,12 @@ subdirs-$(CONFIG_CMD_JFFS2) += jffs2
 subdirs-$(CONFIG_CMD_REISER) += reiserfs
 subdirs-$(CONFIG_YAFFS2) += yaffs2
 subdirs-$(CONFIG_CMD_UBIFS) += ubifs
+subdirs-$(CONFIG_CMD_ROMFS) += romfs
 
 SUBDIRS	:= $(subdirs-y)
 
 $(obj).depend all:
+	@echo $(SUBDIRS)
 	@for dir in $(SUBDIRS) ; do \
 		$(MAKE) -C $$dir $@ ; done
+	$(MAKE) -C romfs $@
diff --git a/fs/romfs/Makefile b/fs/romfs/Makefile
new file mode 100644
index 0000000..5ba72cc
--- /dev/null
+++ b/fs/romfs/Makefile
@@ -0,0 +1,47 @@
+#
+# (C) Copyright 2000-2006
+# Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+include $(TOPDIR)/config.mk
+
+LIB	= $(obj)libromfs.a
+
+COBJS-y += romfs.o
+
+COBJS	:= $(COBJS-y)
+SRCS	:= $(COBJS:.o=.c)
+OBJS	:= $(addprefix $(obj),$(COBJS))
+
+all:	$(LIB)
+
+$(LIB):	$(obj).depend $(OBJS)
+	echo ahoj
+	$(AR) $(ARFLAGS) $@ $(OBJS)
+
+#########################################################################
+
+# defines $(obj).depend target
+include $(SRCTREE)/rules.mk
+
+sinclude $(obj).depend
+
+#########################################################################
diff --git a/fs/romfs/romfs.c b/fs/romfs/romfs.c
new file mode 100644
index 0000000..ef7d8df
--- /dev/null
+++ b/fs/romfs/romfs.c
@@ -0,0 +1,294 @@
+/*
+ * (C) Copyright 2007 Michal Simek
+ *
+ * Michal SIMEK <monstr@monstr.eu>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <asm/byteorder.h>
+
+/* ROMFS superblock */
+struct romfs_super {
+	u32 word0;
+	u32 word1;
+	u32 size;
+	u32 checksum;
+	char name[0];
+};
+
+struct romfs_inode {
+	u32 next;
+	u32 spec;
+	u32 size;
+	u32 checksum;
+	char name[0];
+};
+
+#undef DEBUG_ROMFS
+
+#define ROMFS_ALIGN(x)	(((x) & 0xfffffff0))
+#define HEADERSIZE(name)	(0x20 + ROMFS_ALIGN(strlen(name)))
+
+/* find romfs inode */
+static unsigned long romfs_resolve (unsigned long begin, unsigned long offset,
+				unsigned long size, int raw, char *filename)
+{
+	unsigned long inodeoffset = 0, nextoffset;
+	struct romfs_inode *inode;
+#ifdef DEBUG_ROMFS
+	printf ("ROMFS_resolve: begin 0x%lx, offset 0x%lx, size 0x%lx, "
+		"raw 0x%x, filename %s\n\n",
+					begin, offset, size, raw, filename);
+#endif
+
+	while (inodeoffset < size) {
+		inode = (struct romfs_inode *)(begin + offset + inodeoffset);
+		nextoffset = ROMFS_ALIGN(inode->next);
+#ifdef DEBUG_ROMFS
+		printf("inode 0x%x, name %s - len 0x%x, next inode 0x%lx,"
+			"compare names 0x%x\n", (u32)inode, inode->name,
+			strlen (inode->name), nextoffset,
+			strncmp (filename, inode->name, strlen (filename)));
+#endif
+		if (!strncmp (filename, inode->name, strlen (inode->name))) {
+			char *p = strtok (NULL, "/");
+
+			if (raw && (p == NULL || *p == '\0'))
+				return offset + inodeoffset;
+
+			return romfs_resolve (begin,
+					inodeoffset + HEADERSIZE (inode->name),
+					size, raw, p);
+		}
+		inodeoffset = nextoffset;
+		offset = 0; /* clear offset at the end because first label */
+	}
+
+	printf ("Can't find corresponding entry\n");
+	return 0;
+}
+
+int romfs_load (char *loadoffset, int info, char *filename)
+{
+	struct romfs_inode *inode;
+	struct romfs_super *sb;
+	char *data;
+	int pocet;
+	unsigned long offset;
+
+	sb = (struct romfs_super *) info;
+
+	offset = romfs_resolve (info, HEADERSIZE (sb->name),
+				sb->size, 1, strtok (filename, "/"));
+	if (offset <= 0)
+		return offset;
+
+	inode = (struct romfs_inode *)(info + offset);
+	data = (char *)((int)inode + HEADERSIZE (inode->name));
+	pocet = inode->size;
+	while (pocet--)
+		*loadoffset++ = *data++;
+
+	return inode->size;
+}
+
+static int romfs_list_inode (int info, unsigned long offset)
+{
+	struct romfs_inode *inode =
+			(struct romfs_inode *)(info + offset);
+	struct romfs_inode *hardlink = NULL;
+	char str[3], *data;
+
+/*	mapping		spec.info means
+ 0	hard link	link destination [file header]
+ 1	directory	first file's header
+ 2	regular file	unused, must be zero [MBZ]
+ 3	symbolic link	unused, MBZ (file data is the link content)
+ 4	block device	16/16 bits major/minor number
+ 5	char device		- " -
+ 6	socket		unused, MBZ
+ 7	fifo		unused, MBZ */
+
+	switch (inode->next & 0x7) {
+	case 0:
+		str[0] = 'h';
+		break;
+	case 1:
+		str[0] = 'd';
+		break;
+	case 2:
+		str[0] = 'f';
+		break;
+	case 3:
+		str[0] = 'l';
+		break;
+	case 4:
+		str[0] = 'b';
+		break;
+	case 5:
+		str[0] = 'c';
+		break;
+	case 6:
+		str[0] = 's';
+		break;
+	case 7:
+		str[0] = 'p';
+		break;
+	default:
+		str[0] = '?';
+	}
+
+	if (inode->next & 0x8) {
+		str[1] = 'x';
+	} else {
+		str[1] = '-';
+	}
+	str[2] = '\0';
+
+	if ((str[0] == 'b') || (str[0] == 'c')) {
+#ifdef DEBUG_ROMFS
+		printf (" %s  %3d,%3d %12s 0x%08x 0x%08x", str,
+			(inode->spec & 0xffff0000) >> 16,
+			inode->spec & 0x0000ffff, inode->name, (u32)inode,
+			inode->spec);
+#else
+		printf (" %s  %3d,%3d %12s", str,
+			(inode->spec & 0xffff0000) >> 16,
+			inode->spec & 0x0000ffff, inode->name);
+
+#endif
+	} else {
+#ifdef DEBUG_ROMFS
+		printf (" %s  %7d %12s 0x%08x 0x%08x", str, inode->size,
+			inode->name, (u32)inode, inode->spec);
+#else
+		printf (" %s  %7d %12s", str, inode->size, inode->name);
+#endif
+		if (str[0] == 'l') {
+			data = (char *)((int)inode + HEADERSIZE (inode->name));
+			puts (" -> ");
+			puts (data);
+		}
+		if (str[0] == 'h') {
+			hardlink = (struct romfs_inode *)(info + inode->spec);
+			puts (" -> ");
+			puts (hardlink->name);
+		}
+	}
+	puts ("\n");
+	return ROMFS_ALIGN(inode->next);
+}
+
+/* listing directory */
+int romfs_ls (int info, char *filename)
+{
+	struct romfs_inode *inode;
+	struct romfs_super *sb;
+	unsigned long inodeoffset = 0, nextoffset;
+	unsigned long size;
+
+	sb = (struct romfs_super *) info;
+	inode = (struct romfs_inode *) info;
+
+	if ((strlen (filename) != 0) && strcmp (filename, "/")) {
+		inodeoffset = romfs_resolve (info,
+			HEADERSIZE (sb->name), sb->size, 1,
+			strtok (filename, "/"));
+
+		/* inode not found */
+		if (inodeoffset == 0)
+			return 0;
+
+		/* look at what is it */
+		inode = (struct romfs_inode *)(info + inodeoffset);
+		if ((inode->next & 0x7) != 1)
+			return (romfs_list_inode (info, inodeoffset) > 0);
+	}
+
+	/* print directory */
+	size = sb->size;
+	inodeoffset = inodeoffset + HEADERSIZE (inode->name);
+
+	while (inodeoffset < size) {
+		nextoffset = romfs_list_inode (info, inodeoffset);
+		if (nextoffset == 0)
+			break;
+		inodeoffset = nextoffset;
+	}
+	return 1;
+}
+
+/* cat file */
+int romfs_cat (int info, char *filename)
+{
+	struct romfs_inode *inode;
+	struct romfs_super *sb;
+	unsigned long inodeoffset = 0;
+	char *data;
+
+	sb = (struct romfs_super *) info;
+	inode = (struct romfs_inode *) info;
+
+	if ((strlen (filename) != 0) && strcmp (filename, "/")) {
+		inodeoffset = romfs_resolve (info,
+			HEADERSIZE (sb->name), sb->size, 1,
+			strtok (filename, "/"));
+
+		/* inode not found */
+		if (inodeoffset == 0)
+			return 0;
+
+		/* look at what it is */
+		inode = (struct romfs_inode *)(info + inodeoffset);
+		if ((inode->next & 0x7) == 2) {
+			data =(char *) (info + inodeoffset +
+					(u32)HEADERSIZE (inode->name));
+			printf("%s\n", data);
+			return 1;
+		}
+	}
+	return 0;
+}
+
+int romfs_info (int info)
+{
+	struct romfs_super *sb;
+	sb = (struct romfs_super *)info;
+
+	printf ("name: \t\t%s, len %d B\n", sb->name, strlen (sb->name));
+	printf ("size of SB:\t%d B\n", HEADERSIZE (sb->name));
+	printf ("full size:\t%d B\n", sb->size);
+	printf ("checksum:\t0x%x\n", sb->checksum);
+	printf ("fs address:\t0x%x\n", (u32)sb);
+	return 1;
+}
+
+int romfs_check (int info)
+{
+	struct romfs_super *sb;
+
+	sb = (struct romfs_super *) info;
+
+	if ((sb->word0 != 0x2D726F6D) || (sb->word1 != 0x3166732D))
+		return 0;
+
+	return 1;
+}
diff --git a/include/config_cmd_all.h b/include/config_cmd_all.h
index c747b4b..b42c1f6 100644
--- a/include/config_cmd_all.h
+++ b/include/config_cmd_all.h
@@ -68,6 +68,7 @@
 #define CONFIG_CMD_PORTIO	/* Port I/O			*/
 #define CONFIG_CMD_REGINFO	/* Register dump		*/
 #define CONFIG_CMD_REISER	/* Reiserfs support		*/
+#define CONFIG_CMD_ROMFS	/* ROMFS support		*/
 #define CONFIG_CMD_RUN		/* run command in env variable	*/
 #define CONFIG_CMD_SAVES	/* save S record dump		*/
 #define CONFIG_CMD_SCSI		/* SCSI Support			*/
diff --git a/include/configs/microblaze-generic.h b/include/configs/microblaze-generic.h
index 72715f6..9a30525 100644
--- a/include/configs/microblaze-generic.h
+++ b/include/configs/microblaze-generic.h
@@ -224,6 +224,8 @@
 #define CONFIG_CMD_MFSL
 #define CONFIG_CMD_ECHO
 
+#define CONFIG_CMD_ROMFS
+
 #if defined(CONFIG_DCACHE) || defined(CONFIG_ICACHE)
 	#define CONFIG_CMD_CACHE
 #else
@@ -232,8 +234,10 @@
 
 #ifndef CONFIG_SYS_ENET
 	#undef CONFIG_CMD_NET
+	#undef CONFIG_NET_MULTI
 #else
 	#define CONFIG_CMD_PING
+	#define CONFIG_NET_MULTI
 #endif
 
 #if defined(CONFIG_SYSTEMACE)
@@ -301,4 +305,15 @@
 
 #define CONFIG_CMDLINE_EDITING
 
+/* Use the HUSH parser */
+#define CONFIG_SYS_HUSH_PARSER
+#ifdef  CONFIG_SYS_HUSH_PARSER
+#define CONFIG_SYS_PROMPT_HUSH_PS2 "> "
+#endif
+
+#define CONFIG_FIT		1
+#define CONFIG_OF_LIBFDT	1
+
+#define   CONFIG_SYS_BOOTMAPSZ	(1 << 31) /* Initial Memory map for Linux */
+
 #endif	/* __CONFIG_H */
diff --git a/include/configs/petalogix-microblaze-auto.h.template b/include/configs/petalogix-microblaze-auto.h.template
new file mode 100644
index 0000000..0d30663
--- /dev/null
+++ b/include/configs/petalogix-microblaze-auto.h.template
@@ -0,0 +1,355 @@
+/*
+ * (C) Copyright 2007-2008 Michal Simek
+ *
+ * Michal SIMEK <monstr@monstr.eu>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+#include "../board/petalogix/microblaze-auto/xparameters.h"
+
+#define	CONFIG_MICROBLAZE	1	/* MicroBlaze CPU */
+#define	MICROBLAZE_V5		1
+
+/* uart */
+#ifdef XILINX_UARTLITE_BASEADDR
+	#define	CONFIG_XILINX_UARTLITE
+	#define	CONFIG_SERIAL_BASE	XILINX_UARTLITE_BASEADDR
+	#define	CONFIG_BAUDRATE		XILINX_UARTLITE_BAUDRATE
+	#define	CONFIG_SYS_BAUDRATE_TABLE	{ CONFIG_BAUDRATE }
+	#define CONSOLE_ARG	"console=console=ttyUL0,115200\0"
+#elif XILINX_UART16550_BASEADDR
+	#define CONFIG_SYS_NS16550	1
+	#define CONFIG_SYS_NS16550_SERIAL
+	#define CONFIG_SYS_NS16550_REG_SIZE	-4
+	#define CONFIG_CONS_INDEX	1
+	#define CONFIG_SYS_NS16550_COM1	(XILINX_UART16550_BASEADDR + 0x1000 + 0x3)
+	#define CONFIG_SYS_NS16550_CLK	XILINX_UART16550_CLOCK_HZ
+	#define	CONFIG_BAUDRATE		115200
+
+	/* The following table includes the supported baudrates */
+	#define CONFIG_SYS_BAUDRATE_TABLE  \
+		{300, 600, 1200, 2400, 4800, 9600, 19200, 38400, 57600, 115200, 230400}
+	#define CONSOLE_ARG	"console=console=ttyS0,115200\0"
+#else
+	#error Undefined uart
+#endif
+
+/* setting reset address */
+/*#define	CONFIG_SYS_RESET_ADDRESS	TEXT_BASE*/
+
+/* ethernet */
+#ifdef XILINX_EMAC_BASEADDR
+	#define CONFIG_XILINX_EMAC	1
+	#define CONFIG_SYS_ENET
+#elif XILINX_EMACLITE_BASEADDR
+	#define CONFIG_XILINX_EMACLITE	1
+	#define CONFIG_SYS_ENET
+#elif XILINX_LLTEMAC_BASEADDR
+	#define CONFIG_XILINX_LL_TEMAC	1
+	#define CONFIG_SYS_ENET
+#endif
+
+#undef ET_DEBUG
+
+/* gpio */
+#ifdef XILINX_GPIO_BASEADDR
+	#define	CONFIG_SYS_GPIO_0		1
+	#define	CONFIG_SYS_GPIO_0_ADDR		XILINX_GPIO_BASEADDR
+#endif
+
+/* interrupt controller */
+#ifdef XILINX_INTC_BASEADDR
+	#define	CONFIG_SYS_INTC_0		1
+	#define	CONFIG_SYS_INTC_0_ADDR		XILINX_INTC_BASEADDR
+	#define	CONFIG_SYS_INTC_0_NUM		XILINX_INTC_NUM_INTR_INPUTS
+#endif
+
+/* timer */
+#ifdef XILINX_TIMER_BASEADDR
+	#if (XILINX_TIMER_IRQ != -1)
+		#define	CONFIG_SYS_TIMER_0		1
+		#define	CONFIG_SYS_TIMER_0_ADDR	XILINX_TIMER_BASEADDR
+		#define	CONFIG_SYS_TIMER_0_IRQ		XILINX_TIMER_IRQ
+		#define	FREQUENCE		XILINX_CLOCK_FREQ
+		#define	CONFIG_SYS_TIMER_0_PRELOAD	( FREQUENCE/1000 )
+	#endif
+#elif XILINX_CLOCK_FREQ
+	#define	CONFIG_XILINX_CLOCK_FREQ	XILINX_CLOCK_FREQ
+#else
+	#error BAD CLOCK FREQ
+#endif
+/* FSL */
+/* #define	CONFIG_SYS_FSL_2 */
+/* #define	FSL_INTR_2	1 */
+
+/*
+ * memory layout - Example
+ * TEXT_BASE = 0x1200_0000;
+ * CONFIG_SYS_SRAM_BASE = 0x1000_0000;
+ * CONFIG_SYS_SRAM_SIZE = 0x0400_0000;
+ *
+ * CONFIG_SYS_GBL_DATA_OFFSET = 0x1000_0000 + 0x0400_0000 - 0x1000 = 0x13FF_F000
+ * CONFIG_SYS_MONITOR_BASE = 0x13FF_F000 - 0x40000 = 0x13FB_F000
+ * CONFIG_SYS_MALLOC_BASE = 0x13FB_F000 - 0x40000 = 0x13F7_F000
+ *
+ * 0x1000_0000	CONFIG_SYS_SDRAM_BASE
+ *					FREE
+ * 0x1200_0000	TEXT_BASE
+ *		U-BOOT code
+ * 0x1202_0000
+ *					FREE
+ *
+ *					STACK
+ * 0x13F7_F000	CONFIG_SYS_MALLOC_BASE
+ *					MALLOC_AREA	256kB	Alloc
+ * 0x11FB_F000	CONFIG_SYS_MONITOR_BASE
+ *					MONITOR_CODE	256kB	Env
+ * 0x13FF_F000	CONFIG_SYS_GBL_DATA_OFFSET
+ *					GLOBAL_DATA	4kB	bd, gd
+ * 0x1400_0000	CONFIG_SYS_SDRAM_BASE + CONFIG_SYS_SDRAM_SIZE
+ */
+
+/* ddr sdram - main memory */
+#define	CONFIG_SYS_SDRAM_BASE		XILINX_RAM_START
+#define	CONFIG_SYS_SDRAM_SIZE		XILINX_RAM_SIZE
+#define	CONFIG_SYS_MEMTEST_START	CONFIG_SYS_SDRAM_BASE
+#define	CONFIG_SYS_MEMTEST_END		(CONFIG_SYS_SDRAM_BASE + 0x1000)
+
+/* global pointer */
+#define	CONFIG_SYS_GBL_DATA_SIZE	128	/* size of global data */
+/* start of global data */
+#define	CONFIG_SYS_GBL_DATA_OFFSET	(CONFIG_SYS_SDRAM_BASE + CONFIG_SYS_SDRAM_SIZE - CONFIG_SYS_GBL_DATA_SIZE)
+
+/* monitor code */
+#define	SIZE			0x40000
+#define	CONFIG_SYS_MONITOR_LEN		(SIZE - CONFIG_SYS_GBL_DATA_SIZE)
+#define	CONFIG_SYS_MONITOR_BASE	(CONFIG_SYS_GBL_DATA_OFFSET - CONFIG_SYS_MONITOR_LEN)
+#define	CONFIG_SYS_MONITOR_END		(CONFIG_SYS_MONITOR_BASE + CONFIG_SYS_MONITOR_LEN)
+#define	CONFIG_SYS_MALLOC_LEN		SIZE
+#define	CONFIG_SYS_MALLOC_BASE		(CONFIG_SYS_MONITOR_BASE - CONFIG_SYS_MALLOC_LEN)
+
+/* stack */
+#define	CONFIG_SYS_INIT_SP_OFFSET	CONFIG_SYS_MONITOR_BASE
+
+/*#define	RAMENV */
+
+#ifdef XILINX_FLASH_START
+	#define	FLASH
+	#define	CONFIG_SYS_FLASH_BASE		XILINX_FLASH_START
+	#define	CONFIG_SYS_FLASH_SIZE		XILINX_FLASH_SIZE
+	#define	CONFIG_SYS_FLASH_CFI		1
+	#define	CONFIG_FLASH_CFI_DRIVER	1
+	#define	CONFIG_SYS_FLASH_EMPTY_INFO	1	/* ?empty sector */
+	#define	CONFIG_SYS_MAX_FLASH_BANKS	1	/* max number of memory banks */
+	#define	CONFIG_SYS_MAX_FLASH_SECT	512	/* max number of sectors on one chip */
+	#define	CONFIG_SYS_FLASH_PROTECTION		/* hardware flash protection */
+
+	#ifdef	RAMENV
+		#define	CONFIG_ENV_IS_NOWHERE	1
+		#define	CONFIG_ENV_SIZE		0x1000
+		#define	CONFIG_ENV_ADDR		(CONFIG_SYS_MONITOR_BASE - CONFIG_ENV_SIZE)
+
+	#else	/* !RAMENV */
+		#define	CONFIG_ENV_IS_IN_FLASH	1
+		#define	CONFIG_ENV_SECT_SIZE	0x20000	/* 128K(one sector) for env */
+		#define	CONFIG_ENV_ADDR		@bestart@
+		#define	CONFIG_ENV_SIZE		@besize@
+	#endif /* !RAMBOOT */
+#else /* !FLASH */
+	/* ENV in RAM */
+	#define	CONFIG_SYS_NO_FLASH		1
+	#define	CONFIG_ENV_IS_NOWHERE	1
+	#define	CONFIG_ENV_SIZE		0x1000
+	#define	CONFIG_ENV_ADDR		(CONFIG_SYS_MONITOR_BASE - CONFIG_ENV_SIZE)
+	#define	CONFIG_SYS_FLASH_PROTECTION		/* hardware flash protection */
+#endif /* !FLASH */
+
+/* system ace */
+#ifdef XILINX_SYSACE_BASEADDR
+	#define	CONFIG_SYSTEMACE
+	/* #define DEBUG_SYSTEMACE */
+	#define	SYSTEMACE_CONFIG_FPGA
+	#define	CONFIG_SYS_SYSTEMACE_BASE	XILINX_SYSACE_BASEADDR
+	#define	CONFIG_SYS_SYSTEMACE_WIDTH	XILINX_SYSACE_MEM_WIDTH
+	#define	CONFIG_DOS_PARTITION
+#endif
+
+#if defined(XILINX_USE_ICACHE)
+	#define CONFIG_ICACHE
+#else
+	#undef CONFIG_ICACHE
+#endif
+
+#if defined(XILINX_USE_DCACHE)
+	#define CONFIG_DCACHE
+#else
+	#undef CONFIG_DCACHE
+#endif
+
+/*
+ * BOOTP options
+ */
+#define CONFIG_BOOTP_BOOTFILESIZE
+#define CONFIG_BOOTP_BOOTPATH
+#define CONFIG_BOOTP_GATEWAY
+#define CONFIG_BOOTP_HOSTNAME
+
+/*
+ * Command line configuration.
+ */
+#include <config_cmd_default.h>
+
+#define CONFIG_CMD_ASKENV
+#define CONFIG_CMD_IRQ
+#define CONFIG_CMD_MFSL
+#define CONFIG_CMD_ECHO
+
+#define CONFIG_CMD_ROMFS
+
+#if defined(CONFIG_DCACHE) || defined(CONFIG_ICACHE)
+	#define CONFIG_CMD_CACHE
+#else
+	#undef CONFIG_CMD_CACHE
+#endif
+
+#ifndef CONFIG_SYS_ENET
+	#undef CONFIG_CMD_NET
+	#undef CONFIG_NET_MULTI
+#else
+	#define CONFIG_CMD_PING
+	#define CONFIG_NET_MULTI
+	#define CONFIG_CMD_DHCP
+#endif
+
+#if defined(CONFIG_SYSTEMACE)
+	#define CONFIG_CMD_EXT2
+	#define CONFIG_CMD_FAT
+#endif
+
+#if defined(FLASH)
+	#define CONFIG_CMD_ECHO
+	#define CONFIG_CMD_FLASH
+	#define CONFIG_CMD_IMLS
+	#define CONFIG_CMD_JFFS2
+
+	#if !defined(RAMENV)
+		#define CONFIG_CMD_SAVEENV
+		#define CONFIG_CMD_SAVES
+	#endif
+#else
+	#undef CONFIG_CMD_IMLS
+	#undef CONFIG_CMD_FLASH
+	#undef CONFIG_CMD_JFFS2
+#endif
+
+#if defined(CONFIG_CMD_JFFS2)
+/* JFFS2 partitions */
+#define CONFIG_CMD_MTDPARTS	/* mtdparts command line support */
+#define CONFIG_MTD_DEVICE	/* needed for mtdparts commands */
+#define CONFIG_FLASH_CFI_MTD
+#define MTDIDS_DEFAULT		"nor0=@mtdpartsname@"
+
+/* default mtd partition table */
+#define MTDPARTS_DEFAULT	"mtdparts=@mtdparts@"
+#endif
+
+/* Miscellaneous configurable options */
+#define	CONFIG_SYS_PROMPT	"U-Boot-PetaLinux> "
+#define	CONFIG_SYS_CBSIZE	512	/* size of console buffer */
+#define	CONFIG_SYS_PBSIZE	(CONFIG_SYS_CBSIZE + sizeof(CONFIG_SYS_PROMPT) + 16) /* print buffer size */
+#define	CONFIG_SYS_MAXARGS	15	/* max number of command args */
+#define	CONFIG_SYS_LONGHELP
+#define	CONFIG_SYS_LOAD_ADDR	XILINX_RAM_START /* default load address */
+
+#define	CONFIG_BOOTDELAY	4
+#define	CONFIG_BOOTARGS		""
+#define	CONFIG_HOSTNAME		XILINX_BOARD_NAME
+#define	CONFIG_BOOTCOMMAND	"run make_cmdline; bootm ${kernstart}" \
+
+#define	CONFIG_IPADDR		@ipaddr@
+#define	CONFIG_SERVERIP		@serverip@
+#define	CONFIG_ETHADDR		@ethaddr@
+
+/* architecture dependent code */
+#define	CONFIG_SYS_USR_EXCEP	/* user exception */
+#define CONFIG_SYS_HZ	1000
+
+#define	CONFIG_PREBOOT		"echo U-BOOT for ${hostname};setenv preboot;echo;@dhcp@"
+
+#if defined(FLASH)
+#define	CONFIG_EXTRA_ENV_SETTINGS \
+	"autoload=no\0" \
+	"bootfile=image.ub\0" \
+	"mtdids=nor0=@mtdpartsname@\0" \
+	"mtdparts=mtdparts=@mtdparts@\0" \
+	CONSOLE_ARG \
+	"clobstart=@cstart@\0" \
+	"netstart=@nstart@\0" \
+	"bootsize=@bsize@\0" \
+	"bootstart=@bstart@\0" \
+	"bootenvsize=@besize@\0" \
+	"bootenvstart=@bestart@\0" \
+	"jffs2size=@jffs2size@\0" \
+	"jffs2start=@jffs2start@\0" \
+	"eraseenv=protect off ${bootenvstart} +${bootenvsize}; erase ${bootenvstart} +${bootenvsize}\0" \
+	"kernsize=@ksize@\0" \
+	"kernstart=@kstart@\0" \
+	"make_cmdline=setenv netkargs macaddr=${ethaddr};setenv bootargs mtdparts=${mtdparts} ${netkargs} ${console}\0" \
+	"load_kernel=tftp ${clobstart} image.ub\0" \
+	"install_kernel=protect off ${kernstart} +${kernsize};erase ${kernstart} +${kernsize};" \
+		"cp.b ${fileaddr} ${kernstart} ${filesize}\0" \
+	"update_kernel=run load_kernel install_kernel\0" \
+	"load_uboot=tftp ${clobstart} u-boot-s.bin\0" \
+	"install_uboot=protect off ${bootstart} +${bootsize};erase ${bootstart} +${bootsize};" \
+		"cp.b ${clobstart} ${bootstart} ${filesize}\0" \
+	"update_uboot=run load_uboot install_uboot\0" \
+	"load_jffs2=tftp ${clobstart} rootfs.jffs2\0" \
+	"install_jffs2=protect off ${jffs2start} +${jffs2size};erase ${jffs2start} +${jffs2size};" \
+		"cp.b ${clobstart} ${jffs2start} ${filesize}\0" \
+	"update_jffs2=run load_jffs2 install_jffs2\0" \
+	"netboot=run make_cmdline;tftp ${netstart} image.ub; bootm\0" \
+	""
+#else
+#define	CONFIG_EXTRA_ENV_SETTINGS \
+	CONSOLE_ARG \
+	"netstart=@nstart@\0" \
+	"make_cmdline=setenv netkargs macaddr=${ethaddr};setenv bootargs ${netkargs} ${console}\0" \
+	"bootcmd=run netboot\0" \
+	"netboot=run make_cmdline;tftp ${netstart} image.ub; bootm\0" \
+	""
+#endif
+
+#define CONFIG_CMDLINE_EDITING
+
+/* Use the HUSH parser */
+#define CONFIG_SYS_HUSH_PARSER
+#ifdef  CONFIG_SYS_HUSH_PARSER
+#define CONFIG_SYS_PROMPT_HUSH_PS2 "> "
+#endif
+
+#define CONFIG_FIT		1
+#define CONFIG_OF_LIBFDT	1
+
+#define   CONFIG_SYS_BOOTMAPSZ	(1 << 31) /* Initial Memory map for Linux */
+
+#endif	/* __CONFIG_H */
diff --git a/include/image.h b/include/image.h
index beb3a16..0147349 100644
--- a/include/image.h
+++ b/include/image.h
@@ -218,7 +218,7 @@ typedef struct bootm_headers {
 	const char	*fit_uname_rd;	/* init ramdisk subimage node unit name */
 	int		fit_noffset_rd;	/* init ramdisk subimage node offset */
 
-#if defined(CONFIG_PPC)
+#if defined(CONFIG_PPC) || defined (CONFIG_MICROBLAZE)
 	void		*fit_hdr_fdt;	/* FDT blob FIT image header */
 	const char	*fit_uname_fdt;	/* FDT blob subimage node unit name */
 	int		fit_noffset_fdt;/* FDT blob subimage node offset */
diff --git a/include/netdev.h b/include/netdev.h
index 3e66586..ae0be73 100644
--- a/include/netdev.h
+++ b/include/netdev.h
@@ -77,6 +77,8 @@ int tsi108_eth_initialize(bd_t *bis);
 int uec_initialize(int index);
 int uec_standard_init(bd_t *bis);
 int uli526x_initialize(bd_t *bis);
+int xilinx_emaclite_initialize (bd_t *bis);
+int xilinx_ll_temac_initialize(bd_t *bis);
 int sh_eth_initialize(bd_t *bis);
 int dm9000_initialize(bd_t *bis);
 
diff --git a/lib_microblaze/board.c b/lib_microblaze/board.c
index cfed5fe..8d17b03 100644
--- a/lib_microblaze/board.c
+++ b/lib_microblaze/board.c
@@ -30,6 +30,7 @@
 #include <timestamp.h>
 #include <version.h>
 #include <watchdog.h>
+#include <net.h>
 
 DECLARE_GLOBAL_DATA_PTR;
 
@@ -41,10 +42,6 @@ extern int gpio_init (void);
 #ifdef CONFIG_SYS_INTC_0
 extern int interrupts_init (void);
 #endif
-#if defined(CONFIG_CMD_NET)
-extern int eth_init (bd_t * bis);
-extern int getenv_IPaddr (char *);
-#endif
 
 /*
  * Begin and End of memory area for malloc(), and current "brk"
@@ -168,14 +165,20 @@ void board_init (void)
 	}
 #endif
 
+	/* relocate environment function pointers etc. */
+	env_relocate ();
+
 #if defined(CONFIG_CMD_NET)
 	/* IP Address */
-	bd->bi_ip_addr = getenv_IPaddr ("ipaddr");
-	eth_init (bd);
-#endif
+	bd->bi_ip_addr = getenv_IPaddr("ipaddr");
 
-	/* relocate environment function pointers etc. */
-	env_relocate ();
+	printf("Net:   ");
+	eth_initialize(gd->bd);
+
+	uchar enetaddr[6];
+	eth_getenv_enetaddr("ethaddr", enetaddr);
+	printf("MAC:   %pM\n", enetaddr);
+#endif
 
 	/* main_loop */
 	for (;;) {
diff --git a/lib_microblaze/bootm.c b/lib_microblaze/bootm.c
index bce4774..24c1dd7 100644
--- a/lib_microblaze/bootm.c
+++ b/lib_microblaze/bootm.c
@@ -1,5 +1,5 @@
 /*
- * (C) Copyright 2007 Michal Simek
+ * (C) Copyright 2007-2009 Michal Simek
  * (C) Copyright 2004 Atmark Techno, Inc.
  *
  * Michal  SIMEK <monstr@monstr.eu>
@@ -30,28 +30,102 @@
 #include <u-boot/zlib.h>
 #include <asm/byteorder.h>
 
+#if defined(CONFIG_OF_LIBFDT)
+#include <fdt.h>
+#include <libfdt.h>
+#include <fdt_support.h>
+
+#define DEBUG
+
+/*static int boot_get_fdt (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[],
+		bootm_headers_t *images, char **of_flat_tree, ulong *of_size);
+static image_header_t *image_get_fdt (ulong fdt_addr);*/
+#endif
+
 DECLARE_GLOBAL_DATA_PTR;
 
-int do_bootm_linux(int flag, int argc, char *argv[], bootm_headers_t *images)
+extern int do_reset (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[]);
+
+
+void do_bootm_linux (int flag, int argc, char *argv[],
+			bootm_headers_t *images)
 {
-	/* First parameter is mapped to $r5 for kernel boot args */
-	void	(*theKernel) (char *);
+	void	(*theKernel) (char *, ulong, ulong);
 	char	*commandline = getenv ("bootargs");
+	ulong	rd_data_start, rd_data_end;
+	ulong	ep = 0;
+	int	ret;
 
-	if ((flag != 0) && (flag != BOOTM_STATE_OS_GO))
-		return 1;
+	char	*of_flat_tree = NULL;
+#if defined(CONFIG_OF_LIBFDT)
 
-	theKernel = (void (*)(char *))images->ep;
+	//ulong	of_size = 0;
 
-	show_boot_progress (15);
+	/* find flattened device tree */
+	//ret = boot_get_fdt (argc, flag, argc, argv, images,
+	//				&of_flat_tree, &of_size);
+	//if (ret)
+	//	goto error;
 
-#ifdef DEBUG
-	printf ("## Transferring control to Linux (at address %08lx) ...\n",
-		(ulong) theKernel);
+//	char **of_flat_tree = &images->ft_addr;
 #endif
 
-	theKernel (commandline);
+//#if 0
+	/* find kernel entry point */
+	if (images->legacy_hdr_valid) {
+		ep = image_get_ep (&images->legacy_hdr_os_copy);
+#if defined(CONFIG_FIT)
+	} else if (images->fit_uname_os) {
+		ret = fit_image_get_entry (images->fit_hdr_os,
+				images->fit_noffset_os, &ep);
+		if (ret) {
+			puts ("Can't get entry point property!\n");
+			goto error;
+		}
+#endif
+	} else {
+		puts ("Could not find kernel entry point!\n");
+		goto error;
+	}
+//#endif
+	theKernel = (void (*)(char *, ulong, ulong))images->ep;
+	//printf("images->ep 0x%x, ep 0x%x\n", images->ep, ep = image_get_ep (&images->legacy_hdr_os_copy));
+
+	/* find ramdisk */
+	ret = boot_get_ramdisk (argc, argv, images, IH_ARCH_MICROBLAZE,
+			&rd_data_start, &rd_data_end);
+	if (ret)
+		goto error;
+
+	show_boot_progress (15);
+
+//#if defined(CONFIG_OF_LIBFDT)
+	if (!(ulong) of_flat_tree)
+		of_flat_tree = (char *)simple_strtoul (argv[3], NULL, 16);
+//#endif
+	/*
+	 * Linux Kernel Parameters (passing device tree):
+	 * r5: pointer to command line
+	 * r6: pointer to ramdisk
+	 * r7: pointer to the fdt, followed by the board info data
+	 */
+
+//#ifdef DEBUG
+	printf ("## Transferring control to Linux (at address %08lx), 0x%08x " \
+				"ramdisk 0x%08x, FDT 0x%08x...\n",
+		(ulong) theKernel, ep, rd_data_start, (ulong) of_flat_tree);
+//#endif
+	//if (!images->autostart)
+	//	return ;
+
+	theKernel (commandline, rd_data_start, (ulong) of_flat_tree);
+
 	/* does not return */
+	return;
 
-	return 1;
+error:
+	printf("error\n");
+//	if (images->autostart)
+//		do_reset (cmdtp, flag, argc, argv);
+	return;
 }
diff --git a/net/bootp.c b/net/bootp.c
index 0799ae2..a3a94c5 100644
--- a/net/bootp.c
+++ b/net/bootp.c
@@ -344,7 +344,8 @@ static void
 BootpTimeout(void)
 {
 	if (BootpTry >= TIMEOUT_COUNT) {
-		puts ("\nRetry count exceeded; starting again\n");
+		//puts ("\nRetry count exceeded; starting again\n");
+		NetState = NETLOOP_FAIL;
 		NetStartAgain ();
 	} else {
 		NetSetTimeout (TIMEOUT, BootpTimeout);
diff --git a/net/eth.c b/net/eth.c
index 9b50312..a449568 100644
--- a/net/eth.c
+++ b/net/eth.c
@@ -73,7 +73,8 @@ static int __def_eth_init(bd_t *bis)
 	return -1;
 }
 int cpu_eth_init(bd_t *bis) __attribute__((weak, alias("__def_eth_init")));
-int board_eth_init(bd_t *bis) __attribute__((weak, alias("__def_eth_init")));
+//int board_eth_init(bd_t *bis) __attribute__((weak, alias("__def_eth_init")));
+extern int board_eth_init(bd_t *bis);
 
 extern int mv6436x_eth_initialize(bd_t *);
 extern int mv6446x_eth_initialize(bd_t *);
diff --git a/petalinux-uboot-config b/petalinux-uboot-config
new file mode 100644
index 0000000..479f533
--- /dev/null
+++ b/petalinux-uboot-config
@@ -0,0 +1,376 @@
+#!/bin/bash
+#
+#  FILE:
+#     petalinux-uboot-config
+#
+#  DESCRIPTION:
+#     PetaLinux U-boot configuration.
+#
+#	  Majority of this script is dedicated to synchronising
+#	  the FLASH partition configurations in config/.config
+#	  with the U-Boot build parameters.  This is to allow a
+#	  set-once-and-build-for-all framework.
+#
+#	  The idea is to properate the user configurations on the
+#     flash partitioning to U-Boot and subsequently to the Linux
+#	  kernel via kernel boot arguments.
+#
+#  AUTHOR:
+#      Benny Chen   <benny.chen@petalogix.com>
+#
+#  MODIFICATION:
+#      Michal Simek <michal.simek@petalogix.com>
+#
+#  LICENSING:
+#      Copyright (c) 2006 PetaLogix. All rights reserved.
+#
+#   This program is free software; you can redistribute  it and/or modify it
+#   under  the terms of  the GNU General Public License as published by the
+#   Free Software Foundation;  either version 2 of the  License, or (at your
+#   option) any later version.
+#
+#   THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR IMPLIED
+#   WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED WARRANTIES OF
+#   MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN
+#   NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, INDIRECT,
+#   INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+#   NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF
+#   USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+#   ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, OR TORT
+#   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+#   THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+#
+#   You should have received a copy of the  GNU General Public License along
+#   with this program; if not, write  to the Free Software Foundation, Inc.,
+#   675 Mass Ave, Cambridge, MA 02139, USA.
+#
+
+source $CONFIG_CONFIG
+
+# Not doing this if we are not build U-Boot
+if [ "${CONFIG_SYSTEM_BUILD_UBOOT}" != 'y' ]; then
+	exit 0
+fi
+
+#
+# Variables for generating flash
+# partitioning output file.
+#
+OUTFILE_DIR=$UBOOT_BOARD_DIR
+OUTFILE=$OUTFILE_DIR/flash-partition.h
+TMPEXT=.tmp
+TMPFILE=$OUTFILE$TMPEXT
+
+# MTD PARTS Variable - Use to store MTDPARTS string
+MTDPARTS=""
+
+#
+# Indexes to our Partition table arrays
+#
+
+# Bootloader image partition index
+BOOT_PAR=0
+# Boot environment partition index
+BOOTENV_PAR=0
+# Kernel image partition index
+IMAGE_PAR=0
+# JFFS2 (root) image partition index
+JFFS2_PAR=0
+
+#
+# Partition table arrays
+#
+
+# Contains the partition name
+declare -a PAR_NAME
+# Contains the partition size
+declare -a PAR_SIZE
+# Contains the calculated start address of each partition
+declare -a PAR_ADDR
+
+# Maximum number of partitions - FIXME should be declared some where
+MAX_NUM_PARTITIONS=20
+
+#
+# This function parses the $CONFIG_CONFIG file
+# for partition definitions information.
+# The result of this function is stored in the
+# corresponding partition table arrays.
+#
+function read_config_file ()
+{
+	last=0
+	# No idea how many partitions are there, loop through all
+	# start from 1st to last to normalised data.
+	for (( CNT=1; CNT<$MAX_NUM_PARTITIONS+1; CNT++ )); do
+		# The different types of processing required
+		for field in "NAME" "SIZE" "ADDR"; do
+			# Do some substitution to get the variables that we are interested
+			if [ $field != "ADDR" ]; then
+				str="CONFIG_SYSTEM_PARTITION"$CNT"_"$field
+				tmp=$(grep $str $CONFIG_CONFIG | \
+					cut -d "=" -f 2 | tr -d '"')
+				# Reached the last partition ""
+				if [ -z $tmp ]; then
+					last=1
+					break
+				fi
+			fi
+
+			# Here we get the indexes into our interested partitions
+			if [ $field == "NAME" ]; then
+				# Update indexes into your partition
+				if [ $tmp == "boot" ]; then
+					BOOT_PAR=$CNT
+				elif [ $tmp == "bootenv" ]; then
+					BOOTENV_PAR=$CNT
+				elif [ $tmp == "image" ]; then
+					IMAGE_PAR=$CNT
+				elif [ $tmp == "jffs2" ]; then
+					JFFS2_PAR=$CNT
+				fi
+
+				# Update our Name array
+				PAR_NAME[$CNT]=$tmp
+			elif [ $field == "SIZE" ]; then
+				# check if value is specified with 0x appended
+				if [ ${tmp:0:2} != "0x" ]; then
+				    # Add 0x so sh knows that value is in hex
+					tmp=0x$tmp
+				fi
+				# if this partition is the spare partition
+				# we know this from the 0x0 size
+				if [ $tmp == "0x0" ]; then
+					# Calculate the remainder of the FLASH for size
+					PAR_SIZE[$CNT]=$(( $FLASH_START + $FLASH_SIZE \
+							- ${PAR_SIZE[$CNT -1]} - ${PAR_ADDR[$CNT - 1]} ))
+				else
+					PAR_SIZE[$CNT]=$tmp
+				fi
+				PAR_SIZE[$CNT]=$(printf "0x%08x\n" ${PAR_SIZE[$CNT]})
+			else
+				# Calculate start address of partition
+				if [ $CNT = 1 ]; then
+					# First partition
+					PAR_ADDR[$CNT]=$FLASH_START
+				else
+					# Subsequent partition
+					PAR_ADDR[$CNT]=$(( ${PAR_ADDR[$CNT -1]} + \
+											${PAR_SIZE[$CNT -1]} ))
+				fi
+				# We want to maintain the hex value
+				PAR_ADDR[$CNT]=`printf "0x%08x" "${PAR_ADDR[$CNT]}"`
+			fi
+		done
+		# Just so we can break out of nested for loops
+		if [ $last = 1 ]; then
+			break
+		fi
+	done
+}
+
+#
+# The objectives of this function is
+# to abstract all the partition table
+# verifications routine.
+#
+function check_partition_table ()
+{
+	if [ $FLASH_START ]; then
+		# Some checks apply to all the partitions
+		for (( CNT=1; CNT<${#PAR_NAME[@]} + 1; CNT++ )); do
+			# Check that partition is in FLASH Range
+			if [ $((${PAR_ADDR[$CNT]} + ${PAR_SIZE[$CNT]})) -gt  $(($FLASH_START + $FLASH_SIZE)) ]; then
+				printf "FLASH partition %s not in FLASH range\n" "${PAR_NAME[$CNT]}"
+				exit -1
+			fi
+
+			# Add checks that applies to all partitions here
+		done
+
+		# Check if boot, bootenv and image partitions are
+		# defined.  This is the minimum partitions required
+		# for U-Boot.
+		# FIXME - At the moment the names are hardcoded to boot,
+		#	 	  bootenv, and image.
+		if [ $BOOT_PAR = 0 ]; then
+			echo "FLASH partition \"boot\" not defined!"
+			exit -1
+		elif [ $BOOTENV_PAR = 0 ]; then
+			echo "FLASH partition \"bootenv\" not defined!"
+			exit -1
+		elif [ $IMAGE_PAR = 0 ]; then
+			echo "FLASH partition \"image\" not defined!"
+			exit -1
+		fi
+		if [ "${CONFIG_SYSTEM_ROOTFS_JFFS2}" = "y" ] && \
+		   [ "${JFFS2_PAR}" = 0 ]; then
+			echo "JFFS2 partition \"jffs2\" not defined!"
+			exit -1;
+		fi
+	fi
+}
+
+#
+# This function generates partition table
+# output flash-partition.h file
+# To be used by both the C runtime and Make context
+#
+function gen_partition_file ()
+{
+	# Remove any old files
+	if [ -f "$TMPFILE" ]; then
+		rm -f "$TMPFILE"
+	fi
+	if [ -f "$OUTFILE" ]; then
+		rm -f "$OUTFILE"
+	fi
+	echo "/*" >$TMPFILE
+	echo " * Automatically generated by make u-boot: don't edit." >>$TMPFILE
+	echo " */" >> $TMPFILE
+
+	# Build the file based on our partition table arrays
+	for (( CNT=1; CNT<${#PAR_NAME[@]} + 1; CNT++ )); do
+		for field in "START" "SIZE"; do
+			# Make name upper case
+			tmp=$(echo ${PAR_NAME[$CNT]} | tr [:lower:] [:upper:])
+
+			str="#define CONFIG_FLASH_"$tmp"_"$field"		"
+			if [ $field == "START" ]; then
+				printf "%s0x%x\n" "$str" "${PAR_ADDR[$CNT]}" >>$TMPFILE
+			else
+				printf "%s0x%x\n" "$str" "${PAR_SIZE[$CNT]}" >>$TMPFILE
+			fi
+		done
+	done
+
+	# We are done, make the file final
+	mv -f $TMPFILE $OUTFILE
+}
+
+#
+# This function generates the MTDPARTS string
+# as per the required syntax.  Base on the partition
+# table arrays.
+#
+function gen_mtdparts_string ()
+{
+	case "${KERNELVER}" in
+		"2.4")	MTDPARTSNAME="physmap_auto";
+			;;
+
+		"2.6")	MTDPARTSNAME="physmap-flash-0"
+			;;
+
+		*)	echo Invalid Kernel version
+			;;
+	esac
+
+	MTDPARTS="$MTDPARTSNAME:"
+	for (( CNT=1; CNT<${#PAR_NAME[@]} + 1; CNT++ )); do
+		if [ $((${PAR_SIZE[$CNT]} % 0x100000)) -eq "0" ]; then
+			unit=M
+			size=$(( ${PAR_SIZE[$CNT]} / 0x100000 ))
+		else
+			unit=K
+			size=$(( ${PAR_SIZE[$CNT]} / 0x400 ))
+		fi
+
+		MTDPARTS=$MTDPARTS$size$unit"(${PAR_NAME[$CNT]})"
+		if [ $CNT -lt  ${#PAR_NAME[@]} ]; then
+			MTDPARTS=$MTDPARTS","
+		fi
+	done
+}
+
+#
+# This function is to contain all the
+# required file/text substitution code.
+#
+function sub_config_file ()
+{
+	# Construct our MTD parts
+	gen_mtdparts_string
+
+	NET_START=$(($ERAM_START + 8192))
+	NET_START=`printf "0x%x" $NET_START`
+
+	# Crude attempt to autodetect our IP address
+	[ "${CONFIG_SYSTEM_SERVERIP_ADDRESS}" == "AUTO" ] && \
+		CONFIG_SYSTEM_SERVERIP_ADDRESS="$( /sbin/ifconfig eth0 | egrep -o "inet addr:[0-9]+.[0-9]+.[0-9]+.[0-9]+" | cut -d ':' -f 2)"
+
+	[ "${USE_DHCP}" = "y" ] && DHCP_CMD=dhcp
+
+	# Substitutions on the template config file for board
+	sed -e "{s/\@mtdparts\@/$MTDPARTS/g
+			 s/\@mtdpartsname\@/$MTDPARTSNAME/g
+			 s/\@dhcp@/${DHCP_CMD}/g
+			 s/\@ethaddr@/${CONFIG_SYSTEM_MAC_ADDRESS}/g
+			 s/\@ipaddr@/${CONFIG_SYSTEM_IP_ADDRESS}/g
+			 s/\@serverip@/${CONFIG_SYSTEM_SERVERIP_ADDRESS}/g
+			 s/\@ksize\@/${PAR_SIZE[$IMAGE_PAR]}/g
+			 s/\@kstart\@/${PAR_ADDR[$IMAGE_PAR]}/g
+			 s/\@bsize\@/${PAR_SIZE[$BOOT_PAR]}/g
+			 s/\@bstart\@/${PAR_ADDR[$BOOT_PAR]}/g
+			 s/\@jffs2size\@/${PAR_SIZE[$JFFS2_PAR]}/g
+			 s/\@jffs2start\@/${PAR_ADDR[$JFFS2_PAR]}/g
+			 s/\@besize\@/${PAR_SIZE[$BOOTENV_PAR]}/g
+			 s/\@bestart\@/${PAR_ADDR[$BOOTENV_PAR]}/g
+			 s/\@cstart\@/$ERAM_START/g
+			 s/\@nstart\@/$NET_START/g \
+			}" < $UBOOT_SCRIPT_BOARD_TEMPLATE > $UBOOT_SCRIPT_BOARD
+
+	# Add substitution code - here
+}
+
+#
+# This function does the required
+# U-Boot board configuration prior to
+# building u-boot.
+#
+function uboot_config ()
+{
+
+	# Check if u-boot configuration for this vendor platform exist
+	grep ${UBOOT_VENDOR}-${UBOOT_PLATFORM}_config ${UBOOTDIR}/Makefile
+	  >> /dev/null || (echo "Error: U-boot configuration not found" && exit -1)
+
+	XPAR=${UBOOT_BOARD_DIR}/xparameters.h
+	MK=${UBOOT_BOARD_DIR}/config.mk
+
+	echo $XPAR $MK
+
+	if [ ! -f ${XPAR} -o ! -f ${MK} ]; then
+		echo "Error: New U-BOOT needs xparameters.h and config.mk files in vendor folder"
+		echo "Please run petalinux-copy-autoconfig script from hw project folder."
+		exit -1
+	fi
+
+	# then finally, configure u-boot appropriately
+	make -C u-boot ${UBOOT_VENDOR}-${UBOOT_PLATFORM}_config
+}
+
+
+
+#
+# MAIN ROUTINE
+#
+
+# Read config/.config file for FLASh partition definitions
+read_config_file
+
+# Sanity Partition table check
+check_partition_table
+
+# Generate FLASH partition table include file
+gen_partition_file
+
+# Configuration file substitution
+sub_config_file
+
+# Run U-Boot pre configuration
+uboot_config
+
+exit 0
+
+
diff --git a/petalinux_config.mk b/petalinux_config.mk
new file mode 100644
index 0000000..78dca74
--- /dev/null
+++ b/petalinux_config.mk
@@ -0,0 +1,77 @@
+#
+#  FILE:
+#     petalinux_config.mk
+#
+#  DESCRIPTION:
+#     Petalinux U-Boot build configuration file for Make context.
+#
+#  AUTHOR:
+#      Benny Chen   <benny.chen@petalogix.com>
+#
+#  MODIFICATION:
+#
+#  LICENSING:
+#      Copyright (c) 2006 PetaLogix. All rights reserved.
+#
+#   This program is free software; you can redistribute  it and/or modify it
+#   under  the terms of  the GNU General Public License as published by the
+#   Free Software Foundation;  either version 2 of the  License, or (at your
+#   option) any later version.
+#
+#   THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR IMPLIED
+#   WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED WARRANTIES OF
+#   MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN
+#   NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, INDIRECT,
+#   INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+#   NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF
+#   USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+#   ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, OR TORT
+#   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+#   THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+#
+#   You should have received a copy of the  GNU General Public License along
+#   with this program; if not, write  to the Free Software Foundation, Inc.,
+#   675 Mass Ave, Cambridge, MA 02139, USA.
+#
+
+# Generate lower case versions of Vendor and Product strings, for u-boot
+#UBOOT_VENDOR=$(shell echo $(CONFIG_VENDOR) | tr '[\.\/\+A-Z]' '[___a-z]')
+#UBOOT_PLATFORM=$(shell echo $(CONFIG_PRODUCT) | tr '[\.\/\+A-Z]' '[___a-z]')
+# For now, we force petalogix/microblaze-auto combination for u-boot
+UBOOT_VENDOR=petalogix
+UBOOT_PLATFORM=microblaze-auto
+
+UBOOTDIR = $(ROOTDIR)/u-boot
+UBOOTIMG = u-boot-s
+KERNEL_IMG = $(IMAGEDIR)/image.bin
+UB_KERNEL_IMG = $(IMAGEDIR)/image.ub
+MKIMAGE = $(UBOOTDIR)/tools/mkimage
+UBOOT_BOARD_DIR=$(UBOOTDIR)/board/$(UBOOT_VENDOR)/$(UBOOT_PLATFORM)
+
+UBOOT_SCRIPT_BOARD_TEMPLATE=$(UBOOTDIR)/include/configs/$(UBOOT_VENDOR)-$(UBOOT_PLATFORM).h.template
+UBOOT_SCRIPT_BOARD=$(UBOOTDIR)/include/configs/$(UBOOT_VENDOR)-$(UBOOT_PLATFORM).h
+
+# We need to crack some settings out of the user/vendor .config file
+# This is a bit hacky, a more generic system would be nice
+
+# Obtain Hardware Address Mappings
+FLASH_START=$(shell grep FLASH_START $(UBOOT_BOARD_DIR)/xparameters.h \
+		2>/dev/null | sed -r -e 's/[[:space:]]+/ /g' | cut -d ' ' -f 3)
+FLASH_SIZE=$(shell grep FLASH_SIZE $(UBOOT_BOARD_DIR)/xparameters.h \
+		2>/dev/null | sed -r -e 's/[[:space:]]+/ /g' | cut -d ' ' -f 3)
+ERAM_START=$(shell grep CONFIG_KERNEL_BASE_ADDR $(LINUX_CONFIG) \
+                2>/dev/null | cut -d "=" -f 2 | grep -v "^\#")
+# Obtain U-Boot boot partition start address
+FLASH_BOOT_START=$(shell grep CONFIG_FLASH_BOOT_START $(UBOOT_BOARD_DIR)/flash-partition.h 2>/dev/null | cut -f 3)
+# U-Boot boot partition size
+FLASH_BOOT_SIZE=$(shell grep CONFIG_FLASH_BOOT_SIZE $(UBOOT_BOARD_DIR)/flash-partition.h 2>/dev/null | cut -f 3)
+
+# Get MTD partition table info - Not required any more
+#MTDPARTS=$(shell grep CONFIG_SYSTEM_MTDPARTS $(CONFIG_CONFIG) \
+                2>/dev/null | cut -d "=" -f 2 | grep -v "^\#" | tr -d '\"')
+# Are we building u-boot?
+BUILD_UBOOT=$(shell grep CONFIG_SYSTEM_BUILD_UBOOT $(CONFIG_CONFIG) \
+                2>/dev/null | cut -d "=" -f 2 | grep -v "^\#")
+
+USE_DHCP=$(shell grep "CONFIG_SYSTEM_USE_DHCP" $(CONFIG_CONFIG) \
+		2</dev/null | cut -d "=" -f 2 | grep -v "^\#")
diff --git a/xmd.ini b/xmd.ini
new file mode 100644
index 0000000..d200fe2
--- /dev/null
+++ b/xmd.ini
@@ -0,0 +1,4 @@
+connect mb mdm
+dow u-boot
+run
+exit
-- 
1.6.0.4

