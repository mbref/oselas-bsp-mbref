From b0ded688a719ccf95bbd07b3f58c13c7728a4257 Mon Sep 17 00:00:00 2001
From: Soren Brinkmann <soren.brinkmann@xilinx.com>
Date: Wed, 6 Feb 2013 10:15:48 +0100
Subject: [PATCH] clk: zynq: Convert PLLs to DT driven init

Initialize the PLLs from DT driven data and get rid of the obsolete
init code in zynq/clk.c.
Also, adding documentation for the DT binding.

Signed-off-by: Soren Brinkmann <soren.brinkmann@xilinx.com>
Signed-off-by: Michal Simek <michal.simek@xilinx.com>
---
 .../devicetree/bindings/clock/zynq-7000.txt        |   34 ++
 arch/arm/boot/dts/zynq-afx-nand.dts                |   34 ++-
 arch/arm/boot/dts/zynq-afx-nor.dts                 |   34 ++-
 arch/arm/boot/dts/zynq-ep107.dts                   |   34 ++-
 arch/arm/boot/dts/zynq-zc702.dts                   |   34 ++-
 arch/arm/boot/dts/zynq-zc770-xm010.dts             |   34 ++-
 arch/arm/boot/dts/zynq-zc770-xm011.dts             |   34 ++-
 arch/arm/boot/dts/zynq-zc770-xm012.dts             |   34 ++-
 arch/arm/boot/dts/zynq-zc770-xm013.dts             |   34 ++-
 arch/arm/boot/dts/zynq-zed.dts                     |   26 +-
 drivers/clk/zynq/Makefile                          |    2 +-
 drivers/clk/zynq/clk.c                             |  458 ++++++++++++++++++-
 drivers/clk/zynq/pll.c                             |  424 ------------------
 include/linux/clk/zynq.h                           |    3 -
 14 files changed, 717 insertions(+), 502 deletions(-)
 create mode 100644 Documentation/devicetree/bindings/clock/zynq-7000.txt
 delete mode 100644 drivers/clk/zynq/pll.c

diff --git a/Documentation/devicetree/bindings/clock/zynq-7000.txt b/Documentation/devicetree/bindings/clock/zynq-7000.txt
new file mode 100644
index 0000000..085ba19
--- /dev/null
+++ b/Documentation/devicetree/bindings/clock/zynq-7000.txt
@@ -0,0 +1,34 @@
+Device Tree Clock bindings for the Zynq 7000 EPP
+
+The Zynq EPP has several different clk providers, each with there own bindings.
+The purpose of this document is to document their usage.
+
+See clock_bindings.txt for more information on the generic clock bindings.
+See Chapter 25 of Zynq TRM for more information about Zynq clocks.
+
+== PLLs ==
+
+Used to describe the ARM_PLL, DDR_PLL, and IO_PLL.
+
+Required properties:
+- #clock-cells : shall be 0 (only one clock is output from this node)
+- compatible : "xlnx,zynq-pll"
+- reg : set of u32 values, which are the address offsets within the SLCR
+        of the relevant PLL_CTRL register, PLL_CFG and PLL_STATUS register
+	respectively
+- lockbit : the index of the PLL_LOCKED bit in the PLL_STATUS register for this
+  PLL
+- clocks : phandle for parent clock.  should be the phandle for ps_clk
+
+Optional properties:
+- clock-output-names : name of the output clock
+
+Example:
+	armpll: armpll {
+		#clock-cells = <0>;
+		compatible = "xlnx,zynq-pll";
+		clocks = <&ps_clk>;
+		reg = <0x100 0x110 0x10c>;
+		lockbit = <0>;
+		clock-output-names = "armpll";
+	};
diff --git a/arch/arm/boot/dts/zynq-afx-nand.dts b/arch/arm/boot/dts/zynq-afx-nand.dts
index b0d4f45..03dbfae 100644
--- a/arch/arm/boot/dts/zynq-afx-nand.dts
+++ b/arch/arm/boot/dts/zynq-afx-nand.dts
@@ -57,18 +57,40 @@
 		slcr: slcr@f8000000 {
 			compatible = "xlnx,zynq-slcr";
 			reg = <0xF8000000 0x1000>;
-
 			clocks {
 				#address-cells = <1>;
 				#size-cells = <0>;
-
+				armpll: armpll {
+					#clock-cells = <0>;
+					clock-output-names = "armpll";
+					clocks = <&ps_clk>;
+					compatible = "xlnx,zynq-pll";
+					lockbit = <0>;
+					reg = < 0x100 0x110 0x10c >;
+				} ;
+				ddrpll: ddrpll {
+					#clock-cells = <0>;
+					clock-output-names = "ddrpll";
+					clocks = <&ps_clk>;
+					compatible = "xlnx,zynq-pll";
+					lockbit = <1>;
+					reg = < 0x104 0x114 0x10c >;
+				} ;
+				iopll: iopll {
+					#clock-cells = <0>;
+					clock-output-names = "iopll";
+					clocks = <&ps_clk>;
+					compatible = "xlnx,zynq-pll";
+					lockbit = <2>;
+					reg = < 0x108 0x118 0x10c >;
+				} ;
 				ps_clk: ps_clk {
 					#clock-cells = <0>;
-					compatible = "fixed-clock";
 					clock-frequency = <33333333>;
-					clock-output-names = "PS_CLK";
-				};
-			};
+					clock-output-names = "ps_clk";
+					compatible = "fixed-clock";
+				} ;
+			} ;
 		};
 
 		timer@0xf8001000 {
diff --git a/arch/arm/boot/dts/zynq-afx-nor.dts b/arch/arm/boot/dts/zynq-afx-nor.dts
index 9ae6234..b2d3901 100644
--- a/arch/arm/boot/dts/zynq-afx-nor.dts
+++ b/arch/arm/boot/dts/zynq-afx-nor.dts
@@ -57,18 +57,40 @@
 		slcr: slcr@f8000000 {
 			compatible = "xlnx,zynq-slcr";
 			reg = <0xF8000000 0x1000>;
-
 			clocks {
 				#address-cells = <1>;
 				#size-cells = <0>;
-
+				armpll: armpll {
+					#clock-cells = <0>;
+					clock-output-names = "armpll";
+					clocks = <&ps_clk>;
+					compatible = "xlnx,zynq-pll";
+					lockbit = <0>;
+					reg = < 0x100 0x110 0x10c >;
+				} ;
+				ddrpll: ddrpll {
+					#clock-cells = <0>;
+					clock-output-names = "ddrpll";
+					clocks = <&ps_clk>;
+					compatible = "xlnx,zynq-pll";
+					lockbit = <1>;
+					reg = < 0x104 0x114 0x10c >;
+				} ;
+				iopll: iopll {
+					#clock-cells = <0>;
+					clock-output-names = "iopll";
+					clocks = <&ps_clk>;
+					compatible = "xlnx,zynq-pll";
+					lockbit = <2>;
+					reg = < 0x108 0x118 0x10c >;
+				} ;
 				ps_clk: ps_clk {
 					#clock-cells = <0>;
-					compatible = "fixed-clock";
 					clock-frequency = <33333333>;
-					clock-output-names = "PS_CLK";
-				};
-			};
+					clock-output-names = "ps_clk";
+					compatible = "fixed-clock";
+				} ;
+			} ;
 		};
 
 		timer@0xf8001000 {
diff --git a/arch/arm/boot/dts/zynq-ep107.dts b/arch/arm/boot/dts/zynq-ep107.dts
index 31b89db..92ef5cd 100644
--- a/arch/arm/boot/dts/zynq-ep107.dts
+++ b/arch/arm/boot/dts/zynq-ep107.dts
@@ -68,18 +68,40 @@
 		slcr: slcr@f8000000 {
 			compatible = "xlnx,zynq-slcr";
 			reg = <0xF8000000 0x1000>;
-
 			clocks {
 				#address-cells = <1>;
 				#size-cells = <0>;
-
+				armpll: armpll {
+					#clock-cells = <0>;
+					clock-output-names = "armpll";
+					clocks = <&ps_clk>;
+					compatible = "xlnx,zynq-pll";
+					lockbit = <0>;
+					reg = < 0x100 0x110 0x10c >;
+				} ;
+				ddrpll: ddrpll {
+					#clock-cells = <0>;
+					clock-output-names = "ddrpll";
+					clocks = <&ps_clk>;
+					compatible = "xlnx,zynq-pll";
+					lockbit = <1>;
+					reg = < 0x104 0x114 0x10c >;
+				} ;
+				iopll: iopll {
+					#clock-cells = <0>;
+					clock-output-names = "iopll";
+					clocks = <&ps_clk>;
+					compatible = "xlnx,zynq-pll";
+					lockbit = <2>;
+					reg = < 0x108 0x118 0x10c >;
+				} ;
 				ps_clk: ps_clk {
 					#clock-cells = <0>;
-					compatible = "fixed-clock";
 					clock-frequency = <121154004>;
-					clock-output-names = "PS_CLK";
-				};
-			};
+					clock-output-names = "ps_clk";
+					compatible = "fixed-clock";
+				} ;
+			} ;
 		};
 
 		wdt0: swdt@f8005000 {
diff --git a/arch/arm/boot/dts/zynq-zc702.dts b/arch/arm/boot/dts/zynq-zc702.dts
index 4c9d69f..7f7affc 100644
--- a/arch/arm/boot/dts/zynq-zc702.dts
+++ b/arch/arm/boot/dts/zynq-zc702.dts
@@ -56,18 +56,40 @@
 		slcr: slcr@f8000000 {
 			compatible = "xlnx,zynq-slcr";
 			reg = <0xF8000000 0x1000>;
-
 			clocks {
 				#address-cells = <1>;
 				#size-cells = <0>;
-
+				armpll: armpll {
+					#clock-cells = <0>;
+					clock-output-names = "armpll";
+					clocks = <&ps_clk>;
+					compatible = "xlnx,zynq-pll";
+					lockbit = <0>;
+					reg = < 0x100 0x110 0x10c >;
+				} ;
+				ddrpll: ddrpll {
+					#clock-cells = <0>;
+					clock-output-names = "ddrpll";
+					clocks = <&ps_clk>;
+					compatible = "xlnx,zynq-pll";
+					lockbit = <1>;
+					reg = < 0x104 0x114 0x10c >;
+				} ;
+				iopll: iopll {
+					#clock-cells = <0>;
+					clock-output-names = "iopll";
+					clocks = <&ps_clk>;
+					compatible = "xlnx,zynq-pll";
+					lockbit = <2>;
+					reg = < 0x108 0x118 0x10c >;
+				} ;
 				ps_clk: ps_clk {
 					#clock-cells = <0>;
-					compatible = "fixed-clock";
 					clock-frequency = <33333333>;
-					clock-output-names = "PS_CLK";
-				};
-			};
+					clock-output-names = "ps_clk";
+					compatible = "fixed-clock";
+				} ;
+			} ;
 		};
 
 		timer@0xf8001000 {
diff --git a/arch/arm/boot/dts/zynq-zc770-xm010.dts b/arch/arm/boot/dts/zynq-zc770-xm010.dts
index 177965d..cb4d05b 100644
--- a/arch/arm/boot/dts/zynq-zc770-xm010.dts
+++ b/arch/arm/boot/dts/zynq-zc770-xm010.dts
@@ -56,18 +56,40 @@
 		slcr: slcr@f8000000 {
 			compatible = "xlnx,zynq-slcr";
 			reg = <0xF8000000 0x1000>;
-
 			clocks {
 				#address-cells = <1>;
 				#size-cells = <0>;
-
+				armpll: armpll {
+					#clock-cells = <0>;
+					clock-output-names = "armpll";
+					clocks = <&ps_clk>;
+					compatible = "xlnx,zynq-pll";
+					lockbit = <0>;
+					reg = < 0x100 0x110 0x10c >;
+				} ;
+				ddrpll: ddrpll {
+					#clock-cells = <0>;
+					clock-output-names = "ddrpll";
+					clocks = <&ps_clk>;
+					compatible = "xlnx,zynq-pll";
+					lockbit = <1>;
+					reg = < 0x104 0x114 0x10c >;
+				} ;
+				iopll: iopll {
+					#clock-cells = <0>;
+					clock-output-names = "iopll";
+					clocks = <&ps_clk>;
+					compatible = "xlnx,zynq-pll";
+					lockbit = <2>;
+					reg = < 0x108 0x118 0x10c >;
+				} ;
 				ps_clk: ps_clk {
 					#clock-cells = <0>;
-					compatible = "fixed-clock";
 					clock-frequency = <33333333>;
-					clock-output-names = "PS_CLK";
-				};
-			};
+					clock-output-names = "ps_clk";
+					compatible = "fixed-clock";
+				} ;
+			} ;
 		};
 
 		timer@0xf8001000 {
diff --git a/arch/arm/boot/dts/zynq-zc770-xm011.dts b/arch/arm/boot/dts/zynq-zc770-xm011.dts
index be9fd3d..60e4531 100644
--- a/arch/arm/boot/dts/zynq-zc770-xm011.dts
+++ b/arch/arm/boot/dts/zynq-zc770-xm011.dts
@@ -57,18 +57,40 @@
 		slcr: slcr@f8000000 {
 			compatible = "xlnx,zynq-slcr";
 			reg = <0xF8000000 0x1000>;
-
 			clocks {
 				#address-cells = <1>;
 				#size-cells = <0>;
-
+				armpll: armpll {
+					#clock-cells = <0>;
+					clock-output-names = "armpll";
+					clocks = <&ps_clk>;
+					compatible = "xlnx,zynq-pll";
+					lockbit = <0>;
+					reg = < 0x100 0x110 0x10c >;
+				} ;
+				ddrpll: ddrpll {
+					#clock-cells = <0>;
+					clock-output-names = "ddrpll";
+					clocks = <&ps_clk>;
+					compatible = "xlnx,zynq-pll";
+					lockbit = <1>;
+					reg = < 0x104 0x114 0x10c >;
+				} ;
+				iopll: iopll {
+					#clock-cells = <0>;
+					clock-output-names = "iopll";
+					clocks = <&ps_clk>;
+					compatible = "xlnx,zynq-pll";
+					lockbit = <2>;
+					reg = < 0x108 0x118 0x10c >;
+				} ;
 				ps_clk: ps_clk {
 					#clock-cells = <0>;
-					compatible = "fixed-clock";
 					clock-frequency = <33333333>;
-					clock-output-names = "PS_CLK";
-				};
-			};
+					clock-output-names = "ps_clk";
+					compatible = "fixed-clock";
+				} ;
+			} ;
 		};
 
 		timer@0xf8001000 {
diff --git a/arch/arm/boot/dts/zynq-zc770-xm012.dts b/arch/arm/boot/dts/zynq-zc770-xm012.dts
index 64da8a2..250ec66 100644
--- a/arch/arm/boot/dts/zynq-zc770-xm012.dts
+++ b/arch/arm/boot/dts/zynq-zc770-xm012.dts
@@ -59,18 +59,40 @@
 		slcr: slcr@f8000000 {
 			compatible = "xlnx,zynq-slcr";
 			reg = <0xF8000000 0x1000>;
-
 			clocks {
 				#address-cells = <1>;
 				#size-cells = <0>;
-
+				armpll: armpll {
+					#clock-cells = <0>;
+					clock-output-names = "armpll";
+					clocks = <&ps_clk>;
+					compatible = "xlnx,zynq-pll";
+					lockbit = <0>;
+					reg = < 0x100 0x110 0x10c >;
+				} ;
+				ddrpll: ddrpll {
+					#clock-cells = <0>;
+					clock-output-names = "ddrpll";
+					clocks = <&ps_clk>;
+					compatible = "xlnx,zynq-pll";
+					lockbit = <1>;
+					reg = < 0x104 0x114 0x10c >;
+				} ;
+				iopll: iopll {
+					#clock-cells = <0>;
+					clock-output-names = "iopll";
+					clocks = <&ps_clk>;
+					compatible = "xlnx,zynq-pll";
+					lockbit = <2>;
+					reg = < 0x108 0x118 0x10c >;
+				} ;
 				ps_clk: ps_clk {
 					#clock-cells = <0>;
-					compatible = "fixed-clock";
 					clock-frequency = <33333333>;
-					clock-output-names = "PS_CLK";
-				};
-			};
+					clock-output-names = "ps_clk";
+					compatible = "fixed-clock";
+				} ;
+			} ;
 		};
 
 		timer@0xf8001000 {
diff --git a/arch/arm/boot/dts/zynq-zc770-xm013.dts b/arch/arm/boot/dts/zynq-zc770-xm013.dts
index 01ea70e..8db4a0a 100644
--- a/arch/arm/boot/dts/zynq-zc770-xm013.dts
+++ b/arch/arm/boot/dts/zynq-zc770-xm013.dts
@@ -56,18 +56,40 @@
 		slcr: slcr@f8000000 {
 			compatible = "xlnx,zynq-slcr";
 			reg = <0xF8000000 0x1000>;
-
 			clocks {
 				#address-cells = <1>;
 				#size-cells = <0>;
-
+				armpll: armpll {
+					#clock-cells = <0>;
+					clock-output-names = "armpll";
+					clocks = <&ps_clk>;
+					compatible = "xlnx,zynq-pll";
+					lockbit = <0>;
+					reg = < 0x100 0x110 0x10c >;
+				} ;
+				ddrpll: ddrpll {
+					#clock-cells = <0>;
+					clock-output-names = "ddrpll";
+					clocks = <&ps_clk>;
+					compatible = "xlnx,zynq-pll";
+					lockbit = <1>;
+					reg = < 0x104 0x114 0x10c >;
+				} ;
+				iopll: iopll {
+					#clock-cells = <0>;
+					clock-output-names = "iopll";
+					clocks = <&ps_clk>;
+					compatible = "xlnx,zynq-pll";
+					lockbit = <2>;
+					reg = < 0x108 0x118 0x10c >;
+				} ;
 				ps_clk: ps_clk {
 					#clock-cells = <0>;
-					compatible = "fixed-clock";
 					clock-frequency = <33333333>;
-					clock-output-names = "PS_CLK";
-				};
-			};
+					clock-output-names = "ps_clk";
+					compatible = "fixed-clock";
+				} ;
+			} ;
 		};
 
 		timer@0xf8002000 {
diff --git a/arch/arm/boot/dts/zynq-zed.dts b/arch/arm/boot/dts/zynq-zed.dts
index 390c4bc..d9ceda3 100644
--- a/arch/arm/boot/dts/zynq-zed.dts
+++ b/arch/arm/boot/dts/zynq-zed.dts
@@ -261,10 +261,34 @@
 			clocks {
 				#address-cells = <1>;
 				#size-cells = <0>;
+				armpll: armpll {
+					#clock-cells = <0>;
+					clock-output-names = "armpll";
+					clocks = <&ps_clk>;
+					compatible = "xlnx,zynq-pll";
+					lockbit = <0>;
+					reg = < 0x100 0x110 0x10c >;
+				} ;
+				ddrpll: ddrpll {
+					#clock-cells = <0>;
+					clock-output-names = "ddrpll";
+					clocks = <&ps_clk>;
+					compatible = "xlnx,zynq-pll";
+					lockbit = <1>;
+					reg = < 0x104 0x114 0x10c >;
+				} ;
+				iopll: iopll {
+					#clock-cells = <0>;
+					clock-output-names = "iopll";
+					clocks = <&ps_clk>;
+					compatible = "xlnx,zynq-pll";
+					lockbit = <2>;
+					reg = < 0x108 0x118 0x10c >;
+				} ;
 				ps_clk: ps_clk {
 					#clock-cells = <0>;
 					clock-frequency = <33333333>;
-					clock-output-names = "PS_CLK";
+					clock-output-names = "ps_clk";
 					compatible = "fixed-clock";
 				} ;
 			} ;
diff --git a/drivers/clk/zynq/Makefile b/drivers/clk/zynq/Makefile
index 62d931a..1c4763a 100644
--- a/drivers/clk/zynq/Makefile
+++ b/drivers/clk/zynq/Makefile
@@ -1,3 +1,3 @@
 # Zynq clock specific Makefile
 
-obj-$(CONFIG_ARCH_ZYNQ)	+= clk.o clk621.o peripheral_clk.o pll.o
+obj-$(CONFIG_ARCH_ZYNQ)	+= clk.o clk621.o peripheral_clk.o
diff --git a/drivers/clk/zynq/clk.c b/drivers/clk/zynq/clk.c
index 8b74fde..0a2571a 100644
--- a/drivers/clk/zynq/clk.c
+++ b/drivers/clk/zynq/clk.c
@@ -16,16 +16,10 @@
 
 #include <linux/clk-provider.h>
 #include <linux/clkdev.h>
+#include <linux/io.h>
 #include <linux/of.h>
 #include <linux/clk/zynq.h>
 
-#define SLCR_ARMPLL_CTRL		(slcr_base + 0x100)
-#define SLCR_DDRPLL_CTRL		(slcr_base + 0x104)
-#define SLCR_IOPLL_CTRL			(slcr_base + 0x108)
-#define SLCR_PLL_STATUS			(slcr_base + 0x10c)
-#define SLCR_ARMPLL_CFG			(slcr_base + 0x110)
-#define SLCR_DDRPLL_CFG			(slcr_base + 0x114)
-#define SLCR_IOPLL_CFG			(slcr_base + 0x118)
 #define SLCR_ARM_CLK_CTRL		(slcr_base + 0x120)
 #define SLCR_DDR_CLK_CTRL		(slcr_base + 0x124)
 #define SLCR_DCI_CLK_CTRL		(slcr_base + 0x128)
@@ -46,6 +40,425 @@
 #define SLCR_FPGA3_CLK_CTRL		(slcr_base + 0x1a0)
 #define SLCR_621_TRUE			(slcr_base + 0x1c4)
 
+static void __iomem *zynq_slcr_base;
+
+
+/* clock implementation for Zynq PLLs */
+
+/**
+ * struct zynq_pll
+ * @hw:		Handle between common and hardware-specific interfaces
+ * @pll_ctrl:	PLL control register
+ * @pll_cfg:	PLL config register
+ * @pll_status:	PLL status register
+ * @lock:	Register lock
+ * @lockbit:	Indicates the associated PLL_LOCKED bit in the PLL status
+ *		register.
+ * @bypassed:	Indicates PLL bypass. 1 = bypassed, 0 = PLL output
+ */
+struct zynq_pll {
+	struct clk_hw	hw;
+	void __iomem	*pll_ctrl;
+	void __iomem	*pll_cfg;
+	void __iomem	*pll_status;
+	spinlock_t	lock;
+	u32		lockbit;
+	u8		bypassed;
+};
+#define to_zynq_pll(_hw)	container_of(_hw, struct zynq_pll, hw)
+
+/* Register bitfield defines */
+#define PLLCTRL_FBDIV_MASK	0x7f000
+#define PLLCTRL_FBDIV_SHIFT	12
+#define PLLCTRL_BYPASS_MASK	0x10
+#define PLLCTRL_BYPASS_SHIFT	4
+#define PLLCTRL_BPQUAL_MASK	(1 << 3)
+#define PLLCTRL_PWRDWN_MASK	2
+#define PLLCTRL_PWRDWN_SHIFT	1
+#define PLLCTRL_RESET_MASK	1
+#define PLLCTRL_RESET_SHIFT	0
+#define PLLCFG_PLLRES_MASK	0xf0
+#define PLLCFG_PLLRES_SHIFT	4
+#define PLLCFG_PLLCP_MASK	0xf00
+#define PLLCFG_PLLCP_SHIFT	8
+#define PLLCFG_LOCKCNT_MASK	0x3ff000
+#define PLLCFG_LOCKCNT_SHIFT	12
+
+/**
+ * zynq_pll_get_params() - Get PLL parameters for given feedback divider
+ * @fbdiv: Desired feedback divider
+ * @rpll_cp: PLL_CP value (return value)
+ * @rpll_res: PLL_RES value (return value)
+ * @rlock_cnt: LOCK_CNT value (return value)
+ * Returns 0 on success.
+ */
+static int zynq_pll_get_pll_params(unsigned int fbdiv, u32 *rpll_cp,
+		u32 *rpll_res, u32 *rlock_cnt)
+{
+	unsigned int pll_cp;
+	unsigned int pll_res;
+	unsigned int lock_cnt;
+
+	/* Check that fbdiv is in a valid range */
+	if ((fbdiv < 13) || (fbdiv > 66))
+		return -EINVAL;
+
+	/* Set other PLL parameters according to target fbdiv */
+	if ((fbdiv >= 41) && (fbdiv <= 47))
+		pll_cp = 3;
+	else
+		pll_cp = 2;
+
+	if (fbdiv <= 15)
+		pll_res = 6;
+	else if ((fbdiv >= 16) && (fbdiv <= 19))
+		pll_res = 10;
+	else if ((fbdiv >= 31) && (fbdiv <= 40))
+		pll_res = 2;
+	else if (fbdiv >= 48)
+		pll_res = 4;
+	else
+		pll_res = 12;
+
+	switch (fbdiv) {
+	case 13:
+		lock_cnt = 750;
+		break;
+	case 14:
+		lock_cnt = 700;
+		break;
+	case 15:
+		lock_cnt = 650;
+		break;
+	case 16:
+		lock_cnt = 625;
+		break;
+	case 17:
+		lock_cnt = 575;
+		break;
+	case 18:
+		lock_cnt = 550;
+		break;
+	case 19:
+		lock_cnt = 525;
+		break;
+	case 20:
+		lock_cnt = 500;
+		break;
+	case 21:
+		lock_cnt = 475;
+		break;
+	case 22:
+		lock_cnt = 450;
+		break;
+	case 23:
+		lock_cnt = 425;
+		break;
+	case 24 ... 25:
+		lock_cnt = 400;
+		break;
+	case 26:
+		lock_cnt = 375;
+		break;
+	case 27 ... 28:
+		lock_cnt = 350;
+		break;
+	case 29 ... 30:
+		lock_cnt = 325;
+		break;
+	case 31 ... 33:
+		lock_cnt = 300;
+		break;
+	case 34 ... 36:
+		lock_cnt = 275;
+		break;
+	default:
+		lock_cnt = 250;
+		break;
+	}
+
+	*rpll_cp = pll_cp;
+	*rpll_res = pll_res;
+	*rlock_cnt = lock_cnt;
+	return 0;
+}
+
+/**
+ * zynq_pll_set_rate() - Change frequency of a PLL
+ * @hw:		Handle between common and hardware-specific interfaces
+ * @rate:	Desired clock frequency
+ * @prate:	Clock frequency of parent clock
+ * Returns 0 on success, negative errno otherwise.
+ */
+static int zynq_pll_set_rate(struct clk_hw *hw, unsigned long rate,
+		unsigned long prate)
+{
+	struct zynq_pll *clk = to_zynq_pll(hw);
+	u32 reg, fbdiv, pll_res, pll_cp, lock_cnt;
+	unsigned long flags;
+
+	/*
+	 * Set a new rate to the PLL includes bypassing and resetting the PLL,
+	 * hence the connected subsystem will see old_f->bypass_f->new_f. Every
+	 * driver must register clock notifiers for its clock to make sure it is
+	 * asked for rate changes. This way it can make sure it can work with
+	 * new_f and do whatever is necessary to continue working after such a
+	 * change.
+	 */
+	/* Rate change is only possible if not bypassed */
+	if (clk->bypassed)
+		return -EINVAL;
+
+	fbdiv = DIV_ROUND_CLOSEST(rate, prate);
+	if (zynq_pll_get_pll_params(fbdiv, &pll_cp, &pll_res, &lock_cnt))
+		return -EINVAL;
+
+	spin_lock_irqsave(&clk->lock, flags);
+
+	/* Write new parameters */
+	reg = readl(clk->pll_ctrl);
+	reg &= ~PLLCTRL_FBDIV_MASK;
+	reg |= (fbdiv << PLLCTRL_FBDIV_SHIFT) & PLLCTRL_FBDIV_MASK;
+	writel(reg, clk->pll_ctrl);
+
+	reg = (pll_res << PLLCFG_PLLRES_SHIFT) & PLLCFG_PLLRES_MASK;
+	reg |= (pll_cp << PLLCFG_PLLCP_SHIFT) & PLLCFG_PLLCP_MASK;
+	reg |= (lock_cnt << PLLCFG_LOCKCNT_SHIFT) & PLLCFG_LOCKCNT_MASK;
+	writel(reg, clk->pll_cfg);
+
+	/* bypass PLL */
+	reg = readl(clk->pll_ctrl);
+	reg |= PLLCTRL_BYPASS_MASK;
+	writel(reg, clk->pll_ctrl);
+	/* reset PLL */
+	reg |= PLLCTRL_RESET_MASK;
+	writel(reg, clk->pll_ctrl);
+	reg &= ~PLLCTRL_RESET_MASK;
+	writel(reg, clk->pll_ctrl);
+	/* wait for PLL lock */
+	while (readl(clk->pll_status) & (1 << clk->lockbit)) ;
+	/* remove bypass */
+	reg &= ~PLLCTRL_BYPASS_MASK;
+	writel(reg, clk->pll_ctrl);
+
+	spin_unlock_irqrestore(&clk->lock, flags);
+
+	return 0;
+}
+
+/**
+ * zynq_pll_round_rate() - Round a clock frequency
+ * @hw:		Handle between common and hardware-specific interfaces
+ * @rate:	Desired clock frequency
+ * @prate:	Clock frequency of parent clock
+ * Returns frequency closest to @rate the hardware can generate.
+ */
+static long zynq_pll_round_rate(struct clk_hw *hw, unsigned long rate,
+		unsigned long *prate)
+{
+	struct zynq_pll *clk = to_zynq_pll(hw);
+	u32 fbdiv;
+
+	if (clk->bypassed)
+		return *prate;
+
+	fbdiv = DIV_ROUND_CLOSEST(rate, *prate);
+	if (fbdiv < 13)
+		fbdiv = 13;
+	else if (fbdiv > 66)
+		fbdiv = 66;
+
+	return *prate * fbdiv;
+}
+
+/**
+ * zynq_pll_recalc_rate() - Recalculate clock frequency
+ * @hw:			Handle between common and hardware-specific interfaces
+ * @parent_rate:	Clock frequency of parent clock
+ * Returns current clock frequency.
+ */
+static unsigned long zynq_pll_recalc_rate(struct clk_hw *hw, unsigned long
+		parent_rate)
+{
+	struct zynq_pll *clk = to_zynq_pll(hw);
+	u32 fbdiv;
+
+	if (clk->bypassed)
+		return parent_rate;
+
+	/* makes probably sense to redundantly save fbdiv in the struct
+	 * zynq_pll to save the IO access. */
+	fbdiv = (readl(clk->pll_ctrl) & PLLCTRL_FBDIV_MASK) >>
+		PLLCTRL_FBDIV_SHIFT;
+
+	return parent_rate * fbdiv;
+}
+
+/**
+ * zynq_pll_enable - Enable clock
+ * @hw:		Handle between common and hardware-specific interfaces
+ * Returns 0 on success
+ */
+static int zynq_pll_enable(struct clk_hw *hw)
+{
+	unsigned long flags = 0;
+	u32 reg;
+	struct zynq_pll *clk = to_zynq_pll(hw);
+
+	if (!clk->bypassed)
+		return 0;
+
+	pr_info("PLL: Enable\n");
+
+	/* Power up PLL and wait for lock before removing bypass */
+	spin_lock_irqsave(&clk->lock, flags);
+
+	reg = readl(clk->pll_ctrl);
+	reg &= ~(PLLCTRL_RESET_MASK | PLLCTRL_PWRDWN_MASK);
+	writel(reg, clk->pll_ctrl);
+	while (readl(clk->pll_status) & (1 << clk->lockbit))
+		;
+
+	reg = readl(clk->pll_ctrl);
+	reg &= ~PLLCTRL_BYPASS_MASK;
+	writel(reg, clk->pll_ctrl);
+
+	spin_unlock_irqrestore(&clk->lock, flags);
+
+	clk->bypassed = 0;
+
+	return 0;
+}
+
+/**
+ * zynq_pll_disable - Disable clock
+ * @hw:		Handle between common and hardware-specific interfaces
+ * Returns 0 on success
+ */
+static void zynq_pll_disable(struct clk_hw *hw)
+{
+	unsigned long flags = 0;
+	u32 reg;
+	struct zynq_pll *clk = to_zynq_pll(hw);
+
+	if (clk->bypassed)
+		return;
+
+	pr_info("PLL: Bypass\n");
+
+	/* Set bypass bit and shut down PLL */
+	spin_lock_irqsave(&clk->lock, flags);
+
+	reg = readl(clk->pll_ctrl);
+	reg |= PLLCTRL_BYPASS_MASK;
+	writel(reg, clk->pll_ctrl);
+	reg |= PLLCTRL_RESET_MASK | PLLCTRL_PWRDWN_MASK;
+	writel(reg, clk->pll_ctrl);
+
+	spin_unlock_irqrestore(&clk->lock, flags);
+
+	clk->bypassed = 1;
+}
+
+/**
+ * zynq_pll_is_enabled - Check if a clock is enabled
+ * @hw:		Handle between common and hardware-specific interfaces
+ * Returns 1 if the clock is enabled, 0 otherwise.
+ *
+ * Not sure this is a good idea, but since disabled means bypassed for
+ * this clock implementation we say we are always enabled.
+ */
+static int zynq_pll_is_enabled(struct clk_hw *hw)
+{
+	return 1;
+}
+
+static const struct clk_ops zynq_pll_ops = {
+	.enable = zynq_pll_enable,
+	.disable = zynq_pll_disable,
+	.is_enabled = zynq_pll_is_enabled,
+	.set_rate = zynq_pll_set_rate,
+	.round_rate = zynq_pll_round_rate,
+	.recalc_rate = zynq_pll_recalc_rate
+};
+
+/**
+ * clk_register_zynq_pll() - Register PLL with the clock framework
+ * @np	Pointer to the DT device node
+ */
+static void clk_register_zynq_pll(struct device_node *np)
+{
+	struct zynq_pll *pll;
+	struct clk *clk;
+	int ret;
+	u32 reg;
+	u32 regs[3];
+	const char *parent_name;
+	unsigned long flags = 0;
+	struct clk_init_data initd = {
+		.ops = &zynq_pll_ops,
+		.num_parents = 1,
+		.flags = 0
+	};
+
+	ret = of_property_read_u32_array(np, "reg", regs, ARRAY_SIZE(regs));
+	if (WARN_ON(ret))
+		return;
+
+	if (of_property_read_string(np, "clock-output-names", &initd.name))
+		initd.name = np->name;
+
+	parent_name = of_clk_get_parent_name(np, 0);
+	initd.parent_names = &parent_name;
+
+	pll = kmalloc(sizeof(*pll), GFP_KERNEL);
+	if (!pll) {
+		pr_err("%s: Could not allocate Zynq PLL clk.\n", __func__);
+		return;
+	}
+
+	/* Populate the struct */
+	pll->hw.init = &initd;
+	pll->pll_ctrl = zynq_slcr_base + regs[0];
+	pll->pll_cfg = zynq_slcr_base + regs[1];
+	pll->pll_status = zynq_slcr_base + regs[2];
+	spin_lock_init(&pll->lock);
+	ret = of_property_read_u32(np, "lockbit", &pll->lockbit);
+	if (WARN_ON(ret))
+		goto free_pll;
+
+
+	if (readl(pll->pll_ctrl) & PLLCTRL_BYPASS_MASK)
+		pll->bypassed = 1;
+	else
+		pll->bypassed = 0;
+
+	spin_lock_irqsave(&pll->lock, flags);
+
+	reg = readl(pll->pll_ctrl);
+	reg &= ~PLLCTRL_BPQUAL_MASK;
+	writel(reg, pll->pll_ctrl);
+
+	spin_unlock_irqrestore(&pll->lock, flags);
+
+	clk = clk_register(NULL, &pll->hw);
+	if (WARN_ON(IS_ERR(clk)))
+		goto free_pll;
+
+	WARN_ON(of_clk_add_provider(np, of_clk_src_simple_get, clk));
+	/*
+	 * at least until all clock lookups and init is converted to DT add a
+	 * clkdev to help clk lookups
+	 */
+	clk_register_clkdev(clk, NULL, initd.name);
+
+	return;
+
+free_pll:
+	kfree(pll);
+}
+
+
 static DEFINE_SPINLOCK(armclk_lock);
 static DEFINE_SPINLOCK(ddrclk_lock);
 static DEFINE_SPINLOCK(dciclk_lock);
@@ -67,15 +480,15 @@ static DEFINE_SPINLOCK(aperclk_lock);
 
 
 /* Clock parent arrays */
-static const char *cpu_parents[] __initdata = {"ARMPLL", "ARMPLL",
-	"DDRPLL", "IOPLL"};
-static const char *def_periph_parents[] __initdata = {"IOPLL", "IOPLL",
-	"ARMPLL", "DDRPLL"};
-static const char *gem_parents[] __initdata = {"IOPLL", "IOPLL", "ARMPLL",
-	"DDRPLL", "GEM0EMIO", "GEM0EMIO", "GEM0EMIO", "GEM0EMIO"};
-static const char *dbg_parents[] __initdata = {"IOPLL", "IOPLL", "ARMPLL",
-	"DDRPLL", "DBGEMIOTRC", "DBGEMIOTRC", "DBGEMIOTRC", "DBGEMIOTRC"};
-static const char *dci_parents[] __initdata = {"DDRPLL"};
+static const char *cpu_parents[] __initdata = {"armpll", "armpll",
+	"ddrpll", "iopll"};
+static const char *def_periph_parents[] __initdata = {"iopll", "iopll",
+	"armpll", "ddrpll"};
+static const char *gem_parents[] __initdata = {"iopll", "iopll", "armpll",
+	"ddrpll", "GEM0EMIO", "GEM0EMIO", "GEM0EMIO", "GEM0EMIO"};
+static const char *dbg_parents[] __initdata = {"iopll", "iopll", "armpll",
+	"ddrpll", "DBGEMIOTRC", "DBGEMIOTRC", "DBGEMIOTRC", "DBGEMIOTRC"};
+static const char *dci_parents[] __initdata = {"ddrpll"};
 static const char *clk621_parents[] __initdata = {"CPU_MASTER_CLK"};
 
 /**
@@ -95,6 +508,7 @@ static void __init zynq_clkdev_add(const char *con_id, const char *dev_id,
 
 static const struct of_device_id clk_match[] __initconst = {
 	{ .compatible = "fixed-clock", .data = of_fixed_clk_setup, },
+	{ .compatible = "xlnx,zynq-pll", .data = clk_register_zynq_pll, },
 	{}
 };
 
@@ -111,15 +525,9 @@ void __init zynq_clock_init(void __iomem *slcr_base)
 
 	pr_info("Zynq clock init\n");
 
+	zynq_slcr_base = slcr_base;
 	of_clk_init(clk_match);
 
-	clk = clk_register_zynq_pll("ARMPLL", SLCR_ARMPLL_CTRL, SLCR_ARMPLL_CFG,
-			SLCR_PLL_STATUS, 0);
-	clk = clk_register_zynq_pll("DDRPLL", SLCR_DDRPLL_CTRL, SLCR_DDRPLL_CFG,
-			SLCR_PLL_STATUS, 1);
-	clk = clk_register_zynq_pll("IOPLL", SLCR_IOPLL_CTRL, SLCR_IOPLL_CFG,
-			SLCR_PLL_STATUS, 2);
-
 	/* CPU clocks */
 	clk = clk_register_zynq_d1m("CPU_MASTER_CLK", SLCR_ARM_CLK_CTRL,
 			cpu_parents, 4, &armclk_lock);
@@ -153,14 +561,14 @@ void __init zynq_clock_init(void __iomem *slcr_base)
 	clk_prepare(clk);
 	clk_enable(clk);
 	/* DDR clocks */
-	clk = clk_register_divider(NULL, "DDR_2X_DIV_CLK", "DDRPLL", 0,
+	clk = clk_register_divider(NULL, "DDR_2X_DIV_CLK", "ddrpll", 0,
 			SLCR_DDR_CLK_CTRL, 26, 6, CLK_DIVIDER_ONE_BASED,
 			&ddrclk_lock);
 	clk = clk_register_gate(NULL, "DDR_2X_CLK", "DDR_2X_DIV_CLK", 0,
 			SLCR_DDR_CLK_CTRL, 1, 0, &ddrclk_lock);
 	clk_prepare(clk);
 	clk_enable(clk);
-	clk = clk_register_divider(NULL, "DDR_3X_DIV_CLK", "DDRPLL", 0,
+	clk = clk_register_divider(NULL, "DDR_3X_DIV_CLK", "ddrpll", 0,
 			SLCR_DDR_CLK_CTRL, 20, 6, CLK_DIVIDER_ONE_BASED,
 			&ddrclk_lock);
 	clk = clk_register_gate(NULL, "DDR_3X_CLK", "DDR_3X_DIV_CLK", 0,
diff --git a/drivers/clk/zynq/pll.c b/drivers/clk/zynq/pll.c
deleted file mode 100644
index 252eb6f..0000000
--- a/drivers/clk/zynq/pll.c
+++ /dev/null
@@ -1,424 +0,0 @@
-/**
- * Clock implementation modeling the PLLs used in Xilinx Zynq.
- * All PLLs are sourced by the fixed rate PS_CLK.
- * Rate is adjustable by reprogramming the feedback divider.
- * PLLs can be bypassed. When the bypass bit is set the PLL_OUT = PS_CLK
- *
- * The PLL is bypassed when its enable count reaches zero, and brought up
- * when a clock consumer enables the PLL
- * Bypassing the PLL also shuts it down.
- *
- * Functions to set a new rate are provided, though they are only compile
- * tested!!! There is no code calling those, yet.
- *
- *  Copyright (C) 2012 Xilinx
- *
- * This software is licensed under the terms of the GNU General Public
- * License version 2, as published by the Free Software Foundation, and
- * may be copied, distributed, and modified under those terms.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- */
-
-#include <linux/clk-provider.h>
-#include <linux/err.h>
-#include <linux/io.h>
-#include <linux/kernel.h>
-#include <linux/slab.h>
-#include <linux/clk/zynq.h>
-
-/**
- * struct zynq_pll
- * @hw:		Handle between common and hardware-specific interfaces
- * @pll_ctrl:	PLL control register
- * @pll_cfg:	PLL config register
- * @pll_status:	PLL status register
- * @lock:	Register lock
- * @lockbit:	Indicates the associated PLL_LOCKED bit in the PLL status
- *		register.
- * @bypassed:	Indicates PLL bypass. 1 = bypassed, 0 = PLL output
- */
-struct zynq_pll {
-	struct clk_hw	hw;
-	void __iomem	*pll_ctrl;
-	void __iomem	*pll_cfg;
-	void __iomem	*pll_status;
-	spinlock_t	lock;
-	u8		lockbit;
-	u8		bypassed;
-};
-#define to_zynq_pll(_hw)	container_of(_hw, struct zynq_pll, hw)
-
-/* Register bitfield defines */
-#define PLLCTRL_FBDIV_MASK	0x7f000
-#define PLLCTRL_FBDIV_SHIFT	12
-#define PLLCTRL_BYPASS_MASK	0x10
-#define PLLCTRL_BYPASS_SHIFT	4
-#define PLLCTRL_BPQUAL_MASK	(1 << 3)
-#define PLLCTRL_PWRDWN_MASK	2
-#define PLLCTRL_PWRDWN_SHIFT	1
-#define PLLCTRL_RESET_MASK	1
-#define PLLCTRL_RESET_SHIFT	0
-#define PLLCFG_PLLRES_MASK	0xf0
-#define PLLCFG_PLLRES_SHIFT	4
-#define PLLCFG_PLLCP_MASK	0xf00
-#define PLLCFG_PLLCP_SHIFT	8
-#define PLLCFG_LOCKCNT_MASK	0x3ff000
-#define PLLCFG_LOCKCNT_SHIFT	12
-
-/**
- * zynq_pll_get_params() - Get PLL parameters for given feedback divider
- * @fbdiv: Desired feedback divider
- * @rpll_cp: PLL_CP value (return value)
- * @rpll_res: PLL_RES value (return value)
- * @rlock_cnt: LOCK_CNT value (return value)
- * Returns 0 on success.
- */
-static int zynq_pll_get_pll_params(unsigned int fbdiv, u32 *rpll_cp,
-		u32 *rpll_res, u32 *rlock_cnt)
-{
-	unsigned int pll_cp;
-	unsigned int pll_res;
-	unsigned int lock_cnt;
-
-	/* Check that fbdiv is in a valid range */
-	if ((fbdiv < 13) || (fbdiv > 66))
-		return -EINVAL;
-
-	/* Set other PLL parameters according to target fbdiv */
-	if ((fbdiv >= 41) && (fbdiv <= 47))
-		pll_cp = 3;
-	else
-		pll_cp = 2;
-
-	if (fbdiv <= 15)
-		pll_res = 6;
-	else if ((fbdiv >= 16) && (fbdiv <= 19))
-		pll_res = 10;
-	else if ((fbdiv >= 31) && (fbdiv <= 40))
-		pll_res = 2;
-	else if (fbdiv >= 48)
-		pll_res = 4;
-	else
-		pll_res = 12;
-
-	switch (fbdiv) {
-	case 13:
-		lock_cnt = 750;
-		break;
-	case 14:
-		lock_cnt = 700;
-		break;
-	case 15:
-		lock_cnt = 650;
-		break;
-	case 16:
-		lock_cnt = 625;
-		break;
-	case 17:
-		lock_cnt = 575;
-		break;
-	case 18:
-		lock_cnt = 550;
-		break;
-	case 19:
-		lock_cnt = 525;
-		break;
-	case 20:
-		lock_cnt = 500;
-		break;
-	case 21:
-		lock_cnt = 475;
-		break;
-	case 22:
-		lock_cnt = 450;
-		break;
-	case 23:
-		lock_cnt = 425;
-		break;
-	case 24 ... 25:
-		lock_cnt = 400;
-		break;
-	case 26:
-		lock_cnt = 375;
-		break;
-	case 27 ... 28:
-		lock_cnt = 350;
-		break;
-	case 29 ... 30:
-		lock_cnt = 325;
-		break;
-	case 31 ... 33:
-		lock_cnt = 300;
-		break;
-	case 34 ... 36:
-		lock_cnt = 275;
-		break;
-	default:
-		lock_cnt = 250;
-		break;
-	}
-
-	*rpll_cp = pll_cp;
-	*rpll_res = pll_res;
-	*rlock_cnt = lock_cnt;
-	return 0;
-}
-
-/**
- * zynq_pll_set_rate() - Change frequency of a PLL
- * @hw:		Handle between common and hardware-specific interfaces
- * @rate:	Desired clock frequency
- * @prate:	Clock frequency of parent clock
- * Returns 0 on success, negative errno otherwise.
- */
-static int zynq_pll_set_rate(struct clk_hw *hw, unsigned long rate,
-		unsigned long prate)
-{
-	struct zynq_pll *clk = to_zynq_pll(hw);
-	u32 reg, fbdiv, pll_res, pll_cp, lock_cnt;
-	unsigned long flags;
-
-	/*
-	 * Set a new rate to the PLL includes bypassing and resetting the PLL,
-	 * hence the connected subsystem will see old_f->bypass_f->new_f. Every
-	 * driver must register clock notifiers for its clock to make sure it is
-	 * asked for rate changes. This way it can make sure it can work with
-	 * new_f and do whatever is necessary to continue working after such a
-	 * change.
-	 */
-	/* Rate change is only possible if not bypassed */
-	if (clk->bypassed)
-		return -EINVAL;
-
-	fbdiv = DIV_ROUND_CLOSEST(rate, prate);
-	if (zynq_pll_get_pll_params(fbdiv, &pll_cp, &pll_res, &lock_cnt))
-		return -EINVAL;
-
-	spin_lock_irqsave(&clk->lock, flags);
-
-	/* Write new parameters */
-	reg = readl(clk->pll_ctrl);
-	reg &= ~PLLCTRL_FBDIV_MASK;
-	reg |= (fbdiv << PLLCTRL_FBDIV_SHIFT) & PLLCTRL_FBDIV_MASK;
-	writel(reg, clk->pll_ctrl);
-
-	reg = (pll_res << PLLCFG_PLLRES_SHIFT) & PLLCFG_PLLRES_MASK;
-	reg |= (pll_cp << PLLCFG_PLLCP_SHIFT) & PLLCFG_PLLCP_MASK;
-	reg |= (lock_cnt << PLLCFG_LOCKCNT_SHIFT) & PLLCFG_LOCKCNT_MASK;
-	writel(reg, clk->pll_cfg);
-
-	/* bypass PLL */
-	reg = readl(clk->pll_ctrl);
-	reg |= PLLCTRL_BYPASS_MASK;
-	writel(reg, clk->pll_ctrl);
-	/* reset PLL */
-	reg |= PLLCTRL_RESET_MASK;
-	writel(reg, clk->pll_ctrl);
-	reg &= ~PLLCTRL_RESET_MASK;
-	writel(reg, clk->pll_ctrl);
-	/* wait for PLL lock */
-	while (readl(clk->pll_status) & (1 << clk->lockbit)) ;
-	/* remove bypass */
-	reg &= ~PLLCTRL_BYPASS_MASK;
-	writel(reg, clk->pll_ctrl);
-
-	spin_unlock_irqrestore(&clk->lock, flags);
-
-	return 0;
-}
-
-/**
- * zynq_pll_round_rate() - Round a clock frequency
- * @hw:		Handle between common and hardware-specific interfaces
- * @rate:	Desired clock frequency
- * @prate:	Clock frequency of parent clock
- * Returns frequency closest to @rate the hardware can generate.
- */
-static long zynq_pll_round_rate(struct clk_hw *hw, unsigned long rate,
-		unsigned long *prate)
-{
-	struct zynq_pll *clk = to_zynq_pll(hw);
-	u32 fbdiv;
-
-	if (clk->bypassed)
-		return *prate;
-
-	fbdiv = DIV_ROUND_CLOSEST(rate, *prate);
-	if (fbdiv < 13)
-		fbdiv = 13;
-	else if (fbdiv > 66)
-		fbdiv = 66;
-
-	return *prate * fbdiv;
-}
-
-/**
- * zynq_pll_recalc_rate() - Recalculate clock frequency
- * @hw:			Handle between common and hardware-specific interfaces
- * @parent_rate:	Clock frequency of parent clock
- * Returns current clock frequency.
- */
-static unsigned long zynq_pll_recalc_rate(struct clk_hw *hw, unsigned long
-		parent_rate)
-{
-	struct zynq_pll *clk = to_zynq_pll(hw);
-	u32 fbdiv;
-
-	if (clk->bypassed)
-		return parent_rate;
-
-	/* makes probably sense to redundantly save fbdiv in the struct
-	 * zynq_pll to save the IO access. */
-	fbdiv = (readl(clk->pll_ctrl) & PLLCTRL_FBDIV_MASK) >>
-		PLLCTRL_FBDIV_SHIFT;
-
-	return parent_rate * fbdiv;
-}
-
-/**
- * zynq_pll_enable - Enable clock
- * @hw:		Handle between common and hardware-specific interfaces
- * Returns 0 on success
- */
-static int zynq_pll_enable(struct clk_hw *hw)
-{
-	unsigned long flags = 0;
-	u32 reg;
-	struct zynq_pll *clk = to_zynq_pll(hw);
-
-	if (!clk->bypassed)
-		return 0;
-
-	pr_info("PLL: Enable\n");
-
-	/* Power up PLL and wait for lock before removing bypass */
-	spin_lock_irqsave(&clk->lock, flags);
-
-	reg = readl(clk->pll_ctrl);
-	reg &= ~(PLLCTRL_RESET_MASK | PLLCTRL_PWRDWN_MASK);
-	writel(reg, clk->pll_ctrl);
-	while (readl(clk->pll_status) & (1 << clk->lockbit))
-		;
-
-	reg = readl(clk->pll_ctrl);
-	reg &= ~PLLCTRL_BYPASS_MASK;
-	writel(reg, clk->pll_ctrl);
-
-	spin_unlock_irqrestore(&clk->lock, flags);
-
-	clk->bypassed = 0;
-
-	return 0;
-}
-
-/**
- * zynq_pll_disable - Disable clock
- * @hw:		Handle between common and hardware-specific interfaces
- * Returns 0 on success
- */
-static void zynq_pll_disable(struct clk_hw *hw)
-{
-	unsigned long flags = 0;
-	u32 reg;
-	struct zynq_pll *clk = to_zynq_pll(hw);
-
-	if (clk->bypassed)
-		return;
-
-	pr_info("PLL: Bypass\n");
-
-	/* Set bypass bit and shut down PLL */
-	spin_lock_irqsave(&clk->lock, flags);
-
-	reg = readl(clk->pll_ctrl);
-	reg |= PLLCTRL_BYPASS_MASK;
-	writel(reg, clk->pll_ctrl);
-	reg |= PLLCTRL_RESET_MASK | PLLCTRL_PWRDWN_MASK;
-	writel(reg, clk->pll_ctrl);
-
-	spin_unlock_irqrestore(&clk->lock, flags);
-
-	clk->bypassed = 1;
-}
-
-/**
- * zynq_pll_is_enabled - Check if a clock is enabled
- * @hw:		Handle between common and hardware-specific interfaces
- * Returns 1 if the clock is enabled, 0 otherwise.
- *
- * Not sure this is a good idea, but since disabled means bypassed for
- * this clock implementation we say we are always enabled.
- */
-static int zynq_pll_is_enabled(struct clk_hw *hw)
-{
-	return 1;
-}
-
-static const struct clk_ops zynq_pll_ops = {
-	.enable = zynq_pll_enable,
-	.disable = zynq_pll_disable,
-	.is_enabled = zynq_pll_is_enabled,
-	.set_rate = zynq_pll_set_rate,
-	.round_rate = zynq_pll_round_rate,
-	.recalc_rate = zynq_pll_recalc_rate
-};
-
-/**
- * clk_register_zynq_pll() - Register PLL with the clock framework
- * @name:	Clock name
- * @pllctrl:	Pointer to PLL control register
- * @pllcfg:	Pointer to PLL configuration register
- * @pllstatus:	Pointer to PLL status register
- * @lockbit:	Indicates the associated PLL_LOCKED bit in the PLL status
- *		register.
- * Returns clk_register() return value or errpointer.
- */
-struct clk *clk_register_zynq_pll(const char *name, void __iomem *pllctrl,
-		void __iomem *pllcfg, void __iomem *pllstatus, u8 lockbit)
-{
-	struct zynq_pll *clk;
-	u32 reg;
-	unsigned long flags = 0;
-	const char *pnames[] = {"PS_CLK"};
-	struct clk_init_data initd = {
-		.name = name,
-		.ops = &zynq_pll_ops,
-		.parent_names = pnames,
-		.num_parents = 1,
-		.flags = 0
-	};
-
-	clk = kmalloc(sizeof(*clk), GFP_KERNEL);
-	if (!clk) {
-		pr_err("%s: Could not allocate Zynq PLL clk.\n", __func__);
-		return ERR_PTR(-ENOMEM);
-	}
-
-
-	/* Populate the struct */
-	clk->hw.init = &initd;
-	clk->pll_ctrl = pllctrl;
-	clk->pll_cfg = pllcfg;
-	clk->pll_status = pllstatus;
-	spin_lock_init(&clk->lock);
-	clk->lockbit = lockbit;
-
-	if (readl(clk->pll_ctrl) & PLLCTRL_BYPASS_MASK)
-		clk->bypassed = 1;
-	else
-		clk->bypassed = 0;
-
-	spin_lock_irqsave(&clk->lock, flags);
-
-	reg = readl(clk->pll_ctrl);
-	reg &= ~PLLCTRL_BPQUAL_MASK;
-	writel(reg, clk->pll_ctrl);
-
-	spin_unlock_irqrestore(&clk->lock, flags);
-
-	return clk_register(NULL, &clk->hw);
-}
diff --git a/include/linux/clk/zynq.h b/include/linux/clk/zynq.h
index 845a0c5..f14adbc 100644
--- a/include/linux/clk/zynq.h
+++ b/include/linux/clk/zynq.h
@@ -28,9 +28,6 @@ struct clk *clk_register_zynq_d1m(const char *name,
 		void __iomem *clkctrl, const char **pnames, u8 num_parents,
 		spinlock_t *lock);
 
-struct clk *clk_register_zynq_pll(const char *name, void __iomem *pllctrl,
-		void __iomem *pllcfg, void __iomem *pllstatus, u8 lockbit);
-
 struct clk *clk_register_zynq_clk621(const char *name,
 		void __iomem *clkctrl, void __iomem *clk621,
 		unsigned int basediv,
-- 
1.7.1

