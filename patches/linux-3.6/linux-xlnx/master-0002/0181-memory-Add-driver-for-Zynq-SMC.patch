From 6cffa68066c3dbace05b6937b8e3d671ca6cd62a Mon Sep 17 00:00:00 2001
From: Soren Brinkmann <soren.brinkmann@xilinx.com>
Date: Tue, 5 Feb 2013 10:03:10 +0100
Subject: [PATCH] memory: Add driver for Zynq SMC

This adds a driver for Zynq's static memory controller.
The SMC (compatible with ARM's PL353)  supports NAND, NOR and SRAM memory.
This driver separates SMC generic code from the memory specific drivers
and provides an API for them.
Additionaly, the SMC driver manages power management features like
clock gating.

This patch also has impact on the device tree bindings. Existing NAND and NOR
nodes have to converted to subnodes of the new SMC node.

Signed-off-by: Soren Brinkmann <soren.brinkmann@xilinx.com>
Signed-off-by: Michal Simek <michal.simek@xilinx.com>
---
 .../devicetree/bindings/arm/zynq/xlnx,zynq-smc.txt |   30 +
 arch/arm/boot/dts/zynq-afx-nand.dts                |   60 ++-
 arch/arm/boot/dts/zynq-afx-nor.dts                 |   70 ++-
 arch/arm/boot/dts/zynq-zc770-xm011.dts             |   60 ++-
 arch/arm/boot/dts/zynq-zc770-xm012.dts             |   55 +-
 drivers/clk/zynq/clk.c                             |   19 +-
 drivers/memory/Kconfig                             |    7 +
 drivers/memory/Makefile                            |    1 +
 drivers/memory/zynq-smc.c                          |  602 ++++++++++++++++++++
 drivers/mtd/nand/xilinx_nandps.c                   |  244 ++-------
 include/linux/memory/zynq-smc.h                    |   32 +
 11 files changed, 853 insertions(+), 327 deletions(-)
 create mode 100644 Documentation/devicetree/bindings/arm/zynq/xlnx,zynq-smc.txt
 create mode 100644 drivers/memory/zynq-smc.c
 create mode 100644 include/linux/memory/zynq-smc.h

diff --git a/Documentation/devicetree/bindings/arm/zynq/xlnx,zynq-smc.txt b/Documentation/devicetree/bindings/arm/zynq/xlnx,zynq-smc.txt
new file mode 100644
index 0000000..1ae80ed
--- /dev/null
+++ b/Documentation/devicetree/bindings/arm/zynq/xlnx,zynq-smc.txt
@@ -0,0 +1,30 @@
+Device tree bindings for Zynq's SMC (PL353)
+
+The SMC supports NAND, NOR and SRAM memory. The SMC driver handles generic
+tasks, while children drivers handle memory type specifics.
+
+Required properties:
+ compatible: Compatibility string. Must be "xlnx,ps7-smc".
+ reg: Specify the base and size of the SMC registers in the memory map.
+      E.g.: reg = <0xe000e000 0x1000>;
+ #address-cells: Address cells, must be 1.
+ #size-cells: Size cells. Must be 1.
+ ranges
+
+Child nodes:
+ For NAND the "xlnx,ps7-nand" and for NOR the "cfi-flash" drivers are supported
+ as child nodes.
+
+Example:
+	ps7_smc_0: ps7-smc@e000e000 {
+		compatible = "xlnx,ps7-smc";
+		reg = <0xe000e000 0x1000>;
+		#address-cells = <1>;
+		#size-cells = <1>;
+		ranges;
+
+		ps7_nand_0: ps7-nand@e1000000 {
+			compatible = "xlnx,ps7-nand-1.00.a";
+			(...)
+		};
+	};
diff --git a/arch/arm/boot/dts/zynq-afx-nand.dts b/arch/arm/boot/dts/zynq-afx-nand.dts
index 32c6d71..b0d4f45 100644
--- a/arch/arm/boot/dts/zynq-afx-nand.dts
+++ b/arch/arm/boot/dts/zynq-afx-nand.dts
@@ -78,36 +78,44 @@
 			interrupt-parent = <&gic>;
 		};
 
-		nand@e1000000 {
-			compatible = "xlnx,ps7-nand-1.00.a";
-			reg = <0xe1000000 0x1000000 0xe000e000 0x1000>;
-			xlnx,nand-width = <16>;
-			#address-cells = <0x1>;
-			#size-cells = <0x1>;
-
-			partition@0 {
-				label = "nand-fsbl-uboot-bit";
-				reg = <0x0 0x500000>;
+		smc@0xe000e000 {
+			compatible = "xlnx,ps7-smc";
+			reg = <0xe000e000 0x1000>;
+			#address-cells = <1>;
+			#size-cells = <1>;
+			ranges;
+
+			nand@e1000000 {
+				compatible = "xlnx,ps7-nand-1.00.a";
+				reg = <0xe1000000 0x1000000>;
+				xlnx,nand-width = <16>;
+				#address-cells = <0x1>;
+				#size-cells = <0x1>;
+
+				partition@0 {
+					label = "nand-fsbl-uboot-bit";
+					reg = <0x0 0x500000>;
+					};
+
+				partition@1 {
+					label = "nand-linux";
+					reg = <0x500000 0x300000>;
 				};
 
-			partition@1 {
-				label = "nand-linux";
-				reg = <0x500000 0x300000>;
-			};
-
-			partition@2 {
-				label = "nand-devicetree";
-				reg = <0x800000 0x100000>;
-			};
+				partition@2 {
+					label = "nand-devicetree";
+					reg = <0x800000 0x100000>;
+				};
 
-			partition@3 {
-				label = "nand-ramdisk";
-				reg = <0x900000 0x400000>;
-			};
+				partition@3 {
+					label = "nand-ramdisk";
+					reg = <0x900000 0x400000>;
+				};
 
-			partition@4 {
-				label = "nand-scratch";
-				reg = <0xd00000 0x200000>;
+				partition@4 {
+					label = "nand-scratch";
+					reg = <0xd00000 0x200000>;
+				};
 			};
 		};
 
diff --git a/arch/arm/boot/dts/zynq-afx-nor.dts b/arch/arm/boot/dts/zynq-afx-nor.dts
index a0197ba..9ae6234 100644
--- a/arch/arm/boot/dts/zynq-afx-nor.dts
+++ b/arch/arm/boot/dts/zynq-afx-nor.dts
@@ -78,39 +78,47 @@
 			interrupt-parent = <&gic>;
 		};
 
-		nor: nor@e2000000 {
-			compatible = "cfi-flash";
-			bank-width = <1>;
-			reg = <0xE2000000 0x2000000>; /* 32MB */
+		smc@0xe000e000 {
+			compatible = "xlnx,ps7-smc";
+			reg = <0xe000e000 0x1000>;
 			#address-cells = <1>;
 			#size-cells = <1>;
-			partition@0 {
-				label = "nor-fsbl";
-				reg = <0x0 0x80000>; /* 512K */
-			};
-			partition@1 {
-				label = "nor-u-boot";
-				reg = <0x80000 0x80000>; /* 512K */
-			};
-			partition@2 {
-				label = "nor-linux";
-				reg = <0x100000 0x500000>; /* 5MB */
-			};
-			partition@3 {
-				label = "nor-device-tree";
-				reg = <0x600000 0x20000>; /* 128K */
-			};
-			partition@4 {
-				label = "nor-user";
-				reg = <0x620000 0x8E0000>; /* 8875K */
-			};
-			partition@5 {
-				label = "nor-scratch";
-				reg = <0xF00000 0x100000>; /* 1MB */
-			};
-			partition@6 {
-				label = "nor-rootfs";
-				reg = <0x1000000 0x1000000>; /* 16MB */
+			ranges;
+
+			nor: nor@e2000000 {
+				compatible = "cfi-flash";
+				bank-width = <1>;
+				reg = <0xE2000000 0x2000000>; /* 32MB */
+				#address-cells = <1>;
+				#size-cells = <1>;
+				partition@0 {
+					label = "nor-fsbl";
+					reg = <0x0 0x80000>; /* 512K */
+				};
+				partition@1 {
+					label = "nor-u-boot";
+					reg = <0x80000 0x80000>; /* 512K */
+				};
+				partition@2 {
+					label = "nor-linux";
+					reg = <0x100000 0x500000>; /* 5MB */
+				};
+				partition@3 {
+					label = "nor-device-tree";
+					reg = <0x600000 0x20000>; /* 128K */
+				};
+				partition@4 {
+					label = "nor-user";
+					reg = <0x620000 0x8E0000>; /* 8875K */
+				};
+				partition@5 {
+					label = "nor-scratch";
+					reg = <0xF00000 0x100000>; /* 1MB */
+				};
+				partition@6 {
+					label = "nor-rootfs";
+					reg = <0x1000000 0x1000000>; /* 16MB */
+				};
 			};
 		};
 	};
diff --git a/arch/arm/boot/dts/zynq-zc770-xm011.dts b/arch/arm/boot/dts/zynq-zc770-xm011.dts
index e8bf6ea..be9fd3d 100644
--- a/arch/arm/boot/dts/zynq-zc770-xm011.dts
+++ b/arch/arm/boot/dts/zynq-zc770-xm011.dts
@@ -113,31 +113,41 @@
 			num-chip-select = <4>;
 		};
 
-		nand@e1000000 {
-			compatible = "xlnx,ps7-nand-1.00.a";
-			reg = <0xe1000000 0x1000000 0xe000e000 0x1000>;
-			xlnx,nand-width = <8>;
-			#address-cells = <0x1>;
-			#size-cells = <0x1>;
-			partition@nand-fsbl-uboot {
-				label = "nand-fsbl-uboot";
-				reg = <0x0 0x100000>;
-			};
-			partition@nand-linux {
-				label = "nand-linux";
-				reg = <0x100000 0x500000>;
-			};
-			partition@nand-device-tree {
-				label = "nand-device-tree";
-				reg = <0x600000 0x20000>;
-			};
-			partition@nand-rootfs {
-				label = "nand-rootfs";
-				reg = <0x620000 0x5E0000>;
-			};
-			partition@nand-bitstream {
-				label = "nand-bitstream";
-				reg = <0xC00000 0x400000>;
+		smc@0xe000e000 {
+			compatible = "xlnx,ps7-smc";
+			reg = <0xe000e000 0x1000>;
+			#address-cells = <1>;
+			#size-cells = <1>;
+			ranges;
+
+			nand@e1000000 {
+				compatible = "xlnx,ps7-nand-1.00.a";
+				reg = <0xe1000000 0x1000000>;
+				xlnx,nand-width = <8>;
+				#address-cells = <1>;
+				#size-cells = <1>;
+
+				partition@nand-fsbl-uboot {
+					label = "nand-fsbl-uboot";
+					reg = <0x0 0x100000>;
+				};
+				partition@nand-linux {
+					label = "nand-linux";
+					reg = <0x100000 0x500000>;
+				};
+				partition@nand-device-tree {
+					label = "nand-device-tree";
+					reg = <0x600000 0x20000>;
+				};
+				partition@nand-rootfs {
+					label = "nand-rootfs";
+					reg = <0x620000 0x5E0000>;
+				};
+				partition@nand-bitstream {
+					label = "nand-bitstream";
+					reg = <0xC00000 0x400000>;
+
+				};
 			};
 		};
 
diff --git a/arch/arm/boot/dts/zynq-zc770-xm012.dts b/arch/arm/boot/dts/zynq-zc770-xm012.dts
index b081c4c..64da8a2 100644
--- a/arch/arm/boot/dts/zynq-zc770-xm012.dts
+++ b/arch/arm/boot/dts/zynq-zc770-xm012.dts
@@ -125,31 +125,40 @@
 			};
 		};
 
-		nor: nor@e2000000 {
-			compatible = "cfi-flash";
-			bank-width = <1>;
-			reg = <0xE2000000 0x2000000>; /* 32MB */
+		smc@0xe000e000 {
+			compatible = "xlnx,ps7-smc";
+			reg = <0xe000e000 0x1000>;
 			#address-cells = <1>;
 			#size-cells = <1>;
-			partition@nor-fsbl-uboot {
-				label = "nor-fsbl-uboot";
-				reg = <0x0 0x100000>;
-			};
-			partition@nor-linux {
-				label = "nor-linux";
-				reg = <0x100000 0x500000>;
-			};
-			partition@nor-device-tree {
-				label = "nor-device-tree";
-				reg = <0x600000 0x20000>;
-			};
-			partition@nor-rootfs {
-				label = "nor-rootfs";
-				reg = <0x620000 0x5E0000>;
-			};
-			partition@nor-bitstream {
-				label = "nor-bitstream";
-				reg = <0xC00000 0x400000>;
+			ranges;
+
+			nor: nor@e2000000 {
+				compatible = "cfi-flash";
+				bank-width = <1>;
+				reg = <0xE2000000 0x2000000>; /* 32MB */
+				#address-cells = <1>;
+				#size-cells = <1>;
+
+				partition@nor-fsbl-uboot {
+					label = "nor-fsbl-uboot";
+					reg = <0x0 0x100000>;
+				};
+				partition@nor-linux {
+					label = "nor-linux";
+					reg = <0x100000 0x500000>;
+				};
+				partition@nor-device-tree {
+					label = "nor-device-tree";
+					reg = <0x600000 0x20000>;
+				};
+				partition@nor-rootfs {
+					label = "nor-rootfs";
+					reg = <0x620000 0x5E0000>;
+				};
+				partition@nor-bitstream {
+					label = "nor-bitstream";
+					reg = <0xC00000 0x400000>;
+				};
 			};
 		};
 
diff --git a/drivers/clk/zynq/clk.c b/drivers/clk/zynq/clk.c
index ffc1c3a..8b74fde 100644
--- a/drivers/clk/zynq/clk.c
+++ b/drivers/clk/zynq/clk.c
@@ -49,8 +49,8 @@
 static DEFINE_SPINLOCK(armclk_lock);
 static DEFINE_SPINLOCK(ddrclk_lock);
 static DEFINE_SPINLOCK(dciclk_lock);
-/* static DEFINE_SPINLOCK(smcclk_lock); */
 static DEFINE_SPINLOCK(pcapclk_lock);
+static DEFINE_SPINLOCK(smcclk_lock);
 static DEFINE_SPINLOCK(lqspiclk_lock);
 static DEFINE_SPINLOCK(gem0clk_lock);
 static DEFINE_SPINLOCK(gem1clk_lock);
@@ -177,11 +177,10 @@ void __init zynq_clock_init(void __iomem *slcr_base)
 			def_periph_parents, &lqspiclk_lock);
 	zynq_clkdev_add(NULL, "LQSPI", clk);
 
-	/*
-	 * clk = clk_register_zynq_gd1m("SMC_CLK", SLCR_SMC_CLK_CTRL,
-	 *		def_periph_parents, &smcclk_lock);
-	 * zynq_clkdev_add(NULL, "SMC", clk);
-	 */
+	clk = clk_register_zynq_gd1m("SMC_CLK", SLCR_SMC_CLK_CTRL,
+			def_periph_parents, &smcclk_lock);
+	zynq_clkdev_add(NULL, "SMC", clk);
+
 	clk = clk_register_zynq_gd1m("PCAP_CLK", SLCR_PCAP_CLK_CTRL,
 			def_periph_parents, &pcapclk_lock);
 	zynq_clkdev_add(NULL, "PCAP", clk);
@@ -329,9 +328,7 @@ void __init zynq_clock_init(void __iomem *slcr_base)
 	clk = clk_register_gate(NULL, "LQSPI_CPU1X", "CPU_1X_CLK", 0,
 			SLCR_APER_CLK_CTRL, 23, 0, &aperclk_lock);
 	zynq_clkdev_add(NULL, "LQSPI_APER", clk);
-	/*
-	 * clk = clk_register_gate(NULL, "SMC_CPU1X", "CPU_1X_CLK", 0,
-	 *		SLCR_APER_CLK_CTRL, 24, 0, &aperclk_lock);
-	 * zynq_clkdev_add(NULL, "SMC_APER", clk);
-	 */
+	clk = clk_register_gate(NULL, "SMC_CPU1X", "CPU_1X_CLK", 0,
+			SLCR_APER_CLK_CTRL, 24, 0, &aperclk_lock);
+	zynq_clkdev_add(NULL, "SMC_APER", clk);
 }
diff --git a/drivers/memory/Kconfig b/drivers/memory/Kconfig
index 067f311..8458cf5 100644
--- a/drivers/memory/Kconfig
+++ b/drivers/memory/Kconfig
@@ -40,4 +40,11 @@ config TEGRA30_MC
 	  analysis, especially for IOMMU/SMMU(System Memory Management
 	  Unit) module.
 
+config ZYNQ_SMC
+	bool "Zynq Static Memory Controller(SMC) driver"
+	default y
+	depends on ARCH_ZYNQ
+	help
+	  This driver is for the Static Memory Controller(SMC) module available
+	  in Zynq SoCs.
 endif
diff --git a/drivers/memory/Makefile b/drivers/memory/Makefile
index 42b3ce9..43dbb70 100644
--- a/drivers/memory/Makefile
+++ b/drivers/memory/Makefile
@@ -5,3 +5,4 @@
 obj-$(CONFIG_TI_EMIF)		+= emif.o
 obj-$(CONFIG_TEGRA20_MC)	+= tegra20-mc.o
 obj-$(CONFIG_TEGRA30_MC)	+= tegra30-mc.o
+obj-$(CONFIG_ZYNQ_SMC)		+= zynq-smc.o
diff --git a/drivers/memory/zynq-smc.c b/drivers/memory/zynq-smc.c
new file mode 100644
index 0000000..2d14388
--- /dev/null
+++ b/drivers/memory/zynq-smc.c
@@ -0,0 +1,602 @@
+/*
+ * Xilinx Zynq SMC Driver
+ *
+ * Copyright (C) 2012 - 2013 Xilinx, Inc.
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ *
+ * Currently only a single SMC instance is supported.
+ */
+
+#include <linux/clk.h>
+#include <linux/io.h>
+#include <linux/kernel.h>
+#include <linux/memory/zynq-smc.h>
+#include <linux/module.h>
+#include <linux/of_platform.h>
+#include <linux/platform_device.h>
+#include <linux/slab.h>
+
+/* Register definitions */
+#define XSMCPS_MEMC_STATUS_OFFS		0	/* Controller status reg, RO */
+#define XSMCPS_CFG_CLR_OFFS		0xC	/* Clear config reg, WO */
+#define XSMCPS_DIRECT_CMD_OFFS		0x10	/* Direct command reg, WO */
+#define XSMCPS_SET_CYCLES_OFFS		0x14	/* Set cycles register, WO */
+#define XSMCPS_SET_OPMODE_OFFS		0x18	/* Set opmode register, WO */
+#define XSMCPS_ECC_STATUS_OFFS		0x400	/* ECC status register */
+#define XSMCPS_ECC_MEMCFG_OFFS		0x404	/* ECC mem config reg */
+#define XSMCPS_ECC_MEMCMD1_OFFS		0x408	/* ECC mem cmd1 reg */
+#define XSMCPS_ECC_MEMCMD2_OFFS		0x40C	/* ECC mem cmd2 reg */
+#define XSMCPS_ECC_VALUE0_OFFS		0x418	/* ECC value 0 reg */
+
+#define XSMCPS_CFG_CLR_INT_1	0x10
+#define XSMCPS_ECC_STATUS_BUSY	(1 << 6)
+#define XSMCPS_DC_UPT_NAND_REGS	((4 << 23) |	/* CS: NAND chip */ \
+				 (2 << 21))	/* UpdateRegs operation */
+
+#define XNANDPS_ECC_CMD1	((0x80)       |	/* Write command */ \
+				 (0 << 8)     |	/* Read command */ \
+				 (0x30 << 16) |	/* Read End command */ \
+				 (1 << 24))	/* Read End command calid */
+
+#define XNANDPS_ECC_CMD2	((0x85)	      |	/* Write col change cmd */ \
+				 (5 << 8)     |	/* Read col change cmd */ \
+				 (0xE0 << 16) |	/* Read col change end cmd */ \
+				 (1 << 24)) /* Read col change end cmd valid */
+/**
+ * struct xsmcps_data
+ * @devclk		Pointer to the peripheral clock
+ * @aperclk		Pointer to the APER clock
+ * @clk_rate_change_nb	Notifier block for clock frequency change callback
+ */
+struct xsmcps_data {
+	struct clk		*devclk;
+	struct clk		*aperclk;
+	struct notifier_block	clk_rate_change_nb;
+	struct resource		*res;
+};
+
+/* SMC virtual register base */
+static void __iomem *xsmcps_base;
+static DEFINE_SPINLOCK(xsmcps_lock);
+
+/**
+ * xsmcps_set_buswidth - Set memory buswidth
+ * @bw	Memory buswidth (8 | 16)
+ * Returns 0 on success or negative errno.
+ *
+ * Must be called with xsmcps_lock held.
+ */
+static int __devinit xsmcps_set_buswidth(unsigned int bw)
+{
+	u32 reg;
+
+	if (bw != 8 && bw != 16)
+		return -EINVAL;
+
+	reg = readl(xsmcps_base + XSMCPS_SET_OPMODE_OFFS);
+	reg &= ~3;
+	if (bw == 16)
+		reg |= 1;
+	writel(reg, xsmcps_base + XSMCPS_SET_OPMODE_OFFS);
+
+	return 0;
+}
+
+/**
+ * xsmcps_set_cycles - Set memory timing parameters
+ * @t0	t_rc		read cycle time
+ * @t1	t_wc		write cycle time
+ * @t2	t_rea/t_ceoe	output enable assertion delay
+ * @t3	t_wp		write enable deassertion delay
+ * @t4	t_clr/t_pc	page cycle time
+ * @t5	t_ar/t_ta	ID read time/turnaround time
+ * @t6	t_rr		busy to RE timing
+ *
+ * Sets NAND chip specific timing parameters.
+ *
+ * Must be called with xsmcps_lock held.
+ */
+static void __devinit xsmcps_set_cycles(u32 t0, u32 t1, u32 t2, u32 t3, u32
+		t4, u32 t5, u32 t6)
+{
+	t0 &= 0xf;
+	t1 = (t1 & 0xf) << 4;
+	t2 = (t2 & 7) << 8;
+	t3 = (t3 & 7) << 11;
+	t4 = (t4 & 7) << 14;
+	t5 = (t5 & 7) << 17;
+	t6 = (t6 & 0xf) << 20;
+
+	t0 |= t1 | t2 | t3 | t4 | t5 | t6;
+
+	writel(t0, xsmcps_base + XSMCPS_SET_CYCLES_OFFS);
+}
+
+/**
+ * xsmcps_ecc_is_busy_noirq - Read ecc busy flag
+ * Returns the ecc_status bit from the ecc_status register. 1 = busy, 0 = idle
+ *
+ * Must be called with xsmcps_lock held.
+ */
+static int xsmcps_ecc_is_busy_noirq(void)
+{
+	return !!(readl(xsmcps_base + XSMCPS_ECC_STATUS_OFFS) &
+			XSMCPS_ECC_STATUS_BUSY);
+}
+
+/**
+ * xsmcps_ecc_is_busy - Read ecc busy flag
+ * Returns the ecc_status bit from the ecc_status register. 1 = busy, 0 = idle
+ */
+int xsmcps_ecc_is_busy(void)
+{
+	unsigned long flags;
+	int ret;
+
+	spin_lock_irqsave(&xsmcps_lock, flags);
+
+	ret = xsmcps_ecc_is_busy_noirq();
+
+	spin_unlock_irqrestore(&xsmcps_lock, flags);
+
+	return ret;
+}
+EXPORT_SYMBOL_GPL(xsmcps_ecc_is_busy);
+
+/**
+ * xsmcps_get_ecc_val - Read ecc_valueN registers
+ * @ecc_reg	Index of the ecc_value reg (0..3)
+ * Returns the content of the requested ecc_value register.
+ *
+ * There are four valid ecc_value registers. The argument is truncated to stay
+ * within this valid boundary.
+ */
+u32 xsmcps_get_ecc_val(int ecc_reg)
+{
+	u32 reg;
+	u32 addr;
+	unsigned long flags;
+
+	ecc_reg &= 3;
+	addr = XSMCPS_ECC_VALUE0_OFFS | (ecc_reg << 2);
+
+	spin_lock_irqsave(&xsmcps_lock, flags);
+
+	reg = readl(xsmcps_base + addr);
+
+	spin_unlock_irqrestore(&xsmcps_lock, flags);
+
+	return reg;
+}
+EXPORT_SYMBOL_GPL(xsmcps_get_ecc_val);
+
+/**
+ * xsmcps_get_nand_int_status_raw - Get NAND interrupt status bit
+ * Returns the raw_int_status1 bit from the memc_status register
+ */
+int xsmcps_get_nand_int_status_raw(void)
+{
+	u32 reg;
+	unsigned long flags;
+
+	spin_lock_irqsave(&xsmcps_lock, flags);
+
+	reg = readl(xsmcps_base + XSMCPS_MEMC_STATUS_OFFS);
+
+	spin_unlock_irqrestore(&xsmcps_lock, flags);
+
+	reg >>= 6;
+	reg &= 1;
+
+	return reg;
+}
+EXPORT_SYMBOL_GPL(xsmcps_get_nand_int_status_raw);
+
+/**
+ * xsmcps_clr_nand_int - Clear NAND interrupt
+ */
+void xsmcps_clr_nand_int(void)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&xsmcps_lock, flags);
+
+	writel(XSMCPS_CFG_CLR_INT_1, xsmcps_base + XSMCPS_CFG_CLR_OFFS);
+
+	spin_unlock_irqrestore(&xsmcps_lock, flags);
+}
+EXPORT_SYMBOL_GPL(xsmcps_clr_nand_int);
+
+/**
+ * xsmcps_set_ecc_mode - Set SMC ECC mode
+ * @mode	ECC mode (BYPASS, APB, MEM)
+ * Returns 0 on success or negative errno.
+ */
+int xsmcps_set_ecc_mode(enum xsmcps_ecc_mode mode)
+{
+	u32 reg;
+	unsigned long flags;
+	int ret = 0;
+
+	switch (mode) {
+	case XSMCPS_ECCMODE_BYPASS:
+	case XSMCPS_ECCMODE_APB:
+	case XSMCPS_ECCMODE_MEM:
+		spin_lock_irqsave(&xsmcps_lock, flags);
+
+		reg = readl(xsmcps_base + XSMCPS_ECC_MEMCFG_OFFS);
+		reg &= ~0xc;
+		reg |= mode << 2;
+		writel(reg, xsmcps_base + XSMCPS_ECC_MEMCFG_OFFS);
+
+		spin_unlock_irqrestore(&xsmcps_lock, flags);
+		break;
+	default:
+		ret = -EINVAL;
+	}
+
+	return ret;
+}
+EXPORT_SYMBOL_GPL(xsmcps_set_ecc_mode);
+
+/**
+ * xsmcps_set_ecc_pg_size - Set SMC ECC page size
+ * @pg_sz	ECC page size
+ * Returns 0 on success or negative errno.
+ */
+int xsmcps_set_ecc_pg_size(unsigned int pg_sz)
+{
+	u32 reg;
+	u32 sz;
+	unsigned long flags;
+
+	switch (pg_sz) {
+	case 0:
+		sz = 0;
+		break;
+	case 512:
+		sz = 1;
+		break;
+	case 1024:
+		sz = 2;
+		break;
+	case 2048:
+		sz = 3;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	spin_lock_irqsave(&xsmcps_lock, flags);
+
+	reg = readl(xsmcps_base + XSMCPS_ECC_MEMCFG_OFFS);
+	reg &= ~3;
+	reg |= sz;
+	writel(reg, xsmcps_base + XSMCPS_ECC_MEMCFG_OFFS);
+
+	spin_unlock_irqrestore(&xsmcps_lock, flags);
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(xsmcps_set_ecc_pg_size);
+
+static int xsmcps_clk_notifier_cb(struct notifier_block *nb,
+		unsigned long event, void *data)
+{
+
+	switch (event) {
+	case PRE_RATE_CHANGE:
+		/*
+		 * if a rate change is announced we need to check whether we can
+		 * run under the changed conditions
+		 */
+		/* fall through */
+	case POST_RATE_CHANGE:
+		return NOTIFY_OK;
+	case ABORT_RATE_CHANGE:
+	default:
+		return NOTIFY_DONE;
+	}
+}
+
+#ifdef CONFIG_PM_SLEEP
+static int xsmcps_suspend(struct device *dev)
+{
+	struct xsmcps_data *xsmcps = dev_get_drvdata(dev);
+
+	clk_disable(xsmcps->devclk);
+	clk_disable(xsmcps->aperclk);
+
+	return 0;
+}
+
+static int xsmcps_resume(struct device *dev)
+{
+	int ret;
+	struct xsmcps_data *xsmcps = dev_get_drvdata(dev);
+
+	ret = clk_enable(xsmcps->aperclk);
+	if (ret) {
+		dev_err(dev, "Cannot enable APER clock.\n");
+		return ret;
+	}
+
+	ret = clk_enable(xsmcps->devclk);
+	if (ret) {
+		dev_err(dev, "Cannot enable device clock.\n");
+		clk_disable(xsmcps->aperclk);
+		return ret;
+	}
+	return ret;
+}
+#endif
+
+static SIMPLE_DEV_PM_OPS(xsmcps_dev_pm_ops, xsmcps_suspend, xsmcps_resume);
+
+/**
+ * xsmcps_init_nand_interface - Initialize the NAND interface
+ * @pdev	Pointer to the platform_device struct
+ * @nand_node	Pointer to the xnandps device_node struct
+ */
+static void __devinit xsmcps_init_nand_interface(struct platform_device *pdev,
+		struct device_node *nand_node)
+{
+	u32 t_rc, t_wc, t_rea, t_wp, t_clr, t_ar, t_rr;
+	unsigned int bw;
+	int err;
+	unsigned long flags;
+
+	err = of_property_read_u32(nand_node, "xlnx,nand-width", &bw);
+	if (err) {
+		dev_warn(&pdev->dev,
+				"xlnx,nand-width not in device tree, using 8");
+		bw = 8;
+	}
+	err = of_property_read_u32(nand_node, "t_rc", &t_rc);
+	if (err) {
+		dev_warn(&pdev->dev, "t_rc not in device tree, using 4");
+		t_rc = 4;
+	}
+	err = of_property_read_u32(nand_node, "t_wc", &t_wc);
+	if (err) {
+		dev_warn(&pdev->dev, "t_wc not in device tree, using 4");
+		t_wc = 4;
+	}
+	err = of_property_read_u32(nand_node, "t_rea", &t_rea);
+	if (err) {
+		dev_warn(&pdev->dev, "t_rea not in device tree, using 1");
+		t_rea = 1;
+	}
+	err = of_property_read_u32(nand_node, "t_wp", &t_wp);
+	if (err) {
+		dev_warn(&pdev->dev, "t_wp not in device tree, using 2");
+		t_wp = 2;
+	}
+	err = of_property_read_u32(nand_node, "t_clr", &t_clr);
+	if (err) {
+		dev_warn(&pdev->dev, "t_clr not in device tree, using 2");
+		t_clr = 2;
+	}
+	err = of_property_read_u32(nand_node, "t_ar", &t_ar);
+	if (err) {
+		dev_warn(&pdev->dev, "t_ar not in device tree, using 2");
+		t_ar = 2;
+	}
+	err = of_property_read_u32(nand_node, "t_rr", &t_rr);
+	if (err) {
+		dev_warn(&pdev->dev, "t_rr not in device tree, using 4");
+		t_rr = 4;
+	}
+
+	spin_lock_irqsave(&xsmcps_lock, flags);
+
+	if (xsmcps_set_buswidth(bw)) {
+		dev_warn(&pdev->dev, "xlnx,nand-width not valid, using 8");
+		xsmcps_set_buswidth(8);
+	}
+
+	/*
+	 * Default assume 50MHz clock (20ns cycle time) and 3V operation
+	 * The SET_CYCLES_REG register value depends on the flash device.
+	 * Look in to the device datasheet and change its value, This value
+	 * is for 2Gb Numonyx flash.
+	 */
+	xsmcps_set_cycles(t_rc, t_wc, t_rea, t_wp, t_clr, t_ar, t_rr);
+	writel(XSMCPS_CFG_CLR_INT_1, xsmcps_base + XSMCPS_CFG_CLR_OFFS);
+	writel(XSMCPS_DC_UPT_NAND_REGS, xsmcps_base + XSMCPS_DIRECT_CMD_OFFS);
+	/* Wait till the ECC operation is complete */
+	while (xsmcps_ecc_is_busy_noirq())
+		cpu_relax();
+	/* Set the command1 and command2 register */
+	writel(XNANDPS_ECC_CMD1, xsmcps_base + XSMCPS_ECC_MEMCMD1_OFFS);
+	writel(XNANDPS_ECC_CMD2, xsmcps_base + XSMCPS_ECC_MEMCMD2_OFFS);
+
+	spin_unlock_irqrestore(&xsmcps_lock, flags);
+}
+
+const struct of_device_id matches_nor[] = {
+	{.compatible = "cfi-flash"},
+	{}
+};
+const struct of_device_id matches_nand[] = {
+	{.compatible = "xlnx,ps7-nand-1.00.a"},
+	{}
+};
+
+static int __devinit xsmcps_probe(struct platform_device *pdev)
+{
+	struct xsmcps_data *xsmcps;
+	struct device_node *child;
+	unsigned long flags;
+	int err;
+	struct device_node *of_node = pdev->dev.of_node;
+	const struct of_device_id *matches = NULL;
+
+	xsmcps = kzalloc(sizeof(*xsmcps), GFP_KERNEL);
+	if (!xsmcps) {
+		dev_err(&pdev->dev, "unable to allocate memory\n");
+		return -ENOMEM;
+	}
+
+	xsmcps->aperclk = clk_get_sys("SMC_APER", NULL);
+	if (IS_ERR(xsmcps->aperclk)) {
+		dev_err(&pdev->dev, "APER clock not found.\n");
+		err = PTR_ERR(xsmcps->aperclk);
+		goto out_free;
+	}
+
+	xsmcps->devclk = clk_get_sys("SMC", NULL);
+	if (IS_ERR(xsmcps->devclk)) {
+		dev_err(&pdev->dev, "Device clock not found.\n");
+		err = PTR_ERR(xsmcps->devclk);
+		goto out_clk_put_aper;
+	}
+
+	err = clk_prepare_enable(xsmcps->aperclk);
+	if (err) {
+		dev_err(&pdev->dev, "Unable to enable APER clock.\n");
+		goto out_clk_put;
+	}
+
+	err = clk_prepare_enable(xsmcps->devclk);
+	if (err) {
+		dev_err(&pdev->dev, "Unable to enable device clock.\n");
+		goto out_clk_dis_aper;
+	}
+
+	platform_set_drvdata(pdev, xsmcps);
+
+	xsmcps->clk_rate_change_nb.notifier_call = xsmcps_clk_notifier_cb;
+	if (clk_notifier_register(xsmcps->devclk, &xsmcps->clk_rate_change_nb))
+		dev_warn(&pdev->dev, "Unable to register clock notifier.\n");
+
+	/* Get the NAND controller virtual address */
+	xsmcps->res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!xsmcps->res) {
+		err = -ENODEV;
+		dev_err(&pdev->dev, "platform_get_resource failed\n");
+		goto out_clk_disable;
+	}
+	xsmcps->res = request_mem_region(xsmcps->res->start,
+			resource_size(xsmcps->res), pdev->name);
+	if (!xsmcps->res) {
+		err = -ENOMEM;
+		dev_err(&pdev->dev, "request_mem_region failed\n");
+		goto out_clk_disable;
+	}
+
+	xsmcps_base = ioremap(xsmcps->res->start, resource_size(xsmcps->res));
+	if (!xsmcps_base) {
+		err = -EIO;
+		dev_err(&pdev->dev, "ioremap failed\n");
+		goto out_release_mem_region;
+	}
+
+	/* clear interrupts */
+	spin_lock_irqsave(&xsmcps_lock, flags);
+
+	writel(0x52, xsmcps_base + XSMCPS_CFG_CLR_OFFS);
+
+	spin_unlock_irqrestore(&xsmcps_lock, flags);
+
+	/* Find compatible children. Only a single child is supported */
+	for_each_available_child_of_node(of_node, child) {
+		if (of_match_node(matches_nand, child)) {
+			xsmcps_init_nand_interface(pdev, child);
+			if (!matches) {
+				matches = matches_nand;
+			} else {
+				dev_err(&pdev->dev,
+					"incompatible configuration\n");
+				goto out_release_mem_region;
+			}
+		}
+
+		if (of_match_node(matches_nor, child)) {
+			static int counts = 0;
+			if (!matches) {
+				matches = matches_nor;
+			} else {
+				if (matches != matches_nor || counts > 1) {
+					dev_err(&pdev->dev,
+						"incompatible configuration\n");
+					goto out_release_mem_region;
+				}
+			}
+			counts++;
+		}
+	}
+
+	if (matches)
+		of_platform_populate(of_node, matches, NULL, &pdev->dev);
+
+	return 0;
+
+out_release_mem_region:
+	release_mem_region(xsmcps->res->start, resource_size(xsmcps->res));
+	kfree(xsmcps->res);
+out_clk_disable:
+	clk_disable_unprepare(xsmcps->devclk);
+out_clk_dis_aper:
+	clk_disable_unprepare(xsmcps->aperclk);
+out_clk_put:
+	clk_put(xsmcps->devclk);
+out_clk_put_aper:
+	clk_put(xsmcps->aperclk);
+out_free:
+	kfree(xsmcps);
+
+	return err;
+}
+
+static int __devexit xsmcps_remove(struct platform_device *pdev)
+{
+	struct xsmcps_data *xsmcps = platform_get_drvdata(pdev);
+
+	clk_notifier_unregister(xsmcps->devclk, &xsmcps->clk_rate_change_nb);
+	release_mem_region(xsmcps->res->start, resource_size(xsmcps->res));
+	kfree(xsmcps->res);
+	iounmap(xsmcps_base);
+	clk_disable_unprepare(xsmcps->devclk);
+	clk_disable_unprepare(xsmcps->aperclk);
+	clk_put(xsmcps->devclk);
+	clk_put(xsmcps->aperclk);
+	kfree(xsmcps);
+
+	return 0;
+}
+
+/* Match table for device tree binding */
+static const struct of_device_id xsmcps_of_match[] __devinitconst = {
+	{.compatible = "xlnx,ps7-smc"},
+};
+MODULE_DEVICE_TABLE(of, xsmcps_of_match);
+
+static struct platform_driver xsmcps_driver = {
+	.probe		= xsmcps_probe,
+	.remove		= __devexit_p(xsmcps_remove),
+	.driver		= {
+		.name	= "xsmcps",
+		.owner	= THIS_MODULE,
+		.pm	= &xsmcps_dev_pm_ops,
+		.of_match_table = xsmcps_of_match,
+	},
+};
+
+module_platform_driver(xsmcps_driver);
+
+MODULE_AUTHOR("Xilinx, Inc.");
+MODULE_DESCRIPTION("Xilinx PS SMC Driver");
+MODULE_LICENSE("GPL");
diff --git a/drivers/mtd/nand/xilinx_nandps.c b/drivers/mtd/nand/xilinx_nandps.c
index 0b47cca..9196d88 100644
--- a/drivers/mtd/nand/xilinx_nandps.c
+++ b/drivers/mtd/nand/xilinx_nandps.c
@@ -23,6 +23,7 @@
 #include <linux/io.h>
 #include <linux/ioport.h>
 #include <linux/irq.h>
+#include <linux/memory/zynq-smc.h>
 #include <linux/module.h>
 #include <linux/moduleparam.h>
 #include <linux/mtd/mtd.h>
@@ -37,74 +38,17 @@
 
 #define XNANDPS_DRIVER_NAME "xilinx_nandps"
 
-/* Memory controller configuration register offset */
-#define XSMCPS_MC_STATUS		0x000	/* Controller status reg, RO */
-#define XSMCPS_MC_CLR_CONFIG		0x00C	/* Clear config reg, WO */
-#define XSMCPS_MC_DIRECT_CMD		0x010	/* Direct command reg, WO */
-#define XSMCPS_MC_SET_CYCLES		0x014	/* Set cycles register, WO */
-#define XSMCPS_MC_SET_OPMODE		0x018	/* Set opmode register, WO */
-
-/* Add ECC reg, nand_cycles, sram_cycles and opmode_x_n registers
-   There are multiple interfaces also we need to take care.*/
-
-/* Register definitions */
-/* ECC register offset */
-#define XSMCPS_ECC_STATUS_OFFSET	0x400 /* ECC status register */
-#define XSMCPS_ECC_MEMCFG_OFFSET	0x404 /* ECC mem config reg */
-#define XSMCPS_ECC_MEMCMD1_OFFSET	0x408 /* ECC mem cmd1 reg */
-#define XSMCPS_ECC_MEMCMD2_OFFSET	0x40C /* ECC mem cmd2 reg */
-#define XSMCPS_ECC_VALUE0_OFFSET	0x418 /* ECC value 0 reg */
-
-/*
- * The NAND flash driver defines
- */
-
+/* NAND flash driver defines */
 #define XNANDPS_CMD_PHASE	1	/* End command valid in command phase */
 #define XNANDPS_DATA_PHASE	2	/* End command valid in data phase */
 #define XNANDPS_ECC_SIZE	512	/* Size of data for ECC operation */
 
-/*
- * Register values for using NAND interface of NAND controller
- * The SET_CYCLES_REG register value depends on the flash device. Look in to the
- * device datasheet and change its value, This value is for 2Gb Numonyx flash.
- */
-
 /* Flash memory controller operating parameters */
-#define XNANDPS_CLR_CONFIG	((0x1 << 1)  |	/* Disable interrupt */ \
-				(0x1 << 4)   |	/* Clear interrupt */ \
-				(0x1 << 6))	/* Disable ECC interrupt */
-
-/* Assuming 50MHz clock (20ns cycle time) and 3V operation */
-#define XNANDPS_SET_CYCLES	((0x4 << 20) |	/* t_rr from nand_cycles */ \
-				(0x2 << 17)  |	/* t_ar from nand_cycles */ \
-				(0x2 << 14)  |	/* t_clr from nand_cycles */ \
-				(0x2 << 11)  |	/* t_wp from nand_cycles */ \
-				(0x1 << 8)   |	/* t_rea from nand_cycles */ \
-				(0x4 << 4)   |	/* t_wc from nand_cycles */ \
-				(0x4 << 0))	/* t_rc from nand_cycles */
-
-#define XNANDPS_SET_OPMODE	0x0
-
-#define XNANDPS_DIRECT_CMD	((0x4 << 23) |	/* Chip 0 from interface 1 */ \
-				(0x2 << 21))	/* UpdateRegs operation */
-
-#define XNANDPS_ECC_CONFIG	((0x1 << 2)  |	/* ECC available on APB */ \
-				(0x1 << 4)   |	/* ECC read at end of page */ \
-				(0x0 << 5))	/* No Jumping */
-
-#define XNANDPS_ECC_CMD1	((0x80)      |	/* Write command */ \
-				(0x00 << 8)  |	/* Read command */ \
-				(0x30 << 16) |	/* Read End command */ \
-				(0x1 << 24))	/* Read End command calid */
-
-#define XNANDPS_ECC_CMD2	((0x85)      |	/* Write col change cmd */ \
-				(0x05 << 8)  |	/* Read col change cmd */ \
-				(0xE0 << 16) |	/* Read col change end cmd */ \
-				(0x1 << 24))	/* Read col change
-							end cmd valid */
-/*
- * AXI Address definitions
- */
+
+#define XNANDPS_ECC_CONFIG	((1 << 4)  |	/* ECC read at end of page */ \
+				 (0 << 5))	/* No Jumping */
+
+/* AXI Address definitions */
 #define START_CMD_SHIFT		3
 #define END_CMD_SHIFT		11
 #define END_CMD_VALID_SHIFT	20
@@ -117,23 +61,13 @@
 #define XNANDPS_ECC_LAST	(1 << ECC_LAST_SHIFT)	/* Set ECC_Last */
 #define XNANDPS_CLEAR_CS	(1 << CLEAR_CS_SHIFT)	/* Clear chip select */
 
-/*
- * ECC block registers bit position and bit mask
- */
-#define XNANDPS_ECC_BUSY	(1 << 6)	/* ECC block is busy */
-
-/*
- * ONFI Get/Set features command
- */
+/* ONFI Get/Set features command */
 #define NAND_CMD_GET_FEATURES	0xEE
 #define NAND_CMD_SET_FEATURES	0xEF
 
 #define ONDIE_ECC_FEATURE_ADDR	0x90
 
-/*
- * Macros for the NAND controller register read/write
- */
-#define xnandps_read32(addr)		__raw_readl(addr)
+/* Macros for the NAND controller register read/write */
 #define xnandps_write32(addr, val)	__raw_writel((val), (addr))
 
 
@@ -157,7 +91,6 @@ struct xnandps_command_format {
  * @mtd:		MTD information structure
  * @parts:		Pointer	to the mtd_partition structure
  * @nand_base:		Virtual address of the NAND flash device
- * @smc_regs:		Virtual address of the NAND controller registers
  * @end_cmd_pending:	End command is pending
  * @end_cmd:		End command
  **/
@@ -166,7 +99,6 @@ struct xnandps_info {
 	struct mtd_info		mtd;
 	struct mtd_partition	*parts;
 	void __iomem		*nand_base;
-	void __iomem		*smc_regs;
 	unsigned long		end_cmd_pending;
 	unsigned long		end_cmd;
 };
@@ -260,36 +192,6 @@ static struct nand_bbt_descr bbt_mirror_descr = {
 };
 
 /**
- * xnandps_init_nand_flash - Initialize NAND controller
- * @smc_regs:	Virtual address of the NAND controller registers
- * @option:	Device property flags
- *
- * This function initializes the NAND flash interface on the NAND controller.
- **/
-static void xnandps_init_nand_flash(void __iomem *smc_regs, int option)
-{
-	/* disable interrupts */
-	xnandps_write32(smc_regs + XSMCPS_MC_CLR_CONFIG, XNANDPS_CLR_CONFIG);
-	/* Initialize the NAND interface by setting cycles and operation mode */
-	xnandps_write32(smc_regs + XSMCPS_MC_SET_CYCLES, XNANDPS_SET_CYCLES);
-	if (option & NAND_BUSWIDTH_16)
-		xnandps_write32(smc_regs + XSMCPS_MC_SET_OPMODE,
-				(XNANDPS_SET_OPMODE | 0x1));
-	else
-		xnandps_write32(smc_regs + XSMCPS_MC_SET_OPMODE,
-				XNANDPS_SET_OPMODE);
-	xnandps_write32(smc_regs + XSMCPS_MC_DIRECT_CMD, XNANDPS_DIRECT_CMD);
-
-	/* Wait till the ECC operation is complete */
-	while (xnandps_read32(smc_regs + XSMCPS_ECC_STATUS_OFFSET) &
-			XNANDPS_ECC_BUSY)
-		;
-	/* Set the command1 and command2 register */
-	xnandps_write32(smc_regs + XSMCPS_ECC_MEMCMD1_OFFSET, XNANDPS_ECC_CMD1);
-	xnandps_write32(smc_regs + XSMCPS_ECC_MEMCMD2_OFFSET, XNANDPS_ECC_CMD2);
-}
-
-/**
  * xnandps_calculate_hwecc - Calculate Hardware ECC
  * @mtd:	Pointer to the mtd_info structure
  * @data:	Pointer to the page data
@@ -303,22 +205,17 @@ static void xnandps_init_nand_flash(void __iomem *smc_regs, int option)
 static int
 xnandps_calculate_hwecc(struct mtd_info *mtd, const u8 *data, u8 *ecc_code)
 {
-	struct xnandps_info *xnand =
-				container_of(mtd, struct xnandps_info, mtd);
 	u32 ecc_value = 0;
 	u8 ecc_reg, ecc_byte;
 	u32 ecc_status;
 
 	/* Wait till the ECC operation is complete */
-	do {
-		ecc_status = xnandps_read32(xnand->smc_regs +
-			XSMCPS_ECC_STATUS_OFFSET);
-	} while (ecc_status & XNANDPS_ECC_BUSY);
+	while (xsmcps_ecc_is_busy())
+		cpu_relax();
 
 	for (ecc_reg = 0; ecc_reg < 4; ecc_reg++) {
 		/* Read ECC value for each block */
-		ecc_value = xnandps_read32(xnand->smc_regs +
-				XSMCPS_ECC_VALUE0_OFFSET + (ecc_reg * 4));
+		ecc_value = xsmcps_get_ecc_val(ecc_reg);
 		ecc_status = (ecc_value >> 24) & 0xFF;
 		/* ECC value valid */
 		if (ecc_status & 0x40) {
@@ -780,7 +677,7 @@ static void xnandps_cmd_function(struct mtd_info *mtd, unsigned int command,
 		return;
 
 	/* Clear interrupt */
-	xnandps_write32((xnand->smc_regs + XSMCPS_MC_CLR_CONFIG), (1 << 4));
+	xsmcps_clr_nand_int();
 
 	/* Get the command phase address */
 	if (curr_cmd->end_cmd_valid == XNANDPS_CMD_PHASE)
@@ -938,17 +835,11 @@ static int xnandps_verify_buf(struct mtd_info *mtd, const uint8_t *buf,
  **/
 static int xnandps_device_ready(struct mtd_info *mtd)
 {
-	struct xnandps_info *xnand =
-		container_of(mtd, struct xnandps_info, mtd);
-	unsigned long status;
-
-	/* Check the raw_int_status1 bit */
-	status = xnandps_read32(xnand->smc_regs + XSMCPS_MC_STATUS) & 0x40;
-	/* Clear the interrupt condition */
-	if (status)
-		xnandps_write32((xnand->smc_regs + XSMCPS_MC_CLR_CONFIG),
-					(1<<4));
-	return status ? 1 : 0;
+	if (xsmcps_get_nand_int_status_raw()) {
+		xsmcps_clr_nand_int();
+		return 1;
+	}
+	return 0;
 }
 
 /**
@@ -964,14 +855,12 @@ static int __devinit xnandps_probe(struct platform_device *pdev)
 	struct xnandps_info *xnand;
 	struct mtd_info *mtd;
 	struct nand_chip *nand_chip;
-	struct resource *nand_res, *smc_res;
-	unsigned long ecc_page_size;
+	struct resource *nand_res;
 	int err = 0;
 	u8 maf_id, dev_id, i;
 	u8 get_feature;
 	u8 set_feature[4] = {0x08, 0x00, 0x00, 0x00};
 	int ondie_ecc_enabled = 0;
-	unsigned long ecc_cfg;
 	struct mtd_part_parser_data ppdata;
 	const unsigned int *prop;
 	u32 options = 0;
@@ -1003,27 +892,7 @@ static int __devinit xnandps_probe(struct platform_device *pdev)
 		dev_err(&pdev->dev, "ioremap for NAND failed\n");
 		goto out_release_nand_mem_region;
 	}
-	/* Get the NAND controller virtual address */
-	smc_res = platform_get_resource(pdev, IORESOURCE_MEM, 1);
-	if (smc_res == NULL) {
-		err = -ENODEV;
-		dev_err(&pdev->dev, "platform_get_resource for cont failed\n");
-		goto out_nand_iounmap;
-	}
-	smc_res = request_mem_region(smc_res->start, resource_size(smc_res),
-					pdev->name);
-	if (smc_res == NULL) {
-		err = -ENOMEM;
-		dev_err(&pdev->dev, "request_mem_region for cont failed\n");
-		goto out_nand_iounmap;
-	}
 
-	xnand->smc_regs = ioremap(smc_res->start, resource_size(smc_res));
-	if (!xnand->smc_regs) {
-		err = -EIO;
-		dev_err(&pdev->dev, "ioremap for cont failed\n");
-		goto out_release_smc_mem_region;
-	}
 	/* Get x8 or x16 mode from device tree */
 	prop = of_get_property(pdev->dev.of_node, "xlnx,nand-width", NULL);
 	if (prop) {
@@ -1072,9 +941,6 @@ static int __devinit xnandps_probe(struct platform_device *pdev)
 
 	platform_set_drvdata(pdev, xnand);
 
-	/* Initialize the NAND flash interface on NAND controller */
-	xnandps_init_nand_flash(xnand->smc_regs, nand_chip->options);
-
 	/* first scan to find the device and get the page size */
 	if (nand_scan_ident(mtd, 1, NULL)) {
 		err = -ENXIO;
@@ -1123,84 +989,53 @@ static int __devinit xnandps_probe(struct platform_device *pdev)
 		}
 	}
 
+	nand_chip->ecc.mode = NAND_ECC_HW;
+	nand_chip->ecc.read_oob = xnandps_read_oob;
+	nand_chip->ecc.read_page_raw = xnandps_read_page_raw;
+	nand_chip->ecc.strength = 1;
+	nand_chip->ecc.write_oob = xnandps_write_oob;
+	nand_chip->ecc.write_page_raw = xnandps_write_page_raw;
 	if (ondie_ecc_enabled) {
 		/* bypass the controller ECC block */
-		ecc_cfg = xnandps_read32(xnand->smc_regs +
-			XSMCPS_ECC_MEMCFG_OFFSET);
-		ecc_cfg &= ~0xc;
-		xnandps_write32(xnand->smc_regs + XSMCPS_ECC_MEMCFG_OFFSET,
-			ecc_cfg);
+		xsmcps_set_ecc_mode(XSMCPS_ECCMODE_BYPASS);
 
 		/* The software ECC routines won't work with the
 				SMC controller */
-		nand_chip->ecc.mode = NAND_ECC_HW;
+		nand_chip->ecc.bytes = 0;
+		nand_chip->ecc.layout = &ondie_nand_oob_64;
 		nand_chip->ecc.read_page = xnandps_read_page_raw;
 		nand_chip->ecc.write_page = xnandps_write_page_raw;
-		nand_chip->ecc.read_page_raw = xnandps_read_page_raw;
-		nand_chip->ecc.write_page_raw = xnandps_write_page_raw;
-		nand_chip->ecc.read_oob = xnandps_read_oob;
-		nand_chip->ecc.write_oob = xnandps_write_oob;
 		nand_chip->ecc.size = mtd->writesize;
-		nand_chip->ecc.bytes = 0;
-		nand_chip->ecc.strength = 1;
 		/* On-Die ECC spare bytes offset 8 is used for ECC codes */
-		nand_chip->ecc.layout = &ondie_nand_oob_64;
 		/* Use the BBT pattern descriptors */
 		nand_chip->bbt_td = &bbt_main_descr;
 		nand_chip->bbt_md = &bbt_mirror_descr;
 	} else {
 		/* Hardware ECC generates 3 bytes ECC code for each 512 bytes */
-		nand_chip->ecc.mode = NAND_ECC_HW;
-		nand_chip->ecc.size = XNANDPS_ECC_SIZE;
 		nand_chip->ecc.bytes = 3;
 		nand_chip->ecc.calculate = xnandps_calculate_hwecc;
 		nand_chip->ecc.correct = xnandps_correct_data;
 		nand_chip->ecc.hwctl = NULL;
 		nand_chip->ecc.read_page = xnandps_read_page_hwecc;
+		nand_chip->ecc.size = XNANDPS_ECC_SIZE;
 		nand_chip->ecc.write_page = xnandps_write_page_hwecc;
-		nand_chip->ecc.read_page_raw = xnandps_read_page_raw;
-		nand_chip->ecc.write_page_raw = xnandps_write_page_raw;
-		nand_chip->ecc.read_oob = xnandps_read_oob;
-		nand_chip->ecc.write_oob = xnandps_write_oob;
-		nand_chip->ecc.strength = 1;
 
+		xsmcps_set_ecc_pg_size(mtd->writesize);
 		switch (mtd->writesize) {
 		case 512:
-			ecc_page_size = 0x1;
-			/* Set the ECC memory config register */
-			xnandps_write32(xnand->smc_regs +
-			XSMCPS_ECC_MEMCFG_OFFSET,
-			(XNANDPS_ECC_CONFIG | ecc_page_size));
-			break;
 		case 1024:
-			ecc_page_size = 0x2;
-			/* Set the ECC memory config register */
-			xnandps_write32(xnand->smc_regs +
-			XSMCPS_ECC_MEMCFG_OFFSET,
-			(XNANDPS_ECC_CONFIG | ecc_page_size));
-			break;
 		case 2048:
-			ecc_page_size = 0x3;
-			/* Set the ECC memory config register */
-			xnandps_write32(xnand->smc_regs +
-			XSMCPS_ECC_MEMCFG_OFFSET,
-			(XNANDPS_ECC_CONFIG | ecc_page_size));
+			xsmcps_set_ecc_mode(XSMCPS_ECCMODE_APB);
 			break;
 		default:
 			/* The software ECC routines won't work with the
 				SMC controller */
-			nand_chip->ecc.mode = NAND_ECC_HW;
 			nand_chip->ecc.calculate = nand_calculate_ecc;
 			nand_chip->ecc.correct = nand_correct_data;
 			nand_chip->ecc.read_page = xnandps_read_page_swecc;
 			/* nand_chip->ecc.read_subpage = nand_read_subpage; */
 			nand_chip->ecc.write_page = xnandps_write_page_swecc;
-			nand_chip->ecc.read_page_raw = xnandps_read_page_raw;
-			nand_chip->ecc.write_page_raw = xnandps_write_page_raw;
-			nand_chip->ecc.read_oob = xnandps_read_oob;
-			nand_chip->ecc.write_oob = xnandps_write_oob;
 			nand_chip->ecc.size = 256;
-			nand_chip->ecc.bytes = 3;
 			break;
 		}
 
@@ -1222,19 +1057,10 @@ static int __devinit xnandps_probe(struct platform_device *pdev)
 	mtd_device_parse_register(&xnand->mtd, NULL, &ppdata,
 			NULL, 0);
 
-	if (!err) {
-		dev_info(&pdev->dev, "at 0x%08X mapped to 0x%08X\n",
-				smc_res->start, (u32 __force) xnand->nand_base);
-		return 0;
-	}
-
+	return 0;
 
 out_unmap_all_mem:
 	platform_set_drvdata(pdev, NULL);
-	iounmap(xnand->smc_regs);
-out_release_smc_mem_region:
-	release_mem_region(smc_res->start, resource_size(smc_res));
-out_nand_iounmap:
 	iounmap(xnand->nand_base);
 out_release_nand_mem_region:
 	release_mem_region(nand_res->start, resource_size(nand_res));
@@ -1255,7 +1081,7 @@ out_free_data:
 static int __devexit xnandps_remove(struct platform_device *pdev)
 {
 	struct xnandps_info *xnand = platform_get_drvdata(pdev);
-	struct resource *nand_res, *smc_res;
+	struct resource *nand_res;
 
 	/* Release resources, unregister device */
 	nand_release(&xnand->mtd);
@@ -1263,10 +1089,6 @@ static int __devexit xnandps_remove(struct platform_device *pdev)
 	kfree(xnand->parts);
 
 	platform_set_drvdata(pdev, NULL);
-	/* Unmap and release physical address */
-	iounmap(xnand->smc_regs);
-	smc_res = platform_get_resource(pdev, IORESOURCE_MEM, 1);
-	release_mem_region(smc_res->start, resource_size(smc_res));
 
 	iounmap(xnand->nand_base);
 	nand_res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
diff --git a/include/linux/memory/zynq-smc.h b/include/linux/memory/zynq-smc.h
new file mode 100644
index 0000000..40e01a7
--- /dev/null
+++ b/include/linux/memory/zynq-smc.h
@@ -0,0 +1,32 @@
+/*
+ * Xilinx Zynq SMC Driver Header
+ *
+ * Copyright (C) 2012 Xilinx, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify it under
+ * the terms of the GNU General Public License version 2 as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc., 59 Temple
+ * Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef __LINUX_MEMORY_ZYNQ_SMC_H
+#define __LINUX_MEMORY_ZYNQ_SMC_H
+
+enum xsmcps_ecc_mode {
+	XSMCPS_ECCMODE_BYPASS = 0,
+	XSMCPS_ECCMODE_APB = 1,
+	XSMCPS_ECCMODE_MEM = 2
+};
+
+u32 xsmcps_get_ecc_val(int ecc_reg);
+int xsmcps_ecc_is_busy(void);
+int xsmcps_get_nand_int_status_raw(void);
+void xsmcps_clr_nand_int(void);
+int xsmcps_set_ecc_mode(enum xsmcps_ecc_mode mode);
+int xsmcps_set_ecc_pg_size(unsigned int pg_sz);
+
+#endif
-- 
1.7.1

