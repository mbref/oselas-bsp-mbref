From e4965c6159272cb4d8c8f1e9f149749eaebed071 Mon Sep 17 00:00:00 2001
From: Michal Simek <michal.simek@xilinx.com>
Date: Fri, 1 Feb 2013 12:22:26 +0100
Subject: [PATCH] i2c: xilinx: Remove old xilinx_iic driver

From information I have none is using this driver.

Signed-off-by: Michal Simek <michal.simek@xilinx.com>
---
 drivers/i2c/algos/Kconfig                      |    5 -
 drivers/i2c/algos/Makefile                     |    1 -
 drivers/i2c/algos/xilinx_iic/Makefile          |   14 -
 drivers/i2c/algos/xilinx_iic/i2c-algo-xilinx.c |  646 ---------------
 drivers/i2c/algos/xilinx_iic/xiic.c            |  768 ------------------
 drivers/i2c/algos/xilinx_iic/xiic.h            |  554 -------------
 drivers/i2c/algos/xilinx_iic/xiic_i.h          |  400 ----------
 drivers/i2c/algos/xilinx_iic/xiic_intr.c       |  442 -----------
 drivers/i2c/algos/xilinx_iic/xiic_l.c          | 1005 ------------------------
 drivers/i2c/algos/xilinx_iic/xiic_l.h          |  598 --------------
 drivers/i2c/algos/xilinx_iic/xiic_master.c     |  768 ------------------
 drivers/i2c/algos/xilinx_iic/xiic_options.c    |  183 -----
 drivers/i2c/algos/xilinx_iic/xiic_stats.c      |  143 ----
 13 files changed, 0 insertions(+), 5527 deletions(-)
 delete mode 100644 drivers/i2c/algos/xilinx_iic/Makefile
 delete mode 100644 drivers/i2c/algos/xilinx_iic/i2c-algo-xilinx.c
 delete mode 100644 drivers/i2c/algos/xilinx_iic/xiic.c
 delete mode 100644 drivers/i2c/algos/xilinx_iic/xiic.h
 delete mode 100644 drivers/i2c/algos/xilinx_iic/xiic_i.h
 delete mode 100644 drivers/i2c/algos/xilinx_iic/xiic_intr.c
 delete mode 100644 drivers/i2c/algos/xilinx_iic/xiic_l.c
 delete mode 100644 drivers/i2c/algos/xilinx_iic/xiic_l.h
 delete mode 100644 drivers/i2c/algos/xilinx_iic/xiic_master.c
 delete mode 100644 drivers/i2c/algos/xilinx_iic/xiic_options.c
 delete mode 100644 drivers/i2c/algos/xilinx_iic/xiic_stats.c

diff --git a/drivers/i2c/algos/Kconfig b/drivers/i2c/algos/Kconfig
index 0e7a4eb..f1cfe7e 100644
--- a/drivers/i2c/algos/Kconfig
+++ b/drivers/i2c/algos/Kconfig
@@ -14,9 +14,4 @@ config I2C_ALGOPCF
 config I2C_ALGOPCA
 	tristate "I2C PCA 9564 interfaces"
 
-config XILINX_IIC
-	tristate "Xilinx IIC interface"
-	depends on I2C && XILINX_DRIVERS
-	help
-	  Supports the Xilinx IIC interface.
 endmenu
diff --git a/drivers/i2c/algos/Makefile b/drivers/i2c/algos/Makefile
index d1b55e2..215303f 100644
--- a/drivers/i2c/algos/Makefile
+++ b/drivers/i2c/algos/Makefile
@@ -5,6 +5,5 @@
 obj-$(CONFIG_I2C_ALGOBIT)	+= i2c-algo-bit.o
 obj-$(CONFIG_I2C_ALGOPCF)	+= i2c-algo-pcf.o
 obj-$(CONFIG_I2C_ALGOPCA)	+= i2c-algo-pca.o
-obj-$(CONFIG_XILINX_IIC)	+= xilinx_iic/
 
 ccflags-$(CONFIG_I2C_DEBUG_ALGO) := -DDEBUG
diff --git a/drivers/i2c/algos/xilinx_iic/Makefile b/drivers/i2c/algos/xilinx_iic/Makefile
deleted file mode 100644
index a810b5f..0000000
--- a/drivers/i2c/algos/xilinx_iic/Makefile
+++ /dev/null
@@ -1,14 +0,0 @@
-#
-# Makefile for the Xilinx IIC driver
-#
-
-EXTRA_CFLAGS	+= -Idrivers/xilinx_common
-
-obj-$(CONFIG_XILINX_IIC) := xilinx_iic.o
-
-# The Linux adapter for the Xilinx driver code.
-xilinx_iic-objs	:= i2c-algo-xilinx.o
-
-# The Xilinx OS independent code.
-xilinx_iic-objs	+= xiic.o xiic_options.o xiic_master.o \
-		   xiic_intr.o xiic_l.o  xiic_stats.o
diff --git a/drivers/i2c/algos/xilinx_iic/i2c-algo-xilinx.c b/drivers/i2c/algos/xilinx_iic/i2c-algo-xilinx.c
deleted file mode 100644
index 4f3c599..0000000
--- a/drivers/i2c/algos/xilinx_iic/i2c-algo-xilinx.c
+++ /dev/null
@@ -1,646 +0,0 @@
-/*
- * i2c-algo-xilinx.c
- *
- * Xilinx IIC Adapter component to interface IIC component to Linux
- *
- * Author: MontaVista Software, Inc.
- *         source@mvista.com
- *
- * 2002 (c) MontaVista, Software, Inc.  This file is licensed under the terms
- * of the GNU General Public License version 2.  This program is licensed
- * "as is" without any warranty of any kind, whether express or implied.
- */
-
-/*
- * I2C drivers are split into two pieces: the adapter and the algorithm.
- * The adapter is responsible for actually manipulating the hardware and
- * the algorithm is the layer above that that handles the higher level
- * tasks such as transmitting or receiving a buffer.  The best example
- * (in my opinion) of this is the bit banging algorithm has a number of
- * different adapters that can plug in under it to actually wiggle the
- * SDA and SCL.
- *
- * The interesting part is that the drivers Xilinx provides with their
- * IP are also split into two pieces where one part is the OS
- * independent code and the other part is the OS dependent code.  All of
- * the other sources in this directory are the OS independent files as
- * provided by Xilinx with no changes made to them.
- *
- * As it turns out, this maps quite well into the I2C driver philosophy.
- * This file is the I2C algorithm that communicates with the Xilinx OS
- * independent function that will serve as our I2C adapter.  The
- * unfortunate part is that the term "adapter" is overloaded in our
- * context.  Xilinx refers to the OS dependent part of a driver as an
- * adapter.  So from an I2C driver perspective, this file is not an
- * adapter; that role is filled by the Xilinx OS independent files.
- * From a Xilinx perspective, this file is an adapter; it adapts their
- * OS independent code to Linux.
- *
- * Another thing to consider is that the Xilinx OS dependent code knows
- * nothing about Linux I2C adapters, so even though this file is billed
- * as the I2C algorithm, it takes care of the i2c_adapter structure.
- *
- * Fortunately, naming conventions will give you a clue as to what comes
- * from where.  Functions beginning with XIic_ are provided by the
- * Xilinx OS independent files.  Functions beginning with i2c_ are
- * provided by the I2C Linux core.  All functions in this file that are
- * called by Linux have names that begin with xiic_.  The functions in
- * this file that have Handler in their name are registered as callbacks
- * with the underlying Xilinx OS independent layer.  Any other functions
- * are static helper functions.
- */
-
-#include <linux/module.h>
-#include <linux/init.h>
-#include <linux/slab.h>
-#include <linux/interrupt.h>
-#include <linux/device.h>
-#include <linux/i2c.h>
-#include <linux/xilinx_devices.h>
-#include <linux/semaphore.h>
-
-#include <asm/delay.h>
-#include <asm/io.h>
-#include <asm/irq.h>
-
-#include "xbasic_types.h"
-#include "xiic.h"
-#include "xiic_i.h"
-
-#include <linux/platform_device.h>
-#include <linux/of_platform.h>
-#include <linux/of_i2c.h>
-#include <linux/of_address.h>
-
-MODULE_AUTHOR("MontaVista Software, Inc. <source@mvista.com>");
-MODULE_DESCRIPTION("Xilinx IIC driver");
-MODULE_LICENSE("GPL");
-MODULE_PARM_DESC(scan, "Scan for active chips on the bus");
-static int scan = 0;		/* have a look at what's hanging 'round */
-
-/* SAATODO: actually use these? */
-#define XIIC_TIMEOUT           100
-#define XIIC_RETRY             3
-
-#define XILINX_IIC             "xilinx_iic"
-
-/* Our private per device data. */
-struct xiic_data {
-	struct i2c_adapter adap;	/* The Linux I2C core data  */
-	int index;		/* index taken from platform_device */
-	struct completion complete;	/* for waiting for interrupts */
-	u32 base;		/* base memory address */
-	unsigned int irq;	/* device IRQ number    */
-    volatile u32 transmit_intr_flag;   /* semaphore across task and interrupt - ECM */
-    volatile u32 receive_intr_flag;   /* semaphore across task and interrupt - ECM */
-    volatile u32 status_intr_flag;   /* semaphore across task and interrupt - ECM */
-	/*
-	 * The underlying OS independent code needs space as well.  A
-	 * pointer to the following XIic structure will be passed to
-	 * any XIic_ function that requires it.  However, we treat the
-	 * data as an opaque object in this file (meaning that we never
-	 * reference any of the fields inside of the structure).
-	 */
-	XIic Iic;
-
-	/*
-	 * The following bit fields are used to keep track of what
-	 * all has been done to initialize the xiic_dev to make
-	 * error handling out of probe() easier.
-	 */
-	unsigned int reqirq:1;	/* Has request_irq() been called? */
-	unsigned int remapped:1;	/* Has ioremap() been called? */
-	unsigned int started:1;	/* Has XIic_Start() been called? */
-	unsigned int added:1;	/* Has i2c_add_adapter() been called? */
-};
-
-/*******************************************************************************
- * This configuration stuff should become unnecessary after EDK version 8.x is
- * released.
- ******************************************************************************/
-
-static DEFINE_SEMAPHORE(cfg_sem);
-static int
-xiic_xfer(struct i2c_adapter *i2c_adap, struct i2c_msg msgs[], int num)
-{
-    struct xiic_data *dev = (struct xiic_data *) i2c_adap;
-    struct i2c_msg *pmsg;
-    u32 options;
-    int i, retries;
-    u32 Status;
-    u32 writeop;
-	
-    for (i = 0; i < num; i++)
-    {
-        pmsg = &msgs[i];
-
-        if (!pmsg->len) /* If length is zero */
-             continue;  /* on to the next request. */
-
-        /*
-         * This code checks up to 16 times for the
-         * bus busy condition.
-         */
-        retries = 4;
-        while((XIic_IsIicBusy(&dev->Iic) == TRUE) &&
-              (retries-- != 0))
-        {
-            set_current_state(TASK_INTERRUPTIBLE);
-            schedule_timeout(HZ/250);
-        }
-
-
-        /* If bus is still busy, bail */
-        if (XIic_IsIicBusy(&dev->Iic) == TRUE)
-        {
-            printk(KERN_WARNING
-                   "%s #%d: Could not talk to device 0x%2x (%d), bus always busy, trying to reset\n",
-                   dev->adap.name, dev->index, pmsg->addr,
-                   dev->status_intr_flag);
-
-			/* Try stopping, reseting and starting device to clear condition
-			*/
-			if (XIic_Stop(&dev->Iic) != XST_SUCCESS)
-			{
-				/* The bus was in use.. */
-				printk(KERN_WARNING
-					   "%s #%d: Could not stop device. Restart from higher layer.\n",
-					   dev->adap.name, dev->index);
-				return -ENXIO;
-			}
-			else
-			{
-				XIic_Reset(&dev->Iic);
-				if (XIic_Start(&dev->Iic) != XST_SUCCESS)
-				{
-					printk(KERN_ERR "%s #%d: Could not start device.\n",
-						   dev->adap.name, dev->index);
-					return -ENODEV;
-				}
-
-				return -ENXIO;
-			}
-        }
-
-        options = 0;
-        if (pmsg->flags & I2C_M_TEN)
-            options |= XII_SEND_10_BIT_OPTION;
-        XIic_SetOptions(&dev->Iic, options);
-
-        if (XIic_SetAddress(&dev->Iic, XII_ADDR_TO_SEND_TYPE,
-                    pmsg->addr) != XST_SUCCESS)
-        {
-            printk(KERN_WARNING
-                   "%s #%d: Could not set address to 0x%2x.\n",
-                   dev->adap.name, dev->index, pmsg->addr);
-            return -EIO;
-        }
-
-
-        dev->transmit_intr_flag = 0xFFFFFFFF;
-        dev->receive_intr_flag = 0xFFFFFFFF;
-        dev->status_intr_flag = 0xFFFFFFFF;
-
-        /* set the writeop flag to 0 so the adapter does not wait
-         * at bottom of loop
-         */
-        writeop = 0;
-
-		dev->Iic.Stats.TxErrors = 0;
-
-        if (pmsg->flags & I2C_M_RD)
-        {
-            Status = XIic_MasterRecv(&dev->Iic, pmsg->buf, pmsg->len);
-        }
-        else
-        {
-            Status = XIic_MasterSend(&dev->Iic, pmsg->buf, pmsg->len);
-        }
-
-        if (Status != XST_SUCCESS)
-        {
-            printk(KERN_WARNING
-                   "%s #%d: Unexpected error %d.\n",
-                   dev->adap.name, dev->index, (int)Status);
-            return -EIO;
-        }
-
-        /*
-	 * Wait till the data is transmitted or received. If there is an error
-	 * retry for 10 times.
-	 */
-	retries = 10;
-
-	if(pmsg->flags & I2C_M_RD)
-	{
-		while((((volatile int)(dev->receive_intr_flag)) != 0) && (retries != 0))
-		{
-			if ( dev->Iic.Stats.TxErrors != 0)
-			{
-				udelay(25);
-				Status = XIic_MasterRecv(&dev->Iic, pmsg->buf, pmsg->len);
-				dev->Iic.Stats.TxErrors = 0;
-				retries--;
-			}
-
-			/* the udelay was not working for Microblaze and this seems
-			   like a better solution */	
-			schedule_timeout_interruptible(1);
-                }
-	}
-	else
-	{
-		while((((volatile int)(dev->transmit_intr_flag)) != 0) && (retries != 0))
-		{
-			if ( dev->Iic.Stats.TxErrors != 0)
-			{
-				udelay(25);
-				Status = XIic_MasterSend(&dev->Iic, pmsg->buf, pmsg->len);
-				dev->Iic.Stats.TxErrors = 0;
-				retries--;
-			}
-
-			/* the udelay was not working for Microblaze and this seems
-			   like a better solution */	
-			schedule_timeout_interruptible(1);
-		}
-	}
-
-	if(retries == 0)
-	{
-		printk("Unable to talk to Device\n");
-		printk("Wrong Slave address or Slave device Busy\n");
-	}
-    }
-    return num;
-}
-
-static u32 xiic_bit_func(struct i2c_adapter *adap)
-{
-	return I2C_FUNC_SMBUS_EMUL | I2C_FUNC_10BIT_ADDR |
-	    I2C_FUNC_PROTOCOL_MANGLING;
-}
-
-static struct i2c_algorithm xiic_algo = {
-	.master_xfer = xiic_xfer,	/* master_xfer          */
-	.smbus_xfer = NULL,	/* smbus_xfer           */
-	.functionality = xiic_bit_func,	/* functionality        */
-};
-
-/*
- * This routine is registered with the OS as the function to call when
- * the IIC interrupts.  It in turn, calls the Xilinx OS independent
- * interrupt function.  The Xilinx OS independent interrupt function
- * will in turn call any callbacks that we have registered for various
- * conditions.
- */
-static irqreturn_t xiic_interrupt(int irq, void *dev_id)
-{
-	struct xiic_data *dev = dev_id;
-
-	XIic_InterruptHandler(&dev->Iic);
-	return IRQ_HANDLED;
-}
-
-static void RecvHandler(void *CallbackRef, int ByteCount)
-{
-	struct xiic_data *dev = (struct xiic_data *)CallbackRef;
-
-	if (ByteCount == 0) {
-		(dev->receive_intr_flag) = XST_SUCCESS;
-		complete(&dev->complete);
-	}
-}
-
-static void SendHandler(void *CallbackRef, int ByteCount)
-{
-	struct xiic_data *dev = (struct xiic_data *)CallbackRef;
-
-	if (ByteCount == 0) {
-		(dev->transmit_intr_flag) = XST_SUCCESS;
-		complete(&dev->complete);
-	}
-}
-
-static void StatusHandler(void *CallbackRef, int Status)
-{
-	struct xiic_data *dev = (struct xiic_data *)CallbackRef;
-
-	(dev->status_intr_flag) = Status;
-	complete(&dev->complete);
-}
-
-static char *xilinx_iic_do_scan(struct xiic_data *dev)
-{
-	int i;
-	char *page = kmalloc(PAGE_SIZE, GFP_KERNEL);
-	char *cptr = page;
-	u8 data;
-	u32 status;
-
-	for (i = 0x08; i < 0x78 && cptr; i++) {
-
-		snprintf(cptr, PAGE_SIZE - (cptr - page), "%02X: ", i);
-		cptr += strlen(cptr);
-
-		init_completion(&dev->complete);
-		if (XIic_SetAddress(&dev->Iic, XII_ADDR_TO_SEND_TYPE,
-				    i) != XST_SUCCESS) {
-
-			snprintf(cptr, PAGE_SIZE - (cptr - page),
-				 "can't set address\n");
-			cptr += strlen(cptr);
-			continue;
-		}
-
-		dev->receive_intr_flag = ~0;
-		status = XIic_MasterRecv(&dev->Iic, &data, sizeof(data));
-		if (status != XST_SUCCESS) {
-			snprintf(cptr, PAGE_SIZE - (cptr - page),
-				 "unexpected error\n");
-			cptr += strlen(cptr);
-			continue;
-		}
-
-		wait_for_completion(&dev->complete);
-
-		snprintf(cptr, PAGE_SIZE - (cptr - page),
-			 dev->receive_intr_flag == XST_SUCCESS ?
-			 "OK\n" : "not respoding\n");
-		cptr += strlen(cptr);
-	}
-
-	return page;
-}
-
-static ssize_t scan_show(struct device *d, struct device_attribute *attr,
-			 char *text)
-{
-	int len = 0;
-	char *scan_text = xilinx_iic_do_scan(dev_get_drvdata(d));
-
-	if (scan_text) {
-		len = strlen(scan_text);
-		memcpy(text, scan_text, len);
-		kfree(scan_text);
-	}
-	return len;
-}
-
-static  DEVICE_ATTR(scan, S_IRUGO, scan_show, NULL);
-
-static int __devexit xilinx_iic_remove(struct device *device)
-{
-	struct xiic_data *dev;
-
-	dev = dev_get_drvdata(device);
-
-	/*
-	 * If we've told the core I2C code about this dev, tell
-	 * the core I2C code to forget the dev.
-	 */
-	if (dev->added) {
-		/*
-		 * If an error is returned, there's not a whole lot we can
-		 * do.  An error has already been printed out so we'll
-		 * just keep trundling along.
-		 */
-		(void)i2c_del_adapter(&dev->adap);
-	}
-
-	/* Tell the Xilinx code to take this IIC interface down. */
-	if (dev->started) {
-		while (XIic_Stop(&dev->Iic) != XST_SUCCESS) {
-			/* The bus was busy.  Retry. */
-			printk(KERN_WARNING
-			       "%s #%d: Could not stop device.  Will retry.\n",
-			       dev->adap.name, dev->index);
-			set_current_state(TASK_INTERRUPTIBLE);
-			schedule_timeout(HZ / 2);
-		}
-	}
-
-	/*
-	 * Now that the Xilinx code isn't using the IRQ or registers,
-	 * unmap the registers and free the IRQ.
-	 */
-	if (dev->remapped) {
-		iounmap((void *)dev->Iic.BaseAddress);
-	}
-
-	if (dev->reqirq) {
-		disable_irq(dev->irq);
-		free_irq(dev->irq, dev);
-	}
-
-	device_remove_file(device, &dev_attr_scan);
-	kfree(dev);
-
-	return 0;
-}
-
-/** Shared device initialization code */
-static int __devinit xilinx_iic_setup(
-				struct device *device,
-				struct device_node *node,
-				struct resource *r_mem,
-				struct resource *r_irq,
-				u32 ten_bit_addr, 
-				u32 gpo_width) {
-
-	XIic_Config xiic_cfg;
-	struct xiic_data *dev;
-	char *scan_results;
-	int error;
-
-	/* Allocate the dev and zero it out. */
-	dev = kmalloc(sizeof(struct xiic_data), GFP_KERNEL);
-	if (!dev) {
-		dev_err(device, "Cannot allocate struct xiic_data\n");
-		error = -ENOMEM;
-		goto out2;
-	}
-	memset(dev, 0, sizeof(struct xiic_data));
-
-	dev_set_drvdata(device, dev);
-
-	dev->irq = r_irq->start;
-
-	/* initialize fields to satisfy i2c  */
-	dev->index = 0;
-
-	init_completion(&dev->complete);
-
-	memset(&xiic_cfg, 0, sizeof(XIic_Config));
-	xiic_cfg.DeviceId = 0;
-
-	/* Change the addresses to be virtual; save the old ones to restore. */
-	dev->base = r_mem->start;
-	xiic_cfg.BaseAddress =
-	    (u32) ioremap(r_mem->start, r_mem->end - r_mem->start + 1);
-
-	dev->remapped = 1;
-	down(&cfg_sem);
-
-	xiic_cfg.Has10BitAddr = (int)ten_bit_addr;
-	xiic_cfg.GpOutWidth = (u8)gpo_width;
-
-	/* Tell the Xilinx code to bring this IIC interface up. */
-	if (XIic_CfgInitialize(&dev->Iic, &xiic_cfg, xiic_cfg.BaseAddress) !=
-	    XST_SUCCESS) {
-		up(&cfg_sem);
-		dev_err(device, "could not initialize device.\n");
-		error = -ENODEV;
-		goto out;
-	}
-	up(&cfg_sem);
-	XIic_SetRecvHandler(&dev->Iic, (void *)dev, RecvHandler);
-	XIic_SetSendHandler(&dev->Iic, (void *)dev, SendHandler);
-	XIic_SetStatusHandler(&dev->Iic, (void *)dev, StatusHandler);
-
-	/* Grab the IRQ */
-	error = request_irq(dev->irq, xiic_interrupt, 0, dev->adap.name, dev);
-	if (error) {
-		dev_err(device, "could not allocate interrupt %d.\n", dev->irq);
-		goto out;
-	}
-	dev->reqirq = 1;
-
-	if (XIic_Start(&dev->Iic) != XST_SUCCESS) {
-		dev_err(device, "could not start device\n");
-		error = -ENODEV;
-		goto out;
-	}
-	dev->started = 1;
-
-	/* Now tell the core I2C code about our new device. */
-
-	strcpy(dev->adap.name, "xilinx-iic");
-	dev->adap.dev.of_node = node;
-	dev->adap.algo = &xiic_algo;
-	dev->adap.algo_data = NULL;
-	dev->adap.timeout = XIIC_TIMEOUT;
-	dev->adap.retries = XIIC_RETRY;
-	error = i2c_add_adapter(&dev->adap);
-
-	if (error) {
-		dev_err(device, "could not add i2c adapter\n");
-		goto out;
-	}
-	dev->added = 1;
-
-	printk("%s #%d at 0x%08X mapped to 0x%08X, irq=%d\n",
-	       dev->adap.name, dev->index,
-	       dev->base, (unsigned int)dev->Iic.BaseAddress, dev->irq);
-
-	if (scan) {
-		scan_results = xilinx_iic_do_scan(dev);
-		if (scan_results) {
-			printk(scan_results);
-			kfree(scan_results);
-		}
-	}
-	
-	of_i2c_register_devices(&dev->adap);
-
-	error = device_create_file(device, &dev_attr_scan);
-      out:
-	if (error)
-		xilinx_iic_remove(device);
-      out2:
-	return error;
-}
-
-/* Match table for of_platform binding */
-static struct of_device_id __devinitdata xilinx_iic_of_match[] = {
-	{ .compatible = "xlnx,xps-iic-2.00.a", },
-	{},
-};
-MODULE_DEVICE_TABLE(of, xilinx_iic_of_match);
-
-static u32 get_u32(struct platform_device *ofdev, const char *s) {
-	u32 *p = (u32 *)of_get_property(ofdev->dev.of_node, s, NULL);
-	if(p) {
-		return __be32_to_cpup(p);
-	} else {
-		dev_warn(&ofdev->dev, "Parameter %s not found, defaulting to 0.\n", s);
-		return 0;
-	}
-}
-
-static int __devinit xilinx_iic_of_probe(struct platform_device *ofdev, const struct of_device_id *match)
-{
-	u32 ten_bit_addr, gpo_width;
-	struct resource r_irq_struct;
-	struct resource r_mem_struct;
-
-	struct resource *r_irq = &r_irq_struct;	/* Interrupt resources */
-	struct resource *r_mem = &r_mem_struct;	/* IO mem resources */
-	int rc = 0;
-
-	printk(KERN_INFO "Device Tree Probing \'%s\'\n",
-                        ofdev->dev.of_node->name);
-
-	/* Get iospace for the device */
-	rc = of_address_to_resource(ofdev->dev.of_node, 0, r_mem);
-	if(rc) {
-		dev_warn(&ofdev->dev, "invalid address\n");
-		return rc;
-	}
-
-	/* Get IRQ for the device */
-	rc = of_irq_to_resource(ofdev->dev.of_node, 0, r_irq);
-	if(!rc) {
-		dev_warn(&ofdev->dev, "no IRQ found.\n");
-		return rc;
-	}
-
-	ten_bit_addr = get_u32(ofdev, "xlnx,ten-bit-adr");
-	gpo_width = get_u32(ofdev, "xlnx,gpo-width");
-
-        return xilinx_iic_setup(&ofdev->dev, ofdev->dev.of_node, r_mem, r_irq, ten_bit_addr, gpo_width);
-}
-
-static int __devexit xilinx_iic_of_remove(struct platform_device *ofdev)
-{
-	return xilinx_iic_remove(&ofdev->dev);
-}
-
-static struct platform_driver xilinx_iic_of_driver = {
-	.driver = {
-		.name = "iic",
-		.owner = THIS_MODULE,
-		.of_match_table = xilinx_iic_of_match,
-	},
-	.probe		= xilinx_iic_of_probe,
-	.remove		= __devexit_p(xilinx_iic_of_remove), };
-
-/* Registration helpers to keep the number of #ifdefs to a minimum */
-static inline int __init xilinx_iic_of_register(void)
-{
-	return platform_driver_register(&xilinx_iic_of_driver);
-}
-
-static inline void __exit xilinx_iic_of_unregister(void)
-{
-	platform_driver_unregister(&xilinx_iic_of_driver);
-}
-
-static int __init xiic_init(void)
-{
-	int ret;
-
-	ret = xilinx_iic_of_register();
-	if (ret) 
-		printk(KERN_ERR "registering iic driver failed: err=%i", ret);
-
-	return ret;
-}
-
-static void __exit xiic_cleanup(void)
-{
-	xilinx_iic_of_unregister();
-}
-
-module_init(xiic_init);
-module_exit(xiic_cleanup);
diff --git a/drivers/i2c/algos/xilinx_iic/xiic.c b/drivers/i2c/algos/xilinx_iic/xiic.c
deleted file mode 100644
index 6f6925e..0000000
--- a/drivers/i2c/algos/xilinx_iic/xiic.c
+++ /dev/null
@@ -1,768 +0,0 @@
-/* $Id: xiic.c,v 1.1.2.1 2010/04/12 12:13:13 svemula Exp $ */
-/******************************************************************************
-*
-* (c) Copyright 2002-2009 Xilinx, Inc. All rights reserved.
-*
-* This file contains confidential and proprietary information of Xilinx, Inc.
-* and is protected under U.S. and international copyright and other
-* intellectual property laws.
-*
-* DISCLAIMER
-* This disclaimer is not a license and does not grant any rights to the
-* materials distributed herewith. Except as otherwise provided in a valid
-* license issued to you by Xilinx, and to the maximum extent permitted by
-* applicable law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND WITH ALL
-* FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES AND CONDITIONS, EXPRESS,
-* IMPLIED, OR STATUTORY, INCLUDING BUT NOT LIMITED TO WARRANTIES OF
-* MERCHANTABILITY, NON-INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE;
-* and (2) Xilinx shall not be liable (whether in contract or tort, including
-* negligence, or under any other theory of liability) for any loss or damage
-* of any kind or nature related to, arising under or in connection with these
-* materials, including for any direct, or any indirect, special, incidental,
-* or consequential loss or damage (including loss of data, profits, goodwill,
-* or any type of loss or damage suffered as a result of any action brought by
-* a third party) even if such damage or loss was reasonably foreseeable or
-* Xilinx had been advised of the possibility of the same.
-*
-* CRITICAL APPLICATIONS
-* Xilinx products are not designed or intended to be fail-safe, or for use in
-* any application requiring fail-safe performance, such as life-support or
-* safety devices or systems, Class III medical devices, nuclear facilities,
-* applications related to the deployment of airbags, or any other applications
-* that could lead to death, personal injury, or severe property or
-* environmental damage (individually and collectively, "Critical
-* Applications"). Customer assumes the sole risk and liability of any use of
-* Xilinx products in Critical Applications, subject only to applicable laws
-* and regulations governing limitations on product liability.
-*
-* THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS PART OF THIS FILE
-* AT ALL TIMES.
-*
-******************************************************************************/
-/*****************************************************************************/
-/**
-*
-* @file xiic.c
-*
-* Contains required functions for the XIic component. See xiic.h for more
-* information on the driver.
-*
-* <pre>
-* MODIFICATION HISTORY:
-*
-* Ver   Who  Date     Changes
-* ----- --- ------- -----------------------------------------------
-* 1.01a rfp  10/19/01 release
-* 1.01c ecm  12/05/02 new rev
-* 1.01c rmm  05/14/03 Fixed diab compiler warnings relating to asserts.
-* 1.01d jhl  10/08/03 Added general purpose output feature
-* 1.02a jvb  12/13/05 Added CfgInitialize(), and made CfgInitialize() take
-*                     a pointer to a config structure instead of a device id.
-*                     Moved Initialize() into xiic_sinit.c, and have
-*                     Initialize() call CfgInitialize() after it retrieved the
-*                     config structure using the device id. Removed include of
-*                     xparameters.h along with any dependencies on xparameters.h
-*                     and the _g.c config table.
-* 1.02a mta  03/09/06 Added a new function XIic_IsIicBusy() which returns
-*			whether IIC Bus is Busy or Free.
-* 1.13a wgr  03/22/07 Converted to new coding style.
-* 1.15a ktn  02/17/09 Fixed XIic_GetAddress() to return correct device address.
-* 1.16a ktn  07/18/09 Updated the notes in XIic_Reset function to clearly
-*                     indicate that only the Interrupt Registers are reset.
-* 1.16a ktn  10/16/09 Updated the notes in the XIic_SelfTest() API to mention
-*                     that the complete IIC core is Reset on giving a software
-*                     reset to the IIC core. This issue is fixed in the latest
-*                     version of the IIC core (some previous versions of the
-*                     core only reset the Interrupt Logic/Registers), please
-*		      see the Hw specification for further information.
-* 2.00a ktn  10/22/09 Converted all register accesses to 32 bit access.
-		      Some of the macros have been renamed to remove _m from
-*		      the name see the xiic_i.h and xiic_l.h file for further
-*		      information (Example XIic_mClearIntr is now
-*		      XIic_ClearIntr).
-*		      Some of the macros have been renamed to be consistent,
-*		      see the xiic_l.h file for further information
-*		      (Example XIIC_WRITE_IIER is renamed as XIic_WriteIier).
-*		      The driver has been updated to use the HAL APIs/macros.
-* </pre>
-*
-****************************************************************************/
-
-/***************************** Include Files *******************************/
-
-#include "xiic.h"
-#include "xiic_i.h"
-
-/************************** Constant Definitions ***************************/
-
-
-/**************************** Type Definitions *****************************/
-
-
-/***************** Macros (Inline Functions) Definitions *******************/
-
-
-/************************** Function Prototypes ****************************/
-
-static void XIic_StubStatusHandler(void *CallBackRef, int ErrorCode);
-
-static void XIic_StubHandler(void *CallBackRef, int ByteCount);
-
-/************************** Variable Definitions **************************/
-
-
-/*****************************************************************************/
-/**
-*
-* Initializes a specific XIic instance.  The initialization entails:
-*
-* - Initialize the driver to allow access to the device registers and
-*   initialize other subcomponents necessary for the operation of the device.
-* - Default options to:
-*	 - 7-bit slave addressing
-*	 - Send messages as a slave device
-*	 - Repeated start off
-*	 - General call recognition disabled
-* - Clear messageing and error statistics
-*
-* The XIic_Start() function must be called after this function before the device
-* is ready to send and receive data on the IIC bus.
-*
-* Before XIic_Start() is called, the interrupt control must connect the ISR
-* routine to the interrupt handler. This is done by the user, and not
-* XIic_Start() to allow the user to use an interrupt controller of their choice.
-*
-* @param	InstancePtr is a pointer to the XIic instance to be worked on.
-* @param	Config is a reference to a structure containing information
-*		about a specific IIC device. This function can initialize
-*		multiple instance objects with the use of multiple calls giving
-*		different Config information on each call.
-* @param	EffectiveAddr is the device base address in the virtual memory
-*		address space. The caller is responsible for keeping the
-*		address mapping from EffectiveAddr to the device physical base
-*		address unchanged once this function is invoked. Unexpected
-*		errors may occur if the address mapping changes after this
-*		function is called. If address translation is not used, use
-*		Config->BaseAddress for this parameters, passing the physical
-*		address instead.
-*
-* @return
-*		- XST_SUCCESS when successful
-*		- XST_DEVICE_IS_STARTED indicates the device is started
-*		(i.e. interrupts enabled and messaging is possible). Must stop
-*		before re-initialization is allowed.
-*
-* @note		None.
-*
-****************************************************************************/
-int XIic_CfgInitialize(XIic *InstancePtr, XIic_Config * Config,
-			   u32 EffectiveAddr)
-{
-	/*
-	 * Asserts test the validity of selected input arguments.
-	 */
-	Xil_AssertNonvoid(InstancePtr != NULL);
-
-	InstancePtr->IsReady = 0;
-
-	/*
-	 * If the device is started, disallow the initialize and return a Status
-	 * indicating it is started.  This allows the user to stop the device
-	 * and reinitialize, but prevents a user from inadvertently
-	 * initializing.
-	 */
-	if (InstancePtr->IsStarted == XIL_COMPONENT_IS_STARTED) {
-		return XST_DEVICE_IS_STARTED;
-	}
-
-	/*
-	 * Set default values and configuration data, including setting the
-	 * callback handlers to stubs  so the system will not crash should the
-	 * application not assign its own callbacks.
-	 */
-	InstancePtr->IsStarted = 0;
-	InstancePtr->BaseAddress = EffectiveAddr;
-	InstancePtr->RecvHandler = XIic_StubHandler;
-	InstancePtr->RecvBufferPtr = NULL;
-	InstancePtr->SendHandler = XIic_StubHandler;
-	InstancePtr->SendBufferPtr = NULL;
-	InstancePtr->StatusHandler = XIic_StubStatusHandler;
-	InstancePtr->Has10BitAddr = Config->Has10BitAddr;
-	InstancePtr->IsReady = XIL_COMPONENT_IS_READY;
-	InstancePtr->Options = 0;
-	InstancePtr->BNBOnly = FALSE;
-	InstancePtr->GpOutWidth = Config->GpOutWidth;
-	InstancePtr->IsDynamic = FALSE;
-
-	/*
-	 * Reset the device.
-	 */
-	XIic_Reset(InstancePtr);
-
-	XIic_ClearStats(InstancePtr);
-
-	return XST_SUCCESS;
-}
-
-/*****************************************************************************/
-/**
-*
-* This function starts the IIC device and driver by enabling the proper
-* interrupts such that data may be sent and received on the IIC bus.
-* This function must be called before the functions to send and receive data.
-*
-* Before XIic_Start() is called, the interrupt control must connect the ISR
-* routine to the interrupt handler. This is done by the user, and not
-* XIic_Start() to allow the user to use an interrupt controller of their choice.
-*
-* Start enables:
-*  - IIC device
-*  - Interrupts:
-*	 - Addressed as slave to allow messages from another master
-*	 - Arbitration Lost to detect Tx arbitration errors
-*	 - Global IIC interrupt
-*
-* @param	InstancePtr is a pointer to the XIic instance to be worked on.
-*
-* @return	XST_SUCCESS always.
-*
-* @note
-*
-* The device interrupt is connected to the interrupt controller, but no
-* "messaging" interrupts are enabled. Addressed as Slave is enabled to
-* reception of messages when this devices address is written to the bus.
-* The correct messaging interrupts are enabled when sending or receiving
-* via the IicSend() and IicRecv() functions. No action is required
-* by the user to control any IIC interrupts as the driver completely
-* manages all 8 interrupts. Start and Stop control the ability
-* to use the device. Stopping the device completely stops all device
-* interrupts from the processor.
-*
-****************************************************************************/
-int XIic_Start(XIic *InstancePtr)
-{
-	Xil_AssertNonvoid(InstancePtr != NULL);
-	Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
-
-	/*
-	 * Mask off all interrupts, each is enabled when needed.
-	 */
-	XIic_WriteIier(InstancePtr->BaseAddress, 0);
-
-	/*
-	 * Clear all interrupts by reading and rewriting exact value back.
-	 * Only those bits set will get written as 1 (writing 1 clears intr).
-	 */
-	XIic_ClearIntr(InstancePtr->BaseAddress, 0xFFFFFFFF);
-
-	/*
-	 * Enable the device.
-	 */
-	XIic_WriteReg(InstancePtr->BaseAddress, XIIC_CR_REG_OFFSET,
-		 XIIC_CR_ENABLE_DEVICE_MASK);
-	/*
-	 * Set Rx FIFO Occupancy depth to throttle at
-	 * first byte(after reset = 0).
-	 */
-	XIic_WriteReg(InstancePtr->BaseAddress, XIIC_RFD_REG_OFFSET, 0);
-
-	/*
-	 * Clear and enable the interrupts needed.
-	 */
-	XIic_ClearEnableIntr(InstancePtr->BaseAddress,
-				XIIC_INTR_AAS_MASK | XIIC_INTR_ARB_LOST_MASK);
-
-	InstancePtr->IsStarted = XIL_COMPONENT_IS_STARTED;
-	InstancePtr->IsDynamic = FALSE;
-
-	/*
-	 * Enable the Global interrupt enable.
-	 */
-	XIic_IntrGlobalEnable(InstancePtr->BaseAddress);
-
-	return XST_SUCCESS;
-}
-
-/*****************************************************************************/
-/**
-*
-* This function stops the IIC device and driver such that data is no longer
-* sent or received on the IIC bus. This function stops the device by
-* disabling interrupts. This function only disables interrupts within the
-* device such that the caller is responsible for disconnecting the interrupt
-* handler of the device from the interrupt source and disabling interrupts
-* at other levels.
-*
-* Due to bus throttling that could hold the bus between messages when using
-* repeated start option, stop will not occur when the device is actively
-* sending or receiving data from the IIC bus or the bus is being throttled
-* by this device, but instead return XST_IIC_BUS_BUSY.
-*
-* @param	InstancePtr is a pointer to the XIic instance to be worked on.
-*
-* @return
-*		- XST_SUCCESS indicates all IIC interrupts are disabled.
-*		No messages can be received or transmitted until XIic_Start()
-*		is called.
-*		- XST_IIC_BUS_BUSY indicates this device is currently engaged
-*		in message traffic and cannot be stopped.
-*
-* @note		None.
-*
-****************************************************************************/
-int XIic_Stop(XIic *InstancePtr)
-{
-	u32 Status;
-	u32 CntlReg;
-
-	Xil_AssertNonvoid(InstancePtr != NULL);
-
-	/*
-	 * Disable all interrupts globally.
-	 */
-	XIic_IntrGlobalDisable(InstancePtr->BaseAddress);
-
-	CntlReg = XIic_ReadReg(InstancePtr->BaseAddress, XIIC_CR_REG_OFFSET);
-	Status = XIic_ReadReg(InstancePtr->BaseAddress, XIIC_SR_REG_OFFSET);
-
-	if ((CntlReg & XIIC_CR_MSMS_MASK) ||
-		(Status & XIIC_SR_ADDR_AS_SLAVE_MASK)) {
-		/*
-		 * When this device is using the bus
-		 * - re-enable interrupts to finish current messaging
-		 * - return bus busy
-		 */
-		XIic_IntrGlobalEnable(InstancePtr->BaseAddress);
-
-		return XST_IIC_BUS_BUSY;
-	}
-
-	InstancePtr->IsStarted = 0;
-
-	return XST_SUCCESS;
-}
-
-/*****************************************************************************/
-/**
-*
-* Resets the IIC device.
-*
-* @param    InstancePtr is a pointer to the XIic instance to be worked on.
-*
-* @return	None.
-*
-* @note     The complete IIC core is Reset on giving a software reset to
-*           the IIC core. Some previous versions of the core only reset
-*           the Interrupt Logic/Registers, please refer to the HW specification
-*           for futher details about this.
-*
-****************************************************************************/
-void XIic_Reset(XIic *InstancePtr)
-{
-	Xil_AssertVoid(InstancePtr != NULL);
-	Xil_AssertVoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
-
-	XIic_WriteReg(InstancePtr->BaseAddress, XIIC_RESETR_OFFSET,
-			XIIC_RESET_MASK);
-}
-
-/*****************************************************************************/
-/**
-*
-* This function sets the bus addresses. The addresses include the device
-* address that the device responds to as a slave, or the slave address
-* to communicate with on the bus.  The IIC device hardware is built to
-* allow either 7 or 10 bit slave addressing only at build time rather
-* than at run time. When this device is a master, slave addressing can
-* be selected at run time to match addressing modes for other bus devices.
-*
-* Addresses are represented as hex values with no adjustment for the data
-* direction bit as the software manages address bit placement.
-* Example: For a 7 address written to the device of 1010 011X where X is
-* the transfer direction (send/recv), the address parameter for this function
-* needs to be 01010011 or 0x53 where the correct bit alllignment will be
-* handled for 7 as well as 10 bit devices. This is especially important as
-* the bit placement is not handled the same depending on which options are
-* used such as repeated start.
-*
-* @param	InstancePtr is a pointer to the XIic instance to be worked on.
-* @param	AddressType indicates which address is being modified, the
-*		address which this device responds to on the IIC bus as a slave,
-*		or the slave address to communicate with when this device is a
-*		master. One of the following values must be contained in
-*		this argument.
-* <pre>
-*   XII_ADDRESS_TO_SEND		Slave being addressed by a this master
-*   XII_ADDRESS_TO_RESPOND	Address to respond to as a slave device
-* </pre>
-*
-* @param	Address contains the address to be set, 7 bit or 10 bit address.
-*		A ten bit address must be within the range: 0 - 1023 and a 7 bit
-*		address must be within the range 0 - 127.
-*
-* @return
-*		- XST_SUCCESS is returned if the address was successfully set.
-*		- XST_IIC_NO_10_BIT_ADDRESSING indicates only 7 bit addressing
-*		  supported.
-*		- XST_INVALID_PARAM indicates an invalid parameter was
-*		  specified.
-*
-* @note
-*
-* Upper bits of 10-bit address is written only when current device is built
-* as a ten bit device.
-*
-****************************************************************************/
-int XIic_SetAddress(XIic *InstancePtr, int AddressType, int Address)
-{
-	u32 SendAddr;
-
-	Xil_AssertNonvoid(InstancePtr != NULL);
-	Xil_AssertNonvoid(Address < 1023);
-
-	/*
-	 * Set address to respond to for this device into address registers.
-	 */
-	if (AddressType == XII_ADDR_TO_RESPOND_TYPE) {
-		/*
-		 * Address in upper 7 bits.
-		 */
-		SendAddr = ((Address & 0x007F) << 1);
-		XIic_WriteReg(InstancePtr->BaseAddress, XIIC_ADR_REG_OFFSET,
-				SendAddr);
-
-		if (InstancePtr->Has10BitAddr == TRUE) {
-			/*
-			 * Write upper 3 bits of addr to DTR only when 10 bit
-			 * option included in design i.e. register exists.
-			 */
-			SendAddr = ((Address & 0x0380) >> 7);
-			XIic_WriteReg(InstancePtr->BaseAddress,
-					XIIC_TBA_REG_OFFSET, SendAddr);
-		}
-
-		return XST_SUCCESS;
-	}
-
-	/*
-	 * Store address of slave device being read from.
-	 */
-	if (AddressType == XII_ADDR_TO_SEND_TYPE) {
-		InstancePtr->AddrOfSlave = Address;
-		return XST_SUCCESS;
-	}
-
-	return XST_INVALID_PARAM;
-}
-
-/*****************************************************************************/
-/**
-*
-* This function gets the addresses for the IIC device driver. The addresses
-* include the device address that the device responds to as a slave, or the
-* slave address to communicate with on the bus. The address returned has the
-* same format whether 7 or 10 bits.
-*
-* @param	InstancePtr is a pointer to the XIic instance to be worked on.
-* @param	AddressType indicates which address, the address which this
-*		responds to on the IIC bus as a slave, or the slave address to
-*		communicate with when this device is a master. One of the
-*		following values must be contained in this argument.
-* <pre>
-*   XII_ADDRESS_TO_SEND_TYPE	Slave being addressed as a master
-*   XII_ADDRESS_TO_RESPOND_TYPE	Slave address to respond to as a slave
-* </pre>
-*  If neither of the two valid arguments are used, the function returns
-*  the address of the slave device
-*
-* @return	The address retrieved.
-*
-* @note		None.
-*
-****************************************************************************/
-u16 XIic_GetAddress(XIic *InstancePtr, int AddressType)
-{
-	u8  LowAddr;
-	u16 HighAddr = 0;
-
-	Xil_AssertNonvoid(InstancePtr != NULL);
-
-	/*
-	 * Return this device's address.
-	 */
-	if (AddressType == XII_ADDR_TO_RESPOND_TYPE) {
-
-		LowAddr = (u8) XIic_ReadReg(InstancePtr->BaseAddress,
-					     XIIC_ADR_REG_OFFSET);
-
-		if (InstancePtr->Has10BitAddr == TRUE) {
-			HighAddr = (u16) XIic_ReadReg(InstancePtr->BaseAddress,
-							XIIC_TBA_REG_OFFSET);
-		}
-		return ((HighAddr << 8) | (u16) LowAddr);
-	}
-
-	/*
-	 * Otherwise return address of slave device on the IIC bus.
-	 */
-	return InstancePtr->AddrOfSlave;
-}
-
-/*****************************************************************************/
-/**
-*
-* This function sets the contents of the General Purpose Output register
-* for the IIC device driver. Note that the number of bits in this register is
-* parameterizable in the hardware such that it may not exist.  This function
-* checks to ensure that it does exist to prevent bus errors, but does not
-* ensure that the number of bits in the register are sufficient for the
-* value being written (won't cause a bus error).
-*
-* @param	InstancePtr is a pointer to the XIic instance to be worked on.
-* @param	OutputValue contains the value to be written to the register.
-*
-* @return
-*		- XST_SUCCESS if the given data is written to the GPO register.
-* 		- XST_NO_FEATURE if the hardware is configured such that this
-*		register does not contain any bits to read or write.
-*
-* @note		None.
-*
-****************************************************************************/
-int XIic_SetGpOutput(XIic *InstancePtr, u8 OutputValue)
-{
-	Xil_AssertNonvoid(InstancePtr != NULL);
-
-	/*
-	 * If the general purpose output register is implemented by the hardware
-	 * then write the specified value to it, otherwise indicate an error.
-	 */
-	if (InstancePtr->GpOutWidth > 0) {
-		XIic_WriteReg(InstancePtr->BaseAddress, XIIC_GPO_REG_OFFSET,
-				OutputValue);
-		return XST_SUCCESS;
-	} else {
-		return XST_NO_FEATURE;
-	}
-}
-
-/*****************************************************************************/
-/**
-*
-* This function gets the contents of the General Purpose Output register
-* for the IIC device driver. Note that the number of bits in this register is
-* parameterizable in the hardware such that it may not exist. This function
-* checks to ensure that it does exist to prevent bus errors.
-*
-* @param	InstancePtr is a pointer to the XIic instance to be worked on.
-* @param	OutputValuePtr contains the value which was read from the
-*		register.
-*
-* @return
-*		- XST_SUCCESS if the given data is read from the GPO register.
-* 		- XST_NO_FEATURE if the hardware is configured such that this
-*		register does not contain any bits to read or write.
-*
-* The OutputValuePtr is also an output as it contains the value read.
-*
-* @note		None.
-*
-****************************************************************************/
-int XIic_GetGpOutput(XIic *InstancePtr, u8 *OutputValuePtr)
-{
-	Xil_AssertNonvoid(InstancePtr != NULL);
-	Xil_AssertNonvoid(OutputValuePtr != NULL);
-
-	/*
-	 * If the general purpose output register is implemented by the hardware
-	 * then read the value from it, otherwise indicate an error.
-	 */
-	if (InstancePtr->GpOutWidth > 0) {
-		*OutputValuePtr = XIic_ReadReg(InstancePtr->BaseAddress,
-						XIIC_GPO_REG_OFFSET);
-		return XST_SUCCESS;
-	} else {
-		return XST_NO_FEATURE;
-	}
-}
-
-/*****************************************************************************/
-/**
-*
-* A function to determine if the device is currently addressed as a slave.
-*
-* @param	InstancePtr is a pointer to the XIic instance to be worked on.
-*
-* @return
-* 		- TRUE if the device is addressed as slave.
-*		- FALSE if the device is NOT addressed as slave.
-*
-* @note		None.
-*
-****************************************************************************/
-u32 XIic_IsSlave(XIic *InstancePtr)
-{
-	Xil_AssertNonvoid(InstancePtr != NULL);
-
-	if ((XIic_ReadReg(InstancePtr->BaseAddress, XIIC_SR_REG_OFFSET) &
-		 XIIC_SR_ADDR_AS_SLAVE_MASK) == 0) {
-		return FALSE;
-	}
-	return TRUE;
-}
-
-/*****************************************************************************/
-/**
-*
-* Sets the receive callback function, the receive handler, which the driver
-* calls when it finishes receiving data. The number of bytes used to signal
-* when the receive is complete is the number of bytes set in the XIic_Recv
-* function.
-*
-* The handler executes in an interrupt context such that it must minimize
-* the amount of processing performed such as transferring data to a thread
-* context.
-*
-* The number of bytes received is passed to the handler as an argument.
-*
-* @param	InstancePtr is a pointer to the XIic instance to be worked on.
-* @param	CallBackRef is the upper layer callback reference passed back
-*		when the callback function is invoked.
-* @param	FuncPtr is the pointer to the callback function.
-*
-* @return	None.
-*
-* @note		The handler is called within interrupt context .
-*
-****************************************************************************/
-void XIic_SetRecvHandler(XIic *InstancePtr, void *CallBackRef,
-			 XIic_Handler FuncPtr)
-{
-	Xil_AssertVoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
-	Xil_AssertVoid(InstancePtr != NULL);
-	Xil_AssertVoid(FuncPtr != NULL);
-
-	InstancePtr->RecvHandler = FuncPtr;
-	InstancePtr->RecvCallBackRef = CallBackRef;
-}
-
-/*****************************************************************************/
-/**
-*
-* Sets the send callback function, the send handler, which the driver calls when
-* it receives confirmation of sent data. The handler executes in an interrupt
-* context such that it must minimize the amount of processing performed such
-* as transferring data to a thread context.
-*
-* @param	InstancePtr the pointer to the XIic instance to be worked on.
-* @param	CallBackRef the upper layer callback reference passed back when
-*		the callback function is invoked.
-* @param	FuncPtr the pointer to the callback function.
-*
-* @return	None.
-*
-* @note		The handler is called within interrupt context .
-*
-****************************************************************************/
-void XIic_SetSendHandler(XIic *InstancePtr, void *CallBackRef,
-			 XIic_Handler FuncPtr)
-{
-	Xil_AssertVoid(InstancePtr != NULL);
-	Xil_AssertVoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
-	Xil_AssertVoid(FuncPtr != NULL);
-
-	InstancePtr->SendHandler = FuncPtr;
-	InstancePtr->SendCallBackRef = CallBackRef;
-}
-
-/*****************************************************************************/
-/**
-*
-* Sets the status callback function, the status handler, which the driver calls
-* when it encounters conditions which are not data related. The handler
-* executes in an interrupt context such that it must minimize the amount of
-* processing performed such as transferring data to a thread context. The
-* status events that can be returned are described in xiic.h.
-*
-* @param	InstancePtr points to the XIic instance to be worked on.
-* @param	CallBackRef is the upper layer callback reference passed back
-*		when the callback function is invoked.
-* @param	FuncPtr is the pointer to the callback function.
-*
-* @return	None.
-*
-* @note		The handler is called within interrupt context .
-*
-****************************************************************************/
-void XIic_SetStatusHandler(XIic *InstancePtr, void *CallBackRef,
-			   XIic_StatusHandler FuncPtr)
-{
-	Xil_AssertVoid(InstancePtr != NULL);
-	Xil_AssertVoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
-	Xil_AssertVoid(FuncPtr != NULL);
-
-	InstancePtr->StatusHandler = FuncPtr;
-	InstancePtr->StatusCallBackRef = CallBackRef;
-}
-
-/*****************************************************************************
-*
-* This is a stub for the send and recv callbacks. The stub is here in case the
-* upper layers forget to set the handlers.
-*
-* @param	CallBackRef is a pointer to the upper layer callback reference
-* @param	ByteCount is the number of bytes sent or received
-*
-* @return	None.
-*
-* @note		None.
-*
-******************************************************************************/
-static void XIic_StubHandler(void *CallBackRef, int ByteCount)
-{
-	Xil_AssertVoidAlways();
-}
-
-/*****************************************************************************
-*
-* This is a stub for the asynchronous error callback. The stub is here in case
-* the upper layers forget to set the handler.
-*
-* @param	CallBackRef is a pointer to the upper layer callback reference.
-* @param	ErrorCode is the Xilinx error code, indicating the cause of
-*		the error.
-*
-* @return	None.
-*
-* @note		None.
-*
-******************************************************************************/
-static void XIic_StubStatusHandler(void *CallBackRef, int ErrorCode)
-{
-	Xil_AssertVoidAlways();
-}
-
-/*****************************************************************************
-*
-* This is a function which tells whether Bus is Busy or free.
-*
-* @param	InstancePtr points to the XIic instance to be worked on.
-*
-* @return
-*		- TRUE if the Bus is Busy.
-*		- FALSE if the Bus is NOT Busy.
-*
-* @note		None.
-*
-******************************************************************************/
-u32 XIic_IsIicBusy(XIic *InstancePtr)
-{
-	u32 StatusReg;
-
-	StatusReg = XIic_ReadReg(InstancePtr->BaseAddress, XIIC_SR_REG_OFFSET);
-	if (StatusReg & XIIC_SR_BUS_BUSY_MASK) {
-		return TRUE;
-	} else {
-		return FALSE;
-	}
-}
diff --git a/drivers/i2c/algos/xilinx_iic/xiic.h b/drivers/i2c/algos/xilinx_iic/xiic.h
deleted file mode 100644
index 17d081f..0000000
--- a/drivers/i2c/algos/xilinx_iic/xiic.h
+++ /dev/null
@@ -1,554 +0,0 @@
-/* $Id: xiic.h,v 1.1.2.1 2010/04/12 12:13:13 svemula Exp $ */
-/******************************************************************************
-*
-* (c) Copyright 2002-2009 Xilinx, Inc. All rights reserved.
-*
-* This file contains confidential and proprietary information of Xilinx, Inc.
-* and is protected under U.S. and international copyright and other
-* intellectual property laws.
-*
-* DISCLAIMER
-* This disclaimer is not a license and does not grant any rights to the
-* materials distributed herewith. Except as otherwise provided in a valid
-* license issued to you by Xilinx, and to the maximum extent permitted by
-* applicable law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND WITH ALL
-* FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES AND CONDITIONS, EXPRESS,
-* IMPLIED, OR STATUTORY, INCLUDING BUT NOT LIMITED TO WARRANTIES OF
-* MERCHANTABILITY, NON-INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE;
-* and (2) Xilinx shall not be liable (whether in contract or tort, including
-* negligence, or under any other theory of liability) for any loss or damage
-* of any kind or nature related to, arising under or in connection with these
-* materials, including for any direct, or any indirect, special, incidental,
-* or consequential loss or damage (including loss of data, profits, goodwill,
-* or any type of loss or damage suffered as a result of any action brought by
-* a third party) even if such damage or loss was reasonably foreseeable or
-* Xilinx had been advised of the possibility of the same.
-*
-* CRITICAL APPLICATIONS
-* Xilinx products are not designed or intended to be fail-safe, or for use in
-* any application requiring fail-safe performance, such as life-support or
-* safety devices or systems, Class III medical devices, nuclear facilities,
-* applications related to the deployment of airbags, or any other applications
-* that could lead to death, personal injury, or severe property or
-* environmental damage (individually and collectively, "Critical
-* Applications"). Customer assumes the sole risk and liability of any use of
-* Xilinx products in Critical Applications, subject only to applicable laws
-* and regulations governing limitations on product liability.
-*
-* THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS PART OF THIS FILE
-* AT ALL TIMES.
-*
-******************************************************************************/
-/*****************************************************************************/
-/**
-*
-* @file xiic.h
-*
-* XIic is the driver for an IIC master or slave device.
-*
-* In order to reduce the memory requirements of the driver the driver is
-* partitioned such that there are optional parts of the driver.
-* Slave, master, and multimaster features are optional such that all these files
-* are not required at the same time.
-* In order to use the slave and multimaster features of the driver, the user
-* must call functions (XIic_SlaveInclude and XIic_MultiMasterInclude)
-* to dynamically include the code. These functions may be called at any time.
-*
-* Two sets of higher level API's are available in the XIic driver that can
-* be used for Transmission/Reception in Master mode :
-* - XIic_MasterSend()/ XIic_MasterRecv() which is used in normal mode.
-* - XIic_DynMasterSend()/ XIic_DynMasterRecv() which is used in Dynamic mode.
-*
-* Similarly two sets of lower level API's are available in XIic driver that
-* can be used for Transmission/Reception in Master mode:
-* - XIic_Send()/ XIic_Recv() which is used in normal mode
-* - XIic_DynSend()/ XIic_DynRecv() which is used in Dynamic mode.
-*
-* The user should use a single set of APIs as per his requirement and
-* should not intermix them.
-*
-* All the driver APIs can be used for read, write and  combined mode of
-* operations on the IIC bus.
-*
-* In the normal mode IIC support both 7-bit and 10-bit addressing, and in
-* the dynamic mode support only 7-bit addressing.
-*
-* <b>Initialization & Configuration</b>
-*
-* The XIic_Config structure is used by the driver to configure itself. This
-* configuration structure is typically created by the tool-chain based on HW
-* build properties.
-*
-* To support multiple runtime loading and initialization strategies employed
-* by various operating systems, the driver instance can be initialized in one
-* of the following ways:
-*
-*   - XIic_Initialize() - The driver looks up its own
-*     configuration structure created by the tool-chain based on an ID provided
-*     by the tool-chain.
-*
-*   - XIic_CfgInitialize() - The driver uses a configuration structure provided
-*     by the caller. If running in a system with address translation, the
-*     provided virtual memory base address replaces the physical address present
-*     in the configuration structure.
-*
-* <b>General Purpose Output</b>
-* The IIC hardware provides a General Purpose Output Register that allows the
-* user to connect general purpose outputs to devices, such as a write protect,
-* for an EEPROM. This register is parameterizable in the hardware such that
-* there could be zero bits in this register and in this case it will cause
-* a bus error if read or written.
-*
-* <b>Bus Throttling</b>
-*
-* The IIC hardware provides bus throttling which allows either the device, as
-* either a master or a slave, to stop the clock on the IIC bus. This feature
-* allows the software to perform the appropriate processing for each interrupt
-* without an unreasonable response restriction.  With this design, it is
-* important for the user to understand the implications of bus throttling.
-*
-* <b>Repeated Start</b>
-*
-* An application can send multiple messages, as a master, to a slave device
-* and re-acquire the IIC bus each time a message is sent. The repeated start
-* option allows the application to send multiple messages without re-acquiring
-* the IIC bus for each message. The transactions involving repeated start
-* are also called combined transfers if there is Read and Write in the
-* same transaction.
-*
-* The repeated start feature works with all the API's in XIic driver.
-*
-* The Repeated Start feature also could cause the application to lock up, or
-* monopolize the IIC bus, should repeated start option be enabled and sequences
-* of messages never end(periodic data collection).
-* Also when repeated start is not disable before the last master message is
-* sent or received, will leave the bus captive to the master, but unused.
-*
-* <b>Addressing</b>
-*
-* The IIC hardware is parameterized such that it can be built for 7 or 10
-* bit addresses. The driver provides the ability to control which address
-* size is sent in messages as a master to a slave device.  The address size
-* which the hardware responds to as a slave is parameterized as 7 or 10 bits
-* but fixed by the hardware build.
-*
-* Addresses are represented as hex values with no adjustment for the data
-* direction bit as the software manages address bit placement. This is
-* especially important as the bit placement is not handled the same depending
-* on which options are used such as repeated start and 7 vs 10 bit addessing.
-*
-* <b>Data Rates</b>
-*
-* The IIC hardware is parameterized such that it can be built to support
-* data rates from DC to 400KBit. The frequency of the interrupts which
-* occur is proportional to the data rate.
-*
-* <b>Polled Mode Operation</b>
-*
-* This driver does not provide a polled mode of operation primarily because
-* polled mode which is non-blocking is difficult with the amount of
-* interaction with the hardware that is necessary.
-*
-* <b>Interrupts</b>
-*
-* The device has many interrupts which allow IIC data transactions as well
-* as bus status processing to occur.
-*
-* The interrupts are divided into two types, data and status. Data interrupts
-* indicate data has been received or transmitted while the status interrupts
-* indicate the status of the IIC bus. Some of the interrupts, such as Not
-* Addressed As Slave and Bus Not Busy, are only used when these specific
-* events must be recognized as opposed to being enabled at all times.
-*
-* Many of the interrupts are not a single event in that they are continuously
-* present such that they must be disabled after recognition or when undesired.
-* Some of these interrupts, which are data related, may be acknowledged by the
-* software by reading or writing data to the appropriate register, or must
-* be disabled. The following interrupts can be continuous rather than single
-* events.
-*   - Data Transmit Register Empty/Transmit FIFO Empty
-*   - Data Receive Register Full/Receive FIFO
-*   - Transmit FIFO Half Empty
-*   - Bus Not Busy
-*   - Addressed As Slave
-*   - Not Addressed As Slave
-*
-* The following interrupts are not passed directly to the application thru the
-* status callback.  These are only used internally for the driver processing
-* and may result in the receive and send handlers being called to indicate
-* completion of an operation.  The following interrupts are data related
-* rather than status.
-*   - Data Transmit Register Empty/Transmit FIFO Empty
-*   - Data Receive Register Full/Receive FIFO
-*   - Transmit FIFO Half Empty
-*   - Slave Transmit Complete
-*
-* <b>Interrupt To Event Mapping</b>
-*
-* The following table provides a mapping of the interrupts to the events which
-* are passed to the status handler and the intended role (master or slave) for
-* the event. Some interrupts can cause multiple events which are combined
-* together into a single status event such as XII_MASTER_WRITE_EVENT and
-* XII_GENERAL_CALL_EVENT
-* <pre>
-* Interrupt                         Event(s)                      Role
-*
-* Arbitration Lost Interrupt        XII_ARB_LOST_EVENT            Master
-* Transmit Error                    XII_SLAVE_NO_ACK_EVENT        Master
-* IIC Bus Not Busy                  XII_BUS_NOT_BUSY_EVENT        Master
-* Addressed As Slave                XII_MASTER_READ_EVENT,        Slave
-*                                   XII_MASTER_WRITE_EVENT,       Slave
-*                                   XII_GENERAL_CALL_EVENT        Slave
-* </pre>
-* <b>Not Addressed As Slave Interrupt</b>
-*
-* The Not Addressed As Slave interrupt is not passed directly to the
-* application thru the status callback.  It is used to determine the end of
-* a message being received by a slave when there was no stop condition
-* (repeated start).  It will cause the receive handler to be called to
-* indicate completion of the operation.
-*
-* <b>RTOS Independence</b>
-*
-* This driver is intended to be RTOS and processor independent.  It works
-* with physical addresses only.  Any needs for dynamic memory management,
-* threads or thread mutual exclusion, virtual memory, or cache control must
-* be satisfied by the layer above this driver.
-*
-* <pre>
-* MODIFICATION HISTORY:
-*
-* Ver   Who  Date     Changes
-* ----- ---- -------- -----------------------------------------------
-* 1.01a rfp  10/19/01 release
-* 1.01c ecm  12/05/02 new rev
-* 1.01d jhl  10/08/03 Added general purpose output feature
-* 1.01d sv   05/09/05 Changed the data being written to the Address/Control
-*                     Register and removed the code for testing the
-*                     Receive Data Register in XIic_SelfTest function of
-*                     xiic_selftest.c source file
-* 1.02a jvb  12/14/05 I separated dependency on the static config table and
-*                     xparameters.h from the driver initialization by moving
-*                     _Initialize and _LookupConfig to _sinit.c. I also added
-*                     the new _CfgInitialize routine.
-* 1.02a mta  03/09/06 Added a new function XIic_IsIicBusy() which returns
-*			whether IIC Bus is Busy or Free.
-* 1.02a mta  03/09/06 Implemented Repeated Start in the Low Level Driver.
-* 1.03a mta  07/17/06 Added files to support Dynamic IIC controller in High
-*		      level driver. Added xiic_dyn_master.c. Added support
-* 		      for IIC Dynamic controller in Low level driver in xiic_l.c
-* 1.13a wgr  03/22/07 Converted to new coding style.
-* 1.13b ecm  11/29/07 added BB polling loops to the DynSend and DynRecv
-*		      routines to handle the race condition with BNB in IISR.
-* 1.14a sdm  08/22/08 Removed support for static interrupt handlers from the MDD
-*		      file
-* 1.14a ecm  11/13/08 changed BB polling loops in DynRecv to handle race
-*		      condition, CR491889. DynSend was correct from v1.13.b
-* 1.15a ktn  02/17/09 Fixed XIic_GetAddress() to return correct device address.
-* 1.16a ktn  07/17/09 Updated the XIic_SelfTest() to test only Interrupt
-*		      Registers.
-* 2.00a ktn  10/22/09 Converted all register accesses to 32 bit access.,
-*		      Removed the macro XIIC_RESET, XIic_Reset API should be
-*		      used in its place.
-*		      Removed the XIIC_CLEAR_STATS macro, XIic_ClearStats API
-*		      should be used in its place.
-*		      Removed the macro XIic_mEnterCriticalRegion,
-*		      XIic_IntrGlobalDisable should be used in its place.
-*		      Removed the macro XIic_mExitCriticalRegion,
-*		      XIic_IntrGlobalEnable should be used in its place.
-*		      Some of the macros have been renamed to remove _m from
-*		      the name see the xiic_i.h and xiic_l.h file for further
-*		      information (Example XIic_mClearIntr is now
-*		      XIic_ClearIntr).
-*		      Some of the macros have been renamed to be consistent,
-*		      see the xiic_l.h file for further information
-*		      (Example XIIC_WRITE_IIER is renamed as XIic_WriteIier).
-*		      The driver has been updated to use the HAL APIs/macros
-*		      (Example XASSERT_NONVOID is now Xil_AssertNonvoid)
-* 2.01a ktn  04/09/10 Updated TxErrorhandler in xiic_intr.c to be called for
-*		      Master Transmitter case based on Addressed As Slave (AAS)
-*		      bit rather than MSMS bit(CR 540199).
-*
-* </pre>
-*
-******************************************************************************/
-#ifndef XIIC_H			/* prevent circular inclusions */
-#define XIIC_H			/* by using protection macros */
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-/***************************** Include Files *********************************/
-
-#include "xil_types.h"
-#include "xil_assert.h"
-#include "xstatus.h"
-#include "xiic_l.h"
-
-/************************** Constant Definitions *****************************/
-
-/** @name Configuration options
- *
- * The following options may be specified or retrieved for the device and
- * enable/disable additional features of the IIC bus. Each of the options
- * are bit fields such that more than one may be specified.
- * @{
- */
-/**
- * <pre>
- * XII_GENERAL_CALL_OPTION	The general call option allows an IIC slave to
- *				recognized the general call address. The status
- *				handler is called as usual indicating the device
- *				has been addressed as a slave with a general
- *				call. It is the application's responsibility to
- *				perform any special processing for the general
- *				call.
- *
- * XII_REPEATED_START_OPTION	The repeated start option allows multiple
- *				messages to be sent/received on the IIC bus
- *				without rearbitrating for the bus.  The messages
- *				are sent as a series of messages such that the
- *				option must be enabled before the 1st message of
- *				the series, to prevent an stop condition from
- *				being generated on the bus, and disabled before
- *				the last message of the series, to allow the
- *				stop condition to be generated.
- *
- * XII_SEND_10_BIT_OPTION	The send 10 bit option allows 10 bit addresses
- *				to be sent on the bus when the device is a
- *				master. The device can be configured to respond
- *				as to 7 bit addresses even though it may be
- *				communicating with other devices that support 10
- *				bit addresses.  When this option is not enabled,
- *				only 7 bit addresses are sent on the bus.
- *
- * </pre>
- */
-#define XII_GENERAL_CALL_OPTION		0x00000001
-#define XII_REPEATED_START_OPTION	0x00000002
-#define XII_SEND_10_BIT_OPTION		0x00000004
-
-/*@}*/
-
-/** @name Status events
- *
- * The following status events occur during IIC bus processing and are passed
- * to the status callback. Each event is only valid during the appropriate
- * processing of the IIC bus. Each of these events are bit fields such that
- * more than one may be specified.
- * @{
- */
-#define XII_BUS_NOT_BUSY_EVENT	0x00000001 /**< Bus transitioned to not busy */
-#define XII_ARB_LOST_EVENT	0x00000002 /**< Arbitration was lost */
-#define XII_SLAVE_NO_ACK_EVENT	0x00000004 /**< Slave did not ACK (had error) */
-#define XII_MASTER_READ_EVENT	0x00000008 /**< Master reading from slave */
-#define XII_MASTER_WRITE_EVENT	0x00000010 /**< Master writing to slave */
-#define XII_GENERAL_CALL_EVENT	0x00000020 /**< General call to all slaves */
-/*@}*/
-
-
-/*
- * The following address types are used when setting and getting the addresses
- * of the driver. These are mutually exclusive such that only one or the other
- * may be specified.
- */
-#define XII_ADDR_TO_SEND_TYPE	 1 /**< Bus address of slave device */
-#define XII_ADDR_TO_RESPOND_TYPE 2 /**< This device's bus address as slave */
-
-/**************************** Type Definitions *******************************/
-
-/**
- * This typedef contains configuration information for the device.
- */
-typedef struct {
-	u16 DeviceId;	  /**< Unique ID  of device */
-	u32 BaseAddress;  /**< Device base address */
-	int Has10BitAddr; /**< Does device have 10 bit address decoding */
-	u8 GpOutWidth;	  /**< Number of bits in general purpose output */
-} XIic_Config;
-
-/****************************************************************************/
-/**
-* This callback function data type is defined to handle the asynchronous
-* processing of sent and received data of the IIC driver.  The application
-* using this driver is expected to define a handler of this type to support
-* interrupt driven mode. The handlers are called in an interrupt context such
-* that minimal processing should be performed. The handler data type is
-* utilized for both send and receive handlers.
-*
-* @param	CallBackRef is a callback reference passed in by the upper
-*		layer when setting the callback functions, and passed back
-*		to the upper layer when the callback is invoked. Its type is
-*		unimportant to the driver  component, so it is a void pointer.
-* @param	ByteCount indicates the number of bytes remaining to be sent or
-*		received.  A value of zero indicates that the requested number
-*		of bytes were sent or received.
-*
-******************************************************************************/
-typedef void (*XIic_Handler) (void *CallBackRef, int ByteCount);
-
-/******************************************************************************/
-/**
-* This callback function data type is defined to handle the asynchronous
-* processing of status events of the IIC driver.  The application using
-* this driver is expected to define a handler of this type to support
-* interrupt driven mode. The handler is called in an interrupt context such
-* that minimal processing should be performed.
-*
-* @param	CallBackRef is a callback reference passed in by the upper
-*		layer when setting the callback functions, and passed back
-*		to the upper layer when the callback is invoked. Its type is
-*		unimportant to the driver component, so it is a void pointer.
-* @param	StatusEvent indicates one or more status events that occurred.
-*		See the definition of the status events above.
-*
-********************************************************************************/
-typedef void (*XIic_StatusHandler) (void *CallBackRef, int StatusEvent);
-
-/**
- * XIic statistics
- */
-typedef struct {
-	u8 ArbitrationLost;/**< Number of times arbitration was lost */
-	u8 RepeatedStarts; /**< Number of repeated starts */
-	u8 BusBusy;	   /**< Number of times bus busy status returned */
-	u8 RecvBytes;	   /**< Number of bytes received */
-	u8 RecvInterrupts; /**< Number of receive interrupts */
-	u8 SendBytes;	   /**< Number of transmit bytes received */
-	u8 SendInterrupts; /**< Number of transmit interrupts */
-	u8 TxErrors;	   /**< Number of transmit errors (no ack) */
-	u8 IicInterrupts;  /**< Number of IIC (device) interrupts */
-} XIicStats;
-
-/**
- * The XIic driver instance data. The user is required to allocate a
- * variable of this type for every IIC device in the system. A pointer
- * to a variable of this type is then passed to the driver API functions.
- */
-typedef struct {
-	XIicStats Stats;	/**< Statistics */
-	u32 BaseAddress;	/**< Device base address */
-	int Has10BitAddr;	/**< TRUE when 10 bit addressing in design */
-	int IsReady;		/**< Device is initialized and ready */
-	int IsStarted;		/**< Device has been started */
-	int AddrOfSlave;	/**< Slave Address writing to */
-
-	u32 Options;		/**< Current operating options */
-	u8 *SendBufferPtr;	/**< Buffer to send (state) */
-	u8 *RecvBufferPtr;	/**< Buffer to receive (state) */
-	u8 TxAddrMode;		/**< State of Tx Address transmission */
-	int SendByteCount;	/**< Number of data bytes in buffer (state)  */
-	int RecvByteCount;	/**< Number of empty bytes in buffer (state) */
-
-	u32 BNBOnly;		/**< TRUE when BNB interrupt needs to */
-				/**< call callback  */
-	u8 GpOutWidth;		/**< General purpose output width */
-
-	XIic_StatusHandler StatusHandler; /**< Status Handler */
-	void *StatusCallBackRef;  /**< Callback reference for status handler */
-	XIic_Handler RecvHandler; /**< Receive Handler */
-	void *RecvCallBackRef;	  /**< Callback reference for Recv handler */
-	XIic_Handler SendHandler; /**< Send Handler */
-	void *SendCallBackRef;	  /**< Callback reference for send handler */
-	int IsDynamic;		  /**< TRUE when Dynamic control is used*/
-
-} XIic;
-
-/***************** Macros (Inline Functions) Definitions *********************/
-
-/************************** Function Prototypes ******************************/
-
-/*
- * Initialization functions in xiic_sinit.c
- */
-int XIic_Initialize(XIic *InstancePtr, u16 DeviceId);
-XIic_Config *XIic_LookupConfig(u16 DeviceId);
-
-/*
- * Functions in xiic.c
- */
-int XIic_CfgInitialize(XIic *InstancePtr, XIic_Config *Config,
-		       u32 EffectiveAddr);
-
-int XIic_Start(XIic *InstancePtr);
-int XIic_Stop(XIic *InstancePtr);
-
-void XIic_Reset(XIic *InstancePtr);
-
-int XIic_SetAddress(XIic *InstancePtr, int AddressType, int Address);
-u16 XIic_GetAddress(XIic *InstancePtr, int AddressType);
-
-int XIic_SetGpOutput(XIic *InstancePtr, u8 OutputValue);
-int XIic_GetGpOutput(XIic *InstancePtr, u8 *OutputValuePtr);
-
-u32 XIic_IsSlave(XIic *InstancePtr);
-
-void XIic_SetRecvHandler(XIic *InstancePtr, void *CallBackRef,
-			 XIic_Handler FuncPtr);
-void XIic_SetSendHandler(XIic *InstancePtr, void *CallBackRef,
-			 XIic_Handler FuncPtr);
-void XIic_SetStatusHandler(XIic *InstancePtr, void *CallBackRef,
-			   XIic_StatusHandler FuncPtr);
-
-/*
- * Interrupt functions in xiic_intr.c
- */
-void XIic_InterruptHandler(void *InstancePtr);
-
-/*
- * Master send and receive functions in normal mode in xiic_master.c
- */
-int XIic_MasterRecv(XIic *InstancePtr, u8 *RxMsgPtr, int ByteCount);
-int XIic_MasterSend(XIic *InstancePtr, u8 *TxMsgPtr, int ByteCount);
-
-/*
- * Master send and receive functions in dynamic mode in xiic_master.c
- */
-int XIic_DynMasterRecv(XIic *InstancePtr, u8 *RxMsgPtr, u8 ByteCount);
-int XIic_DynMasterSend(XIic *InstancePtr, u8 *TxMsgPtr, u8 ByteCount);
-
-/*
- * Dynamic IIC Core Initialization.
- */
-int XIic_DynamicInitialize(XIic *InstancePtr);
-
-/*
- * Slave send and receive functions in xiic_slave.c
- */
-void XIic_SlaveInclude(void);
-int XIic_SlaveRecv(XIic *InstancePtr, u8 *RxMsgPtr, int ByteCount);
-int XIic_SlaveSend(XIic *InstancePtr, u8 *TxMsgPtr, int ByteCount);
-
-/*
- * Statistics functions in xiic_stats.c
- */
-void XIic_GetStats(XIic *InstancePtr, XIicStats *StatsPtr);
-void XIic_ClearStats(XIic *InstancePtr);
-
-/*
- * Self test functions in xiic_selftest.c
- */
-int XIic_SelfTest(XIic *InstancePtr);
-
-/*
- * Bus busy Function in xiic.c
- */
-u32 XIic_IsIicBusy(XIic *InstancePtr);
-
-/*
- * Options functions in xiic_options.c
- */
-void XIic_SetOptions(XIic *InstancePtr, u32 Options);
-u32 XIic_GetOptions(XIic *InstancePtr);
-
-/*
- * Multi-master functions in xiic_multi_master.c
- */
-void XIic_MultiMasterInclude(void);
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif /* end of protection macro */
diff --git a/drivers/i2c/algos/xilinx_iic/xiic_i.h b/drivers/i2c/algos/xilinx_iic/xiic_i.h
deleted file mode 100644
index eb99d63..0000000
--- a/drivers/i2c/algos/xilinx_iic/xiic_i.h
+++ /dev/null
@@ -1,400 +0,0 @@
-/* $Id: xiic_i.h,v 1.1.2.1 2010/04/12 12:13:14 svemula Exp $ */
-/******************************************************************************
-*
-* (c) Copyright 2002-2009 Xilinx, Inc. All rights reserved.
-*
-* This file contains confidential and proprietary information of Xilinx, Inc.
-* and is protected under U.S. and international copyright and other
-* intellectual property laws.
-*
-* DISCLAIMER
-* This disclaimer is not a license and does not grant any rights to the
-* materials distributed herewith. Except as otherwise provided in a valid
-* license issued to you by Xilinx, and to the maximum extent permitted by
-* applicable law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND WITH ALL
-* FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES AND CONDITIONS, EXPRESS,
-* IMPLIED, OR STATUTORY, INCLUDING BUT NOT LIMITED TO WARRANTIES OF
-* MERCHANTABILITY, NON-INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE;
-* and (2) Xilinx shall not be liable (whether in contract or tort, including
-* negligence, or under any other theory of liability) for any loss or damage
-* of any kind or nature related to, arising under or in connection with these
-* materials, including for any direct, or any indirect, special, incidental,
-* or consequential loss or damage (including loss of data, profits, goodwill,
-* or any type of loss or damage suffered as a result of any action brought by
-* a third party) even if such damage or loss was reasonably foreseeable or
-* Xilinx had been advised of the possibility of the same.
-*
-* CRITICAL APPLICATIONS
-* Xilinx products are not designed or intended to be fail-safe, or for use in
-* any application requiring fail-safe performance, such as life-support or
-* safety devices or systems, Class III medical devices, nuclear facilities,
-* applications related to the deployment of airbags, or any other applications
-* that could lead to death, personal injury, or severe property or
-* environmental damage (individually and collectively, "Critical
-* Applications"). Customer assumes the sole risk and liability of any use of
-* Xilinx products in Critical Applications, subject only to applicable laws
-* and regulations governing limitations on product liability.
-*
-* THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS PART OF THIS FILE
-* AT ALL TIMES.
-*
-******************************************************************************/
-/*****************************************************************************/
-/**
-*
-* @file xiic_i.h
-*
-* This header file contains internal identifiers, which are those shared
-* between XIic components.  The identifiers in this file are not intended for
-* use external to the driver.
-*
-* <pre>
-* MODIFICATION HISTORY:
-*
-* Ver   Who  Date     Changes
-* ----- ---- -------- -----------------------------------------------
-* 1.01a rfp  10/19/01 release
-* 1.01c ecm  12/05/02 new rev
-* 1.13a wgr  03/22/07 Converted to new coding style.
-* 2.00a sdm  10/22/09 Converted all register accesses to 32 bit access.
-*		      Removed the macro XIIC_CLEAR_STATS, user has to
-*		      use the the XIic_ClearStats API in its place.
-*		      Removed the macro XIic_mEnterCriticalRegion,
-*		      XIic_IntrGlobalDisable should be used in its place.
-*		      Removed the macro XIic_mExitCriticalRegion,
-*		      XIic_IntrGlobalEnable should be used in its place.
-*		      Removed the _m prefix from all the macros
-*		      XIic_mSend10BitAddrByte1 is now XIic_Send10BitAddrByte1
-*		      XIic_mSend10BitAddrByte2 is now XIic_Send10BitAddrByte2
-*		      XIic_mSend7BitAddr is now XIic_Send7BitAddr
-*		      XIic_mDisableIntr is now XIic_DisableIntr
-*		      XIic_mEnableIntr is now XIic_EnableIntr
-*		      XIic_mClearIntr is now XIic_ClearIntr
-*		      XIic_mClearEnableIntr is now XIic_ClearEnableIntr
-*		      XIic_mFlushRxFifo is now XIic_FlushRxFifo
-*		      XIic_mFlushTxFifo is now XIic_FlushTxFifo
-*		      XIic_mReadRecvByte is now XIic_ReadRecvByte
-*		      XIic_mWriteSendByte is now XIic_WriteSendByte
-*		      XIic_mSetControlRegister is now XIic_SetControlRegister
-*
-* </pre>
-*
-******************************************************************************/
-
-#ifndef XIIC_I_H		/* prevent circular inclusions */
-#define XIIC_I_H		/* by using protection macros */
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-/***************************** Include Files *********************************/
-
-#include "xil_types.h"
-#include "xil_assert.h"
-#include "xstatus.h"
-#include "xiic.h"
-
-/************************** Constant Definitions *****************************/
-
-/**************************** Type Definitions *******************************/
-
-/***************** Macros (Inline Functions) Definitions *********************/
-
-/******************************************************************************
-*
-* This macro sends the first byte of the address for a 10 bit address during
-* both read and write operations. It takes care of the details to format the
-* address correctly.
-*
-* address = 1111_0xxD   xx = address MSBits
-*                        D = Tx direction = 0 = write
-*
-* @param	SlaveAddress contains the address of the slave to send to.
-* @param	Operation indicates XIIC_READ_OPERATION or XIIC_WRITE_OPERATION
-*
-* @return	None.
-*
-* @note		Signature:
-*		void XIic_Send10BitAddrByte1(u16 SlaveAddress, u8 Operation);
-*
-******************************************************************************/
-#define XIic_Send10BitAddrByte1(SlaveAddress, Operation)		\
-{									\
-	u8 LocalAddr = (u8)((SlaveAddress) >> 7);			\
-	LocalAddr = (LocalAddr & 0xF6) | 0xF0 | (Operation);		\
-	XIic_WriteReg(InstancePtr->BaseAddress, XIIC_DTR_REG_OFFSET,	\
-			(u32) LocalAddr);				\
-}
-
-/******************************************************************************
-*
-* This macro sends the second byte of the address for a 10 bit address during
-* both read and write operations. It takes care of the details to format the
-* address correctly.
-*
-* @param	SlaveAddress contains the address of the slave to send to.
-*
-* @return	None.
-*
-* @note		Signature: void XIic_Send10BitAddrByte2(u16 SlaveAddress,
-*				u8 Operation);
-*
-******************************************************************************/
-#define XIic_Send10BitAddrByte2(SlaveAddress)				\
-	XIic_WriteReg(InstancePtr->BaseAddress, XIIC_DTR_REG_OFFSET,	\
-			(u32)(SlaveAddress));				\
-
-/******************************************************************************
-*
-* This macro sends the address for a 7 bit address during both read and write
-* operations. It takes care of the details to format the address correctly.
-*
-* @param	SlaveAddress contains the address of the slave to send to.
-* @param	Operation indicates XIIC_READ_OPERATION or XIIC_WRITE_OPERATION
-*
-* @return	None.
-*
-* @note		Signature:
-*		void XIic_Send7BitAddr(u16 SlaveAddress, u8 Operation);
-*
-******************************************************************************/
-#define XIic_Send7BitAddr(SlaveAddress, Operation)			\
-{									\
-	u8 LocalAddr = (u8)(SlaveAddress << 1);			\
-	LocalAddr = (LocalAddr & 0xFE) | (Operation);			\
-	XIic_WriteReg(InstancePtr->BaseAddress, XIIC_DTR_REG_OFFSET,	\
-			(u32) LocalAddr); 				\
-}
-
-/******************************************************************************
-*
-* This macro disables the specified interrupts in the Interrupt enable
-* register.  It is non-destructive in that the register is read and only the
-* interrupts specified is changed.
-*
-* @param	BaseAddress is the base address of the IIC device.
-* @param	InterruptMask contains the interrupts to be disabled
-*
-* @return	None.
-*
-* @note		Signature:
-*		void XIic_DisableIntr(u32 BaseAddress, u32 InterruptMask);
-*
-******************************************************************************/
-#define XIic_DisableIntr(BaseAddress, InterruptMask)			\
-	XIic_WriteIier((BaseAddress),					\
-		XIic_ReadIier(BaseAddress) & ~(InterruptMask))
-
-/******************************************************************************
-*
-* This macro enables the specified interrupts in the Interrupt enable
-* register.  It is non-destructive in that the register is read and only the
-* interrupts specified is changed.
-*
-* @param	BaseAddress is the base address of the IIC device.
-* @param	InterruptMask contains the interrupts to be disabled
-*
-* @return	None.
-*
-* @note		Signature:
-*		void XIic_EnableIntr(u32 BaseAddress, u32 InterruptMask);
-*
-******************************************************************************/
-#define XIic_EnableIntr(BaseAddress, InterruptMask)			\
-	XIic_WriteIier((BaseAddress),					\
-		XIic_ReadIier(BaseAddress) | (InterruptMask))
-
-/******************************************************************************
-*
-* This macro clears the specified interrupt in the Interrupt status
-* register.  It is non-destructive in that the register is read and only the
-* interrupt specified is cleared.  Clearing an interrupt acknowledges it.
-*
-* @param	BaseAddress is the base address of the IIC device.
-* @param	InterruptMask contains the interrupts to be disabled
-*
-* @return	None.
-*
-* @note		Signature:
-*		void XIic_ClearIntr(u32 BaseAddress, u32 InterruptMask);
-*
-******************************************************************************/
-#define XIic_ClearIntr(BaseAddress, InterruptMask)			\
-	XIic_WriteIisr((BaseAddress),					\
-		XIic_ReadIisr(BaseAddress) & (InterruptMask))
-
-/******************************************************************************
-*
-* This macro clears and enables the specified interrupt in the Interrupt
-* status and enable registers.  It is non-destructive in that the registers are
-* read and only the interrupt specified is modified.
-* Clearing an interrupt acknowledges it.
-*
-* @param	BaseAddress is the base address of the IIC device.
-* @param	InterruptMask contains the interrupts to be cleared and enabled
-*
-* @return	None.
-*
-* @note		Signature:
-*		void XIic_ClearEnableIntr(u32 BaseAddress, u32 InterruptMask);
-*
-******************************************************************************/
-#define XIic_ClearEnableIntr(BaseAddress, InterruptMask)		\
-{									\
-	XIic_WriteIisr(BaseAddress,					\
-		(XIic_ReadIisr(BaseAddress) & (InterruptMask))); 	\
-									\
-	XIic_WriteIier(BaseAddress,					\
-		(XIic_ReadIier(BaseAddress) | (InterruptMask)));	\
-}
-
-/******************************************************************************
-*
-* This macro flushes the receive FIFO such that all bytes contained within it
-* are discarded.
-*
-* @param	InstancePtr is a pointer to the IIC instance containing the FIFO
-*		to be flushed.
-*
-* @return	None.
-*
-* @note		Signature:
-*		void XIic_FlushRxFifo(XIic *InstancePtr);
-*
-******************************************************************************/
-#define XIic_FlushRxFifo(InstancePtr)					\
-{									\
-	int LoopCnt;							\
-	u8 Temp;							\
-	u8 BytesToRead = XIic_ReadReg(InstancePtr->BaseAddress,	\
-				XIIC_RFO_REG_OFFSET) + 1;		\
-	for(LoopCnt = 0; LoopCnt < BytesToRead; LoopCnt++)		\
-	{								\
-		Temp = (u8) XIic_ReadReg(InstancePtr->BaseAddress,	\
-					  XIIC_DRR_REG_OFFSET);		\
-	}								\
-}
-
-/******************************************************************************
-*
-* This macro flushes the transmit FIFO such that all bytes contained within it
-* are discarded.
-*
-* @param	InstancePtr is a pointer to the IIC instance containing the FIFO
-*		to be flushed.
-*
-* @return	None.
-*
-* @note		Signature:
-*		void XIic_FlushTxFifo(XIic *InstancePtr);
-*
-******************************************************************************/
-#define XIic_FlushTxFifo(InstancePtr);					\
-{									\
-	u32 CntlReg = XIic_ReadReg(InstancePtr->BaseAddress,		\
-					XIIC_CR_REG_OFFSET);		\
-	XIic_WriteReg(InstancePtr->BaseAddress, XIIC_CR_REG_OFFSET,	\
-			CntlReg | XIIC_CR_TX_FIFO_RESET_MASK);		\
-	XIic_WriteReg(InstancePtr->BaseAddress, XIIC_CR_REG_OFFSET,	\
-			CntlReg);					\
-}
-
-/******************************************************************************
-*
-* This macro reads the next available received byte from the receive FIFO
-* and updates all the data structures to reflect it.
-*
-* @param	InstancePtr is a pointer to the IIC instance to be operated on.
-*
-* @return	None.
-*
-* @note		Signature:
-*		void XIic_ReadRecvByte(XIic *InstancePtr);
-*
-******************************************************************************/
-#define XIic_ReadRecvByte(InstancePtr)					\
-{									\
-	*InstancePtr->RecvBufferPtr++ =					\
-	XIic_ReadReg(InstancePtr->BaseAddress, XIIC_DRR_REG_OFFSET);	\
-	InstancePtr->RecvByteCount--;					\
-	InstancePtr->Stats.RecvBytes++;					\
-}
-
-/******************************************************************************
-*
-* This macro writes the next byte to be sent to the transmit FIFO
-* and updates all the data structures to reflect it.
-*
-* @param	InstancePtr is a pointer to the IIC instance to be operated on.
-*
-* @return	None.
-*
-* @note		Signature:
-*		void XIic_WriteSendByte(XIic *InstancePtr);
-*
-******************************************************************************/
-#define XIic_WriteSendByte(InstancePtr)				\
-{									\
-	XIic_WriteReg(InstancePtr->BaseAddress, XIIC_DTR_REG_OFFSET,	\
-		*InstancePtr->SendBufferPtr++);				\
-	InstancePtr->SendByteCount--;					\
-	InstancePtr->Stats.SendBytes++;					\
-}
-
-/******************************************************************************
-*
-* This macro sets up the control register for a master receive operation.
-* A write is necessary if a 10 bit operation is being performed.
-*
-* @param	InstancePtr is a pointer to the IIC instance to be operated on.
-* @param	ControlRegister contains the contents of the IIC device control
-*		register
-* @param	ByteCount contains the number of bytes to be received for the
-*		master receive operation
-*
-* @return	None.
-*
-* @note		Signature:
-*		void XIic_SetControlRegister(XIic *InstancePtr,
-*						u8 ControlRegister,
-*						int ByteCount);
-*
-******************************************************************************/
-#define XIic_SetControlRegister(InstancePtr, ControlRegister, ByteCount)     \
-{									      \
-	(ControlRegister) &= ~(XIIC_CR_NO_ACK_MASK | XIIC_CR_DIR_IS_TX_MASK); \
-	if (InstancePtr->Options & XII_SEND_10_BIT_OPTION) {		\
-		(ControlRegister) |= XIIC_CR_DIR_IS_TX_MASK;		\
-	} else {							\
-		if ((ByteCount) == 1)					\
-		{							\
-			(ControlRegister) |= XIIC_CR_NO_ACK_MASK;	\
-		}							\
-	}								\
-}
-
-/************************** Function Prototypes ******************************/
-
-extern XIic_Config XIic_ConfigTable[];
-
-/* The following variables are shared across files of the driver and
- * are function pointers that are necessary to break dependencies allowing
- * optional parts of the driver to be used without condition compilation
- */
-extern void (*XIic_AddrAsSlaveFuncPtr) (XIic *InstancePtr);
-extern void (*XIic_NotAddrAsSlaveFuncPtr) (XIic *InstancePtr);
-extern void (*XIic_RecvSlaveFuncPtr) (XIic *InstancePtr);
-extern void (*XIic_SendSlaveFuncPtr) (XIic *InstancePtr);
-extern void (*XIic_RecvMasterFuncPtr) (XIic *InstancePtr);
-extern void (*XIic_SendMasterFuncPtr) (XIic *InstancePtr);
-extern void (*XIic_ArbLostFuncPtr) (XIic *InstancePtr);
-extern void (*XIic_BusNotBusyFuncPtr) (XIic *InstancePtr);
-
-void XIic_TransmitFifoFill(XIic *InstancePtr, int Role);
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif /* end of protection macro */
diff --git a/drivers/i2c/algos/xilinx_iic/xiic_intr.c b/drivers/i2c/algos/xilinx_iic/xiic_intr.c
deleted file mode 100644
index 6ea2986..0000000
--- a/drivers/i2c/algos/xilinx_iic/xiic_intr.c
+++ /dev/null
@@ -1,442 +0,0 @@
-/* $Id: xiic_intr.c,v 1.1.2.1 2010/04/12 12:13:14 svemula Exp $ */
-/******************************************************************************
-*
-* (c) Copyright 2002-2009 Xilinx, Inc. All rights reserved.
-*
-* This file contains confidential and proprietary information of Xilinx, Inc.
-* and is protected under U.S. and international copyright and other
-* intellectual property laws.
-*
-* DISCLAIMER
-* This disclaimer is not a license and does not grant any rights to the
-* materials distributed herewith. Except as otherwise provided in a valid
-* license issued to you by Xilinx, and to the maximum extent permitted by
-* applicable law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND WITH ALL
-* FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES AND CONDITIONS, EXPRESS,
-* IMPLIED, OR STATUTORY, INCLUDING BUT NOT LIMITED TO WARRANTIES OF
-* MERCHANTABILITY, NON-INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE;
-* and (2) Xilinx shall not be liable (whether in contract or tort, including
-* negligence, or under any other theory of liability) for any loss or damage
-* of any kind or nature related to, arising under or in connection with these
-* materials, including for any direct, or any indirect, special, incidental,
-* or consequential loss or damage (including loss of data, profits, goodwill,
-* or any type of loss or damage suffered as a result of any action brought by
-* a third party) even if such damage or loss was reasonably foreseeable or
-* Xilinx had been advised of the possibility of the same.
-*
-* CRITICAL APPLICATIONS
-* Xilinx products are not designed or intended to be fail-safe, or for use in
-* any application requiring fail-safe performance, such as life-support or
-* safety devices or systems, Class III medical devices, nuclear facilities,
-* applications related to the deployment of airbags, or any other applications
-* that could lead to death, personal injury, or severe property or
-* environmental damage (individually and collectively, "Critical
-* Applications"). Customer assumes the sole risk and liability of any use of
-* Xilinx products in Critical Applications, subject only to applicable laws
-* and regulations governing limitations on product liability.
-*
-* THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS PART OF THIS FILE
-* AT ALL TIMES.
-*
-******************************************************************************/
-/*****************************************************************************/
-/**
-*
-* @file xiic_intr.c
-*
-* Contains interrupt functions of the XIic driver.  This file is required
-* for the driver.
-*
-* <pre>
-* MODIFICATION HISTORY:
-*
-* Ver   Who  Date     Changes
-* ----- ---- -------- -----------------------------------------------
-* 1.01a rfp  10/19/01 release
-* 1.01c ecm  12/05/02 new rev
-* 1.01c rmm  05/14/03 Fixed diab compiler warnings relating to asserts.
-* 1.03a ecm  06/22/06 Added a call to the status handler in the TxErrorHandler
-*                     even if the Rx buffer pointer is not set. This fix is as
-*                     a result of a Sony use model which did not set the Rx
-*                     pointer while in Master mode so it checks if MSMS == 1.
-* 1.13a wgr  03/22/07 Converted to new coding style.
-* 2.00a sdm  10/22/09 Converted all register accesses to 32 bit access.
-*		      Updated to use the HAL APIs/macros.
-*		      Some of the macros have been renamed to remove _m from
-*		      the name and Some of the macros have been renamed to be
-*		      consistent, see the xiic_l.h file for further information.
-* 2.01a ktn  04/09/10 Updated TxErrorhandler to be called for Master Transmitter
-*		      case based on Addressed As Slave (AAS) bit rather than
-*		      MSMS bit(CR 540199).
-* </pre>
-*
-******************************************************************************/
-
-
-/***************************** Include Files *********************************/
-
-#include "xiic.h"
-#include "xiic_i.h"
-
-/************************** Constant Definitions *****************************/
-
-
-/**************************** Type Definitions *******************************/
-
-
-/***************** Macros (Inline Functions) Definitions ******************/
-
-/************************** Function Prototypes ****************************/
-
-static void StubFunction(XIic *InstancePtr);
-static void TxErrorHandler(XIic *InstancePtr);
-
-/************************** Variable Definitions *****************************/
-
-/* The following function pointers are used to help allow finer partitioning
- * of the driver such that some parts of it are optional. These pointers are
- * setup by functions in the optional parts of the driver.
- */
-void (*XIic_AddrAsSlaveFuncPtr) (XIic *InstancePtr) = StubFunction;
-void (*XIic_NotAddrAsSlaveFuncPtr) (XIic *InstancePtr) = StubFunction;
-void (*XIic_RecvSlaveFuncPtr) (XIic *InstancePtr) = StubFunction;
-void (*XIic_SendSlaveFuncPtr) (XIic *InstancePtr) = StubFunction;
-void (*XIic_RecvMasterFuncPtr) (XIic *InstancePtr) = StubFunction;
-void (*XIic_SendMasterFuncPtr) (XIic *InstancePtr) = StubFunction;
-void (*XIic_ArbLostFuncPtr) (XIic *InstancePtr) = StubFunction;
-void (*XIic_BusNotBusyFuncPtr) (XIic *InstancePtr) = StubFunction;
-
-/*****************************************************************************/
-/**
-*
-* This function is the interrupt handler for the XIic driver. This function
-* should be connected to the interrupt system.
-*
-* Only one interrupt source is handled for each interrupt allowing
-* higher priority system interrupts quicker response time.
-*
-* @param	InstancePtr is a pointer to the XIic instance to be worked on.
-*
-* @return	None.
-*
-* @internal
-*
-* The XIIC_INTR_ARB_LOST_MASK and XIIC_INTR_TX_ERROR_MASK interrupts must have
-* higher priority than the other device interrupts so that the IIC device does
-* not get into a potentially confused state. The remaining interrupts may be
-* rearranged with no harm.
-*
-******************************************************************************/
-void XIic_InterruptHandler(void *InstancePtr)
-{
-	u32 Status;
-	u32 IntrStatus;
-	u32 IntrPending;
-	u32 IntrEnable;
-	XIic *IicPtr = NULL;
-	u32 Clear = 0;
-
-	/*
-	 * Verify that each of the inputs are valid.
-	 */
-	Xil_AssertVoid(InstancePtr != NULL);
-
-	/*
-	 * Convert the non-typed pointer to an IIC instance pointer
-	 */
-	IicPtr = (XIic *) InstancePtr;
-
-	/*
-	 * Get the interrupt Status.
-	 */
-	IntrPending = XIic_ReadIisr(IicPtr->BaseAddress);
-	IntrEnable = XIic_ReadIier(IicPtr->BaseAddress);
-	IntrStatus = IntrPending & IntrEnable;
-
-	/*
-	 * Do not processes a devices interrupts if the device has no
-	 * interrupts pending or the global interrupts have been disabled.
-	 */
-	if ((IntrStatus == 0) |
-		(XIic_IsIntrGlobalEnabled(IicPtr->BaseAddress) == FALSE)) {
-		return;
-	}
-
-	/*
-	 * Update interrupt stats and get the contents of the status register.
-	 */
-	IicPtr->Stats.IicInterrupts++;
-	Status = XIic_ReadReg(IicPtr->BaseAddress, XIIC_SR_REG_OFFSET);
-
-	/*
-	 * Service requesting interrupt.
-	 */
-	if (IntrStatus & XIIC_INTR_ARB_LOST_MASK) {
-		/* Bus Arbritration Lost */
-
-		IicPtr->Stats.ArbitrationLost++;
-		XIic_ArbLostFuncPtr(IicPtr);
-
-		Clear = XIIC_INTR_ARB_LOST_MASK;
-	} else if (IntrStatus & XIIC_INTR_TX_ERROR_MASK) {
-		/* Transmit errors (no acknowledge) received */
-
-		IicPtr->Stats.TxErrors++;
-		TxErrorHandler(IicPtr);
-
-		Clear = XIIC_INTR_TX_ERROR_MASK;
-	} else if (IntrStatus & XIIC_INTR_NAAS_MASK) {
-		/* Not Addressed As Slave */
-
-		XIic_NotAddrAsSlaveFuncPtr(IicPtr);
-		Clear = XIIC_INTR_NAAS_MASK;
-	} else if (IntrStatus & XIIC_INTR_RX_FULL_MASK) {
-		/* Receive register/FIFO is full */
-
-		IicPtr->Stats.RecvInterrupts++;
-
-		if (Status & XIIC_SR_ADDR_AS_SLAVE_MASK) {
-			XIic_RecvSlaveFuncPtr(IicPtr);
-		} else {
-			XIic_RecvMasterFuncPtr(IicPtr);
-		}
-
-		Clear = XIIC_INTR_RX_FULL_MASK;
-	} else if (IntrStatus & XIIC_INTR_AAS_MASK) {
-		/* Addressed As Slave */
-
-		XIic_AddrAsSlaveFuncPtr(IicPtr);
-		Clear = XIIC_INTR_AAS_MASK;
-	} else if (IntrStatus & XIIC_INTR_BNB_MASK) {
-		/* IIC bus has transitioned to not busy */
-
-		/* Check if send callback needs to run */
-		if (IicPtr->BNBOnly == TRUE) {
-			XIic_BusNotBusyFuncPtr(IicPtr);
-			IicPtr->BNBOnly = FALSE;
-		} else {
-			IicPtr->SendHandler(IicPtr->SendCallBackRef, 0);
-		}
-
-		Clear = XIIC_INTR_BNB_MASK;
-
-		/* The bus is not busy, disable BusNotBusy interrupt */
-		XIic_DisableIntr(IicPtr->BaseAddress, XIIC_INTR_BNB_MASK);
-
-	} else if ((IntrStatus & XIIC_INTR_TX_EMPTY_MASK) ||
-		 (IntrStatus & XIIC_INTR_TX_HALF_MASK)) {
-		/* Transmit register/FIFO is empty or  empty */
-		IicPtr->Stats.SendInterrupts++;
-
-		if (Status & XIIC_SR_ADDR_AS_SLAVE_MASK) {
-			XIic_SendSlaveFuncPtr(IicPtr);
-		} else {
-			XIic_SendMasterFuncPtr(IicPtr);
-		}
-
-		IntrStatus = XIic_ReadIisr(IicPtr->BaseAddress);
-		Clear = IntrStatus & (XIIC_INTR_TX_EMPTY_MASK |
-					  XIIC_INTR_TX_HALF_MASK);
-	}
-
-	/*
-	 * Clear Interrupts.
-	 */
-	XIic_WriteIisr(IicPtr->BaseAddress, Clear);
-}
-
-/******************************************************************************
-*
-* This function fills the FIFO using the occupancy register to determine the
-* available space to be filled. When the repeated start option is on, the last
-* byte is withheld to allow the control register to be properly set on the last
-* byte.
-*
-* @param	InstancePtr is a pointer to the XIic instance to be worked on.
-*
-* @param	Role indicates the role of this IIC device, a slave or a master,
-*		on the IIC bus (XIIC_SLAVE_ROLE or XIIC_MASTER_ROLE).
-*
-* @return	None.
-*
-* @note		None.
-*
-******************************************************************************/
-void XIic_TransmitFifoFill(XIic *InstancePtr, int Role)
-{
-	u8 AvailBytes;
-	int LoopCnt;
-	int NumBytesToSend;
-
-	/*
-	 * Determine number of bytes to write to FIFO. Number of bytes that
-	 * can be put into the FIFO is (FIFO depth) - (current occupancy + 1)
-	 * When more room in FIFO than msg bytes put all of message in the FIFO.
-	 */
-	AvailBytes = IIC_TX_FIFO_DEPTH -
-			(u8) (XIic_ReadReg(InstancePtr->BaseAddress,
-					XIIC_TFO_REG_OFFSET) + 1);
-
-	if (InstancePtr->SendByteCount > AvailBytes) {
-		NumBytesToSend = AvailBytes;
-	} else {
-		/*
-		 * More space in FIFO than bytes in message.
-		 */
-		if ((InstancePtr->Options & XII_REPEATED_START_OPTION) ||
-			(Role == XIIC_SLAVE_ROLE)) {
-			NumBytesToSend = InstancePtr->SendByteCount;
-		} else {
-			NumBytesToSend = InstancePtr->SendByteCount - 1;
-		}
-	}
-
-	/*
-	 * Fill FIFO with amount determined above.
-	 */
-	for (LoopCnt = 0; LoopCnt < NumBytesToSend; LoopCnt++) {
-		XIic_WriteSendByte(InstancePtr);
-	}
-}
-
-/*****************************************************************************/
-/**
-*
-* This interrupt occurs four different ways: Two as master and two as slave.
-* Master:
-* <pre>
-*  (1) Transmitter (IMPLIES AN ERROR)
-*      The slave receiver did not acknowledge properly.
-*  (2) Receiver (Implies Tx complete)
-*      Interrupt caused by setting TxAck high in the IIC to indicate to the
-*      the last byte has been transmitted.
-* </pre>
-*
-* Slave:
-* <pre>
-*  (3) Transmitter (Implies Tx complete)
-*      Interrupt caused by master device indicating last byte of the message
-*      has been transmitted.
-*  (4) Receiver (IMPLIES AN ERROR)
-*      Interrupt caused by setting TxAck high in the IIC to indicate Rx
-*      IIC had a problem - set by this device and condition already known
-*      and interrupt is not enabled.
-* </pre>
-*
-* This interrupt is enabled during Master send and receive and disabled
-* when this device knows it is going to send a negative acknowledge (Ack = No).
-*
-* Signals user of Tx error via status callback sending: XII_TX_ERROR_EVENT
-*
-* When MasterRecv has no message to send and only receives one byte of data
-* from the salve device, the TxError must be enabled to catch addressing
-* errors, yet there is not opportunity to disable TxError when there is no
-* data to send allowing disabling on last byte. When the slave sends the
-* only byte the NOAck causes a Tx Error. To disregard this as no real error,
-* when there is data in the Receive FIFO/register then the error was not
-* a device address write error, but a NOACK read error - to be ignored.
-* To work with or without FIFO's, the Rx Data interrupt is used to indicate
-* data is in the Rx register.
-*
-* @param	InstancePtr is a pointer to the XIic instance to be worked on.
-*
-* @return	None.
-*
-******************************************************************************/
-static void TxErrorHandler(XIic *InstancePtr)
-{
-	u32 IntrStatus;
-	u32 CntlReg;
-
-	/*
-	 * When Sending as a slave, Tx error signals end of msg. Not Addressed
-	 * As Slave will handle the callbacks. this is used to only flush
-	 * the Tx fifo. The addressed as slave bit is gone as soon as the bus
-	 * has been released such that the buffer pointers are used to determine
-	 * the direction of transfer (send or receive).
-	 */
-	if (InstancePtr->RecvBufferPtr == NULL) {
-		/*
-		 * Master Receiver finished reading message. Flush Tx fifo to
-		 * remove an 0xFF that was written to prevent bus throttling,
-		 * and disable all transmit and receive interrupts.
-		 */
-		XIic_FlushTxFifo(InstancePtr);
-		XIic_DisableIntr(InstancePtr->BaseAddress,
-				  XIIC_TX_RX_INTERRUPTS);
-
-		/*
-		 * If operating in Master mode, call status handler to indicate
-		 * NOACK occured.
-		 */
-		IntrStatus = XIic_ReadIisr(InstancePtr->BaseAddress);
-		if ((IntrStatus & XIIC_INTR_AAS_MASK) == 0) {
-			InstancePtr->StatusHandler(InstancePtr->
-						   StatusCallBackRef,
-						   XII_SLAVE_NO_ACK_EVENT);
-		}
-
-		return;
-	}
-
-	/*
-	 * Data in the receive register from either master or slave receive
-	 * When:slave, indicates master sent last byte, message completed.
-	 * When:master, indicates a master Receive with one byte received. When
-	 * a byte is in Rx reg then the Tx error indicates the Rx data was
-	 * recovered normally Tx errors are not enabled such that this should
-	 * not occur.
-	 */
-	IntrStatus = XIic_ReadIisr(InstancePtr->BaseAddress);
-	if (IntrStatus & XIIC_INTR_RX_FULL_MASK) {
-		/* Rx Reg/FIFO has data,  Disable Tx error interrupts */
-
-		XIic_DisableIntr(InstancePtr->BaseAddress,
-				  XIIC_INTR_TX_ERROR_MASK);
-		return;
-	}
-
-	XIic_FlushTxFifo(InstancePtr);
-
-	/*
-	 * Disable and clear Tx empty,  empty, Rx Full or Tx error interrupts.
-	 */
-	XIic_DisableIntr(InstancePtr->BaseAddress, XIIC_TX_RX_INTERRUPTS);
-	XIic_ClearIntr(InstancePtr->BaseAddress, XIIC_TX_RX_INTERRUPTS);
-
-	/* Clear MSMS as on Tx error when Rxing, the bus will be
-	 * stopped but MSMS bit is still set. Reset to proper state
-	 */
-	CntlReg = XIic_ReadReg(InstancePtr->BaseAddress, XIIC_CR_REG_OFFSET);
-	CntlReg &= ~XIIC_CR_MSMS_MASK;
-	XIic_WriteReg(InstancePtr->BaseAddress, XIIC_CR_REG_OFFSET, CntlReg);
-
-
-	/*
-	 * Set FIFO occupancy depth = 1 so that the first byte will throttle
-	 * next recieve msg.
-	 */
-	XIic_WriteReg(InstancePtr->BaseAddress, XIIC_RFD_REG_OFFSET, 0);
-
-	/*
-	 * Call the event callback.
-	 */
-	InstancePtr->StatusHandler(InstancePtr->StatusCallBackRef,
-				   XII_SLAVE_NO_ACK_EVENT);
-}
-
-/*****************************************************************************/
-/**
-*
-* This function is a stub function that is used for the default function for
-* events that are handled optionally only when the appropriate modules are
-* linked in.  Function pointers are used to handle some events to allow
-* some events to be optionally handled.
-*
-* @param	InstancePtr is a pointer to the XIic instance to be worked on.
-*
-******************************************************************************/
-static void StubFunction(XIic *InstancePtr)
-{
-	Xil_AssertVoidAlways();
-}
diff --git a/drivers/i2c/algos/xilinx_iic/xiic_l.c b/drivers/i2c/algos/xilinx_iic/xiic_l.c
deleted file mode 100644
index 9311b5b..0000000
--- a/drivers/i2c/algos/xilinx_iic/xiic_l.c
+++ /dev/null
@@ -1,1005 +0,0 @@
-/* $Id: xiic_l.c,v 1.1.2.1 2010/04/12 12:13:14 svemula Exp $ */
-/******************************************************************************
-*
-* (c) Copyright 2002-2009 Xilinx, Inc. All rights reserved.
-*
-* This file contains confidential and proprietary information of Xilinx, Inc.
-* and is protected under U.S. and international copyright and other
-* intellectual property laws.
-*
-* DISCLAIMER
-* This disclaimer is not a license and does not grant any rights to the
-* materials distributed herewith. Except as otherwise provided in a valid
-* license issued to you by Xilinx, and to the maximum extent permitted by
-* applicable law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND WITH ALL
-* FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES AND CONDITIONS, EXPRESS,
-* IMPLIED, OR STATUTORY, INCLUDING BUT NOT LIMITED TO WARRANTIES OF
-* MERCHANTABILITY, NON-INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE;
-* and (2) Xilinx shall not be liable (whether in contract or tort, including
-* negligence, or under any other theory of liability) for any loss or damage
-* of any kind or nature related to, arising under or in connection with these
-* materials, including for any direct, or any indirect, special, incidental,
-* or consequential loss or damage (including loss of data, profits, goodwill,
-* or any type of loss or damage suffered as a result of any action brought by
-* a third party) even if such damage or loss was reasonably foreseeable or
-* Xilinx had been advised of the possibility of the same.
-*
-* CRITICAL APPLICATIONS
-* Xilinx products are not designed or intended to be fail-safe, or for use in
-* any application requiring fail-safe performance, such as life-support or
-* safety devices or systems, Class III medical devices, nuclear facilities,
-* applications related to the deployment of airbags, or any other applications
-* that could lead to death, personal injury, or severe property or
-* environmental damage (individually and collectively, "Critical
-* Applications"). Customer assumes the sole risk and liability of any use of
-* Xilinx products in Critical Applications, subject only to applicable laws
-* and regulations governing limitations on product liability.
-*
-* THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS PART OF THIS FILE
-* AT ALL TIMES.
-*
-******************************************************************************/
-/*****************************************************************************/
-/**
-*
-* @file xiic_l.c
-*
-* This file contains low-level driver functions that can be used to access the
-* device in normal and dynamic controller mode. The user should refer to the
-* hardware device specification for more details of the device operation.
-*
-* <pre>
-* MODIFICATION HISTORY:
-*
-* Ver   Who  Date     Changes
-* ----- --- -------   -----------------------------------------------
-* 1.01b jhl 05/13/02  First release
-* 1.01b jhl 10/14/02  Corrected bug in the receive function, the setup of the
-*                     interrupt status mask was not being done in the loop such
-*                     that a read would sometimes fail on the last byte because
-*                     the transmit error which should have been ignored was
-*                     being used.  This would leave an extra byte in the FIFO
-*                     and the bus throttled such that the next operation would
-*                     also fail.  Also updated the receive function to not
-*                     disable the device after the last byte until after the
-*                     bus transitions to not busy which is more consistent
-*                     with the expected behavior.
-* 1.01c ecm  12/05/02 new rev
-* 1.02a mta  03/09/06 Implemented Repeated Start in the Low Level Driver.
-* 1.03a mta  04/04/06 Implemented Dynamic IIC core routines.
-* 1.03a ecm  06/15/06 Fixed the hang in low_level_eeprom_test with -O0
-*                     Added polling loops for BNB to allow the slave to
-*                     respond correctly. Also added polling loop prior
-*                     to reset in _Recv.
-* 1.13a wgr  03/22/07 Converted to new coding style.
-* 1.13b ecm  11/29/07 added BB polling loops to the DynSend and DynRecv
-*			routines to handle the race condition with BNB in IISR.
-* 2.00a sdm  10/22/09 Converted all register accesses to 32 bit access.
-*		      Updated to use the HAL APIs/macros.
-*		      Some of the macros have been renamed to remove _m from
-*		      the name and Some of the macros have been renamed to be
-*		      consistent, see the xiic_i.h and xiic_l.h files for
-*		      further information.
-* </pre>
-*
-****************************************************************************/
-
-/***************************** Include Files *******************************/
-
-#include "xil_types.h"
-#include "xil_assert.h"
-#include "xiic_l.h"
-
-/************************** Constant Definitions ***************************/
-
-/**************************** Type Definitions *****************************/
-
-/***************** Macros (Inline Functions) Definitions *******************/
-
-/************************** Function Prototypes ****************************/
-
-static unsigned RecvData(u32 BaseAddress, u8 *BufferPtr,
-			 unsigned ByteCount, u8 Option);
-static unsigned SendData(u32 BaseAddress, u8 *BufferPtr,
-			 unsigned ByteCount, u8 Option);
-
-static unsigned DynRecvData(u32 BaseAddress, u8 *BufferPtr, u8 ByteCount);
-static unsigned DynSendData(u32 BaseAddress, u8 *BufferPtr,
-				u8 ByteCount, u8 Option);
-
-/************************** Variable Definitions **************************/
-
-/****************************************************************************/
-/**
-* Receive data as a master on the IIC bus.  This function receives the data
-* using polled I/O and blocks until the data has been received. It only
-* supports 7 bit addressing mode of operation. The user is responsible for
-* ensuring the bus is not busy if multiple masters are present on the bus.
-*
-* @param	BaseAddress contains the base address of the IIC device.
-* @param	Address contains the 7 bit IIC address of the device to send the
-*		specified data to.
-* @param	BufferPtr points to the data to be sent.
-* @param	ByteCount is the number of bytes to be sent.
-* @param	Option indicates whether to hold or free the bus after reception
-*		of data, XIIC_STOP = end with STOP condition,
-*		XIIC_REPEATED_START = don't end with STOP condition.
-*
-* @return	The number of bytes received.
-*
-* @note		None.
-*
-******************************************************************************/
-unsigned XIic_Recv(u32 BaseAddress, u8 Address,
-			u8 *BufferPtr, unsigned ByteCount, u8 Option)
-{
-	u32 CntlReg;
-	unsigned RemainingByteCount;
-	volatile u32 StatusReg;
-
-	/* Tx error is enabled incase the address (7 or 10) has no device to
-	 * answer with Ack. When only one byte of data, must set NO ACK before
-	 * address goes out therefore Tx error must not be enabled as it will go
-	 * off immediately and the Rx full interrupt will be checked.  If full,
-	 * then the one byte was received and the Tx error will be disabled
-	 * without sending an error callback msg
-	 */
-	XIic_ClearIisr(BaseAddress,
-			XIIC_INTR_RX_FULL_MASK | XIIC_INTR_TX_ERROR_MASK |
-			XIIC_INTR_ARB_LOST_MASK);
-
-	/* Set receive FIFO occupancy depth for 1 byte (zero based) */
-	XIic_WriteReg(BaseAddress,  XIIC_RFD_REG_OFFSET, 0);
-
-
-	/* Check to see if already Master on the Bus.
-	 * If Repeated Start bit is not set send Start bit by setting MSMS bit
-	 * else Send the address
-	 */
-	CntlReg = XIic_ReadReg(BaseAddress,  XIIC_CR_REG_OFFSET);
-	if ((CntlReg & XIIC_CR_REPEATED_START_MASK) == 0) {
-		/* 7 bit slave address, send the address for a read operation
-		 * and set the state to indicate the address has been sent
-		 */
-		XIic_Send7BitAddress(BaseAddress, Address,
-					XIIC_READ_OPERATION);
-
-
-		/* MSMS gets set after putting data in FIFO. Start the master
-		 * receive operation by setting CR Bits MSMS to Master, if the
-		 * buffer is only one byte, then it should not be acknowledged
-		 * to indicate the end of data
-		 */
-		CntlReg = XIIC_CR_MSMS_MASK | XIIC_CR_ENABLE_DEVICE_MASK;
-		if (ByteCount == 1) {
-			CntlReg |= XIIC_CR_NO_ACK_MASK;
-		}
-
-		/* Write out the control register to start receiving data and
-		 * call the function to receive each byte into the buffer
-		 */
-		XIic_WriteReg(BaseAddress,  XIIC_CR_REG_OFFSET, CntlReg);
-
-		/* Clear the latched interrupt status for the bus not busy bit
-		 * which must be done while the bus is busy
-		 */
-		StatusReg = XIic_ReadReg(BaseAddress,  XIIC_SR_REG_OFFSET);
-
-		while ((StatusReg & XIIC_SR_BUS_BUSY_MASK) == 0) {
-			StatusReg = XIic_ReadReg(BaseAddress,
-						  XIIC_SR_REG_OFFSET);
-		}
-
-		XIic_ClearIisr(BaseAddress, XIIC_INTR_BNB_MASK);
-	} else {
-		/* Already owns the Bus indicating that its a Repeated Start
-		 * call. 7 bit slave address, send the address for a read
-		 * operation and set the state to indicate the address has been
-		 * sent
-		 */
-		XIic_Send7BitAddress(BaseAddress, Address,
-					XIIC_READ_OPERATION);
-	}
-	/* Try to receive the data from the IIC bus */
-
-	RemainingByteCount = RecvData(BaseAddress, BufferPtr,
-				      ByteCount, Option);
-
-	CntlReg = XIic_ReadReg(BaseAddress,  XIIC_CR_REG_OFFSET);
-	if ((CntlReg & XIIC_CR_REPEATED_START_MASK) == 0) {
-		/* The receive is complete, disable the IIC device if the Option
-		 * is to release the Bus after Reception of data and return the
-		 * number of bytes that was received
-		 */
-		XIic_WriteReg(BaseAddress,  XIIC_CR_REG_OFFSET, 0);
-	}
-
-	/* Return the number of bytes that was received */
-
-	return ByteCount - RemainingByteCount;
-}
-
-/******************************************************************************
-*
-* Receive the specified data from the device that has been previously addressed
-* on the IIC bus.  This function assumes that the 7 bit address has been sent
-* and it should wait for the transmit of the address to complete.
-*
-* @param	BaseAddress contains the base address of the IIC device.
-* @param	BufferPtr points to the buffer to hold the data that is
-*		received.
-* @param	ByteCount is the number of bytes to be received.
-* @param	Option indicates whether to hold or free the bus after reception
-*		of data, XIIC_STOP = end with STOP condition,
-*		XIIC_REPEATED_START = don't end with STOP condition.
-*
-* @return	The number of bytes remaining to be received.
-*
-* @note
-*
-* This function does not take advantage of the receive FIFO because it is
-* designed for minimal code space and complexity.  It contains loops that
-* that could cause the function not to return if the hardware is not working.
-*
-* This function assumes that the calling function will disable the IIC device
-* after this function returns.
-*
-******************************************************************************/
-static unsigned RecvData(u32 BaseAddress, u8 *BufferPtr,
-			 unsigned ByteCount, u8 Option)
-{
-	u32 CntlReg;
-	u32 IntrStatusMask;
-	u32 IntrStatus;
-
-	/* Attempt to receive the specified number of bytes on the IIC bus */
-
-	while (ByteCount > 0) {
-		/* Setup the mask to use for checking errors because when
-		 * receiving one byte OR the last byte of a multibyte message an
-		 * error naturally occurs when the no ack is done to tell the
-		 * slave the last byte
-		 */
-		if (ByteCount == 1) {
-			IntrStatusMask =
-				XIIC_INTR_ARB_LOST_MASK | XIIC_INTR_BNB_MASK;
-		} else {
-			IntrStatusMask =
-				XIIC_INTR_ARB_LOST_MASK |
-				XIIC_INTR_TX_ERROR_MASK | XIIC_INTR_BNB_MASK;
-		}
-
-		/* Wait for the previous transmit and the 1st receive to
-		 * complete by checking the interrupt status register of the
-		 * IPIF
-		 */
-		while (1) {
-			IntrStatus = XIic_ReadIisr(BaseAddress);
-			if (IntrStatus & XIIC_INTR_RX_FULL_MASK) {
-				break;
-			}
-			/* Check the transmit error after the receive full
-			 * because when sending only one byte transmit error
-			 * will occur because of the no ack to indicate the end
-			 * of the data
-			 */
-			if (IntrStatus & IntrStatusMask) {
-				return ByteCount;
-			}
-		}
-
-		CntlReg = XIic_ReadReg(BaseAddress,  XIIC_CR_REG_OFFSET);
-
-		/* Special conditions exist for the last two bytes so check for
-		 * them. Note that the control register must be setup for these
-		 * conditions before the data byte which was already received is
-		 * read from the receive FIFO (while the bus is throttled
-		 */
-		if (ByteCount == 1) {
-			if (Option == XIIC_STOP) {
-
-				/* If the Option is to release the bus after the
-				 * last data byte, it has already been read and
-				 * no ack has been done, so clear MSMS while
-				 * leaving the device enabled so it can get off
-				 * the IIC bus appropriately with a stop
-				 */
-				XIic_WriteReg(BaseAddress,  XIIC_CR_REG_OFFSET,
-					 XIIC_CR_ENABLE_DEVICE_MASK);
-			}
-		}
-
-		/* Before the last byte is received, set NOACK to tell the slave
-		 * IIC device that it is the end, this must be done before
-		 * reading the byte from the FIFO
-		 */
-		if (ByteCount == 2) {
-			/* Write control reg with NO ACK allowing last byte to
-			 * have the No ack set to indicate to slave last byte
-			 * read
-			 */
-			XIic_WriteReg(BaseAddress,  XIIC_CR_REG_OFFSET,
-				 CntlReg | XIIC_CR_NO_ACK_MASK);
-		}
-
-		/* Read in data from the FIFO and unthrottle the bus such that
-		 * the next byte is read from the IIC bus
-		 */
-		*BufferPtr++ = (u8) XIic_ReadReg(BaseAddress,
-						  XIIC_DRR_REG_OFFSET);
-
-		if ((ByteCount == 1) && (Option == XIIC_REPEATED_START)) {
-
-			/* RSTA bit should be set only when the FIFO is
-			 * completely Empty.
-			 */
-			XIic_WriteReg(BaseAddress,  XIIC_CR_REG_OFFSET,
-				 XIIC_CR_ENABLE_DEVICE_MASK | XIIC_CR_MSMS_MASK
-				 | XIIC_CR_REPEATED_START_MASK);
-
-		}
-
-		/* Clear the latched interrupt status so that it will be updated
-		 * with the new state when it changes, this must be done after
-		 * the receive register is read
-		 */
-		XIic_ClearIisr(BaseAddress, XIIC_INTR_RX_FULL_MASK |
-				XIIC_INTR_TX_ERROR_MASK |
-				XIIC_INTR_ARB_LOST_MASK);
-		ByteCount--;
-	}
-
-	if (Option == XIIC_STOP) {
-
-		/* If the Option is to release the bus after Reception of data,
-		 * wait for the bus to transition to not busy before returning,
-		 * the IIC device cannot be disabled until this occurs. It
-		 * should transition as the MSMS bit of the control register was
-		 * cleared before the last byte was read from the FIFO
-		 */
-		while (1) {
-			if (XIic_ReadIisr(BaseAddress) & XIIC_INTR_BNB_MASK) {
-				break;
-			}
-		}
-	}
-
-	return ByteCount;
-}
-
-/****************************************************************************/
-/**
-* Send data as a master on the IIC bus.  This function sends the data
-* using polled I/O and blocks until the data has been sent. It only supports
-* 7 bit addressing mode of operation.  The user is responsible for ensuring
-* the bus is not busy if multiple masters are present on the bus.
-*
-* @param	BaseAddress contains the base address of the IIC device.
-* @param	Address contains the 7 bit IIC address of the device to send the
-*		specified data to.
-* @param	BufferPtr points to the data to be sent.
-* @param	ByteCount is the number of bytes to be sent.
-* @param	Option indicates whether to hold or free the bus after
-* 		transmitting the data.
-*
-* @return	The number of bytes sent.
-*
-* @note		None.
-*
-******************************************************************************/
-unsigned XIic_Send(u32 BaseAddress, u8 Address,
-		   u8 *BufferPtr, unsigned ByteCount, u8 Option)
-{
-	unsigned RemainingByteCount;
-	u32 ControlReg;
-	volatile u32 StatusReg;
-
-	/* Check to see if already Master on the Bus.
-	 * If Repeated Start bit is not set send Start bit by setting
-	 * MSMS bit else Send the address.
-	 */
-	ControlReg = XIic_ReadReg(BaseAddress,  XIIC_CR_REG_OFFSET);
-	if ((ControlReg & XIIC_CR_REPEATED_START_MASK) == 0) {
-		/*
-		 * Put the address into the FIFO to be sent and indicate
-		 * that the operation to be performed on the bus is a
-		 * write operation
-		 */
-		XIic_Send7BitAddress(BaseAddress, Address,
-					XIIC_WRITE_OPERATION);
-		/* Clear the latched interrupt status so that it will
-		 * be updated with the new state when it changes, this
-		 * must be done after the address is put in the FIFO
-		 */
-		XIic_ClearIisr(BaseAddress, XIIC_INTR_TX_EMPTY_MASK |
-				XIIC_INTR_TX_ERROR_MASK |
-				XIIC_INTR_ARB_LOST_MASK);
-
-		/*
-		 * MSMS must be set after putting data into transmit FIFO,
-		 * indicate the direction is transmit, this device is master
-		 * and enable the IIC device
-		 */
-		XIic_WriteReg(BaseAddress,  XIIC_CR_REG_OFFSET,
-			 XIIC_CR_MSMS_MASK | XIIC_CR_DIR_IS_TX_MASK |
-			 XIIC_CR_ENABLE_DEVICE_MASK);
-
-		/*
-		 * Clear the latched interrupt
-		 * status for the bus not busy bit which must be done while
-		 * the bus is busy
-		 */
-		StatusReg = XIic_ReadReg(BaseAddress,  XIIC_SR_REG_OFFSET);
-		while ((StatusReg & XIIC_SR_BUS_BUSY_MASK) == 0) {
-			StatusReg = XIic_ReadReg(BaseAddress,
-						  XIIC_SR_REG_OFFSET);
-		}
-
-		XIic_ClearIisr(BaseAddress, XIIC_INTR_BNB_MASK);
-	}
-	else {
-		/*
-		 * Already owns the Bus indicating that its a Repeated Start
-		 * call. 7 bit slave address, send the address for a write
-		 * operation and set the state to indicate the address has
-		 * been sent.
-		 */
-		XIic_Send7BitAddress(BaseAddress, Address,
-					XIIC_WRITE_OPERATION);
-	}
-
-	/* Send the specified data to the device on the IIC bus specified by the
-	 * the address
-	 */
-	RemainingByteCount = SendData(BaseAddress, BufferPtr,
-					ByteCount, Option);
-
-	ControlReg = XIic_ReadReg(BaseAddress,  XIIC_CR_REG_OFFSET);
-	if ((ControlReg & XIIC_CR_REPEATED_START_MASK) == 0) {
-		/*
-		 * The Transmission is completed, disable the IIC device if
-		 * the Option is to release the Bus after transmission of data
-		 * and return the number of bytes that was received. Only wait
-		 * if master, if addressed as slave just reset to release
-		 * the bus.
-		 */
-		if ((ControlReg & XIIC_CR_MSMS_MASK) != 0) {
-			XIic_WriteReg(BaseAddress,  XIIC_CR_REG_OFFSET,
-				 (ControlReg & ~XIIC_CR_MSMS_MASK));
-			StatusReg = XIic_ReadReg(BaseAddress,
-					XIIC_SR_REG_OFFSET);
-			while ((StatusReg & XIIC_SR_BUS_BUSY_MASK) != 0) {
-				StatusReg = XIic_ReadReg(BaseAddress,
-						XIIC_SR_REG_OFFSET);
-			}
-		}
-
-		XIic_WriteReg(BaseAddress,  XIIC_CR_REG_OFFSET, 0);
-	}
-
-	return ByteCount - RemainingByteCount;
-}
-
-/******************************************************************************
-*
-* Send the specified buffer to the device that has been previously addressed
-* on the IIC bus.  This function assumes that the 7 bit address has been sent
-* and it should wait for the transmit of the address to complete.
-*
-* @param	BaseAddress contains the base address of the IIC device.
-* @param	BufferPtr points to the data to be sent.
-* @param	ByteCount is the number of bytes to be sent.
-* @param	Option indicates whether to hold or free the bus after
-*		transmitting the data.
-*
-* @return	The number of bytes remaining to be sent.
-*
-* @note
-*
-* This function does not take advantage of the transmit FIFO because it is
-* designed for minimal code space and complexity.  It contains loops that
-* that could cause the function not to return if the hardware is not working.
-*
-******************************************************************************/
-static unsigned SendData(u32 BaseAddress, u8 *BufferPtr,
-			 unsigned ByteCount, u8 Option)
-{
-	u32 IntrStatus;
-
-	/*
-	 * Send the specified number of bytes in the specified buffer by polling
-	 * the device registers and blocking until complete
-	 */
-	while (ByteCount > 0) {
-		/*
-		 * Wait for the transmit to be empty before sending any more
-		 * data by polling the interrupt status register
-		 */
-		while (1) {
-			IntrStatus = XIic_ReadIisr(BaseAddress);
-
-			if (IntrStatus & (XIIC_INTR_TX_ERROR_MASK |
-					  XIIC_INTR_ARB_LOST_MASK |
-					  XIIC_INTR_BNB_MASK)) {
-				return ByteCount;
-			}
-
-			if (IntrStatus & XIIC_INTR_TX_EMPTY_MASK) {
-				break;
-			}
-		}
-		/* If there is more than one byte to send then put the
-		 * next byte to send into the transmit FIFO
-		 */
-		if (ByteCount > 1) {
-			XIic_WriteReg(BaseAddress,  XIIC_DTR_REG_OFFSET,
-				 *BufferPtr++);
-		}
-		else {
-			if (Option == XIIC_STOP) {
-				/*
-				 * If the Option is to release the bus after
-				 * the last data byte, Set the stop Option
-				 * before sending the last byte of data so
-				 * that the stop Option will be generated
-				 * immediately following the data. This is
-				 * done by clearing the MSMS bit in the
-				 * control register.
-				 */
-				XIic_WriteReg(BaseAddress,  XIIC_CR_REG_OFFSET,
-					 XIIC_CR_ENABLE_DEVICE_MASK |
-					 XIIC_CR_DIR_IS_TX_MASK);
-			}
-
-			/*
-			 * Put the last byte to send in the transmit FIFO
-			 */
-			XIic_WriteReg(BaseAddress,  XIIC_DTR_REG_OFFSET,
-				 *BufferPtr++);
-
-			if (Option == XIIC_REPEATED_START) {
-				XIic_ClearIisr(BaseAddress,
-						XIIC_INTR_TX_EMPTY_MASK);
-				/*
-				 * Wait for the transmit to be empty before
-				 * setting RSTA bit.
-				 */
-				while (1) {
-					IntrStatus =
-						XIic_ReadIisr(BaseAddress);
-					if (IntrStatus &
-						XIIC_INTR_TX_EMPTY_MASK) {
-						/*
-						 * RSTA bit should be set only
-						 * when the FIFO is completely
-						 * Empty.
-						 */
-						XIic_WriteReg(BaseAddress,
-							 XIIC_CR_REG_OFFSET,
-						   XIIC_CR_REPEATED_START_MASK |
-						   XIIC_CR_ENABLE_DEVICE_MASK |
-						   XIIC_CR_DIR_IS_TX_MASK |
-						   XIIC_CR_MSMS_MASK);
-						break;
-					}
-				}
-			}
-		}
-
-		/*
-		 * Clear the latched interrupt status register and this must be
-		 * done after the transmit FIFO has been written to or it won't
-		 * clear
-		 */
-		XIic_ClearIisr(BaseAddress, XIIC_INTR_TX_EMPTY_MASK);
-
-		/*
-		 * Update the byte count to reflect the byte sent and clear
-		 * the latched interrupt status so it will be updated for the
-		 * new state
-		 */
-		ByteCount--;
-	}
-
-	if (Option == XIIC_STOP) {
-		/*
-		 * If the Option is to release the bus after transmission of
-		 * data, Wait for the bus to transition to not busy before
-		 * returning, the IIC device cannot be disabled until this
-		 * occurs. Note that this is different from a receive operation
-		 * because the stop Option causes the bus to go not busy.
-		 */
-		while (1) {
-			if (XIic_ReadIisr(BaseAddress) &
-				XIIC_INTR_BNB_MASK) {
-				break;
-			}
-		}
-	}
-
-	return ByteCount;
-}
-
-/*****************************************************************************/
-/**
-* Receive data as a master on the IIC bus. This function receives the data
-* using polled I/O and blocks until the data has been received. It only
-* supports 7 bit addressing. The user is responsible for ensuring the bus is
-* not busy if multiple masters are present on the bus.
-*
-* @param	BaseAddress contains the base address of the IIC Device.
-* @param	Address contains the 7 bit IIC Device address of the device to
-*		send the specified data to.
-* @param	BufferPtr points to the data to be sent.
-* @param	ByteCount is the number of bytes to be sent. This value can't be
-*		greater than 255 and needs to be greater than 0.
-*
-* @return	The number of bytes received.
-*
-* @note		Upon entry to this function, the IIC interface needs to be
-*		already enabled in the CR register.
-*
-******************************************************************************/
-unsigned XIic_DynRecv(u32 BaseAddress, u8 Address, u8 *BufferPtr, u8 ByteCount)
-{
-	unsigned RemainingByteCount;
-	u32 StatusRegister;
-
-	/*
-	 * Clear the latched interrupt status so that it will be updated with
-	 * the new state when it changes.
-	 */
-	XIic_ClearIisr(BaseAddress, XIIC_INTR_TX_EMPTY_MASK |
-			XIIC_INTR_TX_ERROR_MASK | XIIC_INTR_ARB_LOST_MASK);
-
-	/*
-	 * Send the 7 bit slave address for a read operation and set the state
-	 * to indicate the address has been sent. Upon writing the address, a
-	 * start condition is initiated. MSMS is automatically set to master
-	 * when the address is written to the Fifo. If MSMS was already set,
-	 * then a re-start is sent prior to the address.
-	 */
-	XIic_DynSend7BitAddress(BaseAddress, Address, XIIC_READ_OPERATION);
-
-	/*
-	 * Wait for the bus to go busy.
-	 */
-	StatusRegister = XIic_ReadReg(BaseAddress,  XIIC_SR_REG_OFFSET);
-
-	while (( StatusRegister & XIIC_SR_BUS_BUSY_MASK)
-			!= XIIC_SR_BUS_BUSY_MASK) {
-		StatusRegister = XIic_ReadReg(BaseAddress,
-				XIIC_SR_REG_OFFSET);
-	}
-
-	/*
-	 * Clear the latched interrupt status for the bus not busy bit which
-	 * must be done while the bus is busy.
-	 */
-	XIic_ClearIisr(BaseAddress, XIIC_INTR_BNB_MASK);
-
-	/*
-	 * Write to the Tx Fifo the dynamic stop control bit with the number of
-	 * bytes that are to be read over the IIC interface from the presently
-	 * addressed device.
-	 */
-	XIic_DynSendStop(BaseAddress, ByteCount);
-
-	/*
-	 * Receive the data from the IIC bus.
-	 */
-	RemainingByteCount = DynRecvData(BaseAddress, BufferPtr, ByteCount);
-
-	/*
-	 * The receive is complete. Return the number of bytes that were
-	 * received.
-	 */
-	return ByteCount - RemainingByteCount;
-}
-
-/*****************************************************************************/
-/**
-* Receive the specified data from the device that has been previously addressed
-* on the IIC bus. This function assumes the following:
-* - The Rx Fifo occupancy depth has been set to its max.
-* - Upon entry, the Rx Fifo is empty.
-* - The 7 bit address has been sent.
-* - The dynamic stop and number of bytes to receive has been written to Tx
-*   Fifo.
-*
-* @param	BaseAddress contains the base address of the IIC Device.
-* @param	BufferPtr points to the buffer to hold the data that is
-*		received.
-* @param	ByteCount is the number of bytes to be received. The range of
-*		this value is greater than 0 and not higher than 255.
-*
-* @return	The number of bytes remaining to be received.
-*
-* @note		This function contains loops that could cause the function not
-*		to return if the hardware is not working.
-*
-******************************************************************************/
-static unsigned DynRecvData(u32 BaseAddress, u8 *BufferPtr, u8 ByteCount)
-{
- 	u32 StatusReg;
- 	u32 IntrStatus;
- 	u32 IntrStatusMask;
-
- 	while (ByteCount > 0) {
-
- 		/*
- 		 * Setup the mask to use for checking errors because when
- 		 * receiving one byte OR the last byte of a multibyte message
- 		 * an error naturally occurs when the no ack is done to tell
- 		 * the slave the last byte.
- 		 */
- 		if (ByteCount == 1) {
- 			IntrStatusMask =
- 				XIIC_INTR_ARB_LOST_MASK | XIIC_INTR_BNB_MASK;
- 		} else {
- 			IntrStatusMask =
- 				XIIC_INTR_ARB_LOST_MASK |
- 				XIIC_INTR_TX_ERROR_MASK | XIIC_INTR_BNB_MASK;
- 		}
-
- 		/*
- 		 * Wait for a byte to show up in the Rx Fifo.
- 		 */
-		while (1) {
-			IntrStatus = XIic_ReadIisr(BaseAddress);
-			StatusReg = XIic_ReadReg(BaseAddress,
-						  XIIC_SR_REG_OFFSET);
-
-			if ((StatusReg & XIIC_SR_RX_FIFO_EMPTY_MASK) !=
-				XIIC_SR_RX_FIFO_EMPTY_MASK) {
-				break;
-			}
-			/*
-			 * Check the transmit error after the receive full
-			 * because when sending only one byte transmit error
-			 * will occur because of the no ack to indicate the end
-		 	 * of the data.
-			 */
-			if (IntrStatus & IntrStatusMask) {
-				return ByteCount;
-			}
-		}
-
-		/*
-		 * Read in byte from the Rx Fifo. If the Fifo reached the
-		 * programmed occupancy depth as programmed in the Rx occupancy
-		 * reg, this read access will un throttle the bus such that
-		 * the next byte is read from the IIC bus.
-		 */
-		*BufferPtr++ = XIic_ReadReg(BaseAddress,  XIIC_DRR_REG_OFFSET);
-		ByteCount--;
-	}
-
-	return ByteCount;
-}
-
-/*****************************************************************************/
-/**
-* Send data as a master on the IIC bus. This function sends the data using
-* polled I/O and blocks until the data has been sent. It only supports 7 bit
-* addressing. The user is responsible for ensuring the bus is not busy if
-* multiple masters are present on the bus.
-*
-* @param	BaseAddress contains the base address of the IIC Device.
-* @param	Address contains the 7 bit IIC address of the device to send the
-*		specified data to.
-* @param	BufferPtr points to the data to be sent.
-* @param	ByteCount is the number of bytes to be sent.
-* @param	Option: XIIC_STOP = end with STOP condition,
-*		XIIC_REPEATED_START = don't end with STOP condition.
-*
-* @return	The number of bytes sent.
-*
-* @note		None.
-*
-******************************************************************************/
-unsigned XIic_DynSend(u32 BaseAddress, u16 Address, u8 *BufferPtr,
-			u8 ByteCount, u8 Option)
-{
-	unsigned RemainingByteCount;
-	u32 StatusRegister;
-
-	/*
-	 * Clear the latched interrupt status so that it will be updated with
-	 * the new state when it changes, this must be done after the address
-	 * is put in the FIFO
-	 */
-	XIic_ClearIisr(BaseAddress, XIIC_INTR_TX_EMPTY_MASK |
-			XIIC_INTR_TX_ERROR_MASK | XIIC_INTR_ARB_LOST_MASK);
-
-	/*
-	 * Put the address into the Fifo to be sent and indicate that the
-	 * operation to be performed on the bus is a write operation. Upon
-	 * writing the address, a start condition is initiated. MSMS is
-	 * automatically set to master when the address is written to the Fifo.
-	 * If MSMS was already set, then a re-start is sent prior to the
-	 * address.
-	 */
-	if(!(Address & XIIC_TX_DYN_STOP_MASK)) {
-
-		XIic_DynSend7BitAddress(BaseAddress, Address,
-				XIIC_WRITE_OPERATION);
-	} else {
-		XIic_DynSendStartStopAddress(BaseAddress, Address,
-					XIIC_WRITE_OPERATION);
-	}
-
-	/*
-	 * Wait for the bus to go busy.
-	 */
-	StatusRegister = XIic_ReadReg(BaseAddress,  XIIC_SR_REG_OFFSET);
-
-	while (( StatusRegister & XIIC_SR_BUS_BUSY_MASK) !=
-			XIIC_SR_BUS_BUSY_MASK) {
-		StatusRegister = XIic_ReadReg(BaseAddress,
-				XIIC_SR_REG_OFFSET);
-	}
-
-	/*
-	 * Clear the latched interrupt status for the bus not busy bit which
-	 * must be done while the bus is busy.
-	 */
-	XIic_ClearIisr(BaseAddress, XIIC_INTR_BNB_MASK);
-
-	/*
-	 * Send the specified data to the device on the IIC bus specified by the
-	 * the address.
-	 */
-	RemainingByteCount = DynSendData(BaseAddress, BufferPtr, ByteCount,
-					 Option);
-
-	/*
-	 * The send is complete return the number of bytes that was sent.
-	 */
-	return ByteCount - RemainingByteCount;
-}
-
-/******************************************************************************
-*
-* Send the specified buffer to the device that has been previously addressed
-* on the IIC bus. This function assumes that the 7 bit address has been sent.
-*
-* @param	BaseAddress contains the base address of the IIC Device.
-* @param	BufferPtr points to the data to be sent.
-* @param	ByteCount is the number of bytes to be sent.
-* @param	Option: XIIC_STOP = end with STOP condition, XIIC_REPEATED_START
-*		= don't end with STOP condition.
-*
-* @return	The number of bytes remaining to be sent.
-*
-* @note		This function does not take advantage of the transmit Fifo
-*		because it is designed for minimal code space and complexity.
-*
-******************************************************************************/
-static unsigned DynSendData(u32 BaseAddress, u8 *BufferPtr,
-			    u8 ByteCount, u8 Option)
-{
-	u32 IntrStatus;
-
-	while (ByteCount > 0) {
-		/*
-		 * Wait for the transmit to be empty before sending any more
-		 * data by polling the interrupt status register.
-		 */
-		while (1) {
-			IntrStatus = XIic_ReadIisr(BaseAddress);
-			if (IntrStatus & (XIIC_INTR_TX_ERROR_MASK |
-					  XIIC_INTR_ARB_LOST_MASK |
-					  XIIC_INTR_BNB_MASK)) {
-				/*
-				 * Error condition (NACK or ARB Lost or BNB
-				 * Error Has occurred. Clear the Control
-				 * register to send a STOP condition on the Bus
-				 * and return the number of bytes still to
-				 * transmit.
-				 */
-				XIic_WriteReg(BaseAddress,  XIIC_CR_REG_OFFSET,
-						0x03);
-				XIic_WriteReg(BaseAddress,  XIIC_CR_REG_OFFSET,
-						0x01);
-
-				return ByteCount;
-			}
-
-			/*
-			 * Check for the transmit Fifo to become Empty.
-			 */
-			if (IntrStatus & XIIC_INTR_TX_EMPTY_MASK) {
-				break;
-			}
-		}
-
-		/*
-		 * Send data to Tx Fifo. If a stop condition is specified and
-		 * the last byte is being sent, then set the dynamic stop bit.
-		 */
-		if ((ByteCount == 1) && (Option == XIIC_STOP)) {
-			/*
-			 * The MSMS will be cleared automatically upon setting
-			 *  dynamic stop.
-			 */
-			XIic_WriteReg(BaseAddress,  XIIC_DTR_REG_OFFSET,
-					XIIC_TX_DYN_STOP_MASK | *BufferPtr++);
-		} else {
-			XIic_WriteReg(BaseAddress,  XIIC_DTR_REG_OFFSET,
-					*BufferPtr++);
-		}
-
-		/*
-		 * Update the byte count to reflect the byte sent.
-		 */
-		ByteCount--;
-	}
-
-	if (Option == XIIC_STOP) {
-		/*
-		 * If the Option is to release the bus after transmission of
-		 * data, Wait for the bus to transition to not busy before
-		 * returning, the IIC device cannot be disabled until this
-		 * occurs.
-		 */
-		while (1) {
-			if (XIic_ReadIisr(BaseAddress) & XIIC_INTR_BNB_MASK) {
-				break;
-			}
-		}
-	}
-
-	return ByteCount;
-}
-
-/******************************************************************************
-*
-* Initialize the IIC core for Dynamic Functionality.
-*
-* @param	BaseAddress contains the base address of the IIC Device.
-*
-* @return	XST_SUCCESS if Successful else XST_FAILURE.
-*
-* @note		None.
-*
-******************************************************************************/
-int XIic_DynInit(u32 BaseAddress)
-{
-	u32 Status;
-
-	/*
-	 * Reset IIC Core.
-	 */
-	XIic_WriteReg(BaseAddress, XIIC_RESETR_OFFSET, XIIC_RESET_MASK);
-
-	/*
-	 * Set receive Fifo depth to maximum (zero based).
-	 */
-	XIic_WriteReg(BaseAddress,  XIIC_RFD_REG_OFFSET,
-			IIC_RX_FIFO_DEPTH - 1);
-
-	/*
-	 * Reset Tx Fifo.
-	 */
-	XIic_WriteReg(BaseAddress,  XIIC_CR_REG_OFFSET,
-			XIIC_CR_TX_FIFO_RESET_MASK);
-
-	/*
-	 * Enable IIC Device, remove Tx Fifo reset & disable general call.
-	 */
-	XIic_WriteReg(BaseAddress, XIIC_CR_REG_OFFSET,
-			XIIC_CR_ENABLE_DEVICE_MASK);
-
-	/*
-	 * Read status register and verify IIC Device is in initial state. Only
-	 * the Tx Fifo and Rx Fifo empty bits should be set.
-	 */
-	Status = XIic_ReadReg(BaseAddress,  XIIC_SR_REG_OFFSET);
-	if(Status == (XIIC_SR_RX_FIFO_EMPTY_MASK |
-		XIIC_SR_TX_FIFO_EMPTY_MASK)) {
-		return XST_SUCCESS;
-	}
-
-	return XST_FAILURE;
-}
diff --git a/drivers/i2c/algos/xilinx_iic/xiic_l.h b/drivers/i2c/algos/xilinx_iic/xiic_l.h
deleted file mode 100644
index 6323239..0000000
--- a/drivers/i2c/algos/xilinx_iic/xiic_l.h
+++ /dev/null
@@ -1,598 +0,0 @@
-/* $Id: xiic_l.h,v 1.1.2.1 2010/04/12 12:13:14 svemula Exp $ */
-/******************************************************************************
-*
-* (c) Copyright 2002-2009 Xilinx, Inc. All rights reserved.
-*
-* This file contains confidential and proprietary information of Xilinx, Inc.
-* and is protected under U.S. and international copyright and other
-* intellectual property laws.
-*
-* DISCLAIMER
-* This disclaimer is not a license and does not grant any rights to the
-* materials distributed herewith. Except as otherwise provided in a valid
-* license issued to you by Xilinx, and to the maximum extent permitted by
-* applicable law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND WITH ALL
-* FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES AND CONDITIONS, EXPRESS,
-* IMPLIED, OR STATUTORY, INCLUDING BUT NOT LIMITED TO WARRANTIES OF
-* MERCHANTABILITY, NON-INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE;
-* and (2) Xilinx shall not be liable (whether in contract or tort, including
-* negligence, or under any other theory of liability) for any loss or damage
-* of any kind or nature related to, arising under or in connection with these
-* materials, including for any direct, or any indirect, special, incidental,
-* or consequential loss or damage (including loss of data, profits, goodwill,
-* or any type of loss or damage suffered as a result of any action brought by
-* a third party) even if such damage or loss was reasonably foreseeable or
-* Xilinx had been advised of the possibility of the same.
-*
-* CRITICAL APPLICATIONS
-* Xilinx products are not designed or intended to be fail-safe, or for use in
-* any application requiring fail-safe performance, such as life-support or
-* safety devices or systems, Class III medical devices, nuclear facilities,
-* applications related to the deployment of airbags, or any other applications
-* that could lead to death, personal injury, or severe property or
-* environmental damage (individually and collectively, "Critical
-* Applications"). Customer assumes the sole risk and liability of any use of
-* Xilinx products in Critical Applications, subject only to applicable laws
-* and regulations governing limitations on product liability.
-*
-* THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS PART OF THIS FILE
-* AT ALL TIMES.
-*
-******************************************************************************/
-/****************************************************************************/
-/**
-*
-* @file xiic_l.h
-*
-* This header file contains identifiers and driver functions (or
-* macros) that can be used to access the device in normal and dynamic
-* controller mode.  High-level driver functions are defined in xiic.h.
-*
-* <pre>
-* MODIFICATION HISTORY:
-*
-* Ver   Who  Date     Changes
-* ----- ---- -------- -----------------------------------------------
-* 1.00b jhl  05/07/02 First release
-* 1.01c ecm  12/05/02 new rev
-* 1.01d jhl  10/08/03 Added general purpose output feature
-* 1.02a mta  03/09/06 Implemented Repeated Start in the Low Level Driver.
-* 1.03a mta  04/04/06 Implemented Dynamic IIC core routines.
-* 1.03a rpm  09/08/06 Added include of xstatus.h for completeness
-* 1.13a wgr  03/22/07 Converted to new coding style.
-* 1.16a ktn  07/18/09 Updated the notes in XIIC_RESET macro to clearly indicate
-*                     that only the Interrupt Registers are reset.
-* 1.16a ktn  10/16/09 Updated the notes in the XIIC_RESET macro to mention
-*                     that the complete IIC core is Reset on giving a software
-*                     reset to the IIC core. Some previous versions of the
-*                     core only reset the Interrupt Logic/Registers, please
-*                     refer to the HW specification for futher details.
-* 2.00a sdm  10/22/09 Converted all register accesses to 32 bit access,
-*		      the register offsets are defined to be on 32 bit boundry.
-*		      Removed the macro XIIC_RESET, XIic_Reset API should be
-*		      used in its place.
-*		      Some of the macros have been renamed to be consistent -
-*		      XIIC_GINTR_DISABLE is renamed as XIic_IntrGlobalDisable,
-*		      XIIC_GINTR_ENABLE is renamed as XIic_IntrGlobalEnable,
-*		      XIIC_IS_GINTR_ENABLED is renamed as
-*		      XIic_IsIntrGlobalEnabled,
-*		      XIIC_WRITE_IISR is renamed as XIic_WriteIisr,
-*		      XIIC_READ_IISR is renamed as XIic_ReadIisr,
-*		      XIIC_WRITE_IIER is renamed as XIic_WriteIier
-*		      The _m prefix in the name of the macros has been removed -
-*		      XIic_mClearIisr is now XIic_ClearIisr,
-*		      XIic_mSend7BitAddress is now XIic_Send7BitAddress,
-*		      XIic_mDynSend7BitAddress is now XIic_DynSend7BitAddress,
-*		      XIic_mDynSendStartStopAddress is now
-*		      XIic_DynSendStartStopAddress,
-*		      XIic_mDynSendStop is now XIic_DynSendStop.
-*
-*
-* </pre>
-*
-*****************************************************************************/
-#ifndef XIIC_L_H		/* prevent circular inclusions */
-#define XIIC_L_H		/* by using protection macros */
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-/***************************** Include Files ********************************/
-
-#include "xil_types.h"
-#include "xil_assert.h"
-#include "xstatus.h"
-#include "xil_io.h"
-
-/************************** Constant Definitions ****************************/
-
-/** @name Register Map
- *
- * Register offsets for the XIic device.
- * @{
- */
-#define XIIC_DGIER_OFFSET	0x1C  /**< Global Interrupt Enable Register */
-#define XIIC_IISR_OFFSET	0x20  /**< Interrupt Status Register */
-#define XIIC_IIER_OFFSET	0x28  /**< Interrupt Enable Register */
-#define XIIC_RESETR_OFFSET	0x40  /**< Reset Register */
-#define XIIC_CR_REG_OFFSET	0x100 /**< Control Register */
-#define XIIC_SR_REG_OFFSET	0x104 /**< Status Register */
-#define XIIC_DTR_REG_OFFSET	0x108 /**< Data Tx Register */
-#define XIIC_DRR_REG_OFFSET	0x10C /**< Data Rx Register */
-#define XIIC_ADR_REG_OFFSET	0x110 /**< Address Register */
-#define XIIC_TFO_REG_OFFSET	0x114 /**< Tx FIFO Occupancy */
-#define XIIC_RFO_REG_OFFSET	0x118 /**< Rx FIFO Occupancy */
-#define XIIC_TBA_REG_OFFSET	0x11C /**< 10 Bit Address reg */
-#define XIIC_RFD_REG_OFFSET	0x120 /**< Rx FIFO Depth reg */
-#define XIIC_GPO_REG_OFFSET	0x124 /**< Output Register */
-/* @} */
-
-
-/**
- * @name Device Global Interrupt Enable Register masks (CR) mask(s)
- * @{
- */
-#define XIIC_GINTR_ENABLE_MASK	0x80000000 /**< Global Interrupt Enable Mask */
-/* @} */
-
-/** @name IIC Device Interrupt Status/Enable (INTR) Register Masks
- *
- * <b> Interrupt Status Register (IISR) </b>
- *
- * This register holds the interrupt status flags for the Spi device.
- *
- * <b> Interrupt Enable Register (IIER) </b>
- *
- * This register is used to enable interrupt sources for the IIC device.
- * Writing a '1' to a bit in this register enables the corresponding Interrupt.
- * Writing a '0' to a bit in this register disables the corresponding Interrupt.
- *
- * IISR/IIER registers have the same bit definitions and are only defined once.
- * @{
- */
-#define XIIC_INTR_ARB_LOST_MASK	0x00000001 /**< 1 = Arbitration lost */
-#define XIIC_INTR_TX_ERROR_MASK	0x00000002 /**< 1 = Tx error/msg complete */
-#define XIIC_INTR_TX_EMPTY_MASK	0x00000004 /**< 1 = Tx FIFO/reg empty */
-#define XIIC_INTR_RX_FULL_MASK	0x00000008 /**< 1 = Rx FIFO/reg=OCY level */
-#define XIIC_INTR_BNB_MASK	0x00000010 /**< 1 = Bus not busy */
-#define XIIC_INTR_AAS_MASK	0x00000020 /**< 1 = When addr as slave */
-#define XIIC_INTR_NAAS_MASK	0x00000040 /**< 1 = Not addr as slave */
-#define XIIC_INTR_TX_HALF_MASK	0x00000080 /**< 1 = Tx FIFO half empty */
-
-/**
- * All Tx interrupts commonly used.
- */
-#define XIIC_TX_INTERRUPTS	(XIIC_INTR_TX_ERROR_MASK | \
-				 XIIC_INTR_TX_EMPTY_MASK |  \
-				 XIIC_INTR_TX_HALF_MASK)
-
-/**
- * All interrupts commonly used
- */
-#define XIIC_TX_RX_INTERRUPTS	(XIIC_INTR_RX_FULL_MASK | XIIC_TX_INTERRUPTS)
-
-/* @} */
-
-/**
- * @name Reset Register mask
- * @{
- */
-#define XIIC_RESET_MASK		0x0000000A /**< RESET Mask  */
-/* @} */
-
-
-/**
- * @name Control Register masks (CR) mask(s)
- * @{
- */
-#define XIIC_CR_ENABLE_DEVICE_MASK	0x00000001 /**< Device enable = 1 */
-#define XIIC_CR_TX_FIFO_RESET_MASK	0x00000002 /**< Transmit FIFO reset=1 */
-#define XIIC_CR_MSMS_MASK		0x00000004 /**< Master starts Txing=1 */
-#define XIIC_CR_DIR_IS_TX_MASK		0x00000008 /**< Dir of Tx. Txing=1 */
-#define XIIC_CR_NO_ACK_MASK		0x00000010 /**< Tx Ack. NO ack = 1 */
-#define XIIC_CR_REPEATED_START_MASK	0x00000020 /**< Repeated start = 1 */
-#define XIIC_CR_GENERAL_CALL_MASK	0x00000040 /**< Gen Call enabled = 1 */
-/* @} */
-
-/**
- * @name Status Register masks (SR) mask(s)
- * @{
- */
-#define XIIC_SR_GEN_CALL_MASK		0x00000001 /**< 1 = A Master issued
-						    * a GC */
-#define XIIC_SR_ADDR_AS_SLAVE_MASK	0x00000002 /**< 1 = When addressed as
-						    * slave */
-#define XIIC_SR_BUS_BUSY_MASK		0x00000004 /**< 1 = Bus is busy */
-#define XIIC_SR_MSTR_RDING_SLAVE_MASK	0x00000008 /**< 1 = Dir: Master <--
-						    * slave */
-#define XIIC_SR_TX_FIFO_FULL_MASK	0x00000010 /**< 1 = Tx FIFO full */
-#define XIIC_SR_RX_FIFO_FULL_MASK	0x00000020 /**< 1 = Rx FIFO full */
-#define XIIC_SR_RX_FIFO_EMPTY_MASK	0x00000040 /**< 1 = Rx FIFO empty */
-#define XIIC_SR_TX_FIFO_EMPTY_MASK	0x00000080 /**< 1 = Tx FIFO empty */
-/* @} */
-
-/**
- * @name Data Tx Register (DTR) mask(s)
- * @{
- */
-#define XIIC_TX_DYN_START_MASK		0x00000100 /**< 1 = Set dynamic start */
-#define XIIC_TX_DYN_STOP_MASK		0x00000200 /**< 1 = Set dynamic stop */
-#define IIC_TX_FIFO_DEPTH		16     /**< Tx fifo capacity */
-/* @} */
-
-/**
- * @name Data Rx Register (DRR) mask(s)
- * @{
- */
-#define IIC_RX_FIFO_DEPTH		16	/**< Rx fifo capacity */
-/* @} */
-
-
-#define XIIC_TX_ADDR_SENT		0x00
-#define XIIC_TX_ADDR_MSTR_RECV_MASK	0x02
-
-
-/**
- * The following constants are used to specify whether to do
- * Read or a Write operation on IIC bus.
- */
-#define XIIC_READ_OPERATION	1 /**< Read operation on the IIC bus */
-#define XIIC_WRITE_OPERATION	0 /**< Write operation on the IIC bus */
-
-/**
- * The following constants are used with the transmit FIFO fill function to
- * specify the role which the IIC device is acting as, a master or a slave.
- */
-#define XIIC_MASTER_ROLE	1 /**< Master on the IIC bus */
-#define XIIC_SLAVE_ROLE		0 /**< Slave on the IIC bus */
-
-/**
- * The following constants are used with Transmit Function (XIic_Send) to
- * specify whether to STOP after the current transfer of data or own the bus
- * with a Repeated start.
- */
-#define XIIC_STOP		0x00 /**< Send a stop on the IIC bus after
-					* the current data transfer */
-#define XIIC_REPEATED_START	0x01 /**< Donot Send a stop on the IIC bus after
-					* the current data transfer */
-
-/***************** Macros (Inline Functions) Definitions *********************/
-
-#define XIic_In32 	Xil_In32
-#define XIic_Out32 	Xil_Out32
-
-/****************************************************************************/
-/**
-*
-* Read from the specified IIC device register.
-*
-* @param	BaseAddress is the base address of the device.
-* @param	RegOffset is the offset from the 1st register of the device to
-*		select the specific register.
-*
-* @return	The value read from the register.
-*
-* @note		C-Style signature:
-*		u32 XIic_ReadReg(u32 BaseAddress, u32 RegOffset);
-*
-* 		This macro does not do any checking to ensure that the
-*		register exists if the register may be excluded due to
-*		parameterization, such as the GPO Register.
-*
-******************************************************************************/
-#define XIic_ReadReg(BaseAddress, RegOffset) \
-	XIic_In32((BaseAddress) + (RegOffset))
-
-/***************************************************************************/
-/**
-*
-* Write to the specified IIC device register.
-*
-* @param	BaseAddress is the base address of the device.
-* @param	RegOffset is the offset from the 1st register of the
-*		device to select the specific register.
-* @param	RegisterValue is the value to be written to the register.
-*
-* @return	None.
-*
-* @note		C-Style signature:
-*		void XIic_WriteReg(u32 BaseAddress, u32 RegOffset,
-*					u32 RegisterValue);
-* 		This macro does not do any checking to ensure that the
-*		register exists if the register may be excluded due to
-*		parameterization, such as the GPO Register.
-*
-******************************************************************************/
-#define XIic_WriteReg(BaseAddress, RegOffset, RegisterValue) \
-	XIic_Out32((BaseAddress) + (RegOffset), (RegisterValue))
-
-/******************************************************************************/
-/**
-*
-* This macro disables all interrupts for the device by writing to the Global
-* interrupt enable register.
-*
-* @param	BaseAddress is the base address of the IIC device.
-*
-* @return	None.
-*
-* @note		C-Style signature:
-*		void XIic_IntrGlobalDisable(u32 BaseAddress);
-*
-******************************************************************************/
-#define XIic_IntrGlobalDisable(BaseAddress)				\
-	XIic_WriteReg((BaseAddress), XIIC_DGIER_OFFSET, 0)
-
-/******************************************************************************/
-/**
-*
-* This macro writes to the global interrupt enable register to enable
-* interrupts from the device. This function does not enable individual
-* interrupts as the Interrupt Enable Register must be set appropriately.
-*
-* @param	BaseAddress is the base address of the IIC device.
-*
-* @return	None.
-*
-* @note		C-Style signature:
-*		void XIic_IntrGlobalEnable(u32 BaseAddress);
-*
-******************************************************************************/
-#define XIic_IntrGlobalEnable(BaseAddress)				\
-	XIic_WriteReg((BaseAddress), XIIC_DGIER_OFFSET, 		\
-		XIIC_GINTR_ENABLE_MASK)
-
-/******************************************************************************/
-/**
-*
-* This function determines if interrupts are enabled at the global level by
-* reading the global interrupt register.
-*
-* @param	BaseAddress is the base address of the IIC device.
-*
-* @return
-*		- TRUE if the global interrupt is enabled.
-*		- FALSE if global interrupt is disabled.
-*
-* @note		C-Style signature:
-*		int XIic_IsIntrGlobalEnabled(u32 BaseAddress);
-*
-******************************************************************************/
-#define XIic_IsIntrGlobalEnabled(BaseAddress)			\
-	(XIic_ReadReg((BaseAddress), XIIC_DGIER_OFFSET) ==		\
-		XIIC_GINTR_ENABLE_MASK)
-
-/******************************************************************************/
-/**
-*
-* This function sets the Interrupt status register to the specified value.
-*
-* This register implements a toggle on write functionality. The interrupt is
-* cleared by writing to this register with the bits to be cleared set to a one
-* and all others to zero. Setting a bit which is zero within this register
-* causes an interrupt to be generated.
-*
-* This function writes only the specified value to the register such that
-* some status bits may be set and others cleared.  It is the caller's
-* responsibility to get the value of the register prior to setting the value
-* to prevent an destructive behavior.
-*
-* @param	BaseAddress is the base address of the IIC device.
-* @param	Status is the value to be written to the Interrupt
-*		status register.
-*
-* @return	None.
-*
-* @note		C-Style signature:
-*		void XIic_WriteIisr(u32 BaseAddress, u32 Status);
-*
-******************************************************************************/
-#define XIic_WriteIisr(BaseAddress, Status)	\
-	XIic_WriteReg((BaseAddress), XIIC_IISR_OFFSET, (Status))
-
-/******************************************************************************/
-/**
-*
-* This function gets the contents of the Interrupt Status Register.
-* This register indicates the status of interrupt sources for the device.
-* The status is independent of whether interrupts are enabled such
-* that the status register may also be polled when interrupts are not enabled.
-*
-* @param	BaseAddress is the base address of the IIC device.
-*
-* @return	The value read from the Interrupt Status Register.
-*
-* @note		C-Style signature:
-*		u32 XIic_ReadIisr(u32 BaseAddress);
-*
-******************************************************************************/
-#define XIic_ReadIisr(BaseAddress) 					\
-	XIic_ReadReg((BaseAddress), XIIC_IISR_OFFSET)
-
-/******************************************************************************/
-/**
-*
-* This function sets the contents of the Interrupt Enable Register.
-*
-* This function writes only the specified value to the register such that
-* some interrupt sources may be enabled and others disabled.  It is the
-* caller's responsibility to get the value of the interrupt enable register
-* prior to setting the value to prevent a destructive behavior.
-*
-* @param	BaseAddress is the base address of the IIC device.
-* @param	Enable is the value to be written to the Interrupt Enable
-*		Register. Bit positions of 1 will be enabled. Bit positions of 0
-*		will be disabled.
-*
-* @return 	None
-*
-* @note		C-Style signature:
-*		void XIic_WriteIier(u32 BaseAddress, u32 Enable);
-*
-******************************************************************************/
-#define XIic_WriteIier(BaseAddress, Enable)				\
-	XIic_WriteReg((BaseAddress), XIIC_IIER_OFFSET, (Enable))
-
-/******************************************************************************/
-/**
-*
-*
-* This function gets the Interrupt Enable Register contents.
-*
-* @param	BaseAddress is the base address of the IIC device.
-*
-* @return	The contents read from the Interrupt Enable Register.
-*		Bit positions of 1 indicate that the corresponding interrupt
-*		is enabled. Bit positions of 0 indicate that the corresponding
-*		interrupt is disabled.
-*
-* @note		C-Style signature:
-*		u32 XIic_ReadIier(u32 BaseAddress)
-*
-******************************************************************************/
-#define XIic_ReadIier(BaseAddress)					\
-	XIic_ReadReg((BaseAddress), XIIC_IIER_OFFSET)
-
-/******************************************************************************/
-/**
-*
-* This macro clears the specified interrupt in the Interrupt status
-* register.  It is non-destructive in that the register is read and only the
-* interrupt specified is cleared.  Clearing an interrupt acknowledges it.
-*
-* @param	BaseAddress is the base address of the IIC device.
-* @param	InterruptMask is the bit mask of the interrupts to be cleared.
-*
-* @return	None.
-*
-* @note		C-Style signature:
-*		void XIic_ClearIisr(u32 BaseAddress, u32 InterruptMask);
-*
-******************************************************************************/
-#define XIic_ClearIisr(BaseAddress, InterruptMask)		\
-	XIic_WriteIisr((BaseAddress),			\
-	XIic_ReadIisr(BaseAddress) & (InterruptMask))
-
-/******************************************************************************/
-/**
-*
-* This macro sends the address for a 7 bit address during both read and write
-* operations. It takes care of the details to format the address correctly.
-* This macro is designed to be called internally to the drivers.
-*
-* @param	BaseAddress is the base address of the IIC Device.
-* @param	SlaveAddress is the address of the slave to send to.
-* @param	Operation indicates XIIC_READ_OPERATION or XIIC_WRITE_OPERATION
-*
-* @return	None.
-*
-* @note		C-Style signature:
-*		void XIic_Send7BitAddress(u32 BaseAddress, u8 SlaveAddress,
-*						u8 Operation);
-*
-******************************************************************************/
-#define XIic_Send7BitAddress(BaseAddress, SlaveAddress, Operation)	\
-{									\
-	u8 LocalAddr = (u8)(SlaveAddress << 1);				\
-	LocalAddr = (LocalAddr & 0xFE) | (Operation);			\
-	XIic_WriteReg(BaseAddress, XIIC_DTR_REG_OFFSET, LocalAddr);	\
-}
-
-/******************************************************************************/
-/**
-*
-* This macro sends the address for a 7 bit address during both read and write
-* operations. It takes care of the details to format the address correctly.
-* This macro is designed to be called internally to the drivers for Dynamic
-* controller functionality.
-*
-* @param	BaseAddress is the base address of the IIC Device.
-* @param	SlaveAddress is the address of the slave to send to.
-* @param	Operation indicates XIIC_READ_OPERATION or XIIC_WRITE_OPERATION.
-*
-* @return	None.
-*
-* @note		C-Style signature:
-* 		void XIic_DynSend7BitAddress(u32 BaseAddress,
-*				u8 SlaveAddress, u8 Operation);
-*
-******************************************************************************/
-#define XIic_DynSend7BitAddress(BaseAddress, SlaveAddress, Operation)	\
-{									\
-	u8 LocalAddr = (u8)(SlaveAddress << 1);				\
-	LocalAddr = (LocalAddr & 0xFE) | (Operation);			\
-	XIic_WriteReg(BaseAddress, XIIC_DTR_REG_OFFSET,		\
-			XIIC_TX_DYN_START_MASK | LocalAddr);		\
-}
-
-/******************************************************************************/
-/**
-*
-* This macro sends the address, start and stop for a 7 bit address during both
-* write operations. It takes care of the details to format the address
-* correctly. This macro is designed to be called internally to the drivers.
-*
-* @param	BaseAddress is the base address of the IIC Device.
-* @param	SlaveAddress is the address of the slave to send to.
-* @param	Operation indicates XIIC_WRITE_OPERATION.
-*
-* @return	None.
-*
-* @note		C-Style signature:
-* 		void XIic_DynSendStartStopAddress(u32 BaseAddress,
-*							u8 SlaveAddress,
-*							u8 Operation);
-*
-******************************************************************************/
-#define XIic_DynSendStartStopAddress(BaseAddress, SlaveAddress, Operation) \
-{									 \
-	u8 LocalAddr = (u8)(SlaveAddress << 1);				 \
-	LocalAddr = (LocalAddr & 0xFE) | (Operation);			 \
-	XIic_WriteReg(BaseAddress, XIIC_DTR_REG_OFFSET,		 \
-			XIIC_TX_DYN_START_MASK | XIIC_TX_DYN_STOP_MASK | \
-			LocalAddr);					 \
-}
-
-/******************************************************************************/
-/**
-*
-* This macro sends a stop condition on IIC bus for Dynamic logic.
-*
-* @param	BaseAddress is the base address of the IIC Device.
-* @param	ByteCount is the number of Rx bytes received before the master.
-*		doesn't respond with ACK.
-*
-* @return	None.
-*
-* @note		C-Style signature:
-* 		void XIic_DynSendStop(u32 BaseAddress, u32 ByteCount);
-*
-******************************************************************************/
-#define XIic_DynSendStop(BaseAddress, ByteCount)			\
-{									\
-	XIic_WriteReg(BaseAddress, XIIC_DTR_REG_OFFSET,		\
-			XIIC_TX_DYN_STOP_MASK | ByteCount); 		\
-}
-
-/************************** Function Prototypes *****************************/
-
-unsigned XIic_Recv(u32 BaseAddress, u8 Address,
-		   u8 *BufferPtr, unsigned ByteCount, u8 Option);
-
-unsigned XIic_Send(u32 BaseAddress, u8 Address,
-		   u8 *BufferPtr, unsigned ByteCount, u8 Option);
-
-unsigned XIic_DynRecv(u32 BaseAddress, u8 Address, u8 *BufferPtr, u8 ByteCount);
-
-unsigned XIic_DynSend(u32 BaseAddress, u16 Address, u8 *BufferPtr,
-		      u8 ByteCount, u8 Option);
-
-int XIic_DynInit(u32 BaseAddress);
-
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif /* end of protection macro */
diff --git a/drivers/i2c/algos/xilinx_iic/xiic_master.c b/drivers/i2c/algos/xilinx_iic/xiic_master.c
deleted file mode 100644
index 55b2dd9..0000000
--- a/drivers/i2c/algos/xilinx_iic/xiic_master.c
+++ /dev/null
@@ -1,768 +0,0 @@
-/* $Id: xiic_master.c,v 1.1.2.1 2010/04/12 12:13:14 svemula Exp $ */
-/******************************************************************************
-*
-* (c) Copyright 2002-2009 Xilinx, Inc. All rights reserved.
-*
-* This file contains confidential and proprietary information of Xilinx, Inc.
-* and is protected under U.S. and international copyright and other
-* intellectual property laws.
-*
-* DISCLAIMER
-* This disclaimer is not a license and does not grant any rights to the
-* materials distributed herewith. Except as otherwise provided in a valid
-* license issued to you by Xilinx, and to the maximum extent permitted by
-* applicable law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND WITH ALL
-* FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES AND CONDITIONS, EXPRESS,
-* IMPLIED, OR STATUTORY, INCLUDING BUT NOT LIMITED TO WARRANTIES OF
-* MERCHANTABILITY, NON-INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE;
-* and (2) Xilinx shall not be liable (whether in contract or tort, including
-* negligence, or under any other theory of liability) for any loss or damage
-* of any kind or nature related to, arising under or in connection with these
-* materials, including for any direct, or any indirect, special, incidental,
-* or consequential loss or damage (including loss of data, profits, goodwill,
-* or any type of loss or damage suffered as a result of any action brought by
-* a third party) even if such damage or loss was reasonably foreseeable or
-* Xilinx had been advised of the possibility of the same.
-*
-* CRITICAL APPLICATIONS
-* Xilinx products are not designed or intended to be fail-safe, or for use in
-* any application requiring fail-safe performance, such as life-support or
-* safety devices or systems, Class III medical devices, nuclear facilities,
-* applications related to the deployment of airbags, or any other applications
-* that could lead to death, personal injury, or severe property or
-* environmental damage (individually and collectively, "Critical
-* Applications"). Customer assumes the sole risk and liability of any use of
-* Xilinx products in Critical Applications, subject only to applicable laws
-* and regulations governing limitations on product liability.
-*
-* THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS PART OF THIS FILE
-* AT ALL TIMES.
-*
-******************************************************************************/
-/*****************************************************************************/
-/**
-*
-* @file xiic_master.c
-*
-* Contains master functions for the XIic component. This file is necessary to
-* send or receive as a master on the IIC bus.
-*
-* <pre>
-* MODIFICATION HISTORY:
-*
-* Ver   Who  Date     Changes
-* ----- --- ------- -----------------------------------------------
-* 1.01b jhl 03/27/02 Reparitioned the driver
-* 1.01c ecm 12/05/02 new rev
-* 1.13a wgr 03/22/07 Converted to new coding style.
-* 2.00a ktn 10/22/09 Converted all register accesses to 32 bit access.
-*		     Updated to use the HAL APIs/macros.
-*		     Removed the macro XIic_mEnterCriticalRegion,
-*		     XIic_IntrGlobalDisable should be used in its place.
-*		     Removed the macro XIic_mExitCriticalRegion,
-*		     XIic_IntrGlobalEnable should be used in its place.
-*		     Some of the macros have been renamed to remove _m from
-*		     the name and some of the macros have been renamed to be
-*		     consistent, see the xiic_i.h and xiic_l.h files for further
-*		     information
-* </pre>
-*
-****************************************************************************/
-
-/***************************** Include Files *******************************/
-
-#include "xiic.h"
-#include "xiic_i.h"
-
-/************************** Constant Definitions ***************************/
-
-
-/**************************** Type Definitions *****************************/
-
-
-/***************** Macros (Inline Functions) Definitions *******************/
-
-/*****************************************************************************
-*
-* This macro includes master code such that master operations, sending
-* and receiving data, may be used.  This function hooks the master processing
-* to the driver such that events are handled properly and allows master
-* processing to be optional.  It must be called before any functions which
-* are contained in this file are called, such as after the driver is
-* initialized.
-*
-* @param	None.
-*
-* @return 	None.
-*
-* @note		None.
-*
-******************************************************************************/
-#define XIIC_MASTER_INCLUDE						\
-{									\
-	XIic_RecvMasterFuncPtr = RecvMasterData;			\
-	XIic_SendMasterFuncPtr = SendMasterData;			\
-}
-
-/************************** Function Prototypes ****************************/
-
-static void SendSlaveAddr(XIic *InstancePtr);
-static void RecvMasterData(XIic *InstancePtr);
-static void SendMasterData(XIic *InstancePtr);
-static int IsBusBusy(XIic *InstancePtr);
-
-/************************** Variable Definitions **************************/
-
-/****************************************************************************/
-/**
-* This function sends data as a master on the IIC bus. If the bus is busy, it
-* will indicate so and then enable an interrupt such that the status handler
-* will be called when the bus is no longer busy.  The slave address which has
-* been set with the XIic_SetAddress() function is the address to which the
-* specific data is sent.  Sending data on the bus performs a write operation.
-*
-* @param	InstancePtr points to the Iic instance to be worked on.
-* @param	TxMsgPtr points to the data to be transmitted.
-* @param	ByteCount is the number of message bytes to be sent.
-*
-* @return
-*		- XST_SUCCESS indicates the message transmission has been
-*		initiated.
-*		- XST_IIC_BUS_BUSY indicates the bus was in use and that
-*		the BusNotBusy interrupt is enabled which will update the
-*		EventStatus when the bus is no longer busy.
-*
-* @note		None.
-*
-******************************************************************************/
-int XIic_MasterSend(XIic *InstancePtr, u8 *TxMsgPtr, int ByteCount)
-{
-	u32 CntlReg;
-
-	XIic_IntrGlobalDisable(InstancePtr->BaseAddress);
-
-	/*
-	 * Ensure that the master processing has been included such that events
-	 * will be properly handled.
-	 */
-	XIIC_MASTER_INCLUDE;
-	InstancePtr->IsDynamic = FALSE;
-
-	/*
-	 * If the busy is busy, then exit the critical region and wait for the
-	 * bus to not be busy, the function enables the bus not busy interrupt.
-	 */
-	if (IsBusBusy(InstancePtr)) {
-		XIic_IntrGlobalEnable(InstancePtr->BaseAddress);
-
-		return XST_IIC_BUS_BUSY;
-	}
-
-	/*
-	 * If it is already a master on the bus (repeated start), the direction
-	 * was set to Tx which is throttling bus. The control register needs to
-	 * be set before putting data into the FIFO.
-	 */
-	CntlReg = XIic_ReadReg(InstancePtr->BaseAddress, XIIC_CR_REG_OFFSET);
-	if (CntlReg & XIIC_CR_MSMS_MASK) {
-		CntlReg &= ~XIIC_CR_NO_ACK_MASK;
-		CntlReg |= (XIIC_CR_DIR_IS_TX_MASK |
-				XIIC_CR_REPEATED_START_MASK);
-
-		XIic_WriteReg(InstancePtr->BaseAddress, XIIC_CR_REG_OFFSET,
-				CntlReg);
-		InstancePtr->Stats.RepeatedStarts++;
-	}
-
-	/*
-	 * Save message state.
-	 */
-	InstancePtr->SendByteCount = ByteCount;
-	InstancePtr->SendBufferPtr = TxMsgPtr;
-
-	/*
-	 * Put the address into the FIFO to be sent and indicate that the
-	 * operation to be performed on the bus is a write operation,
-	 * a general call address is handled the same as a 7 bit address even
-	 * if 10 bit address is selected.
-	 * Set the transmit address state to indicate the address has been sent.
-	 */
-	if ((InstancePtr->Options & XII_SEND_10_BIT_OPTION) &&
-		(InstancePtr->AddrOfSlave != 0)) {
-		XIic_Send10BitAddrByte1(InstancePtr->AddrOfSlave,
-					 XIIC_WRITE_OPERATION);
-		XIic_Send10BitAddrByte2(InstancePtr->AddrOfSlave);
-	} else {
-		XIic_Send7BitAddr(InstancePtr->AddrOfSlave,
-				   XIIC_WRITE_OPERATION);
-	}
-	/*
-	 * Set the transmit address state to indicate the address has been sent
-	 * for communication with event driven processing.
-	 */
-	InstancePtr->TxAddrMode = XIIC_TX_ADDR_SENT;
-
-	/*
-	 * Fill remaining available FIFO with message data.
-	 */
-	if (InstancePtr->SendByteCount > 1) {
-		XIic_TransmitFifoFill(InstancePtr, XIIC_MASTER_ROLE);
-	}
-
-	/*
-	 * After filling fifo, if data yet to send > 1, enable Tx  empty
-	 * interrupt.
-	 */
-	if (InstancePtr->SendByteCount > 1) {
-		XIic_ClearEnableIntr(InstancePtr->BaseAddress,
-					XIIC_INTR_TX_HALF_MASK);
-	}
-
-	/*
-	 * Clear any pending Tx empty, Tx Error and then enable them.
-	 */
-	XIic_ClearEnableIntr(InstancePtr->BaseAddress,
-				XIIC_INTR_TX_ERROR_MASK |
-				XIIC_INTR_TX_EMPTY_MASK);
-
-	/*
-	 * When repeated start not used, MSMS must be set after putting data
-	 * into transmit FIFO, start the transmitter.
-	 */
-	CntlReg = XIic_ReadReg(InstancePtr->BaseAddress, XIIC_CR_REG_OFFSET);
-	if ((CntlReg & XIIC_CR_MSMS_MASK) == 0) {
-		CntlReg &= ~XIIC_CR_NO_ACK_MASK;
-		CntlReg |= XIIC_CR_MSMS_MASK | XIIC_CR_DIR_IS_TX_MASK;
-		XIic_WriteReg(InstancePtr->BaseAddress, XIIC_CR_REG_OFFSET,
-			 CntlReg);
-	}
-
-	XIic_IntrGlobalEnable(InstancePtr->BaseAddress);
-
-	return XST_SUCCESS;
-}
-
-/*****************************************************************************/
-/**
-* This function receives data as a master from a slave device on the IIC bus.
-* If the bus is busy, it will indicate so and then enable an interrupt such
-* that the status handler will be called when the bus is no longer busy.  The
-* slave address which has been set with the XIic_SetAddress() function is the
-* address from which data is received. Receiving data on the bus performs a
-* read operation.
-*
-* @param	InstancePtr is a pointer to the Iic instance to be worked on.
-* @param	RxMsgPtr is a pointer to the data to be transmitted
-* @param	ByteCount is the number of message bytes to be sent
-*
-* @return
-*		- XST_SUCCESS indicates the message reception processes has
-*		been initiated.
-*		- XST_IIC_BUS_BUSY indicates the bus was in use and that the
-*		BusNotBusy interrupt is enabled which will update the
-*		EventStatus when the bus is no longer busy.
-*		- XST_IIC_GENERAL_CALL_ADDRESS indicates the slave address
-*		is set to the the general call address. This is not allowed
-*		for Master receive mode.
-*
-* @internal
-*
-* The receive FIFO threshold is a zero based count such that 1 must be
-* subtracted from the desired count to get the correct value. When receiving
-* data it is also necessary to not receive the last byte with the prior bytes
-* because the acknowledge must be setup before the last byte is received.
-*
-******************************************************************************/
-int XIic_MasterRecv(XIic *InstancePtr, u8 *RxMsgPtr, int ByteCount)
-{
-	u32 CntlReg;
-	u8 Temp;
-
-	/*
-	 * If the slave address is zero (general call) the master can't perform
-	 * receive operations, indicate an error.
-	 */
-	if (InstancePtr->AddrOfSlave == 0) {
-		return XST_IIC_GENERAL_CALL_ADDRESS;
-	}
-
-	XIic_IntrGlobalDisable(InstancePtr->BaseAddress);
-
-	/*
-	 * Ensure that the master processing has been included such that events
-	 * will be properly handled.
-	 */
-	XIIC_MASTER_INCLUDE;
-	InstancePtr->IsDynamic = FALSE;
-
-	/*
-	 * If the busy is busy, then exit the critical region and wait for the
-	 * bus to not be busy, the function enables the bus not busy interrupt.
-	 */
-	if (IsBusBusy(InstancePtr)) {
-		XIic_IntrGlobalEnable(InstancePtr->BaseAddress);
-
-		return XST_IIC_BUS_BUSY;
-	}
-
-	/*
-	 * Save message state for event driven processing.
-	 */
-	InstancePtr->RecvByteCount = ByteCount;
-	InstancePtr->RecvBufferPtr = RxMsgPtr;
-
-	/*
-	 * Clear and enable Rx full interrupt if using 7 bit, If 10 bit, wait
-	 * until last address byte sent incase arbitration gets lost while
-	 * sending out address.
-	 */
-	if ((InstancePtr->Options & XII_SEND_10_BIT_OPTION) == 0) {
-		XIic_ClearEnableIntr(InstancePtr->BaseAddress,
-					XIIC_INTR_RX_FULL_MASK);
-	}
-
-	/*
-	 * If already a master on the bus, the direction was set by Rx Interrupt
-	 * routine to Tx which is throttling bus because during Rxing, Tx reg is
-	 * empty = throttle. CR needs setting before putting data or the address
-	 * written will go out as Tx instead of receive. Start Master Rx by
-	 * setting CR Bits MSMS to Master and msg direction.
-	 */
-	CntlReg = XIic_ReadReg(InstancePtr->BaseAddress, XIIC_CR_REG_OFFSET);
-
-	if (CntlReg & XIIC_CR_MSMS_MASK) {
-		CntlReg |= XIIC_CR_REPEATED_START_MASK;
-		XIic_SetControlRegister(InstancePtr, CntlReg, ByteCount);
-
-		InstancePtr->Stats.RepeatedStarts++;
-		XIic_WriteReg(InstancePtr->BaseAddress, XIIC_CR_REG_OFFSET,
-			 CntlReg);
-
-	}
-
-	/*
-	 * Set receive FIFO occupancy depth which must be done prior to writing
-	 * the address in the FIFO because the transmitter will immediatedly
-	 * start when in repeated start mode followed by the receiver such that
-	 * the number of  bytes to receive should be set 1st.
-	 */
-	if (ByteCount == 1) {
-		Temp = 0;
-	} else {
-		if (ByteCount <= IIC_RX_FIFO_DEPTH) {
-			Temp = ByteCount - 2;
-		} else {
-			Temp = IIC_RX_FIFO_DEPTH - 1;
-		}
-	}
-	XIic_WriteReg(InstancePtr->BaseAddress, XIIC_RFD_REG_OFFSET,
-			(u32) Temp);
-
-	if (InstancePtr->Options & XII_SEND_10_BIT_OPTION) {
-		/*
-		 * Send the 1st and 2nd byte of the 10 bit address of a write
-		 * operation, write because it's a 10 bit address.
-		 */
-		XIic_Send10BitAddrByte1(InstancePtr->AddrOfSlave,
-					 XIIC_WRITE_OPERATION);
-		XIic_Send10BitAddrByte2(InstancePtr->AddrOfSlave);
-
-		/*
-		 * Set flag to indicate the next byte of the address needs to be
-		 * send, clear and enable Tx empty interrupt.
-		 */
-		InstancePtr->TxAddrMode = XIIC_TX_ADDR_MSTR_RECV_MASK;
-		XIic_ClearEnableIntr(InstancePtr->BaseAddress,
-					XIIC_INTR_TX_EMPTY_MASK);
-	} else {
-		/*
-		 * 7 bit slave address, send the address for a read operation
-		 * and set the state to indicate the address has been sent.
-		 */
-		XIic_Send7BitAddr(InstancePtr->AddrOfSlave,
-				   XIIC_READ_OPERATION);
-		InstancePtr->TxAddrMode = XIIC_TX_ADDR_SENT;
-	}
-
-	/*
-	 * Tx error is enabled incase the address (7 or 10) has no device to
-	 * answer with Ack. When only one byte of data, must set NO ACK before
-	 * address goes out therefore Tx error must not be enabled as it will
-	 * go off immediately and the Rx full interrupt will be checked.
-	 * If full, then the one byte was received and the Tx error will be
-	 * disabled without sending an error callback msg.
-	 */
-	XIic_ClearEnableIntr(InstancePtr->BaseAddress,
-				XIIC_INTR_TX_ERROR_MASK);
-
-	/*
-	 * When repeated start not used, MSMS gets set after putting data
-	 * in Tx reg. Start Master Rx by setting CR Bits MSMS to Master and
-	 * msg direction.
-	 */
-	CntlReg = XIic_ReadReg(InstancePtr->BaseAddress, XIIC_CR_REG_OFFSET);
-	if ((CntlReg & XIIC_CR_MSMS_MASK) == 0) {
-		CntlReg |= XIIC_CR_MSMS_MASK;
-		XIic_SetControlRegister(InstancePtr, CntlReg, ByteCount);
-		XIic_WriteReg(InstancePtr->BaseAddress, XIIC_CR_REG_OFFSET,
-				CntlReg);
-	}
-
-	XIic_IntrGlobalEnable(InstancePtr->BaseAddress);
-
-	return XST_SUCCESS;
-}
-
-/*****************************************************************************
-*
-* This function checks to see if the IIC bus is busy.  If so, it will enable
-* the bus not busy interrupt such that the driver is notified when the bus
-* is no longer busy.
-*
-* @param	InstancePtr points to the Iic instance to be worked on.
-*
-* @return
-*		- FALSE indicates the IIC bus is not busy.
-*		- TRUE indicates the bus was in use and that the BusNotBusy
-*		interrupt is enabled which will update the EventStatus when
-*		the bus is no longer busy.
-*
-* @note		None.
-*
-******************************************************************************/
-static int IsBusBusy(XIic *InstancePtr)
-{
-	u32 CntlReg;
-	u32 StatusReg;
-
-	CntlReg = XIic_ReadReg(InstancePtr->BaseAddress, XIIC_CR_REG_OFFSET);
-	StatusReg = XIic_ReadReg(InstancePtr->BaseAddress, XIIC_SR_REG_OFFSET);
-
-	/*
-	 * If this device is already master of the bus as when using the
-	 * repeated start and the bus is busy setup to wait for it to not be
-	 * busy.
-	 */
-	if (((CntlReg & XIIC_CR_MSMS_MASK) == 0) &&	/* Not master */
-		(StatusReg & XIIC_SR_BUS_BUSY_MASK)) {	/* Is busy */
-		/*
-		 * The bus is busy, clear pending BNB interrupt incase
-		 * previously set and then enable BusNotBusy interrupt.
-		 */
-		InstancePtr->BNBOnly = TRUE;
-		XIic_ClearEnableIntr(InstancePtr->BaseAddress,
-					XIIC_INTR_BNB_MASK);
-		InstancePtr->Stats.BusBusy++;
-
-		return TRUE;
-	}
-
-	return FALSE;
-}
-
-/******************************************************************************
-*
-* This function sends the proper byte of the address as well as generate the
-* proper address bit fields depending on the address byte required and the
-* direction of the data (write or read).
-*
-* A master receiving has the restriction that the direction must be switched
-* from write to read when the third address byte is transmitted.
-* For the last byte of the 10 bit address, repeated start must be set prior
-* to writing the address. If repeated start options is enabled, the
-* control register is written before the address is written to the Tx reg.
-*
-* @param	InstancePtr is a pointer to the XIic instance to be worked on.
-*
-* @return	None.
-*
-* @note
-*
-* This function does read/modify/write to the device control register. Calling
-* functions must ensure critical sections are used.
-*
-******************************************************************************/
-static void SendSlaveAddr(XIic *InstancePtr)
-{
-	u32 CRreg;
-
-	/*
-	 * Set the control register for Master Receive, repeated start must be
-	 * set before writing the address, MSMS should be already set, don't
-	 * set here so if arbitration is lost or some other reason we don't
-	 * want MSMS set incase of error.
-	 */
-	CRreg = XIic_ReadReg(InstancePtr->BaseAddress, XIIC_CR_REG_OFFSET);
-
-	CRreg |= XIIC_CR_REPEATED_START_MASK;
-	CRreg &= ~XIIC_CR_DIR_IS_TX_MASK;
-
-	XIic_WriteReg(InstancePtr->BaseAddress, XIIC_CR_REG_OFFSET, CRreg);
-
-	/*
-	 * Send the 1st byte of the 10 bit address as a read operation, enable
-	 * the receive interrupt to know when data is received, assuming that
-	 * the receive FIFO threshold has been previously set.
-	 */
-	XIic_Send10BitAddrByte1(InstancePtr->AddrOfSlave, XIIC_READ_OPERATION);
-
-	XIic_ClearEnableIntr(InstancePtr->BaseAddress, XIIC_INTR_RX_FULL_MASK);
-}
-
-/******************************************************************************
-*
-* When the IIC Tx FIFO/register goes empty, this routine is called by the
-* interrupt service routine to fill the transmit FIFO with data to be sent.
-*
-* This function also is called by the Tx  empty interrupt as the data handling
-* is identical when you don't assume the FIFO is empty but use the Tx_FIFO_OCY
-* register to indicate the available free FIFO bytes.
-*
-* @param	InstancePtr is a pointer to the XIic instance to be worked on.
-*
-* @return	None.
-*
-* @note		None.
-*
-******************************************************************************/
-static void SendMasterData(XIic *InstancePtr)
-{
-	u32 CntlReg;
-
-	/*
-	 * The device is a master on the bus.  If there is still more address
-	 * bytes to send when in master receive operation and the slave device
-	 * is 10 bit addressed.
-	 * This requires the lower 7 bits of address to be resent when the mode
-	 * switches to Read instead of write (while sending addresses).
-	 */
-	if (InstancePtr->TxAddrMode & XIIC_TX_ADDR_MSTR_RECV_MASK) {
-		/*
-		 * Send the 1st byte of the slave address in the read operation
-		 * and change the state to indicate this has been done
-		 */
-		SendSlaveAddr(InstancePtr);
-		InstancePtr->TxAddrMode = XIIC_TX_ADDR_SENT;
-	}
-
-	/*
-	 * In between 1st and last byte of message, fill the FIFO with more data
-	 * to send, disable the 1/2 empty interrupt based upon data left to
-	 * send.
-	 */
-	else if (InstancePtr->SendByteCount > 1) {
-		XIic_TransmitFifoFill(InstancePtr, XIIC_MASTER_ROLE);
-
-		if (InstancePtr->SendByteCount < 2) {
-			XIic_DisableIntr(InstancePtr->BaseAddress,
-					  XIIC_INTR_TX_HALF_MASK);
-		}
-	}
-	/*
-	 * If there is only one byte left to send, processing differs between
-	 * repeated start and normal messages.
-	 */
-	else if (InstancePtr->SendByteCount == 1) {
-		/*
-		 * When using repeated start, another interrupt is expected
-		 * after the last byte has been sent, so the message is not
-		 * done yet.
-		 */
-		if (InstancePtr->Options & XII_REPEATED_START_OPTION) {
-			XIic_WriteSendByte(InstancePtr);
-		}
-
-		/*
-		 * When not using repeated start, the stop condition must be
-		 * generated after the last byte is written. The bus is
-		 * throttled waiting for the last byte.
-		 */
-		else {
-			/*
-			 * Set the stop condition before sending the last byte
-			 * of data so that the stop condition will be generated
-			 * immediately following the data another transmit
-			 * interrupt is not expected so the message is done.
-			 */
-			CntlReg = XIic_ReadReg(InstancePtr->BaseAddress,
-					XIIC_CR_REG_OFFSET);
-			CntlReg &= ~XIIC_CR_MSMS_MASK;
-			XIic_WriteReg(InstancePtr->BaseAddress,
-					XIIC_CR_REG_OFFSET,
-					CntlReg);
-
-			XIic_WriteSendByte(InstancePtr);
-
-			/*
-			 * Wait for bus to not be busy before declaring message
-			 * has been sent for the no repeated start operation.
-			 * The callback will be called from the BusNotBusy part
-			 * of the Interrupt handler to ensure that the message
-			 * is completely sent.
-			 * Disable the Tx interrupts and enable the BNB
-			 * interrupt.
-			 */
-
-			InstancePtr->BNBOnly = FALSE;
-			XIic_DisableIntr(InstancePtr->BaseAddress,
-						XIIC_TX_INTERRUPTS);
-			XIic_EnableIntr(InstancePtr->BaseAddress,
-					 XIIC_INTR_BNB_MASK);
-
-		}
-	} else {
-		if (InstancePtr->Options & XII_REPEATED_START_OPTION) {
-
-			/*
-			 * The message being sent has completed. When using
-			 * repeated start with no more bytes to send repeated
-			 * start needs to be set in the control register so
-			 * that the bus will still be held by this master.
-			 */
-			CntlReg = XIic_ReadReg(InstancePtr->BaseAddress,
-					XIIC_CR_REG_OFFSET);
-			CntlReg |= XIIC_CR_REPEATED_START_MASK;
-			XIic_WriteReg(InstancePtr->BaseAddress,
-					XIIC_CR_REG_OFFSET, CntlReg);
-
-			/*
-			 * If the message that was being sent has finished,
-			 * disable all transmit interrupts and call the callback
-			 * that was setup to indicate the message was sent,
-			 * with 0 bytes remaining.
-			 */
-
-			XIic_DisableIntr(InstancePtr->BaseAddress,
-					  XIIC_TX_INTERRUPTS);
-			InstancePtr->SendHandler(InstancePtr->SendCallBackRef,
-						 0);
-		}
-	}
-
-	return;
-}
-
-/*****************************************************************************/
-/**
-*
-* This function is called when the receive register is full. The number
-* of bytes received to cause the interrupt is adjustable using the Receive FIFO
-* Depth register. The number of bytes in the register is read in the Receive
-* FIFO occupancy register. Both these registers are zero based values (0-15)
-* such that a value of zero indicates 1 byte.
-*
-* For a Master Receiver to properly signal the end of a message, the data must
-* be read in up to the message length - 1, where control register bits will be
-* set for bus controls to occur on reading of the last byte.
-*
-* @param	InstancePtr is a pointer to the XIic instance to be worked on.
-*
-* @return	None.
-*
-* @note		None.
-*
-******************************************************************************/
-static void RecvMasterData(XIic *InstancePtr)
-{
-	u8 LoopCnt;
-	int BytesInFifo;
-	int BytesToRead;
-	u32 CntlReg;
-
-	/*
-	 * Device is a master receiving, get the contents of the control
-	 * register and determine the number of bytes in fifo to be read out.
-	 */
-	CntlReg = XIic_ReadReg(InstancePtr->BaseAddress, XIIC_CR_REG_OFFSET);
-	BytesInFifo = XIic_ReadReg(InstancePtr->BaseAddress,
-				XIIC_RFO_REG_OFFSET) + 1;
-
-	/*
-	 * If data in FIFO holds all data to be retrieved - 1, set NOACK and
-	 * disable the Tx error.
-	 */
-	if ((InstancePtr->RecvByteCount - BytesInFifo) == 1) {
-		/*
-		 * Disable Tx error interrupt to prevent interrupt
-		 * as this device will cause it when it set NO ACK next.
-		 */
-		XIic_DisableIntr(InstancePtr->BaseAddress,
-				  XIIC_INTR_TX_ERROR_MASK);
-		XIic_ClearIntr(InstancePtr->BaseAddress,
-				XIIC_INTR_TX_ERROR_MASK);
-
-		/*
-		 * Write control reg with NO ACK allowing last byte to
-		 * have the No ack set to indicate to slave last byte read.
-		 */
-		XIic_WriteReg(InstancePtr->BaseAddress, XIIC_CR_REG_OFFSET,
-			 (CntlReg | XIIC_CR_NO_ACK_MASK));
-
-		/*
-		 * Read one byte to clear a place for the last byte to be read
-		 * which will set the NO ACK.
-		 */
-		XIic_ReadRecvByte(InstancePtr);
-	}
-
-	/*
-	 * If data in FIFO is all the data to be received then get the data
-	 * and also leave the device in a good state for the next transaction.
-	 */
-	else if ((InstancePtr->RecvByteCount - BytesInFifo) == 0) {
-		/*
-		 * If repeated start option is off then the master should stop
-		 * using the bus, otherwise hold the bus, setting repeated start
-		 * stops the slave from transmitting data when the FIFO is read.
-		 */
-		if ((InstancePtr->Options & XII_REPEATED_START_OPTION) == 0) {
-			CntlReg &= ~XIIC_CR_MSMS_MASK;
-		} else {
-			CntlReg |= XIIC_CR_REPEATED_START_MASK;
-		}
-		XIic_WriteReg(InstancePtr->BaseAddress, XIIC_CR_REG_OFFSET,
-			 CntlReg);
-
-		/*
-		 * Read data from the FIFO then set zero based FIFO read depth
-		 * for a byte.
-		 */
-		for (LoopCnt = 0; LoopCnt < BytesInFifo; LoopCnt++) {
-			XIic_ReadRecvByte(InstancePtr);
-		}
-		XIic_WriteReg(InstancePtr->BaseAddress,
-				XIIC_RFD_REG_OFFSET, 0);
-
-		/*
-		 * Disable Rx full interrupt and write the control reg with ACK
-		 * allowing next byte sent to be acknowledged automatically.
-		 */
-		XIic_DisableIntr(InstancePtr->BaseAddress,
-				  XIIC_INTR_RX_FULL_MASK);
-
-		XIic_WriteReg(InstancePtr->BaseAddress, XIIC_CR_REG_OFFSET,
-			 (CntlReg & ~XIIC_CR_NO_ACK_MASK));
-
-		/*
-		 * Send notification of msg Rx complete in RecvHandler callback.
-		 */
-		InstancePtr->RecvHandler(InstancePtr->RecvCallBackRef, 0);
-	} else {
-		/*
-		 * Fifo data not at n-1, read all but the last byte of data
-		 * from the slave, if more than a FIFO full yet to receive
-		 * read a FIFO full.
-		 */
-		BytesToRead = InstancePtr->RecvByteCount - BytesInFifo - 1;
-		if (BytesToRead > IIC_RX_FIFO_DEPTH) {
-			BytesToRead = IIC_RX_FIFO_DEPTH;
-		}
-
-		/*
-		 * Read in data from the FIFO.
-		 */
-		for (LoopCnt = 0; LoopCnt < BytesToRead; LoopCnt++) {
-			XIic_ReadRecvByte(InstancePtr);
-		}
-	}
-}
diff --git a/drivers/i2c/algos/xilinx_iic/xiic_options.c b/drivers/i2c/algos/xilinx_iic/xiic_options.c
deleted file mode 100644
index 0494a4c..0000000
--- a/drivers/i2c/algos/xilinx_iic/xiic_options.c
+++ /dev/null
@@ -1,183 +0,0 @@
-/* $Id: xiic_options.c,v 1.1.2.1 2010/04/12 12:13:14 svemula Exp $ */
-/******************************************************************************
-*
-* (c) Copyright 2002-2009 Xilinx, Inc. All rights reserved.
-*
-* This file contains confidential and proprietary information of Xilinx, Inc.
-* and is protected under U.S. and international copyright and other
-* intellectual property laws.
-*
-* DISCLAIMER
-* This disclaimer is not a license and does not grant any rights to the
-* materials distributed herewith. Except as otherwise provided in a valid
-* license issued to you by Xilinx, and to the maximum extent permitted by
-* applicable law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND WITH ALL
-* FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES AND CONDITIONS, EXPRESS,
-* IMPLIED, OR STATUTORY, INCLUDING BUT NOT LIMITED TO WARRANTIES OF
-* MERCHANTABILITY, NON-INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE;
-* and (2) Xilinx shall not be liable (whether in contract or tort, including
-* negligence, or under any other theory of liability) for any loss or damage
-* of any kind or nature related to, arising under or in connection with these
-* materials, including for any direct, or any indirect, special, incidental,
-* or consequential loss or damage (including loss of data, profits, goodwill,
-* or any type of loss or damage suffered as a result of any action brought by
-* a third party) even if such damage or loss was reasonably foreseeable or
-* Xilinx had been advised of the possibility of the same.
-*
-* CRITICAL APPLICATIONS
-* Xilinx products are not designed or intended to be fail-safe, or for use in
-* any application requiring fail-safe performance, such as life-support or
-* safety devices or systems, Class III medical devices, nuclear facilities,
-* applications related to the deployment of airbags, or any other applications
-* that could lead to death, personal injury, or severe property or
-* environmental damage (individually and collectively, "Critical
-* Applications"). Customer assumes the sole risk and liability of any use of
-* Xilinx products in Critical Applications, subject only to applicable laws
-* and regulations governing limitations on product liability.
-*
-* THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS PART OF THIS FILE
-* AT ALL TIMES.
-*
-******************************************************************************/
-/*****************************************************************************/
-/**
-*
-* @file xiic_options.c
-*
-* Contains options functions for the XIic component. This file is not required
-* unless the functions in this file are called.
-*
-* <pre>
-* MODIFICATION HISTORY:
-*
-* Ver   Who  Date     Changes
-* ----- --- ------- -----------------------------------------------
-* 1.01b jhl 3/26/02 repartioned the driver
-* 1.01c ecm 12/05/02 new rev
-* 1.13a wgr 03/22/07 Converted to new coding style.
-* 2.00a ktn 10/22/09 Converted all register accesses to 32 bit access.
-*		     Updated to use the HAL APIs/macros.
-* </pre>
-*
-****************************************************************************/
-
-/***************************** Include Files *******************************/
-
-#include "xiic.h"
-#include "xiic_i.h"
-
-/************************** Constant Definitions ***************************/
-
-
-/**************************** Type Definitions *****************************/
-
-
-/***************** Macros (Inline Functions) Definitions *******************/
-
-
-/************************** Function Prototypes ****************************/
-
-
-/************************** Variable Definitions **************************/
-
-
-/*****************************************************************************/
-/**
-*
-* This function sets the options for the IIC device driver. The options control
-* how the device behaves relative to the IIC bus. If an option applies to
-* how messages are sent or received on the IIC bus, it must be set prior to
-* calling functions which send or receive data.
-*
-* To set multiple options, the values must be ORed together. To not change
-* existing options, read/modify/write with the current options using
-* XIic_GetOptions().
-*
-* <b>USAGE EXAMPLE:</b>
-*
-* Read/modify/write to enable repeated start:
-* <pre>
-*   u8 Options;
-*   Options = XIic_GetOptions(&Iic);
-*   XIic_SetOptions(&Iic, Options | XII_REPEATED_START_OPTION);
-* </pre>
-*
-* Disabling General Call:
-* <pre>
-*   Options = XIic_GetOptions(&Iic);
-*   XIic_SetOptions(&Iic, Options &= ~XII_GENERAL_CALL_OPTION);
-* </pre>
-*
-* @param	InstancePtr is a pointer to the XIic instance to be worked on.
-* @param	NewOptions are the options to be set.  See xiic.h for a list of
-*		the available options.
-*
-* @return	None.
-*
-* @note
-*
-* Sending or receiving messages with repeated start enabled, and then
-* disabling repeated start, will not take effect until another master
-* transaction is completed. i.e. After using repeated start, the bus will
-* continue to be throttled after repeated start is disabled until a master
-* transaction occurs allowing the IIC to release the bus.
-* <br><br>
-* Options enabled will have a 1 in its appropriate bit position.
-*
-****************************************************************************/
-void XIic_SetOptions(XIic *InstancePtr, u32 NewOptions)
-{
-	u32 CntlReg;
-
-	Xil_AssertVoid(InstancePtr != NULL);
-
-	XIic_IntrGlobalDisable(InstancePtr->BaseAddress);
-
-	/*
-	 * Update the options in the instance and get the contents of the
-	 * control register such that the general call option can be modified.
-	 */
-	InstancePtr->Options = NewOptions;
-	CntlReg = XIic_ReadReg(InstancePtr->BaseAddress, XIIC_CR_REG_OFFSET);
-
-	/*
-	 * The general call option is the only option that maps directly to
-	 * a hardware register feature.
-	 */
-	if (NewOptions & XII_GENERAL_CALL_OPTION) {
-		CntlReg |= XIIC_CR_GENERAL_CALL_MASK;
-	} else {
-		CntlReg &= ~XIIC_CR_GENERAL_CALL_MASK;
-	}
-
-	/*
-	 * Write the new control register value to the register.
-	 */
-	XIic_WriteReg(InstancePtr->BaseAddress, XIIC_CR_REG_OFFSET, CntlReg);
-
-	XIic_IntrGlobalEnable(InstancePtr->BaseAddress);
-}
-
-/*****************************************************************************/
-/**
-*
-* This function gets the current options for the IIC device. Options control
-* the how the device behaves on the IIC bus. See SetOptions for more information
-* on options.
-*
-* @param	InstancePtr is a pointer to the XIic instance to be worked on.
-*
-* @return	The options of the IIC device. See xiic.h for a list of
-*		available options.
-*
-* @note
-*
-* Options enabled will have a 1 in its appropriate bit position.
-*
-****************************************************************************/
-u32 XIic_GetOptions(XIic *InstancePtr)
-{
-	Xil_AssertNonvoid(InstancePtr != NULL);
-
-	return InstancePtr->Options;
-}
diff --git a/drivers/i2c/algos/xilinx_iic/xiic_stats.c b/drivers/i2c/algos/xilinx_iic/xiic_stats.c
deleted file mode 100644
index abacedc..0000000
--- a/drivers/i2c/algos/xilinx_iic/xiic_stats.c
+++ /dev/null
@@ -1,143 +0,0 @@
-/* $Id: xiic_stats.c,v 1.1.2.1 2010/04/12 12:13:14 svemula Exp $ */
-/******************************************************************************
-*
-* (c) Copyright 2002-2009 Xilinx, Inc. All rights reserved.
-*
-* This file contains confidential and proprietary information of Xilinx, Inc.
-* and is protected under U.S. and international copyright and other
-* intellectual property laws.
-*
-* DISCLAIMER
-* This disclaimer is not a license and does not grant any rights to the
-* materials distributed herewith. Except as otherwise provided in a valid
-* license issued to you by Xilinx, and to the maximum extent permitted by
-* applicable law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND WITH ALL
-* FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES AND CONDITIONS, EXPRESS,
-* IMPLIED, OR STATUTORY, INCLUDING BUT NOT LIMITED TO WARRANTIES OF
-* MERCHANTABILITY, NON-INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE;
-* and (2) Xilinx shall not be liable (whether in contract or tort, including
-* negligence, or under any other theory of liability) for any loss or damage
-* of any kind or nature related to, arising under or in connection with these
-* materials, including for any direct, or any indirect, special, incidental,
-* or consequential loss or damage (including loss of data, profits, goodwill,
-* or any type of loss or damage suffered as a result of any action brought by
-* a third party) even if such damage or loss was reasonably foreseeable or
-* Xilinx had been advised of the possibility of the same.
-*
-* CRITICAL APPLICATIONS
-* Xilinx products are not designed or intended to be fail-safe, or for use in
-* any application requiring fail-safe performance, such as life-support or
-* safety devices or systems, Class III medical devices, nuclear facilities,
-* applications related to the deployment of airbags, or any other applications
-* that could lead to death, personal injury, or severe property or
-* environmental damage (individually and collectively, "Critical
-* Applications"). Customer assumes the sole risk and liability of any use of
-* Xilinx products in Critical Applications, subject only to applicable laws
-* and regulations governing limitations on product liability.
-*
-* THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS PART OF THIS FILE
-* AT ALL TIMES.
-*
-******************************************************************************/
-/*****************************************************************************/
-/**
-*
-* @file xiic_stats.c
-*
-* Contains statistics functions for the XIic component.
-*
-* <pre>
-* MODIFICATION HISTORY:
-*
-* Ver   Who  Date     Changes
-* ----- --- ------- -----------------------------------------------
-* 1.01b jhl 3/26/02 repartioned the driver
-* 1.01c ecm 12/05/02 new rev
-* 1.13a wgr 03/22/07 Converted to new coding style.
-* 2.00a ktn 10/22/09 Converted all register accesses to 32 bit access.
-*		     Updated to use the HAL APIs/macros.
-*		     XIic_ClearStats function is updated as the
-*		     macro XIIC_CLEAR_STATS has been removed.
-* </pre>
-*
-****************************************************************************/
-
-/***************************** Include Files *******************************/
-
-#include "xiic.h"
-#include "xiic_i.h"
-
-/************************** Constant Definitions ***************************/
-
-/**************************** Type Definitions *****************************/
-
-/***************** Macros (Inline Functions) Definitions *******************/
-
-/************************** Function Prototypes ****************************/
-
-/************************** Variable Definitions **************************/
-
-/*****************************************************************************/
-/**
-*
-* Gets a copy of the statistics for an IIC device.
-*
-* @param	InstancePtr is a pointer to the XIic instance to be worked on.
-* @param	StatsPtr is a pointer to a XIicStats structure which will get a
-*		copy of current statistics.
-*
-* @return	None.
-*
-* @note		None.
-*
-****************************************************************************/
-void XIic_GetStats(XIic *InstancePtr, XIicStats * StatsPtr)
-{
-	u8 NumBytes;
-	u8 *SrcPtr;
-	u8 *DestPtr;
-
-	Xil_AssertVoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
-	Xil_AssertVoid(InstancePtr != NULL);
-	Xil_AssertVoid(StatsPtr != NULL);
-
-	/*
-	 * Setup pointers to copy the stats structure
-	 */
-	SrcPtr = (u8 *) &InstancePtr->Stats;
-	DestPtr = (u8 *) StatsPtr;
-
-	/*
-	 * Copy the current statistics to the structure passed in
-	 */
-	for (NumBytes = 0; NumBytes < sizeof(XIicStats); NumBytes++) {
-		*DestPtr++ = *SrcPtr++;
-	}
-}
-
-/*****************************************************************************/
-/**
-*
-* Clears the statistics for the IIC device by zeroing all counts.
-*
-* @param	InstancePtr is a pointer to the XIic instance to be worked on.
-*
-* @return	None.
-*
-* @note		None.
-*
-****************************************************************************/
-void XIic_ClearStats(XIic *InstancePtr)
-{
-	u8 NumBytes;
-	u8 *DestPtr;
-
-	Xil_AssertVoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
-	Xil_AssertVoid(InstancePtr != NULL);
-
-	DestPtr = (u8 *)&InstancePtr->Stats;
-	for (NumBytes = 0; NumBytes < sizeof(XIicStats); NumBytes++) {
-		*DestPtr++ = 0;
-	}
-
-}
-- 
1.7.1

