From fae387c876713d01b8dabaab042488820e4c884d Mon Sep 17 00:00:00 2001
From: Michal Simek <monstr@monstr.eu>
Date: Sat, 20 Oct 2012 09:24:32 +0200
Subject: [PATCH] net: xilinx: Remove ancient emac and temac eth drivers

Remove old drivers which none uses.

Signed-off-by: Michal Simek <monstr@monstr.eu>
---
 drivers/net/ethernet/xilinx/xilinx_emac/Makefile   |   14 -
 drivers/net/ethernet/xilinx/xilinx_emac/xemac.c    |  819 -----
 drivers/net/ethernet/xilinx/xilinx_emac/xemac.h    |  968 ------
 drivers/net/ethernet/xilinx/xilinx_emac/xemac_hw.h |  490 ---
 drivers/net/ethernet/xilinx/xilinx_emac/xemac_i.h  |  758 -----
 .../net/ethernet/xilinx/xilinx_emac/xemac_intr.c   |  389 ---
 .../ethernet/xilinx/xilinx_emac/xemac_intr_dma.c   | 1371 ---------
 .../ethernet/xilinx/xilinx_emac/xemac_intr_fifo.c  |  668 ----
 .../net/ethernet/xilinx/xilinx_emac/xemac_linux.c  | 2802 -----------------
 .../ethernet/xilinx/xilinx_emac/xemac_options.c    |  325 --
 .../net/ethernet/xilinx/xilinx_emac/xemac_phy.c    |  300 --
 drivers/net/ethernet/xilinx/xilinx_temac/Makefile  |   19 -
 drivers/net/ethernet/xilinx/xilinx_temac/xtemac.c  |  464 ---
 drivers/net/ethernet/xilinx/xilinx_temac/xtemac.h  | 1459 ---------
 .../ethernet/xilinx/xilinx_temac/xtemac_control.c  | 1160 -------
 .../net/ethernet/xilinx/xilinx_temac/xtemac_fifo.c | 1173 -------
 .../net/ethernet/xilinx/xilinx_temac/xtemac_i.h    |  118 -
 .../net/ethernet/xilinx/xilinx_temac/xtemac_intr.c |  158 -
 .../xilinx/xilinx_temac/xtemac_intr_fifo.c         |  354 ---
 .../xilinx/xilinx_temac/xtemac_intr_sgdma.c        |  437 ---
 .../net/ethernet/xilinx/xilinx_temac/xtemac_l.c    |  255 --
 .../net/ethernet/xilinx/xilinx_temac/xtemac_l.h    |  705 -----
 .../ethernet/xilinx/xilinx_temac/xtemac_linux.c    | 3242 --------------------
 .../ethernet/xilinx/xilinx_temac/xtemac_selftest.c |  139 -
 .../ethernet/xilinx/xilinx_temac/xtemac_sgdma.c    |  654 ----
 .../ethernet/xilinx/xilinx_temac/xtemac_stats.c    |  100 -
 26 files changed, 0 insertions(+), 19341 deletions(-)
 delete mode 100644 drivers/net/ethernet/xilinx/xilinx_emac/Makefile
 delete mode 100644 drivers/net/ethernet/xilinx/xilinx_emac/xemac.c
 delete mode 100644 drivers/net/ethernet/xilinx/xilinx_emac/xemac.h
 delete mode 100644 drivers/net/ethernet/xilinx/xilinx_emac/xemac_hw.h
 delete mode 100644 drivers/net/ethernet/xilinx/xilinx_emac/xemac_i.h
 delete mode 100644 drivers/net/ethernet/xilinx/xilinx_emac/xemac_intr.c
 delete mode 100644 drivers/net/ethernet/xilinx/xilinx_emac/xemac_intr_dma.c
 delete mode 100644 drivers/net/ethernet/xilinx/xilinx_emac/xemac_intr_fifo.c
 delete mode 100644 drivers/net/ethernet/xilinx/xilinx_emac/xemac_linux.c
 delete mode 100644 drivers/net/ethernet/xilinx/xilinx_emac/xemac_options.c
 delete mode 100644 drivers/net/ethernet/xilinx/xilinx_emac/xemac_phy.c
 delete mode 100644 drivers/net/ethernet/xilinx/xilinx_temac/Makefile
 delete mode 100644 drivers/net/ethernet/xilinx/xilinx_temac/xtemac.c
 delete mode 100644 drivers/net/ethernet/xilinx/xilinx_temac/xtemac.h
 delete mode 100644 drivers/net/ethernet/xilinx/xilinx_temac/xtemac_control.c
 delete mode 100644 drivers/net/ethernet/xilinx/xilinx_temac/xtemac_fifo.c
 delete mode 100644 drivers/net/ethernet/xilinx/xilinx_temac/xtemac_i.h
 delete mode 100644 drivers/net/ethernet/xilinx/xilinx_temac/xtemac_intr.c
 delete mode 100644 drivers/net/ethernet/xilinx/xilinx_temac/xtemac_intr_fifo.c
 delete mode 100644 drivers/net/ethernet/xilinx/xilinx_temac/xtemac_intr_sgdma.c
 delete mode 100644 drivers/net/ethernet/xilinx/xilinx_temac/xtemac_l.c
 delete mode 100644 drivers/net/ethernet/xilinx/xilinx_temac/xtemac_l.h
 delete mode 100644 drivers/net/ethernet/xilinx/xilinx_temac/xtemac_linux.c
 delete mode 100644 drivers/net/ethernet/xilinx/xilinx_temac/xtemac_selftest.c
 delete mode 100644 drivers/net/ethernet/xilinx/xilinx_temac/xtemac_sgdma.c
 delete mode 100644 drivers/net/ethernet/xilinx/xilinx_temac/xtemac_stats.c

diff --git a/drivers/net/ethernet/xilinx/xilinx_emac/Makefile b/drivers/net/ethernet/xilinx/xilinx_emac/Makefile
deleted file mode 100644
index d85ef92..0000000
--- a/drivers/net/ethernet/xilinx/xilinx_emac/Makefile
+++ /dev/null
@@ -1,14 +0,0 @@
-#
-# Makefile for the Xilinx 10/100 OPB EMAC driver
-#
-
-EXTRA_CFLAGS	+= -I$(TOPDIR)/drivers/xilinx_common
-
-obj-$(CONFIG_XILINX_EMAC) := xilinx_emac.o
-
-# The Linux driver for the Xilinx EMAC core.
-xilinx_emac-objs	:= xemac_linux.o
-
-# The Xilinx OS independent code.
-xilinx_emac-objs	+= xemac.o xemac_intr.o xemac_intr_dma.o \
-			   xemac_options.o xemac_phy.o xemac_intr_fifo.o
diff --git a/drivers/net/ethernet/xilinx/xilinx_emac/xemac.c b/drivers/net/ethernet/xilinx/xilinx_emac/xemac.c
deleted file mode 100644
index f7beb01..0000000
--- a/drivers/net/ethernet/xilinx/xilinx_emac/xemac.c
+++ /dev/null
@@ -1,819 +0,0 @@
-/* $Id: xemac.c,v 1.1 2006/11/01 17:30:12 moleres Exp $ */
-/******************************************************************************
-*
-*       XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS"
-*       AS A COURTESY TO YOU, SOLELY FOR USE IN DEVELOPING PROGRAMS AND
-*       SOLUTIONS FOR XILINX DEVICES.  BY PROVIDING THIS DESIGN, CODE,
-*       OR INFORMATION AS ONE POSSIBLE IMPLEMENTATION OF THIS FEATURE,
-*       APPLICATION OR STANDARD, XILINX IS MAKING NO REPRESENTATION
-*       THAT THIS IMPLEMENTATION IS FREE FROM ANY CLAIMS OF INFRINGEMENT,
-*       AND YOU ARE RESPONSIBLE FOR OBTAINING ANY RIGHTS YOU MAY REQUIRE
-*       FOR YOUR IMPLEMENTATION.  XILINX EXPRESSLY DISCLAIMS ANY
-*       WARRANTY WHATSOEVER WITH RESPECT TO THE ADEQUACY OF THE
-*       IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OR
-*       REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE FROM CLAIMS OF
-*       INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
-*       FOR A PARTICULAR PURPOSE.
-*
-*       (c) Copyright 2003 Xilinx Inc.
-*       All rights reserved.
-*
-******************************************************************************/
-/*****************************************************************************/
-/**
-*
-* @file xemac.c
-*
-* The XEmac driver. Functions in this file are the minimum required functions
-* for this driver. See xemac.h for a detailed description of the driver.
-*
-* <pre>
-* MODIFICATION HISTORY:
-*
-* Ver   Who  Date     Changes
-* ----- ---- -------- -------------------------------------------------------
-* 1.00a rpm  07/31/01 First release
-* 1.00b rpm  02/20/02 Repartitioned files and functions
-* 1.00b rpm  07/23/02 Removed the PHY reset from Initialize()
-* 1.00b rmm  09/23/02 Removed commented code in Initialize(). Recycled as
-*                     XEmac_mPhyReset macro in xemac_l.h.
-* 1.00c rpm  12/05/02 New version includes support for simple DMA
-* 1.00c rpm  12/12/02 Changed location of IsStarted assignment in XEmac_Start
-*                     to be sure the flag is set before the device and
-*                     interrupts are enabled.
-* 1.00c rpm  02/03/03 SelfTest was not clearing polled mode. Take driver out
-*                     of polled mode in XEmac_Reset() to fix this problem.
-* 1.00c rmm  05/13/03 Fixed diab compiler warnings relating to asserts.
-* 1.00d rpm  09/26/03 New version includes support PLB Ethernet and v2.00a of
-*                     the packet fifo driver.
-* 1.00e rmm  04/06/04 Changed XEmac_Initialize() to clear the instance data.
-*                     Added XEM_NO_SGEND_INT_OPTION processing to XEmac_Start().
-* 1.01a ecm  09/26/05 Changed XEmac_Initialize() to  create instance variable
-*                     which has the default DMA control words for the hardware.
-*                     Added the Checksum offload initialization to control word.
-* 1.01a wgr  09/14/06 Ported to Linux 2.6
-* 1.11a wgr  03/22/07 Converted to new coding style.
-* </pre>
-******************************************************************************/
-
-/***************************** Include Files *********************************/
-
-#include <linux/string.h>
-#include "xbasic_types.h"
-#include "xemac_i.h"
-#include "xio.h"
-#include "xbuf_descriptor.h"
-#include "xdma_channel.h"
-#include "xipif_v1_23_b.h"	/* Uses v1.23b of the IPIF */
-
-/************************** Constant Definitions *****************************/
-
-
-/**************************** Type Definitions *******************************/
-
-
-/***************** Macros (Inline Functions) Definitions *********************/
-
-
-
-/************************** Function Prototypes ******************************/
-static int ConfigureDma(XEmac * InstancePtr);
-static int ConfigureFifo(XEmac * InstancePtr);
-static void StubFifoHandler(void *CallBackRef);
-static void StubErrorHandler(void *CallBackRef, int ErrorCode);
-static void StubSgHandler(void *CallBackRef, XBufDescriptor * BdPtr,
-			  u32 NumBds);
-
-/************************** Variable Definitions *****************************/
-
-
-/*****************************************************************************/
-/**
-*
-* Initialize a specific XEmac instance/driver.
-*
-* Retrieves the configuration table associated with the DeviceID provided.
-* Sets up the Instance data as determined bu the configuration table
-* Calls the unified local Initialize function contained in xemac,c
-*
-* @param InstancePtr is a pointer to the XEmac instance to be worked on.
-* @param DeviceId is the unique id of the device controlled by this XEmac
-*        instance.  Passing in a device id associates the generic XEmac
-*        instance to a specific device, as chosen by the caller or application
-*        developer.
-* @param VirtualAddress is the address for the base address in the instance.
-*        This method is specific to Linux usage.
-*
-* @return
-*
-* - XST_SUCCESS if initialization was successful
-* - XST_DEVICE_NOT_FOUND if device configuration information was not found for
-*   a device with the supplied device ID.
-*
-* @note
-*
-* None.
-*
-******************************************************************************/
-int XEmac_CfgInitialize(XEmac * InstancePtr, XEmac_Config * ConfigPtr,
-			u32 VirtualAddress)
-{
-	int Result;
-
-	XASSERT_NONVOID(InstancePtr != NULL);
-	XASSERT_NONVOID(ConfigPtr != NULL);
-
-	/* Clear instance memory */
-	memset(InstancePtr, 0, sizeof(XEmac));
-
-	/*
-	 * Assign the provided ConfigPtr to the instance.
-	 */
-	InstancePtr->Config = *ConfigPtr;
-
-	/*
-	 * Save the baseaddresses for faster access
-	 */
-	if (0 != VirtualAddress) {
-		InstancePtr->BaseAddress = VirtualAddress;
-	}
-	else {
-		InstancePtr->BaseAddress = ConfigPtr->BaseAddress;
-	}
-	InstancePtr->PhysAddress = ConfigPtr->BaseAddress;
-
-	/*
-	 * Set some default values
-	 */
-	InstancePtr->IsReady = 0;
-	InstancePtr->IsStarted = 0;
-	InstancePtr->HasMulticastHash = FALSE;
-
-	/* Always default polled to false, let user configure this mode */
-	InstancePtr->IsPolled = FALSE;
-	InstancePtr->FifoRecvHandler = StubFifoHandler;
-	InstancePtr->FifoSendHandler = StubFifoHandler;
-	InstancePtr->ErrorHandler = StubErrorHandler;
-	InstancePtr->SgRecvHandler = StubSgHandler;
-	InstancePtr->SgSendHandler = StubSgHandler;
-
-
-	/*
-	 * Configure the send and receive FIFOs in the MAC
-	 */
-	Result = ConfigureFifo(InstancePtr);
-	if (Result != XST_SUCCESS) {
-		return Result;
-	}
-
-	/*
-	 * If the device is configured for DMA, configure the send and receive DMA
-	 * channels in the MAC.
-	 */
-	if (XEmac_mIsDma(InstancePtr)) {
-		Result = ConfigureDma(InstancePtr);
-		if (Result != XST_SUCCESS) {
-			return Result;
-		}
-
-		if (XEmac_mIsTxDre(InstancePtr) == TRUE) {
-			InstancePtr->TxDmaControlWord = XEM_DFT_SEND_BD_MASK |
-				XDC_DMACR_DRE_MODE_MASK;
-		}
-		else {
-			InstancePtr->TxDmaControlWord = XEM_DFT_SEND_BD_MASK;
-		}
-
-		if (XEmac_mIsRxDre(InstancePtr) == TRUE) {
-			InstancePtr->RxDmaControlWord = XEM_DFT_RECV_BD_MASK |
-				XDC_DMACR_DRE_MODE_MASK;
-		}
-		else {
-			InstancePtr->RxDmaControlWord = XEM_DFT_RECV_BD_MASK;
-		}
-
-		/*
-		 * TX Checksum offload is dynamic and needs to be set for every
-		 * BD that uses it. It is not applicable to all data types so the
-		 * adapter needs to handle each call individually
-		 */
-
-		if (XEmac_mIsRxHwCsum(InstancePtr) == TRUE) {
-			InstancePtr->RxDmaControlWord |=
-				XDC_DMACR_CS_OFFLOAD_MASK;
-		}
-	}
-
-	/*
-	 * Indicate the component is now ready to use. Note that this is done before
-	 * we reset the device and the PHY below, which may seem a bit odd. The
-	 * choice was made to move it here rather than remove the asserts in various
-	 * functions (e.g., Reset() and all functions that it calls).  Applications
-	 * that use multiple threads, one to initialize the XEmac driver and one
-	 * waiting on the IsReady condition could have a problem with this sequence.
-	 */
-	InstancePtr->IsReady = XCOMPONENT_IS_READY;
-
-	/*
-	 * Reset the MAC to get it into its initial state. It is expected that
-	 * device configuration by the user will take place after this
-	 * initialization is done, but before the device is started.
-	 */
-	XEmac_Reset(InstancePtr);
-
-	return XST_SUCCESS;
-}
-
-/*****************************************************************************/
-/**
-*
-* Start the Ethernet controller as follows:
-*   - If not in polled mode
-*       - Set the internal interrupt enable registers appropriately
-*       - Enable interrupts within the device itself. Note that connection of
-*         the driver's interrupt handler to the interrupt source (typically
-*         done using the interrupt controller component) is done by the higher
-*         layer software.
-*       - If the device is configured with scatter-gather DMA, start the DMA
-*         channels if the descriptor lists are not empty
-*   - Enable the transmitter
-*   - Enable the receiver
-*
-* The PHY is enabled after driver initialization. We assume the upper layer
-* software has configured it and the EMAC appropriately before this function
-* is called.
-*
-* @param InstancePtr is a pointer to the XEmac instance to be worked on.
-*
-* @return
-*
-* - XST_SUCCESS if the device was started successfully
-* - XST_NO_CALLBACK if a callback function has not yet been registered using
-*   the SetxxxHandler function. This is required if in interrupt mode.
-* - XST_DEVICE_IS_STARTED if the device is already started
-* - XST_DMA_SG_NO_LIST if configured for scatter-gather DMA and a descriptor
-*   list has not yet been created for the send or receive channel.
-*
-* @note
-*
-* The driver tries to match the hardware configuration. So if the hardware
-* is configured with scatter-gather DMA, the driver expects to start the
-* scatter-gather channels and expects that the user has set up the buffer
-* descriptor lists already. If the user expects to use the driver in a mode
-* different than how the hardware is configured, the user should modify the
-* configuration table to reflect the mode to be used. Modifying the config
-* table is a workaround for now until we get some experience with how users
-* are intending to use the hardware in its different configurations. For
-* example, if the hardware is built with scatter-gather DMA but the user is
-* intending to use only simple DMA, the user either needs to modify the config
-* table as a workaround or rebuild the hardware with only simple DMA.
-*
-* This function makes use of internal resources that are shared between the
-* Start, Stop, and SetOptions functions. So if one task might be setting device
-* options while another is trying to start the device, the user is required to
-* provide protection of this shared data (typically using a semaphore).
-*
-******************************************************************************/
-int XEmac_Start(XEmac * InstancePtr)
-{
-	u32 ControlReg;
-	int Result;
-
-	XASSERT_NONVOID(InstancePtr != NULL);
-	XASSERT_NONVOID(InstancePtr->IsReady == XCOMPONENT_IS_READY);
-
-	/*
-	 * If it is already started, return a status indicating so
-	 */
-	if (InstancePtr->IsStarted == XCOMPONENT_IS_STARTED) {
-		return XST_DEVICE_IS_STARTED;
-	}
-
-	/*
-	 * If not polled, enable interrupts
-	 */
-	if (!InstancePtr->IsPolled) {
-		/*
-		 * Verify that the callbacks have been registered, then enable
-		 * interrupts
-		 */
-		if (XEmac_mIsSgDma(InstancePtr)) {
-			if ((InstancePtr->SgRecvHandler == StubSgHandler) ||
-			    (InstancePtr->SgSendHandler == StubSgHandler)) {
-				return XST_NO_CALLBACK;
-			}
-
-			/* Enable IPIF interrupts */
-			XIIF_V123B_WRITE_DIER(InstancePtr->BaseAddress,
-					      XEM_IPIF_DMA_DFT_MASK |
-					      XIIF_V123B_ERROR_MASK);
-			XIIF_V123B_WRITE_IIER(InstancePtr->BaseAddress,
-					      XEM_EIR_DFT_SG_MASK);
-
-			/* Enable scatter-gather DMA interrupts */
-			ControlReg = XEM_DMA_SG_INTR_MASK;	/* Default mask */
-			if (InstancePtr->IsSgEndDisable) {
-				ControlReg &= ~XDC_IXR_SG_END_MASK;	/* Don't enable SGEND */
-			}
-
-			XDmaChannel_SetIntrEnable(&InstancePtr->RecvChannel,
-						  ControlReg);
-			XDmaChannel_SetIntrEnable(&InstancePtr->SendChannel,
-						  ControlReg);
-		}
-		else {
-			if ((InstancePtr->FifoRecvHandler == StubFifoHandler) ||
-			    (InstancePtr->FifoSendHandler == StubFifoHandler)) {
-				return XST_NO_CALLBACK;
-			}
-
-			/* Enable IPIF interrupts (used by simple DMA also) */
-			XIIF_V123B_WRITE_DIER(InstancePtr->BaseAddress,
-					      XEM_IPIF_FIFO_DFT_MASK |
-					      XIIF_V123B_ERROR_MASK);
-			XIIF_V123B_WRITE_IIER(InstancePtr->BaseAddress,
-					      XEM_EIR_DFT_FIFO_MASK);
-		}
-
-		/* Enable the global IPIF interrupt output */
-		XIIF_V123B_GINTR_ENABLE(InstancePtr->BaseAddress);
-	}
-
-	/*
-	 * Indicate that the device is started before we enable the transmitter
-	 * or receiver. This needs to be done before because as soon as the
-	 * receiver is enabled we may get an interrupt, and there are functions
-	 * in the interrupt handling path that rely on the IsStarted flag.
-	 */
-	InstancePtr->IsStarted = XCOMPONENT_IS_STARTED;
-
-	/*
-	 * Enable the transmitter, and receiver (do a read/modify/write to preserve
-	 * current settings). There is no critical section here since this register
-	 * is not modified during interrupt context.
-	 */
-	ControlReg = XIo_In32(InstancePtr->BaseAddress + XEM_ECR_OFFSET);
-	ControlReg &= ~(XEM_ECR_XMIT_RESET_MASK | XEM_ECR_RECV_RESET_MASK);
-	ControlReg |= (XEM_ECR_XMIT_ENABLE_MASK | XEM_ECR_RECV_ENABLE_MASK);
-
-	XIo_Out32(InstancePtr->BaseAddress + XEM_ECR_OFFSET, ControlReg);
-
-	/*
-	 * If configured with scatter-gather DMA and not polled, restart the
-	 * DMA channels in case there are buffers ready to be sent or received into.
-	 * The DMA SgStart function uses data that can be modified during interrupt
-	 * context, so a critical section is required here.
-	 */
-	if ((XEmac_mIsSgDma(InstancePtr)) && (!InstancePtr->IsPolled)) {
-		XIIF_V123B_GINTR_DISABLE(InstancePtr->BaseAddress);
-
-		/*
-		 * The only error we care about is if the list has not yet been
-		 * created, or on receive, if no buffer descriptors have been
-		 * added yet (the list is empty). Other errors are benign at this point.
-		 */
-		Result = XDmaChannel_SgStart(&InstancePtr->RecvChannel);
-		if ((Result == XST_DMA_SG_NO_LIST) ||
-		    (Result == XST_DMA_SG_LIST_EMPTY)) {
-			XIIF_V123B_GINTR_ENABLE(InstancePtr->BaseAddress);
-			return Result;
-		}
-
-		Result = XDmaChannel_SgStart(&InstancePtr->SendChannel);
-		if (Result == XST_DMA_SG_NO_LIST) {
-			XIIF_V123B_GINTR_ENABLE(InstancePtr->BaseAddress);
-			return Result;
-		}
-
-		XIIF_V123B_GINTR_ENABLE(InstancePtr->BaseAddress);
-	}
-
-	return XST_SUCCESS;
-}
-
-/*****************************************************************************/
-/**
-*
-* Stop the Ethernet MAC as follows:
-*   - If the device is configured with scatter-gather DMA, stop the DMA
-*     channels (wait for acknowledgment of stop)
-*   - Disable the transmitter and receiver
-*   - Disable interrupts if not in polled mode (the higher layer software is
-*     responsible for disabling interrupts at the interrupt controller)
-*
-* The PHY is left enabled after a Stop is called.
-*
-* If the device is configured for scatter-gather DMA, the DMA engine stops at
-* the next buffer descriptor in its list. The remaining descriptors in the list
-* are not removed, so anything in the list will be transmitted or received when
-* the device is restarted. The side effect of doing this is that the last
-* buffer descriptor processed by the DMA engine before stopping may not be the
-* last descriptor in the Ethernet frame. So when the device is restarted, a
-* partial frame (i.e., a bad frame) may be transmitted/received. This is only a
-* concern if a frame can span multiple buffer descriptors, which is dependent
-* on the size of the network buffers.
-*
-* @param InstancePtr is a pointer to the XEmac instance to be worked on.
-*
-* @return
-*
-* - XST_SUCCESS if the device was stopped successfully
-* - XST_DEVICE_IS_STOPPED if the device is already stopped
-*
-* @note
-*
-* This function makes use of internal resources that are shared between the
-* Start, Stop, and SetOptions functions. So if one task might be setting device
-* options while another is trying to start the device, the user is required to
-* provide protection of this shared data (typically using a semaphore).
-*
-******************************************************************************/
-int XEmac_Stop(XEmac * InstancePtr)
-{
-	u32 ControlReg;
-
-	XASSERT_NONVOID(InstancePtr != NULL);
-	XASSERT_NONVOID(InstancePtr->IsReady == XCOMPONENT_IS_READY);
-
-	/*
-	 * If the device is already stopped, do nothing but return a status
-	 * indicating so
-	 */
-	if (InstancePtr->IsStarted != XCOMPONENT_IS_STARTED) {
-		return XST_DEVICE_IS_STOPPED;
-	}
-
-	/*
-	 * If configured for scatter-gather DMA, stop the DMA channels. Ignore
-	 * the XST_DMA_SG_IS_STOPPED return code. There is a critical section
-	 * here between SgStart and SgStop, and SgStart can be called in interrupt
-	 * context, so disable interrupts while calling SgStop.
-	 */
-	if (XEmac_mIsSgDma(InstancePtr)) {
-		XBufDescriptor *BdTemp;	/* temporary descriptor pointer */
-
-		XIIF_V123B_GINTR_DISABLE(InstancePtr->BaseAddress);
-
-		(void) XDmaChannel_SgStop(&InstancePtr->SendChannel, &BdTemp);
-		(void) XDmaChannel_SgStop(&InstancePtr->RecvChannel, &BdTemp);
-
-		XIIF_V123B_GINTR_ENABLE(InstancePtr->BaseAddress);
-	}
-
-	/*
-	 * Disable the transmitter and receiver. There is no critical section
-	 * here since this register is not modified during interrupt context.
-	 */
-	ControlReg = XIo_In32(InstancePtr->BaseAddress + XEM_ECR_OFFSET);
-	ControlReg &= ~(XEM_ECR_XMIT_ENABLE_MASK | XEM_ECR_RECV_ENABLE_MASK);
-	XIo_Out32(InstancePtr->BaseAddress + XEM_ECR_OFFSET, ControlReg);
-
-	/*
-	 * If not in polled mode, disable interrupts for IPIF (includes MAC and
-	 * DMAs)
-	 */
-	if (!InstancePtr->IsPolled) {
-		XIIF_V123B_GINTR_DISABLE(InstancePtr->BaseAddress);
-	}
-
-	InstancePtr->IsStarted = 0;
-
-	return XST_SUCCESS;
-}
-
-/*****************************************************************************/
-/**
-*
-* Reset the Ethernet MAC. This is a graceful reset in that the device is stopped
-* first. Resets the DMA channels, the FIFOs, the transmitter, and the receiver.
-* The PHY is not reset. Any frames in the scatter-gather descriptor lists will
-* remain in the lists. The side effect of doing this is that after a reset and
-* following a restart of the device, frames that were in the list before the
-* reset may be transmitted or received. Reset must only be called after the
-* driver has been initialized.
-*
-* The driver is also taken out of polled mode if polled mode was set. The user
-* is responsbile for re-configuring the driver into polled mode after the
-* reset if desired.
-*
-* The configuration after this reset is as follows:
-*   - Half duplex
-*   - Disabled transmitter and receiver
-*   - Enabled PHY (the PHY is not reset)
-*   - MAC transmitter does pad insertion, FCS insertion, and source address
-*     overwrite.
-*   - MAC receiver does not strip padding or FCS
-*   - Interframe Gap as recommended by IEEE Std. 802.3 (96 bit times)
-*   - Unicast addressing enabled
-*   - Broadcast addressing enabled
-*   - Multicast addressing disabled (addresses are preserved)
-*   - Promiscuous addressing disabled
-*   - Default packet threshold and packet wait bound register values for
-*     scatter-gather DMA operation
-*   - MAC address of all zeros
-*   - Non-polled mode
-*
-* The upper layer software is responsible for re-configuring (if necessary)
-* and restarting the MAC after the reset. Note that the PHY is not reset. PHY
-* control is left to the upper layer software. Note also that driver statistics
-* are not cleared on reset. It is up to the upper layer software to clear the
-* statistics if needed.
-*
-* When a reset is required due to an internal error, the driver notifies the
-* upper layer software of this need through the ErrorHandler callback and
-* specific status codes.  The upper layer software is responsible for calling
-* this Reset function and then re-configuring the device.
-*
-* @param InstancePtr is a pointer to the XEmac instance to be worked on.
-*
-* @return
-*
-* None.
-*
-* @note
-*
-* None.
-*
-* @internal
-*
-* The reset is accomplished by setting the IPIF reset register.  This takes
-* care of resetting all hardware blocks, including the MAC.
-*
-******************************************************************************/
-void XEmac_Reset(XEmac * InstancePtr)
-{
-	XASSERT_VOID(InstancePtr != NULL);
-	XASSERT_VOID(InstancePtr->IsReady == XCOMPONENT_IS_READY);
-
-	/*
-	 * Stop the device first
-	 */
-	(void) XEmac_Stop(InstancePtr);
-
-	/*
-	 * Take the driver out of polled mode
-	 */
-	InstancePtr->IsPolled = FALSE;
-
-	/*
-	 * Reset the entire IPIF at once.  If we choose someday to reset each
-	 * hardware block separately, the reset should occur in the direction of
-	 * data flow. For example, for the send direction the reset order is DMA
-	 * first, then FIFO, then the MAC transmitter.
-	 */
-	XIIF_V123B_RESET(InstancePtr->BaseAddress);
-
-	if (XEmac_mIsSgDma(InstancePtr)) {
-		/*
-		 * After reset, configure the scatter-gather DMA packet threshold and
-		 * packet wait bound registers to default values. Ignore the return
-		 * values of these functions since they only return error if the device
-		 * is not stopped.
-		 */
-		(void) XEmac_SetPktThreshold(InstancePtr, XEM_SEND,
-					     XEM_SGDMA_DFT_THRESHOLD);
-		(void) XEmac_SetPktThreshold(InstancePtr, XEM_RECV,
-					     XEM_SGDMA_DFT_THRESHOLD);
-		(void) XEmac_SetPktWaitBound(InstancePtr, XEM_SEND,
-					     XEM_SGDMA_DFT_WAITBOUND);
-		(void) XEmac_SetPktWaitBound(InstancePtr, XEM_RECV,
-					     XEM_SGDMA_DFT_WAITBOUND);
-	}
-}
-
-/*****************************************************************************/
-/**
-*
-* Set the MAC address for this driver/device.  The address is a 48-bit value.
-* The device must be stopped before calling this function.
-*
-* @param InstancePtr is a pointer to the XEmac instance to be worked on.
-* @param AddressPtr is a pointer to a 6-byte MAC address.
-*
-* @return
-*
-* - XST_SUCCESS if the MAC address was set successfully
-* - XST_DEVICE_IS_STARTED if the device has not yet been stopped
-*
-* @note
-*
-* None.
-*
-******************************************************************************/
-int XEmac_SetMacAddress(XEmac * InstancePtr, u8 *AddressPtr)
-{
-	u32 MacAddr = 0;
-
-	XASSERT_NONVOID(InstancePtr != NULL);
-	XASSERT_NONVOID(AddressPtr != NULL);
-	XASSERT_NONVOID(InstancePtr->IsReady == XCOMPONENT_IS_READY);
-
-	/*
-	 * The device must be stopped before setting the MAC address
-	 */
-	if (InstancePtr->IsStarted == XCOMPONENT_IS_STARTED) {
-		return XST_DEVICE_IS_STARTED;
-	}
-
-	/*
-	 * Set the device station address high and low registers
-	 */
-	MacAddr = (AddressPtr[0] << 8) | AddressPtr[1];
-	XIo_Out32(InstancePtr->BaseAddress + XEM_SAH_OFFSET, MacAddr);
-
-	MacAddr = (AddressPtr[2] << 24) | (AddressPtr[3] << 16) |
-		(AddressPtr[4] << 8) | AddressPtr[5];
-
-	XIo_Out32(InstancePtr->BaseAddress + XEM_SAL_OFFSET, MacAddr);
-
-	return XST_SUCCESS;
-}
-
-/*****************************************************************************/
-/**
-*
-* Get the MAC address for this driver/device.
-*
-* @param InstancePtr is a pointer to the XEmac instance to be worked on.
-* @param BufferPtr is an output parameter, and is a pointer to a buffer into
-*        which the current MAC address will be copied. The buffer must be at
-*        least 6 bytes.
-*
-* @return
-*
-* None.
-*
-* @note
-*
-* None.
-*
-******************************************************************************/
-void XEmac_GetMacAddress(XEmac * InstancePtr, u8 *BufferPtr)
-{
-	u32 MacAddrHi;
-	u32 MacAddrLo;
-
-	XASSERT_VOID(InstancePtr != NULL);
-	XASSERT_VOID(BufferPtr != NULL);
-	XASSERT_VOID(InstancePtr->IsReady == XCOMPONENT_IS_READY);
-
-	MacAddrHi = XIo_In32(InstancePtr->BaseAddress + XEM_SAH_OFFSET);
-	MacAddrLo = XIo_In32(InstancePtr->BaseAddress + XEM_SAL_OFFSET);
-
-	BufferPtr[0] = (u8) (MacAddrHi >> 8);
-	BufferPtr[1] = (u8) MacAddrHi;
-	BufferPtr[2] = (u8) (MacAddrLo >> 24);
-	BufferPtr[3] = (u8) (MacAddrLo >> 16);
-	BufferPtr[4] = (u8) (MacAddrLo >> 8);
-	BufferPtr[5] = (u8) MacAddrLo;
-}
-
-/******************************************************************************/
-/**
-*
-* Configure DMA capabilities.
-*
-* @param InstancePtr is a pointer to the XEmac instance to be worked on.
-*
-* @return
-*
-* - XST_SUCCESS  if successful initialization of DMA
-*
-* @note
-*
-* None.
-*
-******************************************************************************/
-static int ConfigureDma(XEmac * InstancePtr)
-{
-	int Result;
-
-	/*
-	 * Initialize the DMA channels with their base addresses. We assume
-	 * scatter-gather DMA is the only possible configuration. Descriptor space
-	 * will need to be set later by the upper layer.
-	 */
-	Result = XDmaChannel_Initialize(&InstancePtr->RecvChannel,
-					InstancePtr->BaseAddress +
-					XEM_DMA_RECV_OFFSET);
-	if (Result != XST_SUCCESS) {
-		return Result;
-	}
-
-	Result = XDmaChannel_Initialize(&InstancePtr->SendChannel,
-					InstancePtr->BaseAddress +
-					XEM_DMA_SEND_OFFSET);
-
-	return Result;
-}
-
-/******************************************************************************/
-/**
-*
-* Configure the send and receive FIFO components with their base addresses
-* and interrupt masks.  Currently the base addresses are defined constants.
-*
-* @param InstancePtr is a pointer to the XEmac instance to be worked on.
-*
-* @return
-*
-* XST_SUCCESS if successful initialization of the packet FIFOs
-*
-* @note
-*
-* None.
-*
-******************************************************************************/
-static int ConfigureFifo(XEmac * InstancePtr)
-{
-	int Result;
-
-	/*
-	 * Return status from the packet FIFOs initialization is ignored since
-	 * they always return success.
-	 */
-	Result = XPacketFifoV200a_Initialize(&InstancePtr->RecvFifo,
-					     InstancePtr->BaseAddress +
-					     XEM_PFIFO_RXREG_OFFSET,
-					     InstancePtr->BaseAddress +
-					     XEM_PFIFO_RXDATA_OFFSET);
-	if (Result != XST_SUCCESS) {
-		return Result;
-	}
-
-	Result = XPacketFifoV200a_Initialize(&InstancePtr->SendFifo,
-					     InstancePtr->BaseAddress +
-					     XEM_PFIFO_TXREG_OFFSET,
-					     InstancePtr->BaseAddress +
-					     XEM_PFIFO_TXDATA_OFFSET);
-	return Result;
-}
-
-/******************************************************************************/
-/**
-*
-* This is a stub for the scatter-gather send and recv callbacks. The stub
-* is here in case the upper layers forget to set the handlers.
-*
-* @param CallBackRef is a pointer to the upper layer callback reference
-* @param BdPtr is a pointer to the first buffer descriptor in a list
-* @param NumBds is the number of descriptors in the list.
-*
-* @return
-*
-* None.
-*
-* @note
-*
-* None.
-*
-******************************************************************************/
-static void StubSgHandler(void *CallBackRef, XBufDescriptor * BdPtr, u32 NumBds)
-{
-	XASSERT_VOID_ALWAYS();
-}
-
-/******************************************************************************/
-/**
-*
-* This is a stub for the non-DMA send and recv callbacks.  The stub is here in
-* case the upper layers forget to set the handlers.
-*
-* @param CallBackRef is a pointer to the upper layer callback reference
-*
-* @return
-*
-* None.
-*
-* @note
-*
-* None.
-*
-******************************************************************************/
-static void StubFifoHandler(void *CallBackRef)
-{
-	XASSERT_VOID_ALWAYS();
-}
-
-/******************************************************************************/
-/**
-*
-* This is a stub for the asynchronous error callback.  The stub is here in
-* case the upper layers forget to set the handler.
-*
-* @param CallBackRef is a pointer to the upper layer callback reference
-* @param ErrorCode is the Xilinx error code, indicating the cause of the error
-*
-* @return
-*
-* None.
-*
-* @note
-*
-* None.
-*
-******************************************************************************/
-static void StubErrorHandler(void *CallBackRef, int ErrorCode)
-{
-	XASSERT_VOID_ALWAYS();
-}
diff --git a/drivers/net/ethernet/xilinx/xilinx_emac/xemac.h b/drivers/net/ethernet/xilinx/xilinx_emac/xemac.h
deleted file mode 100644
index d5ba852..0000000
--- a/drivers/net/ethernet/xilinx/xilinx_emac/xemac.h
+++ /dev/null
@@ -1,968 +0,0 @@
-/******************************************************************************
-*
-*     Author: Xilinx, Inc.
-*
-*
-*     This program is free software; you can redistribute it and/or modify it
-*     under the terms of the GNU General Public License as published by the
-*     Free Software Foundation; either version 2 of the License, or (at your
-*     option) any later version.
-*
-*
-*     XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS" AS A
-*     COURTESY TO YOU. BY PROVIDING THIS DESIGN, CODE, OR INFORMATION AS
-*     ONE POSSIBLE IMPLEMENTATION OF THIS FEATURE, APPLICATION OR STANDARD,
-*     XILINX IS MAKING NO REPRESENTATION THAT THIS IMPLEMENTATION IS FREE
-*     FROM ANY CLAIMS OF INFRINGEMENT, AND YOU ARE RESPONSIBLE FOR OBTAINING
-*     ANY THIRD PARTY RIGHTS YOU MAY REQUIRE FOR YOUR IMPLEMENTATION.
-*     XILINX EXPRESSLY DISCLAIMS ANY WARRANTY WHATSOEVER WITH RESPECT TO
-*     THE ADEQUACY OF THE IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO ANY
-*     WARRANTIES OR REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE FROM
-*     CLAIMS OF INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY AND
-*     FITNESS FOR A PARTICULAR PURPOSE.
-*
-*
-*     Xilinx hardware products are not intended for use in life support
-*     appliances, devices, or systems. Use in such applications is
-*     expressly prohibited.
-*
-*
-*     (c) Copyright 2002-2004 Xilinx Inc.
-*     All rights reserved.
-*
-*
-*     You should have received a copy of the GNU General Public License along
-*     with this program; if not, write to the Free Software Foundation, Inc.,
-*     675 Mass Ave, Cambridge, MA 02139, USA.
-*
-******************************************************************************/
-/*****************************************************************************/
-/**
-*
-* @file xemac.h
-*
-* The Xilinx Ethernet driver component.  This component supports the Xilinx
-* Ethernet 10/100 MAC (EMAC).
-*
-* The Xilinx Ethernet 10/100 MAC supports the following features:
-*   - Simple and scatter-gather DMA operations, as well as simple memory
-*     mapped direct I/O interface (FIFOs)
-*   - Media Independent Interface (MII) for connection to external
-*     10/100 Mbps PHY transceivers
-*   - MII management control reads and writes with MII PHYs
-*   - Independent internal transmit and receive FIFOs
-*   - CSMA/CD compliant operations for half-duplex modes
-*   - Programmable PHY reset signal
-*   - Unicast, broadcast, multicast, and promiscuous address filtering
-*   - Reception of any address that matches a CAM entry.
-*   - Internal loopback
-*   - Automatic source address insertion or overwrite (programmable)
-*   - Automatic FCS insertion and stripping (programmable)
-*   - Automatic pad insertion and stripping (programmable)
-*   - Pause frame (flow control) detection in full-duplex mode
-*   - Programmable interframe gap
-*   - VLAN frame support
-*   - Pause frame support
-*   - Jumbo frame support
-*   - Dynamic Re-alignment Engine (DRE) support handled automatically
-*
-* The device driver supports all the features listed above.
-*
-* <b>Driver Description</b>
-*
-* The device driver enables higher layer software (e.g., an application) to
-* communicate to the EMAC. The driver handles transmission and reception of
-* Ethernet frames, as well as configuration of the controller. It does not
-* handle protocol stack functionality such as Link Layer Control (LLC) or the
-* Address Resolution Protocol (ARP). The protocol stack that makes use of the
-* driver handles this functionality. This implies that the driver is simply a
-* pass-through mechanism between a protocol stack and the EMAC. A single device
-* driver can support multiple EMACs.
-*
-* The driver is designed for a zero-copy buffer scheme. That is, the driver will
-* not copy buffers. This avoids potential throughput bottlenecks within the
-* driver.
-*
-* Since the driver is a simple pass-through mechanism between a protocol stack
-* and the EMAC, no assembly or disassembly of Ethernet frames is done at the
-* driver-level. This assumes that the protocol stack passes a correctly
-* formatted Ethernet frame to the driver for transmission, and that the driver
-* does not validate the contents of an incoming frame
-*
-* <b>Buffer Alignment</b>
-*
-* It is important to note that when using direct FIFO communication (either
-* polled or interrupt-driven), packet buffers must be 32-bit aligned. When
-* using DMA without DRE and the OPB 10/100 Ethernet core, packet buffers
-* must be 32-bit aligned. When using DMA without DRE and the PLB 10/100
-* Ethernet core, packet buffers must be 64-bit aligned.
-*
-* When using scatter-gather DMA, the buffer descriptors must be 32-bit
-* aligned (for either the OPB or the PLB core). The driver may not enforce
-* this alignment so it is up to the user to guarantee the proper alignment.
-*
-* When DRE is available in the DMA engine, only the buffer descriptors must
-* be aligned, the actual buffers do not need to be aligned to any particular
-* addressing convention, the DRE takes care of that in hardware.
-*
-* <b>Receive Address Filtering</b>
-*
-* The device can be set to accept frames whose destination MAC address:
-*
-*   - Match the station MAC address (see XEmac_SetMacAddress())
-*   - Match the broadcast MAC address (see XEM_BROADCAST_OPTION)
-*   - Match any multicast MAC address (see XEM_MULTICAST_OPTION)
-*   - Match any one of the 64 possible CAM addresses (see XEmac_MulticastAdd()
-*     and XEM_MULTICAST_CAM_OPTION). The CAM is optional.
-*   - Match any MAC address (see XEM_PROMISC_OPTION)
-*
-* <b>PHY Communication</b>
-*
-* The driver provides rudimentary read and write functions to allow the higher
-* layer software to access the PHY. The EMAC provides MII registers for the
-* driver to access. This management interface can be parameterized away in the
-* FPGA implementation process. If this is the case, the PHY read and write
-* functions of the driver return XST_NO_FEATURE.
-*
-* External loopback is usually supported at the PHY. It is up to the user to
-* turn external loopback on or off at the PHY. The driver simply provides pass-
-* through functions for configuring the PHY. The driver does not read, write,
-* or reset the PHY on its own. All control of the PHY must be done by the user.
-*
-* <b>Asynchronous Callbacks</b>
-*
-* The driver services interrupts and passes Ethernet frames to the higher layer
-* software through asynchronous callback functions. When using the driver
-* directly (i.e., not with the RTOS protocol stack), the higher layer
-* software must register its callback functions during initialization. The
-* driver requires callback functions for received frames, for confirmation of
-* transmitted frames, and for asynchronous errors.
-*
-* <b>Interrupts</b>
-*
-* The driver has no dependencies on the interrupt controller. The driver
-* provides two interrupt handlers.  XEmac_IntrHandlerDma() handles interrupts
-* when the EMAC is configured with scatter-gather DMA.  XEmac_IntrHandlerFifo()
-* handles interrupts when the EMAC is configured for direct FIFO I/O or simple
-* DMA.  Either of these routines can be connected to the system interrupt
-* controller by the user.
-*
-* <b>Interrupt Frequency</b>
-*
-* When the EMAC is configured with scatter-gather DMA, the frequency of
-* interrupts can be controlled with the interrupt coalescing features of the
-* scatter-gather DMA engine. The frequency of interrupts can be adjusted using
-* the driver API functions for setting the packet count threshold and the packet
-* wait bound values.
-*
-* The scatter-gather DMA engine only interrupts when the packet count threshold
-* is reached, instead of interrupting for each packet. A packet is a generic
-* term used by the scatter-gather DMA engine, and is equivalent to an Ethernet
-* frame in our case.
-*
-* The packet wait bound is a timer value used during interrupt coalescing to
-* trigger an interrupt when not enough packets have been received to reach the
-* packet count threshold.
-*
-* These values can be tuned by the user to meet their needs. If there appear to
-* be interrupt latency problems or delays in packet arrival that are longer than
-* might be expected, the user should verify that the packet count threshold is
-* set low enough to receive interrupts before the wait bound timer goes off.
-*
-* <b>Device Reset</b>
-*
-* Some errors that can occur in the device require a device reset. These errors
-* are listed in the XEmac_SetErrorHandler() function header. The user's error
-* handler is responsible for resetting the device and re-configuring it based on
-* its needs (the driver does not save the current configuration). When
-* integrating into an RTOS, these reset and re-configure obligations are
-* taken care of by the Xilinx adapter software if it exists for that RTOS.
-*
-* <b>Device Configuration</b>
-*
-* The device can be configured in various ways during the FPGA implementation
-* process.  Configuration parameters are stored in the xemac_g.c files.
-* A table is defined where each entry contains configuration information
-* for an EMAC device.  This information includes such things as the base address
-* of the memory-mapped device, the base addresses of IPIF, DMA, and FIFO modules
-* within the device, and whether the device has DMA, counter registers,
-* multicast support, MII support, and flow control.
-*
-* The driver tries to use the features built into the device. So if, for
-* example, the hardware is configured with scatter-gather DMA, the driver
-* expects to start the scatter-gather channels and expects that the user has set
-* up the buffer descriptor lists already. If the user expects to use the driver
-* in a mode different than how the hardware is configured, the user should
-* modify the configuration table to reflect the mode to be used. Modifying the
-* configuration table is a workaround for now until we get some experience with
-* how users are intending to use the hardware in its different configurations.
-* For example, if the hardware is built with scatter-gather DMA but the user is
-* intending to use only simple DMA, the user either needs to modify the config
-* table as a workaround or rebuild the hardware with only simple DMA. The
-* recommendation at this point is to build the hardware with the features you
-* intend to use. If you're inclined to modify the table, do so before the call
-* to XEmac_Initialize().  Here is a snippet of code that changes a device to
-* simple DMA (the hardware needs to have DMA for this to work of course):
-* <pre>
-*        XEmac_Config *ConfigPtr;
-*
-*        ConfigPtr = XEmac_LookupConfig(DeviceId);
-*        ConfigPtr->IpIfDmaConfig = XEM_CFG_SIMPLE_DMA;
-* </pre>
-*
-* <b>Simple DMA</b>
-*
-* Simple DMA is supported through the FIFO functions, FifoSend and FifoRecv, of
-* the driver (i.e., there is no separate interface for it). The driver makes use
-* of the DMA engine for a simple DMA transfer if the device is configured with
-* DMA, otherwise it uses the FIFOs directly. While the simple DMA interface is
-* therefore transparent to the user, the caching of network buffers is not.
-* If the device is configured with DMA and the FIFO interface is used, the user
-* must ensure that the network buffers are not cached or are cache coherent,
-* since DMA will be used to transfer to and from the Emac device. If the device
-* is configured with DMA and the user really wants to use the FIFOs directly,
-* the user should rebuild the hardware without DMA. If unable to do this, there
-* is a workaround (described above in Device Configuration) to modify the
-* configuration table of the driver to fake the driver into thinking the device
-* has no DMA. A code snippet follows:
-* <pre>
-*        XEmac_Config *ConfigPtr;
-*
-*        ConfigPtr = XEmac_LookupConfig(DeviceId);
-*        ConfigPtr->IpIfDmaConfig = XEM_CFG_NO_DMA;
-* </pre>
-*
-* <b>Asserts</b>
-*
-* Asserts are used within all Xilinx drivers to enforce constraints on argument
-* values. Asserts can be turned off on a system-wide basis by defining, at
-* compile time, the NDEBUG identifier. By default, asserts are turned on and it
-* is recommended that users leave asserts on during development.
-*
-* <b>Building the driver</b>
-*
-* The XEmac driver is composed of several source files. Why so many?  This
-* allows the user to build and link only those parts of the driver that are
-* necessary. Since the EMAC hardware can be configured in various ways (e.g.,
-* with or without DMA), the driver too can be built with varying features.
-* For the most part, this means that besides always linking in xemac.c, you
-* link in only the driver functionality you want. Some of the choices you have
-* are polled vs. interrupt, interrupt with FIFOs only vs. interrupt with DMA,
-* self-test diagnostics, and driver statistics. Note that currently the DMA code
-* must be linked in, even if you don't have DMA in the device.
-*
-* @note
-*
-* Xilinx drivers are typically composed of two components, one is the driver
-* and the other is the adapter.  The driver is independent of OS and processor
-* and is intended to be highly portable.  The adapter is OS-specific and
-* facilitates communication between the driver and an OS.
-* <br><br>
-* This driver is intended to be RTOS and processor independent.  It works
-* with physical addresses only.  Any needs for dynamic memory management,
-* threads or thread mutual exclusion, virtual memory, or cache control must
-* be satisfied by the layer above this driver.
-*
-* <pre>
-* MODIFICATION HISTORY:
-*
-* Ver   Who  Date     Changes
-* ----- ---- -------- -------------------------------------------------------
-* 1.00a rpm  07/31/01 First release
-* 1.00b rpm  02/20/02 Repartitioned files and functions
-* 1.00b rpm  10/08/02 Replaced HasSgDma boolean with IpifDmaConfig enumerated
-*                     configuration parameter
-* 1.00c rpm  12/05/02 New version includes support for simple DMA and the delay
-*                     argument to SgSend
-* 1.00c rpm  02/03/03 The XST_DMA_SG_COUNT_EXCEEDED return code was removed
-*                     from SetPktThreshold in the internal DMA driver. Also
-*                     avoided compiler warnings by initializing Result in the
-*                     DMA interrupt service routines.
-* 1.00d rpm  09/26/03 New version includes support PLB Ethernet and v2.00a of
-*                     the packet fifo driver. Also supports multicast option.
-* 1.00e rmm  04/06/04 SGEND option added, Zero instance memory on init. Changed
-*                     SG DMA callback invokation from once per packet to once
-*                     for all packets received for an interrupt event. Added
-*                     XEmac_GetSgRecvFreeDesc() and GetSgSendFreeDesc()
-*                     functions. Moved some IFG and PHY constants to xemac_l.h.
-* 1.00f rmm  10/19/04 Added programmable CAM address filtering. Added jumbo
-*                     frame support. Added XEmac_PhyReset() function.
-* 1.01a ecm  09/01/05 Added DRE support through Control words in instance which
-*                     are set at initialization.
-*                     Added the config structure items to support separate
-*                     Tx and Rx capabilities..
-* 1.01a wgr  09/14/06 Ported to Linux 2.6
-* 1.11a wgr  03/22/07 Converted to new coding style.
-* </pre>
-*
-******************************************************************************/
-
-#ifndef XEMAC_H			/* prevent circular inclusions */
-#define XEMAC_H			/* by using protection macros */
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-/***************************** Include Files *********************************/
-
-#include "xbasic_types.h"
-#include "xstatus.h"
-#include "xpacket_fifo_v2_00_a.h"	/* Uses v2.00a of Packet Fifo */
-#include "xdma_channel.h"
-
-/************************** Constant Definitions *****************************/
-
-/*
- * Device information
- */
-#define XEM_DEVICE_NAME     "xemac"
-#define XEM_DEVICE_DESC     "Xilinx Ethernet 10/100 MAC"
-
-/** @name Configuration options
- *
- * Device configuration options (see the XEmac_SetOptions() and
- * XEmac_GetOptions() for information on how to use these options)
- * @{
- */
-#define XEM_UNICAST_OPTION        0x00000001UL /**< Unicast addressing
-                                                    (defaults on) */
-#define XEM_BROADCAST_OPTION      0x00000002UL /**< Broadcast addressing
-                                                    (defaults on) */
-#define XEM_PROMISC_OPTION        0x00000004UL /**< Promiscuous addressing
-                                                    (defaults off) */
-#define XEM_FDUPLEX_OPTION        0x00000008UL /**< Full duplex mode
-                                                    (defaults off) */
-#define XEM_POLLED_OPTION         0x00000010UL /**< Polled mode (defaults off) */
-#define XEM_LOOPBACK_OPTION       0x00000020UL /**< Internal loopback mode
-                                                    (defaults off) */
-#define XEM_MULTICAST_OPTION      0x00000040UL /**< Multicast address reception
-                                                    (defaults off) */
-#define XEM_FLOW_CONTROL_OPTION   0x00000080UL /**< Interpret pause frames in
-                                                    full duplex mode (defaults
-                                                    off) */
-#define XEM_INSERT_PAD_OPTION     0x00000100UL /**< Pad short frames on transmit
-                                                    (defaults on) */
-#define XEM_INSERT_FCS_OPTION     0x00000200UL /**< Insert FCS (CRC) on transmit
-                                                    (defaults on) */
-#define XEM_INSERT_ADDR_OPTION    0x00000400UL /**< Insert source address on
-                                                    transmit (defaults on) */
-#define XEM_OVWRT_ADDR_OPTION     0x00000800UL /**< Overwrite source address on
-                                                    transmit. This is only used
-                                                    only used if source address
-                                                    insertion is on (defaults on) */
-#define XEM_NO_SGEND_INT_OPTION   0x00001000UL /**< Disables the SGEND interrupt
-                                                    with SG DMA. Setting this
-                                                    option to ON may help bulk
-                                                    data transfer performance
-                                                    when utilizing higher packet
-                                                    threshold counts on slower
-                                                    systems (default is off) */
-#define XEM_STRIP_PAD_FCS_OPTION  0x00002000UL /**< Strip FCS and padding from
-                                                    received frames (defaults off) */
-#define XEM_JUMBO_OPTION          0x00004000UL /**< Allow reception of Jumbo frames,
-                                                    transmission of Jumbo frames is
-                                                    always enabled.
-                                                    (default is off) */
-#define XEM_MULTICAST_CAM_OPTION  0x00008000UL /**< Allow Rx address filtering
-                                                    for multicast CAM entries
-                                                    (default is off) */
-/*@}*/
-
-/*
- * Some default values for interrupt coalescing within the scatter-gather
- * DMA engine.
- */
-#define XEM_SGDMA_DFT_THRESHOLD     1	/* Default pkt threshold */
-#define XEM_SGDMA_MAX_THRESHOLD     255	/* Maximum pkt theshold */
-#define XEM_SGDMA_DFT_WAITBOUND     5	/* Default pkt wait bound (msec) */
-#define XEM_SGDMA_MAX_WAITBOUND     1023	/* Maximum pkt wait bound (msec) */
-
-/*
- * Direction identifiers. These are used for setting values like packet
- * thresholds and wait bound for specific channels
- */
-#define XEM_SEND    1
-#define XEM_RECV    2
-
-/*
- * Arguments to SgSend function to indicate whether to hold off starting
- * the scatter-gather engine.
- */
-#define XEM_SGDMA_NODELAY     0	/* start SG DMA immediately */
-#define XEM_SGDMA_DELAY       1	/* do not start SG DMA */
-
-/*
- * Constants to determine the configuration of the hardware device. They are
- * used to allow the driver to verify it can operate with the hardware.
- */
-#define XEM_CFG_NO_IPIF             0	/* Not supported by the driver */
-#define XEM_CFG_NO_DMA              1	/* No DMA */
-#define XEM_CFG_SIMPLE_DMA          2	/* Simple DMA */
-#define XEM_CFG_DMA_SG              3	/* DMA scatter gather */
-
-#define XEM_MULTI_CAM_ENTRIES       64	/* Number of storable addresses in
-					   the CAM */
-
-/*
- * The next few constants help upper layers determine the size of memory
- * pools used for Ethernet buffers and descriptor lists.
- */
-#define XEM_MAC_ADDR_SIZE   6	/* six-byte MAC address */
-#define XEM_MTU             1500	/* max size of Ethernet frame */
-#define XEM_JUMBO_MTU       8982	/* max payload size of jumbo frame */
-#define XEM_HDR_SIZE        14	/* size of Ethernet header */
-#define XEM_HDR_VLAN_SIZE   18	/* size of Ethernet header with VLAN */
-#define XEM_TRL_SIZE        4	/* size of Ethernet trailer (FCS) */
-#define XEM_MAX_FRAME_SIZE  (XEM_MTU + XEM_HDR_SIZE + XEM_TRL_SIZE)
-#define XEM_MAX_VLAN_FRAME_SIZE  (XEM_MTU + XEM_HDR_VLAN_SIZE + XEM_TRL_SIZE)
-#define XEM_MAX_JUMBO_FRAME_SIZE (XEM_JUMBO_MTU + XEM_HDR_SIZE + XEM_TRL_SIZE)
-
-/*
- * Define a default number of send and receive buffers
- */
-#define XEM_MIN_RECV_BUFS   32	/* minimum # of recv buffers */
-#define XEM_DFT_RECV_BUFS   64	/* default # of recv buffers */
-
-#define XEM_MIN_SEND_BUFS   16	/* minimum # of send buffers */
-#define XEM_DFT_SEND_BUFS   32	/* default # of send buffers */
-
-#define XEM_MIN_BUFFERS     (XEM_MIN_RECV_BUFS + XEM_MIN_SEND_BUFS)
-#define XEM_DFT_BUFFERS     (XEM_DFT_RECV_BUFS + XEM_DFT_SEND_BUFS)
-
-/*
- * Define the number of send and receive buffer descriptors, used for
- * scatter-gather DMA
- */
-#define XEM_MIN_RECV_DESC   16	/* minimum # of recv descriptors */
-#define XEM_DFT_RECV_DESC   32	/* default # of recv descriptors */
-
-#define XEM_MIN_SEND_DESC   8	/* minimum # of send descriptors */
-#define XEM_DFT_SEND_DESC   16	/* default # of send descriptors */
-
-
-/**************************** Type Definitions *******************************/
-
-/**
- * Ethernet statistics (see XEmac_GetStats() and XEmac_ClearStats())
- */
-typedef struct {
-	u32 XmitFrames;		 /**< Number of frames transmitted */
-	u32 XmitBytes;		 /**< Number of bytes transmitted */
-	u32 XmitLateCollisionErrors;
-				 /**< Number of transmission failures
-                                          due to late collisions */
-	u32 XmitExcessDeferral;	 /**< Number of transmission failures
-                                          due o excess collision deferrals */
-	u32 XmitOverrunErrors;	 /**< Number of transmit overrun errors */
-	u32 XmitUnderrunErrors;	 /**< Number of transmit underrun errors */
-	u32 RecvFrames;		 /**< Number of frames received */
-	u32 RecvBytes;		 /**< Number of bytes received */
-	u32 RecvFcsErrors;	 /**< Number of frames discarded due
-                                          to FCS errors */
-	u32 RecvAlignmentErrors; /**< Number of frames received with
-                                          alignment errors */
-	u32 RecvOverrunErrors;	 /**< Number of frames discarded due
-                                          to overrun errors */
-	u32 RecvUnderrunErrors;	 /**< Number of recv underrun errors */
-	u32 RecvMissedFrameErrors;
-				 /**< Number of frames missed by MAC */
-	u32 RecvCollisionErrors; /**< Number of frames discarded due
-                                          to collisions */
-	u32 RecvLengthFieldErrors;
-				 /**< Number of frames discarded with
-                                          invalid length field */
-	u32 RecvShortErrors;	 /**< Number of short frames discarded */
-	u32 RecvLongErrors;	 /**< Number of long frames discarded */
-	u32 DmaErrors;		 /**< Number of DMA errors since init */
-	u32 FifoErrors;		 /**< Number of FIFO errors since init */
-	u32 RecvInterrupts;	 /**< Number of receive interrupts */
-	u32 XmitInterrupts;	 /**< Number of transmit interrupts */
-	u32 EmacInterrupts;	 /**< Number of MAC (device) interrupts */
-	u32 TotalIntrs;		 /**< Total interrupts */
-} XEmac_Stats;
-
-/**
- * This typedef contains configuration information for a device.
- */
-typedef struct {
-	u16 DeviceId;	    /**< Unique ID  of device */
-	u32 BaseAddress;    /**< Register base address */
-	u32 HasCounters;   /**< Does device have counters? */
-	u8 IpIfDmaConfig;   /**< IPIF/DMA hardware configuration */
-	u32 HasMii;	   /**< Does device support MII? */
-	u32 HasCam;	   /**< Does device have multicast CAM */
-	u32 HasJumbo;	   /**< Can device transfer jumbo frames */
-	u32 TxDre;	   /**< Has data realignment engine on TX channel */
-	u32 RxDre;	   /**< Has data realignment engine on RX channel */
-	u32 TxHwCsum;	   /**< Has checksum offload on TX channel */
-	u32 RxHwCsum;	   /**< Has checksum offload on RX channel */
-} XEmac_Config;
-
-
-/** @name Typedefs for callbacks
- * Callback functions.
- * @{
- */
-/**
- * Callback when data is sent or received with scatter-gather DMA.
- *
- * @param CallBackRef is a callback reference passed in by the upper layer
- *        when setting the callback functions, and passed back to the upper
- *        layer when the callback is invoked.
- * @param BdPtr is a pointer to the first buffer descriptor in a list of
- *        buffer descriptors.
- * @param NumBds is the number of buffer descriptors in the list pointed
- *        to by BdPtr.
- */
-typedef void (*XEmac_SgHandler) (void *CallBackRef, XBufDescriptor * BdPtr,
-				 u32 NumBds);
-
-/**
- * Callback when data is sent or received with direct FIFO communication or
- * simple DMA. The user typically defines two callacks, one for send and one
- * for receive.
- *
- * @param CallBackRef is a callback reference passed in by the upper layer
- *        when setting the callback functions, and passed back to the upper
- *        layer when the callback is invoked.
- */
-typedef void (*XEmac_FifoHandler) (void *CallBackRef);
-
-/**
- * Callback when an asynchronous error occurs.
- *
- * @param CallBackRef is a callback reference passed in by the upper layer
- *        when setting the callback functions, and passed back to the upper
- *        layer when the callback is invoked.
- * @param ErrorCode is a Xilinx error code defined in xstatus.h.  Also see
- *        XEmac_SetErrorHandler() for a description of possible errors.
- */
-typedef void (*XEmac_ErrorHandler) (void *CallBackRef, int ErrorCode);
-
-/*@}*/
-
-/**
- * The XEmac driver instance data. The user is required to allocate a
- * variable of this type for every EMAC device in the system. A pointer
- * to a variable of this type is then passed to the driver API functions.
- */
-typedef struct {
-	XEmac_Config Config;	/* Configuration table entry */
-
-	u32 BaseAddress;	/* Base address (of IPIF) */
-	u32 PhysAddress;	/* Base address, physical  (of IPIF) */
-	u32 IsStarted;		/* Device is currently started */
-	u32 IsReady;		/* Device is initialized and ready */
-	u32 TxDmaControlWord;	/* TX SGDMA channel control word */
-	u32 RxDmaControlWord;	/* RX SGDMA channel control word */
-	u32 IsPolled;		/* Device is in polled mode */
-	u32 HasMulticastHash;	/* Does device support multicast hash table? */
-
-	XEmac_Stats Stats;
-	XPacketFifoV200a RecvFifo;	/* FIFO used to receive frames */
-	XPacketFifoV200a SendFifo;	/* FIFO used to send frames */
-
-	/*
-	 * Callbacks
-	 */
-	XEmac_FifoHandler FifoRecvHandler;	/* for non-DMA/simple DMA interrupts */
-	void *FifoRecvRef;
-	XEmac_FifoHandler FifoSendHandler;	/* for non-DMA/simple DMA interrupts */
-	void *FifoSendRef;
-	XEmac_ErrorHandler ErrorHandler;	/* for asynchronous errors */
-	void *ErrorRef;
-
-	XDmaChannel RecvChannel;	/* DMA receive channel driver */
-	XDmaChannel SendChannel;	/* DMA send channel driver */
-	u32 IsSgEndDisable;	/* Does SG DMA enable SGEND interrupt */
-
-	XEmac_SgHandler SgRecvHandler;	/* callback for scatter-gather DMA */
-	void *SgRecvRef;
-	XEmac_SgHandler SgSendHandler;	/* callback for scatter-gather DMA */
-	void *SgSendRef;
-} XEmac;
-
-
-/***************** Macros (Inline Functions) Definitions *********************/
-/*****************************************************************************/
-/**
-*
-* This macro determines if the device is currently configured for
-* scatter-gather DMA.
-*
-* @param InstancePtr is a pointer to the XEmac instance to be worked on.
-*
-* @return
-*
-* Boolean TRUE if the device is configured for scatter-gather DMA, or FALSE
-* if it is not.
-*
-* @note
-*
-* Signature: u32 XEmac_mIsSgDma(XEmac *InstancePtr)
-*
-******************************************************************************/
-#define XEmac_mIsSgDma(InstancePtr) \
-            ((InstancePtr)->Config.IpIfDmaConfig == XEM_CFG_DMA_SG)
-
-/*****************************************************************************/
-/**
-*
-* This macro determines if the device is currently configured for simple DMA.
-*
-* @param InstancePtr is a pointer to the XEmac instance to be worked on.
-*
-* @return
-*
-* Boolean TRUE if the device is configured for simple DMA, or FALSE otherwise
-*
-* @note
-*
-* Signature: u32 XEmac_mIsSimpleDma(XEmac *InstancePtr)
-*
-******************************************************************************/
-#define XEmac_mIsSimpleDma(InstancePtr) \
-            ((InstancePtr)->Config.IpIfDmaConfig == XEM_CFG_SIMPLE_DMA)
-
-/*****************************************************************************/
-/**
-*
-* This macro determines if the device is currently configured with DMA (either
-* simple DMA or scatter-gather DMA)
-*
-* @param InstancePtr is a pointer to the XEmac instance to be worked on.
-*
-* @return
-*
-* Boolean TRUE if the device is configured with DMA, or FALSE otherwise
-*
-* @note
-*
-* Signature: u32 XEmac_mIsDma(XEmac *InstancePtr)
-*
-******************************************************************************/
-#define XEmac_mIsDma(InstancePtr) \
-            (XEmac_mIsSimpleDma(InstancePtr) || XEmac_mIsSgDma(InstancePtr))
-
-/*****************************************************************************/
-/**
-*
-* This macro determines if the device has CAM option for storing additional
-* receive filters for multicast or unicast addresses.
-*
-* @param InstancePtr is a pointer to the XEmac instance to be worked on.
-*
-* @return
-*
-* Boolean TRUE if the device is configured with the CAM, or FALSE otherwise
-*
-* @note
-*
-* Signature: u32 XEmac_mHasCam(XEmac *InstancePtr)
-*
-******************************************************************************/
-#define XEmac_mHasCam(InstancePtr) \
-    (((InstancePtr)->ConfigPtr->HasCam == 1) ? TRUE : FALSE)
-
-/*****************************************************************************/
-/**
-*
-* This macro determines if the device has the MII option for communications
-* with a PHY.
-*
-* @param InstancePtr is a pointer to the XEmac instance to be worked on.
-*
-* @return
-*
-* Boolean TRUE if the device is configured with MII, or FALSE otherwise
-*
-* @note
-*
-* Signature: u32 XEmac_mHasMii(XEmac *InstancePtr)
-*
-******************************************************************************/
-#define XEmac_mHasMii(InstancePtr) \
-    (((InstancePtr)->Config.HasMii == 1) ? TRUE : FALSE)
-
-/*****************************************************************************/
-/**
-*
-* This macro determines if the device has the option to transfer jumbo sized
-* frames.
-*
-* @param InstancePtr is a pointer to the XEmac instance to be worked on.
-*
-* @return
-*
-* Boolean TRUE if the device is configured with jubmo frame capability, or
-* FALSE otherwise
-*
-* @note
-*
-* Signature: u32 XEmac_mHasJumbo(XEmac *InstancePtr)
-*
-******************************************************************************/
-#define XEmac_mHasJumbo(InstancePtr) \
-    (((InstancePtr)->ConfigPtr->HasJumbo == 1) ? TRUE : FALSE)
-
-/*****************************************************************************/
-/**
-*
-* This macro determines if the device is configured with the Data Realignment
-* Engine (DRE)
-*
-* @param InstancePtr is a pointer to the XEmac instance to be worked on.
-*
-* @return
-*
-* Boolean TRUE if the device is configured with TX DRE, or FALSE otherwise.
-* Note that earlier versions do not have DRE capability so this macro always
-* returns FALSE.
-*
-* @note
-*
-* Signature: u32 XEmac_mIsTxDre(XEmac *InstancePtr)
-*
-******************************************************************************/
-#define XEmac_mIsTxDre(InstancePtr)                                         \
-    (((InstancePtr)->Config.TxDre != 0) ? TRUE : FALSE)
-
-/*****************************************************************************/
-/**
-*
-* This macro determines if the device is configured with the Data Realignment
-* Engine (DRE)
-*
-* @param InstancePtr is a pointer to the XEmac instance to be worked on.
-*
-* @return
-*
-* Boolean TRUE if the device is configured with RX DRE, or FALSE otherwise.
-* Note that earlier versions do not have DRE capability so this macro always
-* returns FALSE.
-*
-* @note
-*
-* Signature: u32 XEmac_mIsRxDre(XEmac *InstancePtr)
-*
-******************************************************************************/
-#define XEmac_mIsRxDre(InstancePtr)                                         \
-    (((InstancePtr)->Config.RxDre != 0) ? TRUE : FALSE)
-
-/*****************************************************************************/
-/**
-*
-* This macro determines if the device is configured with the Checksum offload
-* functionality
-*
-* @param InstancePtr is a pointer to the XEmac instance to be worked on.
-*
-* @return
-*
-* Boolean TRUE if the device is configured with TX CSum, or FALSE otherwise.
-* Note that earlier versions do not have CSum capability so this macro always
-* returns FALSE.
-*
-* @note
-*
-* Signature: u32 XEmac_mIsTxHwCsum(XEmac *InstancePtr)
-*
-******************************************************************************/
-#define XEmac_mIsTxHwCsum(InstancePtr)                                         \
-    (((InstancePtr)->Config.TxHwCsum == 1) ? TRUE : FALSE)
-/*****************************************************************************/
-/**
-*
-* This macro determines if the device is configured with the Checksum offload
-* functionality
-*
-* @param InstancePtr is a pointer to the XEmac instance to be worked on.
-*
-* @return
-*
-* Boolean TRUE if the device is configured with RX CSum, or FALSE otherwise.
-* Note that earlier versions do not have CSum capability so this macro always
-* returns FALSE.
-*
-* @note
-*
-* Signature: u32 XEmac_mIsRxHwCsum(XEmac *InstancePtr)
-*
-******************************************************************************/
-#define XEmac_mIsRxHwCsum(InstancePtr)                                         \
-    (((InstancePtr)->Config.RxHwCsum == 1) ? TRUE : FALSE)
-
-/*****************************************************************************/
-/**
-*
-* This macro enables the TxHwCsum for the EMAC
-*
-* @param InstancePtr is a pointer to the XEmac instance to be worked on.
-*
-* @return
-*
-* none
-*
-* @note
-*
-* Signature: void XEmac_mEnableTxHwCsum(XEmac *InstancePtr)
-*
-******************************************************************************/
-#define XEmac_mEnableTxHwCsum(InstancePtr)                                    \
-        ((InstancePtr)->TxDmaControlWord |= XDC_DMACR_CS_OFFLOAD_MASK);
-
-/*****************************************************************************/
-/**
-*
-* This macro disables the TxHwCsum for the EMAC
-*
-* @param InstancePtr is a pointer to the XEmac instance to be worked on.
-*
-* @return
-*
-* none
-*
-* @note
-*
-* Signature: void XEmac_mDisableTxHwCsum(XEmac *InstancePtr)
-*
-******************************************************************************/
-#define XEmac_mDisableTxHwCsum(InstancePtr)                                    \
-        ((InstancePtr)->TxDmaControlWord &= ~XDC_DMACR_CS_OFFLOAD_MASK);
-
-/*****************************************************************************/
-/**
-*
-* This macro disables the Global interrupt for the EMAC
-*
-* @param InstancePtr is a pointer to the XEmac instance to be worked on.
-*
-* @return
-*
-* none
-*
-* @note
-*
-* Signature: void XEmac_mDisableGIE(XEmac *InstancePtr)
-*
-******************************************************************************/
-#define XEmac_mDisableGIE(InstancePtr)                                           \
-    XIIF_V123B_GINTR_DISABLE((InstancePtr)->BaseAddress);
-
-/*****************************************************************************/
-/**
-*
-* This macro enables the Global interrupt for the EMAC
-*
-* @param InstancePtr is a pointer to the XEmac instance to be worked on.
-*
-* @return
-*
-* none
-*
-* @note
-*
-* Signature: void XEmac_mEnableGIE(XEmac *InstancePtr)
-*
-******************************************************************************/
-#define XEmac_mEnableGIE(InstancePtr)                                           \
-    XIIF_V123B_GINTR_ENABLE((InstancePtr)->BaseAddress);
-
-/************************** Function Prototypes ******************************/
-
-int XEmac_CfgInitialize(XEmac * InstancePtr, XEmac_Config * CfgPtr,
-			u32 VirtualAddress);
-int XEmac_Start(XEmac * InstancePtr);
-int XEmac_Stop(XEmac * InstancePtr);
-void XEmac_Reset(XEmac * InstancePtr);
-
-/*
- * Diagnostic functions in xemac_selftest.c
- */
-int XEmac_SelfTest(XEmac * InstancePtr);
-
-/*
- * Polled functions in xemac_polled.c
- */
-int XEmac_PollSend(XEmac * InstancePtr, u8 *BufPtr, u32 ByteCount);
-int XEmac_PollRecv(XEmac * InstancePtr, u8 *BufPtr, u32 *ByteCountPtr);
-
-/*
- * Interrupts with scatter-gather DMA functions in xemac_intr_dma.c
- */
-int XEmac_SgSend(XEmac * InstancePtr, XBufDescriptor * BdPtr, int Delay);
-int XEmac_SgRecv(XEmac * InstancePtr, XBufDescriptor * BdPtr);
-int XEmac_SetPktThreshold(XEmac * InstancePtr, u32 Direction, u8 Threshold);
-int XEmac_GetPktThreshold(XEmac * InstancePtr, u32 Direction, u8 *ThreshPtr);
-int XEmac_SetPktWaitBound(XEmac * InstancePtr, u32 Direction, u32 TimerValue);
-int XEmac_GetPktWaitBound(XEmac * InstancePtr, u32 Direction, u32 *WaitPtr);
-int XEmac_SetSgRecvSpace(XEmac * InstancePtr, u32 *MemoryPtr,
-			 u32 ByteCount, void *PhyPtr);
-int XEmac_SetSgSendSpace(XEmac * InstancePtr, u32 *MemoryPtr,
-			 u32 ByteCount, void *PhyPtr);
-void XEmac_SetSgRecvHandler(XEmac * InstancePtr, void *CallBackRef,
-			    XEmac_SgHandler FuncPtr);
-void XEmac_SetSgSendHandler(XEmac * InstancePtr, void *CallBackRef,
-			    XEmac_SgHandler FuncPtr);
-unsigned XEmac_GetSgSendFreeDesc(XEmac * InstancePtr);
-unsigned XEmac_GetSgRecvFreeDesc(XEmac * InstancePtr);
-
-void XEmac_IntrHandlerDma(void *InstancePtr);	/* interrupt handler */
-
-/*
- * Interrupts with direct FIFO functions in xemac_intr_fifo.c. Also used
- * for simple DMA.
- */
-int XEmac_FifoSend(XEmac * InstancePtr, u8 *BufPtr, u32 ByteCount);
-int XEmac_FifoRecv(XEmac * InstancePtr, u8 *BufPtr, u32 *ByteCountPtr);
-void XEmac_SetFifoRecvHandler(XEmac * InstancePtr, void *CallBackRef,
-			      XEmac_FifoHandler FuncPtr);
-void XEmac_SetFifoSendHandler(XEmac * InstancePtr, void *CallBackRef,
-			      XEmac_FifoHandler FuncPtr);
-
-void XEmac_IntrHandlerFifo(void *InstancePtr);	/* interrupt handler */
-
-/*
- * General interrupt-related functions in xemac_intr.c
- */
-void XEmac_SetErrorHandler(XEmac * InstancePtr, void *CallBackRef,
-			   XEmac_ErrorHandler FuncPtr);
-
-/*
- * MAC configuration in xemac_options.c
- */
-int XEmac_SetOptions(XEmac * InstancePtr, u32 OptionFlag);
-u32 XEmac_GetOptions(XEmac * InstancePtr);
-int XEmac_SetMacAddress(XEmac * InstancePtr, u8 *AddressPtr);
-void XEmac_GetMacAddress(XEmac * InstancePtr, u8 *BufferPtr);
-int XEmac_SetInterframeGap(XEmac * InstancePtr, u8 Part1, u8 Part2);
-void XEmac_GetInterframeGap(XEmac * InstancePtr, u8 *Part1Ptr, u8 *Part2Ptr);
-
-/*
- * Multicast functions in xemac_multicast.c
- */
-int XEmac_MulticastAdd(XEmac * InstancePtr, u8 *AddressPtr, int Entry);
-int XEmac_MulticastClear(XEmac * InstancePtr, int Entry);
-
-/*
- * PHY configuration in xemac_phy.c
- */
-void XEmac_PhyReset(XEmac * InstancePtr);
-int XEmac_PhyRead(XEmac * InstancePtr, u32 PhyAddress,
-		  u32 RegisterNum, u16 *PhyDataPtr);
-int XEmac_PhyWrite(XEmac * InstancePtr, u32 PhyAddress,
-		   u32 RegisterNum, u16 PhyData);
-
-/*
- * Statistics in xemac_stats.c
- */
-void XEmac_GetStats(XEmac * InstancePtr, XEmac_Stats * StatsPtr);
-void XEmac_ClearStats(XEmac * InstancePtr);
-
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif /* end of protection macro */
diff --git a/drivers/net/ethernet/xilinx/xilinx_emac/xemac_hw.h b/drivers/net/ethernet/xilinx/xilinx_emac/xemac_hw.h
deleted file mode 100644
index d25e7f8..0000000
--- a/drivers/net/ethernet/xilinx/xilinx_emac/xemac_hw.h
+++ /dev/null
@@ -1,490 +0,0 @@
-/* $Id: xemac_hw.h,v 1.1 2007/04/04 18:27:45 wre Exp $ */
-/******************************************************************************
-*
-*       XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS"
-*       AS A COURTESY TO YOU, SOLELY FOR USE IN DEVELOPING PROGRAMS AND
-*       SOLUTIONS FOR XILINX DEVICES.  BY PROVIDING THIS DESIGN, CODE,
-*       OR INFORMATION AS ONE POSSIBLE IMPLEMENTATION OF THIS FEATURE,
-*       APPLICATION OR STANDARD, XILINX IS MAKING NO REPRESENTATION
-*       THAT THIS IMPLEMENTATION IS FREE FROM ANY CLAIMS OF INFRINGEMENT,
-*       AND YOU ARE RESPONSIBLE FOR OBTAINING ANY RIGHTS YOU MAY REQUIRE
-*       FOR YOUR IMPLEMENTATION.  XILINX EXPRESSLY DISCLAIMS ANY
-*       WARRANTY WHATSOEVER WITH RESPECT TO THE ADEQUACY OF THE
-*       IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OR
-*       REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE FROM CLAIMS OF
-*       INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
-*       FOR A PARTICULAR PURPOSE.
-*
-*       (c) Copyright 2003-2006 Xilinx Inc.
-*       All rights reserved.
-*
-******************************************************************************/
-/*****************************************************************************/
-/**
-*
-* @file xemac_hw.h
-*
-* This header file contains identifiers and low-level driver functions (or
-* macros) that can be used to access the device.  High-level driver functions
-* are defined in xemac.h.
-*
-* <pre>
-* MODIFICATION HISTORY:
-*
-* Ver   Who  Date     Changes
-* ----- ---- -------- -----------------------------------------------
-* 1.00b rpm  04/26/02 First release
-* 1.00b rmm  09/23/02 Added XEmac_mPhyReset macro
-* 1.00c rpm  12/05/02 New version includes support for simple DMA
-* 1.00d rpm  09/26/03 New version includes support PLB Ethernet and v2.00a of
-*                     the packet fifo driver.
-* 1.00e rmm  04/06/04 Relocated IFG and MGT max values from 'c' files to this
-*                     one.
-* 1.00f rmm  10/19/04 Added constants for CAM address filtering & jumbo frame
-*                     support.
-* 1.01a rpm  03/08/06 Fixed EMIR TYPE mask
-* 1.11a wgr  03/22/07 Converted to new coding style.
-* </pre>
-*
-******************************************************************************/
-
-#ifndef XEMAC_HW_H		/* prevent circular inclusions */
-#define XEMAC_HW_H		/* by using protection macros */
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-/***************************** Include Files *********************************/
-
-#include "xbasic_types.h"
-#include "xio.h"
-
-/************************** Constant Definitions *****************************/
-
-/* Offset of the MAC registers from the IPIF base address */
-#define XEM_REG_OFFSET     0x1100UL
-
-/*
- * Register offsets for the Ethernet MAC. Each register is 32 bits.
- */
-#define XEM_EMIR_OFFSET   (XEM_REG_OFFSET + 0x0)	/* EMAC Module ID */
-#define XEM_ECR_OFFSET    (XEM_REG_OFFSET + 0x4)	/* MAC Control */
-#define XEM_IFGP_OFFSET   (XEM_REG_OFFSET + 0x8)	/* Interframe Gap */
-#define XEM_SAH_OFFSET    (XEM_REG_OFFSET + 0xC)	/* Station addr, high */
-#define XEM_SAL_OFFSET    (XEM_REG_OFFSET + 0x10)	/* Station addr, low */
-#define XEM_MGTCR_OFFSET  (XEM_REG_OFFSET + 0x14)	/* MII mgmt control */
-#define XEM_MGTDR_OFFSET  (XEM_REG_OFFSET + 0x18)	/* MII mgmt data */
-#define XEM_RPLR_OFFSET   (XEM_REG_OFFSET + 0x1C)	/* Rx packet length */
-#define XEM_TPLR_OFFSET   (XEM_REG_OFFSET + 0x20)	/* Tx packet length */
-#define XEM_TSR_OFFSET    (XEM_REG_OFFSET + 0x24)	/* Tx status */
-#define XEM_RMFC_OFFSET   (XEM_REG_OFFSET + 0x28)	/* Rx missed frames */
-#define XEM_RCC_OFFSET    (XEM_REG_OFFSET + 0x2C)	/* Rx collisions */
-#define XEM_RFCSEC_OFFSET (XEM_REG_OFFSET + 0x30)	/* Rx FCS errors */
-#define XEM_RAEC_OFFSET   (XEM_REG_OFFSET + 0x34)	/* Rx alignment errors */
-#define XEM_TEDC_OFFSET   (XEM_REG_OFFSET + 0x38)	/* Transmit excess
-							 * deferral cnt */
-#define XEM_CAMH_OFFSET   (XEM_REG_OFFSET + 0x40)	/* CAM address, high */
-#define XEM_CAML_OFFSET   (XEM_REG_OFFSET + 0x44)	/* CAM address, low */
-
-/*
- * Register offsets for the IPIF components
- */
-#define XEM_ISR_OFFSET           0x20UL	/* Interrupt status */
-
-#define XEM_DMA_OFFSET           0x2300UL
-#define XEM_DMA_SEND_OFFSET      (XEM_DMA_OFFSET + 0x0)	/* DMA send channel */
-#define XEM_DMA_RECV_OFFSET      (XEM_DMA_OFFSET + 0x40)	/* DMA recv channel */
-
-#define XEM_PFIFO_OFFSET         0x2000UL
-#define XEM_PFIFO_TXREG_OFFSET   (XEM_PFIFO_OFFSET + 0x0)	/* Tx registers */
-#define XEM_PFIFO_RXREG_OFFSET   (XEM_PFIFO_OFFSET + 0x10)	/* Rx registers */
-#define XEM_PFIFO_TXDATA_OFFSET  (XEM_PFIFO_OFFSET + 0x100)	/* Tx keyhole */
-#define XEM_PFIFO_RXDATA_OFFSET  (XEM_PFIFO_OFFSET + 0x200)	/* Rx keyhole */
-
-/*
- * EMAC Module Identification Register (EMIR)
- */
-#define XEM_EMIR_VERSION_MASK    0xFFFF0000UL	/* Device version */
-#define XEM_EMIR_ID_MASK         0x0000FF00UL	/* Device ID */
-#define XEM_EMIR_TYPE_MASK       0x000000FFUL	/* Device type */
-
-/*
- * EMAC Control Register (ECR)
- */
-#define XEM_ECR_FULL_DUPLEX_MASK         0x80000000UL	/* Full duplex mode */
-#define XEM_ECR_XMIT_RESET_MASK          0x40000000UL	/* Reset transmitter */
-#define XEM_ECR_XMIT_ENABLE_MASK         0x20000000UL	/* Enable transmitter */
-#define XEM_ECR_RECV_RESET_MASK          0x10000000UL	/* Reset receiver */
-#define XEM_ECR_RECV_ENABLE_MASK         0x08000000UL	/* Enable receiver */
-#define XEM_ECR_PHY_ENABLE_MASK          0x04000000UL	/* Enable PHY */
-#define XEM_ECR_XMIT_PAD_ENABLE_MASK     0x02000000UL	/* Enable xmit pad insert */
-#define XEM_ECR_XMIT_FCS_ENABLE_MASK     0x01000000UL	/* Enable xmit FCS insert */
-#define XEM_ECR_XMIT_ADDR_INSERT_MASK    0x00800000UL	/* Enable xmit source addr
-							 * insertion */
-#define XEM_ECR_XMIT_ERROR_INSERT_MASK   0x00400000UL	/* Insert xmit error */
-#define XEM_ECR_XMIT_ADDR_OVWRT_MASK     0x00200000UL	/* Enable xmit source addr
-							 * overwrite */
-#define XEM_ECR_LOOPBACK_MASK            0x00100000UL	/* Enable internal
-							 * loopback */
-#define XEM_ECR_RECV_STRIP_ENABLE_MASK   0x00080000UL	/* Enable recv pad/fcs strip */
-#define XEM_ECR_UNICAST_ENABLE_MASK      0x00020000UL	/* Enable unicast addr */
-#define XEM_ECR_MULTI_ENABLE_MASK        0x00010000UL	/* Enable multicast addr */
-#define XEM_ECR_BROAD_ENABLE_MASK        0x00008000UL	/* Enable broadcast addr */
-#define XEM_ECR_PROMISC_ENABLE_MASK      0x00004000UL	/* Enable promiscuous mode */
-#define XEM_ECR_RECV_ALL_MASK            0x00002000UL	/* Receive all frames */
-#define XEM_ECR_RECV_JUMBO_ENABLE_MASK   0x00001000UL	/* Enable jumbo frame
-							   reception */
-#define XEM_ECR_CAM_ENABLE_MASK          0x00000800UL	/* Enable multicast CAM
-							   filtering */
-#define XEM_ECR_PAUSE_FRAME_MASK         0x00000400UL	/* Interpret pause frames */
-#define XEM_ECR_WRITE_CAM_MASK           0x00000100UL	/* Add address to multicast
-							   CAM */
-
-/*
- * Interframe Gap Register (IFGR)
- */
-#define XEM_IFGP_PART1_MASK         0xF8000000UL	/* Interframe Gap Part1 */
-#define XEM_IFGP_PART1_SHIFT        27
-#define XEM_IFGP_PART2_MASK         0x07C00000UL	/* Interframe Gap Part2 */
-#define XEM_IFGP_PART2_SHIFT        22
-#define XEM_IFGP_PART1_MAX          31	/* Max IFG 1 value */
-#define XEM_IFGP_PART2_MAX          31	/* Max IFG 2 value */
-
-/*
- * Station Address High Register (SAH)
- */
-#define XEM_SAH_ADDR_MASK           0x0000FFFFUL	/* Station address high bytes */
-
-/*
- * Station Address Low Register (SAL)
- */
-#define XEM_SAL_ADDR_MASK           0xFFFFFFFFUL	/* Station address low bytes */
-
-/*
- * MII Management Control Register (MGTCR)
- */
-#define XEM_MGTCR_START_MASK        0x80000000UL	/* Start/Busy */
-#define XEM_MGTCR_RW_NOT_MASK       0x40000000UL	/* Read/Write Not (direction) */
-#define XEM_MGTCR_PHY_ADDR_MASK     0x3E000000UL	/* PHY address */
-#define XEM_MGTCR_PHY_ADDR_SHIFT    25	/* PHY address shift */
-#define XEM_MGTCR_REG_ADDR_MASK     0x01F00000UL	/* Register address */
-#define XEM_MGTCR_REG_ADDR_SHIFT    20	/* Register addr shift */
-#define XEM_MGTCR_MII_ENABLE_MASK   0x00080000UL	/* Enable MII from EMAC */
-#define XEM_MGTCR_RD_ERROR_MASK     0x00040000UL	/* MII mgmt read error */
-#define XEM_MGTCR_MAX_PHY_ADDR      31	/* Maximum PHY address */
-#define XEM_MGTCR_MAX_PHY_REG       31	/* Maximum PHY register number */
-
-
-/*
- * MII Management Data Register (MGTDR)
- */
-#define XEM_MGTDR_DATA_MASK         0x0000FFFFUL	/* MII data */
-
-/*
- * Receive Packet Length Register (RPLR)
- */
-#define XEM_RPLR_LENGTH_MASK        0x0000FFFFUL	/* Receive packet length */
-
-/*
- * Transmit Packet Length Register (TPLR)
- */
-#define XEM_TPLR_LENGTH_MASK        0x0000FFFFUL	/* Transmit packet length */
-
-/*
- * Transmit Status Register (TSR)
- */
-#define XEM_TSR_EXCESS_DEFERRAL_MASK 0x80000000UL	/* Transmit excess deferral */
-#define XEM_TSR_FIFO_UNDERRUN_MASK   0x40000000UL	/* Packet FIFO underrun */
-#define XEM_TSR_ATTEMPTS_MASK        0x3E000000UL	/* Transmission attempts */
-#define XEM_TSR_LATE_COLLISION_MASK  0x01000000UL	/* Transmit late collision */
-
-/*
- * Receive Missed Frame Count (RMFC)
- */
-#define XEM_RMFC_DATA_MASK          0x0000FFFFUL
-
-/*
- * Receive Collision Count (RCC)
- */
-#define XEM_RCC_DATA_MASK           0x0000FFFFUL
-
-/*
- * Receive FCS Error Count (RFCSEC)
- */
-#define XEM_RFCSEC_DATA_MASK        0x0000FFFFUL
-
-/*
- * Receive Alignment Error Count (RALN)
- */
-#define XEM_RAEC_DATA_MASK          0x0000FFFFUL
-
-/*
- * Transmit Excess Deferral Count (TEDC)
- */
-#define XEM_TEDC_DATA_MASK          0x0000FFFFUL
-
-/*
- * CAM high (CAMH)
- */
-#define XEM_CAMH_CAM_MASK           0x0000FFFFUL
-#define XEM_CAMH_SLOT_MASK          0x003F0000UL
-#define XEM_CAMH_SLOT_SHIFT         16
-
-/*
- * EMAC Interrupt Registers (Status and Enable) masks. These registers are
- * part of the IPIF IP Interrupt registers
- */
-#define XEM_EIR_XMIT_DONE_MASK         0x00000001UL	/* Xmit complete */
-#define XEM_EIR_RECV_DONE_MASK         0x00000002UL	/* Recv complete */
-#define XEM_EIR_XMIT_ERROR_MASK        0x00000004UL	/* Xmit error */
-#define XEM_EIR_RECV_ERROR_MASK        0x00000008UL	/* Recv error */
-#define XEM_EIR_XMIT_SFIFO_EMPTY_MASK  0x00000010UL	/* Xmit status fifo empty */
-#define XEM_EIR_RECV_LFIFO_EMPTY_MASK  0x00000020UL	/* Recv length fifo empty */
-#define XEM_EIR_XMIT_LFIFO_FULL_MASK   0x00000040UL	/* Xmit length fifo full */
-#define XEM_EIR_RECV_LFIFO_OVER_MASK   0x00000080UL	/* Recv length fifo
-							 * overrun */
-#define XEM_EIR_RECV_LFIFO_UNDER_MASK  0x00000100UL	/* Recv length fifo
-							 * underrun */
-#define XEM_EIR_XMIT_SFIFO_OVER_MASK   0x00000200UL	/* Xmit status fifo
-							 * overrun */
-#define XEM_EIR_XMIT_SFIFO_UNDER_MASK  0x00000400UL	/* Transmit status fifo
-							 * underrun */
-#define XEM_EIR_XMIT_LFIFO_OVER_MASK   0x00000800UL	/* Transmit length fifo
-							 * overrun */
-#define XEM_EIR_XMIT_LFIFO_UNDER_MASK  0x00001000UL	/* Transmit length fifo
-							 * underrun */
-#define XEM_EIR_XMIT_PAUSE_MASK        0x00002000UL	/* Transmit pause pkt
-							 * received */
-#define XEM_EIR_RECV_DFIFO_OVER_MASK   0x00004000UL	/* Receive data fifo
-							 * overrun */
-#define XEM_EIR_RECV_MISSED_FRAME_MASK 0x00008000UL	/* Receive missed frame
-							 * error */
-#define XEM_EIR_RECV_COLLISION_MASK    0x00010000UL	/* Receive collision
-							 * error */
-#define XEM_EIR_RECV_FCS_ERROR_MASK    0x00020000UL	/* Receive FCS error */
-#define XEM_EIR_RECV_LEN_ERROR_MASK    0x00040000UL	/* Receive length field
-							 * error */
-#define XEM_EIR_RECV_SHORT_ERROR_MASK  0x00080000UL	/* Receive short frame
-							 * error */
-#define XEM_EIR_RECV_LONG_ERROR_MASK   0x00100000UL	/* Receive long frame
-							 * error */
-#define XEM_EIR_RECV_ALIGN_ERROR_MASK  0x00200000UL	/* Receive alignment
-							 * error */
-
-
-/**************************** Type Definitions *******************************/
-
-/***************** Macros (Inline Functions) Definitions *********************/
-
-/*****************************************************************************
-*
-* Low-level driver macros and functions. The list below provides signatures
-* to help the user use the macros.
-*
-* u32 XEmac_mReadReg(u32 BaseAddress, int RegOffset)
-* void XEmac_mWriteReg(u32 BaseAddress, int RegOffset, u32 Mask)
-*
-* void XEmac_mSetControlReg(u32 BaseAddress, u32 Mask)
-* void XEmac_mSetMacAddress(u32 BaseAddress, u8 *AddressPtr)
-*
-* void XEmac_mEnable(u32 BaseAddress)
-* void XEmac_mDisable(u32 BaseAddress)
-*
-* u32 XEmac_mIsTxDone(u32 BaseAddress)
-* u32 XEmac_mIsRxEmpty(u32 BaseAddress)
-*
-* void XEmac_SendFrame(u32 BaseAddress, u8 *FramePtr, int Size)
-* int XEmac_RecvFrame(u32 BaseAddress, u8 *FramePtr)
-*
-*****************************************************************************/
-
-/****************************************************************************/
-/**
-*
-* Read the given register.
-*
-* @param    BaseAddress is the base address of the device
-* @param    RegOffset is the register offset to be read
-*
-* @return   The 32-bit value of the register
-*
-* @note     None.
-*
-*****************************************************************************/
-#define XEmac_mReadReg(BaseAddress, RegOffset) \
-                    XIo_In32((BaseAddress) + (RegOffset))
-
-
-/****************************************************************************/
-/**
-*
-* Write the given register.
-*
-* @param    BaseAddress is the base address of the device
-* @param    RegOffset is the register offset to be written
-* @param    Data is the 32-bit value to write to the register
-*
-* @return   None.
-*
-* @note     None.
-*
-*****************************************************************************/
-#define XEmac_mWriteReg(BaseAddress, RegOffset, Data) \
-                    XIo_Out32((BaseAddress) + (RegOffset), (Data))
-
-
-/****************************************************************************/
-/**
-*
-* Set the contents of the control register. Use the XEM_ECR_* constants
-* defined above to create the bit-mask to be written to the register.
-*
-* @param    BaseAddress is the base address of the device
-* @param    Mask is the 16-bit value to write to the control register
-*
-* @return   None.
-*
-* @note     None.
-*
-*****************************************************************************/
-#define XEmac_mSetControlReg(BaseAddress, Mask) \
-                    XIo_Out32((BaseAddress) + XEM_ECR_OFFSET, (Mask))
-
-
-/****************************************************************************/
-/**
-*
-* Set the station address of the EMAC device.
-*
-* @param    BaseAddress is the base address of the device
-* @param    AddressPtr is a pointer to a 6-byte MAC address
-*
-* @return   None.
-*
-* @note     None.
-*
-*****************************************************************************/
-#define XEmac_mSetMacAddress(BaseAddress, AddressPtr)               \
-{                                                                   \
-    u32 MacAddr;                                                \
-                                                                    \
-    MacAddr = ((AddressPtr)[0] << 8) | (AddressPtr)[1];             \
-    XIo_Out32((BaseAddress) + XEM_SAH_OFFSET, MacAddr);             \
-                                                                    \
-    MacAddr = ((AddressPtr)[2] << 24) | ((AddressPtr)[3] << 16) |   \
-              ((AddressPtr)[4] << 8) | (AddressPtr)[5];             \
-                                                                    \
-    XIo_Out32((BaseAddress) + XEM_SAL_OFFSET, MacAddr);             \
-}
-
-
-/****************************************************************************/
-/**
-*
-* Enable the transmitter and receiver. Preserve the contents of the control
-* register.
-*
-* @param    BaseAddress is the base address of the device
-*
-* @return   None.
-*
-* @note     None.
-*
-*****************************************************************************/
-#define XEmac_mEnable(BaseAddress) \
-{ \
-    u32 Control; \
-    Control = XIo_In32((BaseAddress) + XEM_ECR_OFFSET); \
-    Control &= ~(XEM_ECR_XMIT_RESET_MASK | XEM_ECR_RECV_RESET_MASK); \
-    Control |= (XEM_ECR_XMIT_ENABLE_MASK | XEM_ECR_RECV_ENABLE_MASK); \
-    XIo_Out32((BaseAddress) + XEM_ECR_OFFSET, Control); \
-}
-
-
-/****************************************************************************/
-/**
-*
-* Disable the transmitter and receiver. Preserve the contents of the control
-* register.
-*
-* @param    BaseAddress is the base address of the device
-*
-* @return   None.
-*
-* @note     None.
-*
-*****************************************************************************/
-#define XEmac_mDisable(BaseAddress) \
-                XIo_Out32((BaseAddress) + XEM_ECR_OFFSET, \
-                    XIo_In32((BaseAddress) + XEM_ECR_OFFSET) & \
-                    ~(XEM_ECR_XMIT_ENABLE_MASK | XEM_ECR_RECV_ENABLE_MASK))
-
-
-/****************************************************************************/
-/**
-*
-* Check to see if the transmission is complete.
-*
-* @param    BaseAddress is the base address of the device
-*
-* @return   TRUE if it is done, or FALSE if it is not.
-*
-* @note     None.
-*
-*****************************************************************************/
-#define XEmac_mIsTxDone(BaseAddress) \
-             (XIo_In32((BaseAddress) + XEM_ISR_OFFSET) & XEM_EIR_XMIT_DONE_MASK)
-
-
-/****************************************************************************/
-/**
-*
-* Check to see if the receive FIFO is empty.
-*
-* @param    BaseAddress is the base address of the device
-*
-* @return   TRUE if it is empty, or FALSE if it is not.
-*
-* @note     None.
-*
-*****************************************************************************/
-#define XEmac_mIsRxEmpty(BaseAddress) \
-          (!(XIo_In32((BaseAddress) + XEM_ISR_OFFSET) & XEM_EIR_RECV_DONE_MASK))
-
-
-/****************************************************************************/
-/**
-*
-* Reset MII compliant PHY
-*
-* @param    BaseAddress is the base address of the device
-*
-* @return   None.
-*
-* @note     None.
-*
-*****************************************************************************/
-#define XEmac_mPhyReset(BaseAddress) \
-{ \
-    u32 Control;                                    \
-    Control = XIo_In32((BaseAddress) + XEM_ECR_OFFSET); \
-    Control &= ~XEM_ECR_PHY_ENABLE_MASK;                \
-    XIo_Out32((BaseAddress) + XEM_ECR_OFFSET, Control); \
-    Control |= XEM_ECR_PHY_ENABLE_MASK;                 \
-    XIo_Out32((BaseAddress) + XEM_ECR_OFFSET, Control); \
-}
-
-
-/************************** Function Prototypes ******************************/
-
-void XEmac_SendFrame(u32 BaseAddress, u8 *FramePtr, int Size);
-int XEmac_RecvFrame(u32 BaseAddress, u8 *FramePtr);
-
-
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif /* end of protection macro */
diff --git a/drivers/net/ethernet/xilinx/xilinx_emac/xemac_i.h b/drivers/net/ethernet/xilinx/xilinx_emac/xemac_i.h
deleted file mode 100644
index 2ab9f12..0000000
--- a/drivers/net/ethernet/xilinx/xilinx_emac/xemac_i.h
+++ /dev/null
@@ -1,758 +0,0 @@
-/* $Id: xemac_i.h,v 1.2 2007/05/15 00:52:28 wre Exp $ */
-/******************************************************************************
-*
-*       XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS"
-*       AS A COURTESY TO YOU, SOLELY FOR USE IN DEVELOPING PROGRAMS AND
-*       SOLUTIONS FOR XILINX DEVICES.  BY PROVIDING THIS DESIGN, CODE,
-*       OR INFORMATION AS ONE POSSIBLE IMPLEMENTATION OF THIS FEATURE,
-*       APPLICATION OR STANDARD, XILINX IS MAKING NO REPRESENTATION
-*       THAT THIS IMPLEMENTATION IS FREE FROM ANY CLAIMS OF INFRINGEMENT,
-*       AND YOU ARE RESPONSIBLE FOR OBTAINING ANY RIGHTS YOU MAY REQUIRE
-*       FOR YOUR IMPLEMENTATION.  XILINX EXPRESSLY DISCLAIMS ANY
-*       WARRANTY WHATSOEVER WITH RESPECT TO THE ADEQUACY OF THE
-*       IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OR
-*       REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE FROM CLAIMS OF
-*       INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
-*       FOR A PARTICULAR PURPOSE.
-*
-*       (c) Copyright 2003 Xilinx Inc.
-*       All rights reserved.
-*
-******************************************************************************/
-/*****************************************************************************/
-/**
-*
-* @file xemac_i.h
-*
-* This header file contains internal identifiers, which are those shared
-* between XEmac components.  The identifiers in this file are not intended for
-* use external to the driver.
-*
-* <pre>
-* MODIFICATION HISTORY:
-*
-* Ver   Who  Date     Changes
-* ----- ---- -------- -----------------------------------------------
-* 1.00a rpm  07/31/01 First release
-* 1.00b rpm  02/20/02 Repartitioned files and functions
-* 1.00b rpm  04/29/02 Moved register definitions to xemac_hw.h
-* 1.00c rpm  12/05/02 New version includes support for simple DMA
-* 1.00d rpm  09/26/03 New version includes support PLB Ethernet and v2.00a of
-*                     the packet fifo driver.
-* 1.01a ecm  09/01/05 Added DRE support through separate SgSendDRE specific
-*                     define, XEM_DRE_SEND_BD_MASK.
-* 1.11a wgr  03/22/07 Converted to new coding style.
-* </pre>
-*
-******************************************************************************/
-
-#ifndef XEMAC_I_H		/* prevent circular inclusions */
-#define XEMAC_I_H		/* by using protection macros */
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-/***************************** Include Files *********************************/
-
-#include "xemac.h"
-#include "xemac_hw.h"
-
-/******************************************************************************
- *
- * Definitions transferred from the IPIF library header file.
- *
- ******************************************************************************/
-/** @name Register Offsets
- *
- * The following constants define the register offsets for the registers of the
- * IPIF, there are some holes in the memory map for reserved addresses to allow
- * other registers to be added and still match the memory map of the interrupt
- * controller registers
- * @{
- */
-#define XEMAC_DISR_OFFSET     0UL  /**< device interrupt status register */
-#define XEMAC_DIPR_OFFSET     4UL  /**< device interrupt pending register */
-#define XEMAC_DIER_OFFSET     8UL  /**< device interrupt enable register */
-#define XEMAC_DIIR_OFFSET     24UL /**< device interrupt ID register */
-#define XEMAC_DGIER_OFFSET    28UL /**< device global interrupt enable register */
-#define XEMAC_IISR_OFFSET     32UL /**< IP interrupt status register */
-#define XEMAC_IIER_OFFSET     40UL /**< IP interrupt enable register */
-#define XEMAC_RESETR_OFFSET   64UL /**< reset register */
-/* @} */
-
-/**
- * The value used for the reset register to reset the IPIF
- */
-#define XEMAC_RESET_MASK             0xAUL
-
-/**
- * The following constant is used for the device global interrupt enable
- * register, to enable all interrupts for the device, this is the only bit
- * in the register
- */
-#define XEMAC_GINTR_ENABLE_MASK      0x80000000UL
-
-/**
- * The mask to identify each internal IPIF error condition in the device
- * registers of the IPIF. Interrupts are assigned in the register from LSB
- * to the MSB
- */
-#define XEMAC_ERROR_MASK             1UL     /**< LSB of the register */
-
-/** @name Interrupt IDs
- *
- * The interrupt IDs which identify each internal IPIF condition, this value
- * must correlate with the mask constant for the error
- * @{
- */
-#define XEMAC_ERROR_INTERRUPT_ID     0    /**< interrupt bit #, (LSB = 0) */
-#define XEMAC_NO_INTERRUPT_ID        128  /**< no interrupts are pending */
-/* @} */
-
-/**************************** Type Definitions *******************************/
-
-
-/***************** Macros (Inline Functions) Definitions *********************/
-
-
-/*****************************************************************************/
-/**
-*
-* Reset the IPIF component and hardware.  This is a destructive operation that
-* could cause the loss of data since resetting the IPIF of a device also
-* resets the device using the IPIF and any blocks, such as FIFOs or DMA
-* channels, within the IPIF.  All registers of the IPIF will contain their
-* reset value when this function returns.
-*
-* @param RegBaseAddress contains the base address of the IPIF registers.
-*
-* @return   None
-*
-* @note     None
-*
-******************************************************************************/
-#define XEMAC_RESET(RegBaseAddress) \
-    XIo_Out32(RegBaseAddress + XEMAC_RESETR_OFFSET, XEMAC_RESET_MASK)
-
-/*****************************************************************************/
-/**
-*
-* This macro sets the device interrupt status register to the value.
-* This register indicates the status of interrupt sources for a device
-* which contains the IPIF.  The status is independent of whether interrupts
-* are enabled and could be used for polling a device at a higher level rather
-* than a more detailed level.
-*
-* Each bit of the register correlates to a specific interrupt source within the
-* device which contains the IPIF.  With the exception of some internal IPIF
-* conditions, the contents of this register are not latched but indicate
-* the live status of the interrupt sources within the device.  Writing any of
-* the non-latched bits of the register will have no effect on the register.
-*
-* For the latched bits of this register only, setting a bit which is zero
-* within this register causes an interrupt to generated.  The device global
-* interrupt enable register and the device interrupt enable register must be set
-* appropriately to allow an interrupt to be passed out of the device. The
-* interrupt is cleared by writing to this register with the bits to be
-* cleared set to a one and all others to zero.  This register implements a
-* toggle on write functionality meaning any bits which are set in the value
-* written cause the bits in the register to change to the opposite state.
-*
-* This function writes the specified value to the register such that
-* some bits may be set and others cleared.  It is the caller's responsibility
-* to get the value of the register prior to setting the value to prevent a
-* destructive behavior.
-*
-* @param RegBaseAddress contains the base address of the IPIF registers.
-*
-* @param Status contains the value to be written to the interrupt status
-*        register of the device.  The only bits which can be written are
-*        the latched bits which contain the internal IPIF conditions.  The
-*        following values may be used to set the status register or clear an
-*        interrupt condition.
-*        - XEMAC_ERROR_MASK     Indicates a device error in the IPIF
-*
-* @return   None.
-*
-* @note     None.
-*
-******************************************************************************/
-#define XEMAC_WRITE_DISR(RegBaseAddress, Status) \
-    XIo_Out32((RegBaseAddress) + XEMAC_DISR_OFFSET, (Status))
-
-/*****************************************************************************/
-/**
-*
-* This macro gets the device interrupt status register contents.
-* This register indicates the status of interrupt sources for a device
-* which contains the IPIF.  The status is independent of whether interrupts
-* are enabled and could be used for polling a device at a higher level.
-*
-* Each bit of the register correlates to a specific interrupt source within the
-* device which contains the IPIF.  With the exception of some internal IPIF
-* conditions, the contents of this register are not latched but indicate
-* the live status of the interrupt sources within the device.
-*
-* For only the latched bits of this register, the interrupt may be cleared by
-* writing to these bits in the status register.
-*
-* @param    RegBaseAddress contains the base address of the IPIF registers.
-*
-* @return
-*
-* A status which contains the value read from the interrupt status register of
-* the device. The bit definitions are specific to the device with
-* the exception of the latched internal IPIF condition bits. The following
-* values may be used to detect internal IPIF conditions in the status.
-* <br><br>
-* - XEMAC_ERROR_MASK     Indicates a device error in the IPIF
-*
-* @note
-*
-* None.
-*
-******************************************************************************/
-#define XEMAC_READ_DISR(RegBaseAddress) \
-    XIo_In32((RegBaseAddress) + XEMAC_DISR_OFFSET)
-
-/*****************************************************************************/
-/**
-*
-* This function sets the device interrupt enable register contents.
-* This register controls which interrupt sources of the device are allowed to
-* generate an interrupt.  The device global interrupt enable register must also
-* be set appropriately for an interrupt to be passed out of the device.
-*
-* Each bit of the register correlates to a specific interrupt source within the
-* device which contains the IPIF.  Setting a bit in this register enables that
-* interrupt source to generate an interrupt.  Clearing a bit in this register
-* disables interrupt generation for that interrupt source.
-*
-* This function writes only the specified value to the register such that
-* some interrupts source may be enabled and others disabled.  It is the
-* caller's responsibility to get the value of the interrupt enable register
-* prior to setting the value to prevent an destructive behavior.
-*
-* An interrupt source may not be enabled to generate an interrupt, but can
-* still be polled in the interrupt status register.
-*
-* @param    RegBaseAddress contains the base address of the IPIF registers.
-*
-* @param
-*
-* Enable contains the value to be written to the interrupt enable register
-* of the device.  The bit definitions are specific to the device with
-* the exception of the internal IPIF conditions. The following
-* values may be used to enable the internal IPIF conditions interrupts.
-*   - XEMAC_ERROR_MASK     Indicates a device error in the IPIF
-*
-* @return
-*
-* None.
-*
-* @note
-*
-* Signature: Xuint32 XEMAC_WRITE_DIER(Xuint32 RegBaseAddress,
-*                                          Xuint32 Enable)
-*
-******************************************************************************/
-#define XEMAC_WRITE_DIER(RegBaseAddress, Enable) \
-    XIo_Out32((RegBaseAddress) + XEMAC_DIER_OFFSET, (Enable))
-
-/*****************************************************************************/
-/**
-*
-* This function gets the device interrupt enable register contents.
-* This register controls which interrupt sources of the device
-* are allowed to generate an interrupt.  The device global interrupt enable
-* register and the device interrupt enable register must also be set
-* appropriately for an interrupt to be passed out of the device.
-*
-* Each bit of the register correlates to a specific interrupt source within the
-* device which contains the IPIF.  Setting a bit in this register enables that
-* interrupt source to generate an interrupt if the global enable is set
-* appropriately.  Clearing a bit in this register disables interrupt generation
-* for that interrupt source regardless of the global interrupt enable.
-*
-* @param    RegBaseAddress contains the base address of the IPIF registers.
-*
-* @return
-*
-* The value read from the interrupt enable register of the device.  The bit
-* definitions are specific to the device with the exception of the internal
-* IPIF conditions. The following values may be used to determine from the
-* value if the internal IPIF conditions interrupts are enabled.
-* <br><br>
-* - XEMAC_ERROR_MASK     Indicates a device error in the IPIF
-*
-* @note
-*
-* None.
-*
-******************************************************************************/
-#define XEMAC_READ_DIER(RegBaseAddress) \
-    XIo_In32((RegBaseAddress) + XEMAC_DIER_OFFSET)
-
-/*****************************************************************************/
-/**
-*
-* This function gets the device interrupt pending register contents.
-* This register indicates the pending interrupt sources, those that are waiting
-* to be serviced by the software, for a device which contains the IPIF.
-* An interrupt must be enabled in the interrupt enable register of the IPIF to
-* be pending.
-*
-* Each bit of the register correlates to a specific interrupt source within the
-* the device which contains the IPIF.  With the exception of some internal IPIF
-* conditions, the contents of this register are not latched since the condition
-* is latched in the IP interrupt status register, by an internal block of the
-* IPIF such as a FIFO or DMA channel, or by the IP of the device.  This register
-* is read only and is not latched, but it is necessary to acknowledge (clear)
-* the interrupt condition by performing the appropriate processing for the IP
-* or block within the IPIF.
-*
-* This register can be thought of as the contents of the interrupt status
-* register ANDed with the contents of the interrupt enable register.
-*
-* @param RegBaseAddress contains the base address of the IPIF registers.
-*
-* @return
-*
-* The value read from the interrupt pending register of the device.  The bit
-* definitions are specific to the device with the exception of the latched
-* internal IPIF condition bits. The following values may be used to detect
-* internal IPIF conditions in the value.
-* <br><br>
-* - XEMAC_ERROR_MASK     Indicates a device error in the IPIF
-*
-* @note
-*
-* None.
-*
-******************************************************************************/
-#define XEMAC_READ_DIPR(RegBaseAddress) \
-    XIo_In32((RegBaseAddress) + XEMAC_DIPR_OFFSET)
-
-/*****************************************************************************/
-/**
-*
-* This macro gets the device interrupt ID for the highest priority interrupt
-* which is pending from the interrupt ID register. This function provides
-* priority resolution such that faster interrupt processing is possible.
-* Without priority resolution, it is necessary for the software to read the
-* interrupt pending register and then check each interrupt source to determine
-* if an interrupt is pending.  Priority resolution becomes more important as the
-* number of interrupt sources becomes larger.
-*
-* Interrupt priorities are based upon the bit position of the interrupt in the
-* interrupt pending register with bit 0 being the highest priority. The
-* interrupt ID is the priority of the interrupt, 0 - 31, with 0 being the
-* highest priority. The interrupt ID register is live rather than latched such
-* that multiple calls to this function may not yield the same results.  A
-* special value, outside of the interrupt priority range of 0 - 31, is
-* contained in the register which indicates that no interrupt is pending.  This
-* may be useful for allowing software to continue processing interrupts in a
-* loop until there are no longer any interrupts pending.
-*
-* The interrupt ID is designed to allow a function pointer table to be used
-* in the software such that the interrupt ID is used as an index into that
-* table.  The function pointer table could contain an instance pointer, such
-* as to DMA channel, and a function pointer to the function which handles
-* that interrupt.  This design requires the interrupt processing of the device
-* driver to be partitioned into smaller more granular pieces based upon
-* hardware used by the device, such as DMA channels and FIFOs.
-*
-* It is not mandatory that this function be used by the device driver software.
-* It may choose to read the pending register and resolve the pending interrupt
-* priorities on it's own.
-*
-* @param RegBaseAddress contains the base address of the IPIF registers.
-*
-* @return
-*
-* An interrupt ID, 0 - 31, which identifies the highest priority interrupt
-* which is pending.  A value of XIIF_NO_INTERRUPT_ID indicates that there is
-* no interrupt pending. The following values may be used to identify the
-* interrupt ID for the internal IPIF interrupts.
-* <br><br>
-* - XEMAC_ERROR_INTERRUPT_ID     Indicates a device error in the IPIF
-*
-* @note
-*
-* None.
-*
-******************************************************************************/
-#define XEMAC_READ_DIIR(RegBaseAddress) \
-    XIo_In32((RegBaseAddress) + XEMAC_DIIR_OFFSET)
-
-/*****************************************************************************/
-/**
-*
-* This function disables all interrupts for the device by writing to the global
-* interrupt enable register.  This register provides the ability to disable
-* interrupts without any modifications to the interrupt enable register such
-* that it is minimal effort to restore the interrupts to the previous enabled
-* state.  The corresponding function, XIpIf_GlobalIntrEnable, is provided to
-* restore the interrupts to the previous enabled state.  This function is
-* designed to be used in critical sections of device drivers such that it is
-* not necessary to disable other device interrupts.
-*
-* @param RegBaseAddress contains the base address of the IPIF registers.
-*
-* @return
-*
-* None.
-*
-* @note
-*
-* None.
-*
-******************************************************************************/
-#define XEMAC_GINTR_DISABLE(RegBaseAddress) \
-    XIo_Out32((RegBaseAddress) + XEMAC_DGIER_OFFSET, 0)
-
-/*****************************************************************************/
-/**
-*
-* This function writes to the global interrupt enable register to enable
-* interrupts from the device.  This register provides the ability to enable
-* interrupts without any modifications to the interrupt enable register such
-* that it is minimal effort to restore the interrupts to the previous enabled
-* state.  This function does not enable individual interrupts as the interrupt
-* enable register must be set appropriately.  This function is designed to be
-* used in critical sections of device drivers such that it is not necessary to
-* disable other device interrupts.
-*
-* @param RegBaseAddress contains the base address of the IPIF registers.
-*
-* @return
-*
-* None.
-*
-* @note
-*
-* None.
-*
-******************************************************************************/
-#define XEMAC_GINTR_ENABLE(RegBaseAddress)           \
-    XIo_Out32((RegBaseAddress) + XEMAC_DGIER_OFFSET, \
-               XEMAC_GINTR_ENABLE_MASK)
-
-/*****************************************************************************/
-/**
-*
-* This function determines if interrupts are enabled at the global level by
-* reading the global interrupt register. This register provides the ability to
-* disable interrupts without any modifications to the interrupt enable register
-* such that it is minimal effort to restore the interrupts to the previous
-* enabled state.
-*
-* @param RegBaseAddress contains the base address of the IPIF registers.
-*
-* @return
-*
-* XTRUE if interrupts are enabled for the IPIF, XFALSE otherwise.
-*
-* @note
-*
-* None.
-*
-******************************************************************************/
-#define XEMAC_IS_GINTR_ENABLED(RegBaseAddress)             \
-    (XIo_In32((RegBaseAddress) + XEMAC_DGIER_OFFSET) ==    \
-              XEMAC_GINTR_ENABLE_MASK)
-
-/*****************************************************************************/
-/**
-*
-* This function sets the IP interrupt status register to the specified value.
-* This register indicates the status of interrupt sources for the IP of the
-* device.  The IP is defined as the part of the device that connects to the
-* IPIF.  The status is independent of whether interrupts are enabled such that
-* the status register may also be polled when interrupts are not enabled.
-*
-* Each bit of the register correlates to a specific interrupt source within the
-* IP.  All bits of this register are latched. Setting a bit which is zero
-* within this register causes an interrupt to be generated.  The device global
-* interrupt enable register and the device interrupt enable register must be set
-* appropriately to allow an interrupt to be passed out of the device. The
-* interrupt is cleared by writing to this register with the bits to be
-* cleared set to a one and all others to zero.  This register implements a
-* toggle on write functionality meaning any bits which are set in the value
-* written cause the bits in the register to change to the opposite state.
-*
-* This function writes only the specified value to the register such that
-* some status bits may be set and others cleared.  It is the caller's
-* responsibility to get the value of the register prior to setting the value
-* to prevent an destructive behavior.
-*
-* @param RegBaseAddress contains the base address of the IPIF registers.
-*
-* @param Status contains the value to be written to the IP interrupt status
-*        register.  The bit definitions are specific to the device IP.
-*
-* @return
-*
-* None.
-*
-* @note
-*
-* None.
-*
-******************************************************************************/
-#define XEMAC_WRITE_IISR(RegBaseAddress, Status) \
-    XIo_Out32((RegBaseAddress) + XEMAC_IISR_OFFSET, (Status))
-
-/*****************************************************************************/
-/**
-*
-* This macro gets the contents of the IP interrupt status register.
-* This register indicates the status of interrupt sources for the IP of the
-* device.  The IP is defined as the part of the device that connects to the
-* IPIF. The status is independent of whether interrupts are enabled such
-* that the status register may also be polled when interrupts are not enabled.
-*
-* Each bit of the register correlates to a specific interrupt source within the
-* device.  All bits of this register are latched.  Writing a 1 to a bit within
-* this register causes an interrupt to be generated if enabled in the interrupt
-* enable register and the global interrupt enable is set.  Since the status is
-* latched, each status bit must be acknowledged in order for the bit in the
-* status register to be updated.  Each bit can be acknowledged by writing a
-* 0 to the bit in the status register.
-*
-* @param RegBaseAddress contains the base address of the IPIF registers.
-*
-* @return
-*
-* A status which contains the value read from the IP interrupt status register.
-* The bit definitions are specific to the device IP.
-*
-* @note
-*
-* None.
-*
-******************************************************************************/
-#define XEMAC_READ_IISR(RegBaseAddress) \
-    XIo_In32((RegBaseAddress) + XEMAC_IISR_OFFSET)
-
-/*****************************************************************************/
-/**
-*
-* This macro sets the IP interrupt enable register contents.  This register
-* controls which interrupt sources of the IP are allowed to generate an
-* interrupt.  The global interrupt enable register and the device interrupt
-* enable register must also be set appropriately for an interrupt to be
-* passed out of the device containing the IPIF and the IP.
-*
-* Each bit of the register correlates to a specific interrupt source within the
-* IP.  Setting a bit in this register enables the interrupt source to generate
-* an interrupt.  Clearing a bit in this register disables interrupt generation
-* for that interrupt source.
-*
-* This function writes only the specified value to the register such that
-* some interrupt sources may be enabled and others disabled.  It is the
-* caller's responsibility to get the value of the interrupt enable register
-* prior to setting the value to prevent an destructive behavior.
-*
-* @param RegBaseAddress contains the base address of the IPIF registers.
-*
-* @param Enable contains the value to be written to the IP interrupt enable
-*        register. The bit definitions are specific to the device IP.
-*
-* @return
-*
-* None.
-*
-* @note
-*
-* None.
-*
-******************************************************************************/
-#define XEMAC_WRITE_IIER(RegBaseAddress, Enable) \
-    XIo_Out32((RegBaseAddress) + XEMAC_IIER_OFFSET, (Enable))
-
-/*****************************************************************************/
-/**
-*
-* This macro gets the IP interrupt enable register contents.  This register
-* controls which interrupt sources of the IP are allowed to generate an
-* interrupt.  The global interrupt enable register and the device interrupt
-* enable register must also be set appropriately for an interrupt to be
-* passed out of the device containing the IPIF and the IP.
-*
-* Each bit of the register correlates to a specific interrupt source within the
-* IP.  Setting a bit in this register enables the interrupt source to generate
-* an interrupt.  Clearing a bit in this register disables interrupt generation
-* for that interrupt source.
-*
-* @param RegBaseAddress contains the base address of the IPIF registers.
-*
-* @return
-*
-* The contents read from the IP interrupt enable register.  The bit definitions
-* are specific to the device IP.
-*
-* @note
-*
-* Signature: Xuint32 XEMAC_READ_IIER(Xuint32 RegBaseAddress)
-*
-******************************************************************************/
-#define XEMAC_READ_IIER(RegBaseAddress) \
-    XIo_In32((RegBaseAddress) + XEMAC_IIER_OFFSET)
-
-
-/******************************************************************************
- *
- * End of transferred IPIF definitions.
- *
- ******************************************************************************/
-
-/************************** Constant Definitions *****************************/
-
-/*
- * Default buffer descriptor control word masks. The default send BD control
- * is set for incrementing the source address by one for each byte transferred,
- * and specify that the destination address (FIFO) is local to the device. The
- * default receive BD control is set for incrementing the destination address
- * by one for each byte transferred, and specify that the source address is
- * local to the device.
- */
-#define XEM_DFT_SEND_BD_MASK    (XDC_DMACR_SOURCE_INCR_MASK | \
-                                 XDC_DMACR_DEST_LOCAL_MASK)
-#define XEM_DFT_RECV_BD_MASK    (XDC_DMACR_DEST_INCR_MASK |  \
-                                 XDC_DMACR_SOURCE_LOCAL_MASK)
-
-/*
- * Masks for the IPIF Device Interrupt enable and status registers.
- */
-#define XEM_IPIF_EMAC_MASK      0x00000004UL	/* MAC interrupt */
-#define XEM_IPIF_SEND_DMA_MASK  0x00000008UL	/* Send DMA interrupt */
-#define XEM_IPIF_RECV_DMA_MASK  0x00000010UL	/* Receive DMA interrupt */
-#define XEM_IPIF_RECV_FIFO_MASK 0x00000020UL	/* Receive FIFO interrupt */
-#define XEM_IPIF_SEND_FIFO_MASK 0x00000040UL	/* Send FIFO interrupt */
-
-/*
- * Default IPIF Device Interrupt mask when configured for DMA
- */
-#define XEM_IPIF_DMA_DFT_MASK   (XEM_IPIF_SEND_DMA_MASK |   \
-                                 XEM_IPIF_RECV_DMA_MASK |   \
-                                 XEM_IPIF_EMAC_MASK |       \
-                                 XEM_IPIF_SEND_FIFO_MASK |  \
-                                 XEM_IPIF_RECV_FIFO_MASK)
-
-/*
- * Default IPIF Device Interrupt mask when configured without DMA
- */
-#define XEM_IPIF_FIFO_DFT_MASK  (XEM_IPIF_EMAC_MASK |       \
-                                 XEM_IPIF_SEND_FIFO_MASK |  \
-                                 XEM_IPIF_RECV_FIFO_MASK)
-
-#define XEM_IPIF_DMA_DEV_INTR_COUNT   7	/* Number of interrupt sources */
-#define XEM_IPIF_FIFO_DEV_INTR_COUNT  5	/* Number of interrupt sources */
-#define XEM_IPIF_DEVICE_INTR_COUNT  7	/* Number of interrupt sources */
-#define XEM_IPIF_IP_INTR_COUNT      22	/* Number of MAC interrupts */
-
-
-/* a mask for all transmit interrupts, used in polled mode */
-#define XEM_EIR_XMIT_ALL_MASK   (XEM_EIR_XMIT_DONE_MASK |           \
-                                 XEM_EIR_XMIT_ERROR_MASK |          \
-                                 XEM_EIR_XMIT_SFIFO_EMPTY_MASK |    \
-                                 XEM_EIR_XMIT_LFIFO_FULL_MASK)
-
-/* a mask for all receive interrupts, used in polled mode */
-#define XEM_EIR_RECV_ALL_MASK   (XEM_EIR_RECV_DONE_MASK |           \
-                                 XEM_EIR_RECV_ERROR_MASK |          \
-                                 XEM_EIR_RECV_LFIFO_EMPTY_MASK |    \
-                                 XEM_EIR_RECV_LFIFO_OVER_MASK |     \
-                                 XEM_EIR_RECV_LFIFO_UNDER_MASK |    \
-                                 XEM_EIR_RECV_DFIFO_OVER_MASK |     \
-                                 XEM_EIR_RECV_MISSED_FRAME_MASK |   \
-                                 XEM_EIR_RECV_COLLISION_MASK |      \
-                                 XEM_EIR_RECV_FCS_ERROR_MASK |      \
-                                 XEM_EIR_RECV_LEN_ERROR_MASK |      \
-                                 XEM_EIR_RECV_SHORT_ERROR_MASK |    \
-                                 XEM_EIR_RECV_LONG_ERROR_MASK |     \
-                                 XEM_EIR_RECV_ALIGN_ERROR_MASK)
-
-/* a default interrupt mask for scatter-gather DMA operation */
-#define XEM_EIR_DFT_SG_MASK    (XEM_EIR_RECV_ERROR_MASK |           \
-                                XEM_EIR_RECV_LFIFO_OVER_MASK |      \
-                                XEM_EIR_RECV_LFIFO_UNDER_MASK |     \
-                                XEM_EIR_XMIT_SFIFO_OVER_MASK |      \
-                                XEM_EIR_XMIT_SFIFO_UNDER_MASK |     \
-                                XEM_EIR_XMIT_LFIFO_OVER_MASK |      \
-                                XEM_EIR_XMIT_LFIFO_UNDER_MASK |     \
-                                XEM_EIR_RECV_DFIFO_OVER_MASK |      \
-                                XEM_EIR_RECV_MISSED_FRAME_MASK |    \
-                                XEM_EIR_RECV_COLLISION_MASK |       \
-                                XEM_EIR_RECV_FCS_ERROR_MASK |       \
-                                XEM_EIR_RECV_LEN_ERROR_MASK |       \
-                                XEM_EIR_RECV_SHORT_ERROR_MASK |     \
-                                XEM_EIR_RECV_LONG_ERROR_MASK |      \
-                                XEM_EIR_RECV_ALIGN_ERROR_MASK)
-
-/* a default interrupt mask for non-DMA operation (direct FIFOs) */
-#define XEM_EIR_DFT_FIFO_MASK  (XEM_EIR_XMIT_DONE_MASK |            \
-                                XEM_EIR_RECV_DONE_MASK |            \
-                                XEM_EIR_DFT_SG_MASK)
-
-
-/*
- * Mask for the DMA interrupt enable and status registers when configured
- * for scatter-gather DMA.
- */
-#define XEM_DMA_SG_INTR_MASK    (XDC_IXR_DMA_ERROR_MASK  |      \
-                                 XDC_IXR_PKT_THRESHOLD_MASK |   \
-                                 XDC_IXR_PKT_WAIT_BOUND_MASK |  \
-                                 XDC_IXR_SG_END_MASK)
-
-
-/**************************** Type Definitions *******************************/
-
-/***************** Macros (Inline Functions) Definitions *********************/
-
-
-/*****************************************************************************/
-/*
-*
-* Clears a structure of given size, in bytes, by setting each byte to 0.
-*
-* @param StructPtr is a pointer to the structure to be cleared.
-* @param NumBytes is the number of bytes in the structure.
-*
-* @return
-*
-* None.
-*
-* @note
-*
-* Signature: void XEmac_mClearStruct(u8 *StructPtr, unsigned int NumBytes)
-*
-******************************************************************************/
-#define XEmac_mClearStruct(StructPtr, NumBytes)     \
-{                                                   \
-    u32 i;                                          \
-    u8 *BytePtr = (u8 *)(StructPtr);        \
-    for (i=0; i < (unsigned int)(NumBytes); i++)    \
-    {                                               \
-        *BytePtr++ = 0;                             \
-    }                                               \
-}
-
-/************************** Variable Definitions *****************************/
-
-extern XEmac_Config XEmac_ConfigTable[];
-
-/************************** Function Prototypes ******************************/
-
-void XEmac_CheckEmacError(XEmac * InstancePtr, u32 IntrStatus);
-void XEmac_CheckFifoRecvError(XEmac * InstancePtr);
-void XEmac_CheckFifoSendError(XEmac * InstancePtr);
-
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif /* end of protection macro */
diff --git a/drivers/net/ethernet/xilinx/xilinx_emac/xemac_intr.c b/drivers/net/ethernet/xilinx/xilinx_emac/xemac_intr.c
deleted file mode 100644
index 330ef70..0000000
--- a/drivers/net/ethernet/xilinx/xilinx_emac/xemac_intr.c
+++ /dev/null
@@ -1,389 +0,0 @@
-/* $Id: xemac_intr.c,v 1.2 2007/05/15 00:52:28 wre Exp $ */
-/******************************************************************************
-*
-*       XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS"
-*       AS A COURTESY TO YOU, SOLELY FOR USE IN DEVELOPING PROGRAMS AND
-*       SOLUTIONS FOR XILINX DEVICES.  BY PROVIDING THIS DESIGN, CODE,
-*       OR INFORMATION AS ONE POSSIBLE IMPLEMENTATION OF THIS FEATURE,
-*       APPLICATION OR STANDARD, XILINX IS MAKING NO REPRESENTATION
-*       THAT THIS IMPLEMENTATION IS FREE FROM ANY CLAIMS OF INFRINGEMENT,
-*       AND YOU ARE RESPONSIBLE FOR OBTAINING ANY RIGHTS YOU MAY REQUIRE
-*       FOR YOUR IMPLEMENTATION.  XILINX EXPRESSLY DISCLAIMS ANY
-*       WARRANTY WHATSOEVER WITH RESPECT TO THE ADEQUACY OF THE
-*       IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OR
-*       REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE FROM CLAIMS OF
-*       INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
-*       FOR A PARTICULAR PURPOSE.
-*
-*       (c) Copyright 2003 Xilinx Inc.
-*       All rights reserved.
-*
-******************************************************************************/
-/*****************************************************************************/
-/**
-*
-* @file xemac_intr.c
-*
-* This file contains general interrupt-related functions of the XEmac driver.
-*
-* <pre>
-* MODIFICATION HISTORY:
-*
-* Ver   Who  Date     Changes
-* ----- ---- -------- -----------------------------------------------
-* 1.00a rpm  07/31/01 First release
-* 1.00b rpm  02/20/02 Repartitioned files and functions
-* 1.00c rpm  12/05/02 New version includes support for simple DMA
-* 1.00c rpm  03/31/03 Added comment to indicate that no Receive Length FIFO
-*                     overrun interrupts occur in v1.00l and later of the EMAC
-*                     device. This avoids the need to reset the device on
-*                     receive overruns.
-* 1.00d rpm  09/26/03 New version includes support PLB Ethernet and v2.00a of
-*                     the packet fifo driver.
-* 1.11a wgr  03/22/07 Converted to new coding style.
-* </pre>
-*
-******************************************************************************/
-
-/***************************** Include Files *********************************/
-
-#include "xbasic_types.h"
-#include "xemac_i.h"
-#include "xio.h"
-
-/************************** Constant Definitions *****************************/
-
-
-/**************************** Type Definitions *******************************/
-
-
-/***************** Macros (Inline Functions) Definitions *********************/
-
-
-/************************** Variable Definitions *****************************/
-
-
-/************************** Function Prototypes ******************************/
-
-
-/*****************************************************************************/
-/**
-*
-* Set the callback function for handling asynchronous errors.  The upper layer
-* software should call this function during initialization.
-*
-* The error callback is invoked by the driver within interrupt context, so it
-* needs to do its job quickly. If there are potentially slow operations within
-* the callback, these should be done at task-level.
-*
-* The Xilinx errors that must be handled by the callback are:
-* - XST_DMA_ERROR indicates an unrecoverable DMA error occurred. This is
-*   typically a bus error or bus timeout. The handler must reset and
-*   re-configure the device.
-* - XST_FIFO_ERROR indicates an unrecoverable FIFO error occurred. This is a
-*   deadlock condition in the packet FIFO. The handler must reset and
-*   re-configure the device.
-* - XST_RESET_ERROR indicates an unrecoverable MAC error occurred, usually an
-*   overrun or underrun. The handler must reset and re-configure the device.
-* - XST_DMA_SG_NO_LIST indicates an attempt was made to access a scatter-gather
-*   DMA list that has not yet been created.
-* - XST_DMA_SG_LIST_EMPTY indicates the driver tried to get a descriptor from
-*   the receive descriptor list, but the list was empty.
-*
-* @param InstancePtr is a pointer to the XEmac instance to be worked on.
-* @param CallBackRef is a reference pointer to be passed back to the driver in
-*        the callback. This helps the driver correlate the callback to a
-*        particular driver.
-* @param FuncPtr is the pointer to the callback function.
-*
-* @return
-*
-* None.
-*
-* @note
-*
-* None.
-*
-******************************************************************************/
-void XEmac_SetErrorHandler(XEmac * InstancePtr, void *CallBackRef,
-			   XEmac_ErrorHandler FuncPtr)
-{
-	XASSERT_VOID(InstancePtr != NULL);
-	XASSERT_VOID(FuncPtr != NULL);
-	XASSERT_VOID(InstancePtr->IsReady == XCOMPONENT_IS_READY);
-
-	InstancePtr->ErrorHandler = FuncPtr;
-	InstancePtr->ErrorRef = CallBackRef;
-}
-
-/****************************************************************************/
-/*
-*
-* Check the interrupt status bits of the Ethernet MAC for errors. Errors
-* currently handled are:
-* - Receive length FIFO overrun. Indicates data was lost due to the receive
-*   length FIFO becoming full during the reception of a packet. Only a device
-*   reset clears this condition.
-* - Receive length FIFO underrun. An attempt to read an empty FIFO. Only a
-*   device reset clears this condition.
-* - Transmit status FIFO overrun. Indicates data was lost due to the transmit
-*   status FIFO becoming full following the transmission of a packet. Only a
-*   device reset clears this condition.
-* - Transmit status FIFO underrun. An attempt to read an empty FIFO. Only a
-*   device reset clears this condition.
-* - Transmit length FIFO overrun. Indicates data was lost due to the transmit
-*   length FIFO becoming full following the transmission of a packet. Only a
-*   device reset clears this condition.
-* - Transmit length FIFO underrun. An attempt to read an empty FIFO. Only a
-*   device reset clears this condition.
-* - Receive data FIFO overrun. Indicates data was lost due to the receive data
-*   FIFO becoming full during the reception of a packet.
-* - Receive data errors:
-*   - Receive missed frame error. Valid data was lost by the MAC.
-*   - Receive collision error. Data was lost by the MAC due to a collision.
-*   - Receive FCS error.  Data was dicarded by the MAC due to FCS error.
-*   - Receive length field error. Data was dicarded by the MAC due to an invalid
-*     length field in the packet.
-*   - Receive short error. Data was dicarded by the MAC because a packet was
-*     shorter than allowed.
-*   - Receive long error. Data was dicarded by the MAC because a packet was
-*     longer than allowed.
-*   - Receive alignment error. Data was truncated by the MAC because its length
-*     was not byte-aligned.
-*
-* @param InstancePtr is a pointer to the XEmac instance to be worked on.
-* @param IntrStatus is the contents of the interrupt status register to be checked
-*
-* @return
-*
-* None.
-*
-* @note
-*
-* This function is intended for internal use only.
-*
-******************************************************************************/
-void XEmac_CheckEmacError(XEmac * InstancePtr, u32 IntrStatus)
-{
-	u32 ResetError = FALSE;
-
-	/*
-	 * First check for receive fifo overrun/underrun errors. Most require a
-	 * reset by the user to clear, but the data FIFO overrun error does not.
-	 */
-	if (IntrStatus & XEM_EIR_RECV_DFIFO_OVER_MASK) {
-		InstancePtr->Stats.RecvOverrunErrors++;
-		InstancePtr->Stats.FifoErrors++;
-	}
-
-	if (IntrStatus & XEM_EIR_RECV_LFIFO_OVER_MASK) {
-		/*
-		 * Receive Length FIFO overrun interrupts no longer occur in v1.00l
-		 * and later of the EMAC device. Frames are just dropped by the EMAC
-		 * if the length FIFO is full. The user would notice the Receive Missed
-		 * Frame count incrementing without any other errors being reported.
-		 * This code is left here for backward compatibility with v1.00k and
-		 * older EMAC devices.
-		 */
-		InstancePtr->Stats.RecvOverrunErrors++;
-		InstancePtr->Stats.FifoErrors++;
-		ResetError = TRUE;	/* requires a reset */
-	}
-
-	if (IntrStatus & XEM_EIR_RECV_LFIFO_UNDER_MASK) {
-		InstancePtr->Stats.RecvUnderrunErrors++;
-		InstancePtr->Stats.FifoErrors++;
-		ResetError = TRUE;	/* requires a reset */
-	}
-
-	/*
-	 * Now check for general receive errors. Get the latest count where
-	 * available, otherwise just bump the statistic so we know the interrupt
-	 * occurred.
-	 */
-	if (IntrStatus & XEM_EIR_RECV_ERROR_MASK) {
-		if (IntrStatus & XEM_EIR_RECV_MISSED_FRAME_MASK) {
-			/*
-			 * Caused by length FIFO or data FIFO overruns on receive side
-			 */
-			InstancePtr->Stats.RecvMissedFrameErrors =
-				XIo_In32(InstancePtr->BaseAddress +
-					 XEM_RMFC_OFFSET);
-		}
-
-		if (IntrStatus & XEM_EIR_RECV_COLLISION_MASK) {
-			InstancePtr->Stats.RecvCollisionErrors =
-				XIo_In32(InstancePtr->BaseAddress +
-					 XEM_RCC_OFFSET);
-		}
-
-		if (IntrStatus & XEM_EIR_RECV_FCS_ERROR_MASK) {
-			InstancePtr->Stats.RecvFcsErrors =
-				XIo_In32(InstancePtr->BaseAddress +
-					 XEM_RFCSEC_OFFSET);
-		}
-
-		if (IntrStatus & XEM_EIR_RECV_LEN_ERROR_MASK) {
-			InstancePtr->Stats.RecvLengthFieldErrors++;
-		}
-
-		if (IntrStatus & XEM_EIR_RECV_SHORT_ERROR_MASK) {
-			InstancePtr->Stats.RecvShortErrors++;
-		}
-
-		if (IntrStatus & XEM_EIR_RECV_LONG_ERROR_MASK) {
-			InstancePtr->Stats.RecvLongErrors++;
-		}
-
-		if (IntrStatus & XEM_EIR_RECV_ALIGN_ERROR_MASK) {
-			InstancePtr->Stats.RecvAlignmentErrors =
-				XIo_In32(InstancePtr->BaseAddress +
-					 XEM_RAEC_OFFSET);
-		}
-
-		/*
-		 * Bump recv interrupts stats only if not scatter-gather DMA (this
-		 * stat gets bumped elsewhere in that case)
-		 */
-		if (!XEmac_mIsSgDma(InstancePtr)) {
-			InstancePtr->Stats.RecvInterrupts++;	/* TODO: double bump? */
-		}
-
-	}
-
-	/*
-	 * Check for transmit errors. These apply to both DMA and non-DMA modes
-	 * of operation. The entire device should be reset after overruns or
-	 * underruns.
-	 */
-	if (IntrStatus & (XEM_EIR_XMIT_SFIFO_OVER_MASK |
-			  XEM_EIR_XMIT_LFIFO_OVER_MASK)) {
-		InstancePtr->Stats.XmitOverrunErrors++;
-		InstancePtr->Stats.FifoErrors++;
-		ResetError = TRUE;
-	}
-
-	if (IntrStatus & (XEM_EIR_XMIT_SFIFO_UNDER_MASK |
-			  XEM_EIR_XMIT_LFIFO_UNDER_MASK)) {
-		InstancePtr->Stats.XmitUnderrunErrors++;
-		InstancePtr->Stats.FifoErrors++;
-		ResetError = TRUE;
-	}
-
-	if (ResetError) {
-		/*
-		 * If a reset error occurred, disable the EMAC interrupts since the
-		 * reset-causing interrupt(s) is latched in the EMAC - meaning it will
-		 * keep occurring until the device is reset. In order to give the higher
-		 * layer software time to reset the device, we have to disable the
-		 * overrun/underrun interrupts until that happens. We trust that the
-		 * higher layer resets the device. We are able to get away with disabling
-		 * all EMAC interrupts since the only interrupts it generates are for
-		 * error conditions, and we don't care about any more errors right now.
-		 */
-		XEMAC_WRITE_IIER(InstancePtr->BaseAddress, 0);
-
-		/*
-		 * Invoke the error handler callback, which should result in a reset
-		 * of the device by the upper layer software.
-		 */
-		InstancePtr->ErrorHandler(InstancePtr->ErrorRef,
-					  XST_RESET_ERROR);
-	}
-}
-
-/*****************************************************************************/
-/*
-*
-* Check the receive packet FIFO for errors. FIFO error interrupts are:
-* - Deadlock.  See the XPacketFifo component for a description of deadlock on a
-*   FIFO.
-*
-* @param InstancePtr is a pointer to the XEmac instance to be worked on.
-*
-* @return
-*
-* Although the function returns void, it can return an asynchronous error to the
-* application through the error handler.  It can return XST_FIFO_ERROR if a FIFO
-* error occurred.
-*
-* @note
-*
-* This function is intended for internal use only.
-*
-******************************************************************************/
-void XEmac_CheckFifoRecvError(XEmac * InstancePtr)
-{
-	/*
-	 * Although the deadlock is currently the only interrupt from a packet
-	 * FIFO, make sure it is deadlocked before taking action. There is no
-	 * need to clear this interrupt since it requires a reset of the device.
-	 */
-	if (XPF_V200A_IS_DEADLOCKED(&InstancePtr->RecvFifo)) {
-		u32 IntrEnable;
-
-		InstancePtr->Stats.FifoErrors++;
-
-		/*
-		 * Invoke the error callback function, which should result in a reset
-		 * of the device by the upper layer software. We first need to disable
-		 * the FIFO interrupt, since otherwise the upper layer thread that
-		 * handles the reset may never run because this interrupt condition
-		 * doesn't go away until a reset occurs (there is no way to ack it).
-		 */
-		IntrEnable = XEMAC_READ_DIER(InstancePtr->BaseAddress);
-		XEMAC_WRITE_DIER(InstancePtr->BaseAddress,
-				      IntrEnable & ~XEM_IPIF_RECV_FIFO_MASK);
-
-		InstancePtr->ErrorHandler(InstancePtr->ErrorRef,
-					  XST_FIFO_ERROR);
-	}
-}
-
-/*****************************************************************************/
-/*
-*
-* Check the send packet FIFO for errors. FIFO error interrupts are:
-* - Deadlock. See the XPacketFifo component for a description of deadlock on a
-*   FIFO.
-*
-* @param InstancePtr is a pointer to the XEmac instance to be worked on.
-*
-* @return
-*
-* Although the function returns void, it can return an asynchronous error to the
-* application through the error handler.  It can return XST_FIFO_ERROR if a FIFO
-* error occurred.
-*
-* @note
-*
-* This function is intended for internal use only.
-*
-******************************************************************************/
-void XEmac_CheckFifoSendError(XEmac * InstancePtr)
-{
-	/*
-	 * Although the deadlock is currently the only interrupt from a packet
-	 * FIFO, make sure it is deadlocked before taking action. There is no
-	 * need to clear this interrupt since it requires a reset of the device.
-	 */
-	if (XPF_V200A_IS_DEADLOCKED(&InstancePtr->SendFifo)) {
-		u32 IntrEnable;
-
-		InstancePtr->Stats.FifoErrors++;
-
-		/*
-		 * Invoke the error callback function, which should result in a reset
-		 * of the device by the upper layer software. We first need to disable
-		 * the FIFO interrupt, since otherwise the upper layer thread that
-		 * handles the reset may never run because this interrupt condition
-		 * doesn't go away until a reset occurs (there is no way to ack it).
-		 */
-		IntrEnable = XEMAC_READ_DIER(InstancePtr->BaseAddress);
-		XEMAC_WRITE_DIER(InstancePtr->BaseAddress,
-				      IntrEnable & ~XEM_IPIF_SEND_FIFO_MASK);
-
-		InstancePtr->ErrorHandler(InstancePtr->ErrorRef,
-					  XST_FIFO_ERROR);
-	}
-}
diff --git a/drivers/net/ethernet/xilinx/xilinx_emac/xemac_intr_dma.c b/drivers/net/ethernet/xilinx/xilinx_emac/xemac_intr_dma.c
deleted file mode 100644
index 9d825e7..0000000
--- a/drivers/net/ethernet/xilinx/xilinx_emac/xemac_intr_dma.c
+++ /dev/null
@@ -1,1371 +0,0 @@
-/* $Id: xemac_intr_dma.c,v 1.1 2006/11/01 17:30:12 moleres Exp $ */
-/******************************************************************************
-*
-*       XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS"
-*       AS A COURTESY TO YOU, SOLELY FOR USE IN DEVELOPING PROGRAMS AND
-*       SOLUTIONS FOR XILINX DEVICES.  BY PROVIDING THIS DESIGN, CODE,
-*       OR INFORMATION AS ONE POSSIBLE IMPLEMENTATION OF THIS FEATURE,
-*       APPLICATION OR STANDARD, XILINX IS MAKING NO REPRESENTATION
-*       THAT THIS IMPLEMENTATION IS FREE FROM ANY CLAIMS OF INFRINGEMENT,
-*       AND YOU ARE RESPONSIBLE FOR OBTAINING ANY RIGHTS YOU MAY REQUIRE
-*       FOR YOUR IMPLEMENTATION.  XILINX EXPRESSLY DISCLAIMS ANY
-*       WARRANTY WHATSOEVER WITH RESPECT TO THE ADEQUACY OF THE
-*       IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OR
-*       REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE FROM CLAIMS OF
-*       INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
-*       FOR A PARTICULAR PURPOSE.
-*
-*       (c) Copyright 2003 Xilinx Inc.
-*       All rights reserved.
-*
-******************************************************************************/
-/*****************************************************************************/
-/**
-*
-* @file xemac_intr_dma.c
-*
-* Contains functions used in interrupt mode when configured with scatter-gather
-* DMA.
-*
-* The interrupt handler, XEmac_IntrHandlerDma(), must be connected by the user
-* to the interrupt controller.
-*
-* <pre>
-* MODIFICATION HISTORY:
-*
-* Ver   Who  Date     Changes
-* ----- ---- -------- ---------------------------------------------------------
-* 1.00a rpm  07/31/01 First release
-* 1.00b rpm  02/20/02 Repartitioned files and functions
-* 1.00c rpm  12/05/02 New version includes support for simple DMA and the delay
-*                     argument to SgSend
-* 1.00c rpm  02/03/03 The XST_DMA_SG_COUNT_EXCEEDED return code was removed
-*                     from SetPktThreshold in the internal DMA driver. Also
-*                     avoided compiler warnings by initializing Result in the
-*                     interrupt service routines.
-* 1.00c rpm  03/26/03 Fixed a problem in the interrupt service routines where
-*                     the interrupt status was toggled clear after a call to
-*                     ErrorHandler, but if ErrorHandler reset the device the
-*                     toggle actually asserted the interrupt because the
-*                     reset had cleared it.
-* 1.00d rpm  09/26/03 New version includes support PLB Ethernet and v2.00a of
-*                     the packet fifo driver.
-* 1.00e rmm  04/06/04 Instead of invoking once for each packet received,
-*                     send/recv callbacks are invoked once for all packets.
-*                     Added functions XEmac_GetSgRecvFreeDesc() and XEmac_Get-
-*                     SgSendFreeDesc().
-* 1.01a ecm  09/01/05 Added DRE support through Control words in instance which
-*                     are set at initialization.
-* 1.01a wgr  09/14/06 Ported to Linux 2.6
-* 1.11a wgr  03/22/07 Converted to new coding style.
-* </pre>
-*
-******************************************************************************/
-
-/***************************** Include Files *********************************/
-
-#include "xbasic_types.h"
-#include "xemac_i.h"
-#include "xio.h"
-#include "xbuf_descriptor.h"
-#include "xdma_channel.h"
-#include "xipif_v1_23_b.h"	/* Uses v1.23b of the IPIF */
-
-/************************** Constant Definitions *****************************/
-
-
-/**************************** Type Definitions *******************************/
-
-
-/***************** Macros (Inline Functions) Definitions *********************/
-
-
-/************************** Variable Definitions *****************************/
-
-
-/************************** Function Prototypes ******************************/
-
-static void HandleDmaRecvIntr(XEmac * InstancePtr);
-static void HandleDmaSendIntr(XEmac * InstancePtr);
-static void HandleEmacDmaIntr(XEmac * InstancePtr);
-
-/*****************************************************************************/
-/**
-*
-* Send an Ethernet frame using scatter-gather DMA. The caller attaches the
-* frame to one or more buffer descriptors, then calls this function once for
-* each descriptor. The caller is responsible for allocating and setting up the
-* descriptor. An entire Ethernet frame may or may not be contained within one
-* descriptor.  This function simply inserts the descriptor into the scatter-
-* gather engine's transmit list. The caller is responsible for providing mutual
-* exclusion to guarantee that a frame is contiguous in the transmit list. The
-* buffer attached to the descriptor must be 32-bit aligned if using the OPB
-* Ethernet core and 64-bit aligned if using the PLB Ethernet core.
-*
-* The driver updates the descriptor with the device control register before
-* being inserted into the transmit list.  If this is the last descriptor in
-* the frame, the inserts are committed, which means the descriptors for this
-* frame are now available for transmission.
-*
-* It is assumed that the upper layer software supplies a correctly formatted
-* Ethernet frame, including the destination and source addresses, the
-* type/length field, and the data field.  It is also assumed that upper layer
-* software does not append FCS at the end of the frame.
-*
-* This call is non-blocking.  Notification of error or successful transmission
-* is done asynchronously through the send or error callback function.
-*
-* @param InstancePtr is a pointer to the XEmac instance to be worked on.
-* @param BdPtr is the address of a descriptor to be inserted into the transmit
-*        ring.
-* @param Delay indicates whether to start the scatter-gather DMA channel
-*        immediately, or whether to wait. This allows the user to build up a
-*        list of more than one descriptor before starting the transmission of
-*        the packets, which allows the application to keep up with DMA and have
-*        a constant stream of frames being transmitted. Use XEM_SGDMA_NODELAY or
-*        XEM_SGDMA_DELAY, defined in xemac.h, as the value of this argument. If
-*        the user chooses to delay and build a list, the user must call this
-*        function with the XEM_SGDMA_NODELAY option or call XEmac_Start() to
-*        kick off the tranmissions.
-*
-* @return
-*
-* - XST_SUCCESS if the buffer was successfull sent
-* - XST_DEVICE_IS_STOPPED if the Ethernet MAC has not been started yet
-* - XST_NOT_SGDMA if the device is not in scatter-gather DMA mode
-* - XST_DMA_SG_LIST_FULL if the descriptor list for the DMA channel is full
-* - XST_DMA_SG_BD_LOCKED if the DMA channel cannot insert the descriptor into
-*   the list because a locked descriptor exists at the insert point
-* - XST_DMA_SG_NOTHING_TO_COMMIT if even after inserting a descriptor into the
-*   list, the DMA channel believes there are no new descriptors to commit. If
-*   this is ever encountered, there is likely a thread mutual exclusion problem
-*   on transmit.
-*
-* @note
-*
-* This function is not thread-safe. The user must provide mutually exclusive
-* access to this function if there are to be multiple threads that can call it.
-*
-* @internal
-*
-* A status that should never be returned from this function, although
-* the code is set up to handle it, is XST_DMA_SG_NO_LIST. Starting the device
-* requires a list to be created, and this function requires the device to be
-* started.
-*
-******************************************************************************/
-int XEmac_SgSend(XEmac * InstancePtr, XBufDescriptor * BdPtr, int Delay)
-{
-	int Result;
-	u32 BdControl;
-
-	XASSERT_NONVOID(InstancePtr != NULL);
-	XASSERT_NONVOID(BdPtr != NULL);
-	XASSERT_NONVOID(InstancePtr->IsReady == XCOMPONENT_IS_READY);
-
-	/*
-	 * Be sure the device is configured for scatter-gather DMA, then be sure
-	 * it is started.
-	 */
-	if (!XEmac_mIsSgDma(InstancePtr)) {
-		return XST_NOT_SGDMA;
-	}
-
-	/*
-	 * Set some descriptor control word defaults (source address increment
-	 * and local destination address) and the destination address
-	 * (the FIFO).  These are the same for every transmit descriptor.
-	 */
-	BdControl = XBufDescriptor_GetControl(BdPtr);
-	XBufDescriptor_SetControl(BdPtr,
-				  BdControl | (InstancePtr->TxDmaControlWord));
-
-	/*
-	 * If the TX channel has Checksum offload enabled, do not overwrite
-	 * the Data in the destination address location, it is offload related
-	 * not the actual address for the data to be written to
-	 */
-	if ((InstancePtr->TxDmaControlWord & XDC_DMACR_CS_OFFLOAD_MASK) == 0) {
-		XBufDescriptor_SetDestAddress(BdPtr,
-					      InstancePtr->PhysAddress +
-					      XEM_PFIFO_TXDATA_OFFSET);
-	}
-
-	/*
-	 * Put the descriptor in the send list. The DMA component accesses data
-	 * here that can also be modified in interrupt context, so a critical
-	 * section is required.
-	 */
-	XIIF_V123B_GINTR_DISABLE(InstancePtr->BaseAddress);
-
-	Result = XDmaChannel_PutDescriptor(&InstancePtr->SendChannel, BdPtr);
-	if (Result != XST_SUCCESS) {
-		XIIF_V123B_GINTR_ENABLE(InstancePtr->BaseAddress);
-		return Result;
-	}
-
-	/*
-	 * If this is the last buffer in the frame, commit the inserts and start
-	 * the DMA engine if necessary
-	 */
-	if (XBufDescriptor_IsLastControl(BdPtr)) {
-		Result = XDmaChannel_CommitPuts(&InstancePtr->SendChannel);
-		if (Result != XST_SUCCESS) {
-			XIIF_V123B_GINTR_ENABLE(InstancePtr->BaseAddress);
-			return Result;
-		}
-
-		if (Delay == XEM_SGDMA_NODELAY) {
-			/*
-			 * Start the DMA channel. Ignore the return status since we know the
-			 * list exists and has at least one entry and we don't care if the
-			 * channel is already started.  The DMA component accesses data here
-			 * that can be modified at interrupt or task levels, so a critical
-			 * section is required.
-			 */
-			(void) XDmaChannel_SgStart(&InstancePtr->SendChannel);
-		}
-	}
-
-	XIIF_V123B_GINTR_ENABLE(InstancePtr->BaseAddress);
-
-	return XST_SUCCESS;
-}
-
-/*****************************************************************************/
-/**
-*
-* Add a descriptor, with an attached empty buffer, into the receive descriptor
-* list. The buffer attached to the descriptor must be 32-bit aligned if using
-* the OPB Ethernet core and 64-bit aligned if using the PLB Ethernet core.
-* This function is used by the upper layer software during initialization when
-* first setting up the receive descriptors, and also during reception of frames
-* to replace filled buffers with empty buffers. This function can be called
-* when the device is started or stopped. Note that it does start the scatter-
-* gather DMA engine.  Although this is not necessary during initialization, it
-* is not a problem during initialization because the MAC receiver is not yet
-* started.
-*
-* The buffer attached to the descriptor must be aligned on both the front end
-* and the back end.
-*
-* Notification of received frames are done asynchronously through the receive
-* callback function.
-*
-* @param InstancePtr is a pointer to the XEmac instance to be worked on.
-* @param BdPtr is a pointer to the buffer descriptor that will be added to the
-*        descriptor list.
-*
-* @return
-*
-* - XST_SUCCESS if a descriptor was successfully returned to the driver
-* - XST_NOT_SGDMA if the device is not in scatter-gather DMA mode
-* - XST_DMA_SG_LIST_FULL if the receive descriptor list is full
-* - XST_DMA_SG_BD_LOCKED if the DMA channel cannot insert the descriptor into
-*   the list because a locked descriptor exists at the insert point.
-* - XST_DMA_SG_NOTHING_TO_COMMIT if even after inserting a descriptor into the
-*   list, the DMA channel believes there are no new descriptors to commit.
-*
-* @internal
-*
-* A status that should never be returned from this function, although
-* the code is set up to handle it, is XST_DMA_SG_NO_LIST. Starting the device
-* requires a list to be created, and this function requires the device to be
-* started.
-*
-******************************************************************************/
-int XEmac_SgRecv(XEmac * InstancePtr, XBufDescriptor * BdPtr)
-{
-	int Result;
-	u32 BdControl;
-
-	XASSERT_NONVOID(InstancePtr != NULL);
-	XASSERT_NONVOID(BdPtr != NULL);
-	XASSERT_NONVOID(InstancePtr->IsReady == XCOMPONENT_IS_READY);
-
-	/*
-	 * Be sure the device is configured for scatter-gather DMA
-	 */
-	if (!XEmac_mIsSgDma(InstancePtr)) {
-		return XST_NOT_SGDMA;
-	}
-
-	/*
-	 * Set some descriptor control word defaults (destination address increment
-	 * and local source address) and the source address (the FIFO). These are
-	 * the same for every receive descriptor.
-	 */
-	BdControl = XBufDescriptor_GetControl(BdPtr);
-	XBufDescriptor_SetControl(BdPtr,
-				  BdControl | (InstancePtr->RxDmaControlWord));
-	XBufDescriptor_SetSrcAddress(BdPtr,
-				     InstancePtr->PhysAddress +
-				     XEM_PFIFO_RXDATA_OFFSET);
-
-	/*
-	 * Put the descriptor into the channel's descriptor list and commit.
-	 * Although this function is likely called within interrupt context, there
-	 * is the possibility that the upper layer software queues it to a task.
-	 * In this case, a critical section is needed here to protect shared data
-	 * in the DMA component.
-	 */
-	XIIF_V123B_GINTR_DISABLE(InstancePtr->BaseAddress);
-
-	Result = XDmaChannel_PutDescriptor(&InstancePtr->RecvChannel, BdPtr);
-	if (Result != XST_SUCCESS) {
-		XIIF_V123B_GINTR_ENABLE(InstancePtr->BaseAddress);
-		return Result;
-	}
-
-	Result = XDmaChannel_CommitPuts(&InstancePtr->RecvChannel);
-	if (Result != XST_SUCCESS) {
-		XIIF_V123B_GINTR_ENABLE(InstancePtr->BaseAddress);
-		return Result;
-	}
-
-	/*
-	 * Start the DMA channel. Ignore the return status since we know the list
-	 * exists and has at least one entry and we don't care if the channel is
-	 * already started. The DMA component accesses data here that can be
-	 * modified at interrupt or task levels, so a critical section is required.
-	 */
-	(void) XDmaChannel_SgStart(&InstancePtr->RecvChannel);
-
-	XIIF_V123B_GINTR_ENABLE(InstancePtr->BaseAddress);
-
-	return XST_SUCCESS;
-}
-
-
-/*****************************************************************************/
-/**
-*
-* The interrupt handler for the Ethernet driver when configured with scatter-
-* gather DMA.
-*
-* Get the interrupt status from the IpIf to determine the source of the
-* interrupt.  The source can be: MAC, Recv Packet FIFO, Send Packet FIFO, Recv
-* DMA channel, or Send DMA channel. The packet FIFOs only interrupt during
-* "deadlock" conditions.
-*
-* @param InstancePtr is a pointer to the XEmac instance that just interrupted.
-*
-* @return
-*
-* None.
-*
-* @note
-*
-* None.
-*
-******************************************************************************/
-void XEmac_IntrHandlerDma(void *InstancePtr)
-{
-	u32 IntrStatus;
-	XEmac *EmacPtr = (XEmac *) InstancePtr;
-
-	EmacPtr->Stats.TotalIntrs++;
-
-	/*
-	 * Get the interrupt status from the IPIF. There is no clearing of
-	 * interrupts in the IPIF. Interrupts must be cleared at the source.
-	 */
-	IntrStatus = XIIF_V123B_READ_DIPR(EmacPtr->BaseAddress);
-
-	/*
-	 * See which type of interrupt is being requested, and service it
-	 */
-	if (IntrStatus & XEM_IPIF_RECV_DMA_MASK) {	/* Receive DMA interrupt */
-		EmacPtr->Stats.RecvInterrupts++;
-		HandleDmaRecvIntr(EmacPtr);
-	}
-
-	if (IntrStatus & XEM_IPIF_SEND_DMA_MASK) {	/* Send DMA interrupt */
-		EmacPtr->Stats.XmitInterrupts++;
-		HandleDmaSendIntr(EmacPtr);
-	}
-
-	if (IntrStatus & XEM_IPIF_EMAC_MASK) {	/* MAC interrupt */
-		EmacPtr->Stats.EmacInterrupts++;
-		HandleEmacDmaIntr(EmacPtr);
-	}
-
-	if (IntrStatus & XEM_IPIF_RECV_FIFO_MASK) {	/* Receive FIFO interrupt */
-		EmacPtr->Stats.RecvInterrupts++;
-		XEmac_CheckFifoRecvError(EmacPtr);
-	}
-
-	if (IntrStatus & XEM_IPIF_SEND_FIFO_MASK) {	/* Send FIFO interrupt */
-		EmacPtr->Stats.XmitInterrupts++;
-		XEmac_CheckFifoSendError(EmacPtr);
-	}
-
-	if (IntrStatus & XIIF_V123B_ERROR_MASK) {
-		/*
-		 * An error occurred internal to the IPIF. This is more of a debug and
-		 * integration issue rather than a production error. Don't do anything
-		 * other than clear it, which provides a spot for software to trap
-		 * on the interrupt and begin debugging.
-		 */
-		XIIF_V123B_WRITE_DISR(EmacPtr->BaseAddress,
-				      XIIF_V123B_ERROR_MASK);
-	}
-}
-
-/*****************************************************************************/
-/**
-*
-* Set the packet count threshold for this device. The device must be stopped
-* before setting the threshold. The packet count threshold is used for interrupt
-* coalescing, which reduces the frequency of interrupts from the device to the
-* processor. In this case, the scatter-gather DMA engine only interrupts when
-* the packet count threshold is reached, instead of interrupting for each packet.
-* A packet is a generic term used by the scatter-gather DMA engine, and is
-* equivalent to an Ethernet frame in our case.
-*
-* @param InstancePtr is a pointer to the XEmac instance to be worked on.
-* @param Direction indicates the channel, send or receive, from which the
-*        threshold register is read.
-* @param Threshold is the value of the packet threshold count used during
-*        interrupt coalescing. A value of 0 disables the use of packet threshold
-*        by the hardware.
-*
-* @return
-*
-* - XST_SUCCESS if the threshold was successfully set
-* - XST_NOT_SGDMA if the MAC is not configured for scatter-gather DMA
-* - XST_DEVICE_IS_STARTED if the device has not been stopped
-* - XST_INVALID_PARAM if the Direction parameter is invalid. Turning on
-*   asserts would also catch this error.
-*
-* @note
-*
-* The packet threshold could be set to larger than the number of descriptors
-* allocated to the DMA channel. In this case, the wait bound will take over
-* and always indicate data arrival. There was a check in this function that
-* returned an error if the treshold was larger than the number of descriptors,
-* but that was removed because users would then have to set the threshold
-* only after they set descriptor space, which is an order dependency that
-* caused confustion.
-*
-******************************************************************************/
-int XEmac_SetPktThreshold(XEmac * InstancePtr, u32 Direction, u8 Threshold)
-{
-	XASSERT_NONVOID(InstancePtr != NULL);
-	XASSERT_NONVOID(Direction == XEM_SEND || Direction == XEM_RECV);
-	XASSERT_NONVOID(InstancePtr->IsReady == XCOMPONENT_IS_READY);
-
-	/*
-	 * Be sure device is configured for scatter-gather DMA and has been stopped
-	 */
-	if (!XEmac_mIsSgDma(InstancePtr)) {
-		return XST_NOT_SGDMA;
-	}
-
-	if (InstancePtr->IsStarted == XCOMPONENT_IS_STARTED) {
-		return XST_DEVICE_IS_STARTED;
-	}
-
-	/*
-	 * Based on the direction, set the packet threshold in the
-	 * corresponding DMA channel component.  Default to the receive
-	 * channel threshold register (if an invalid Direction is passed).
-	 */
-	switch (Direction) {
-	case XEM_SEND:
-		return XDmaChannel_SetPktThreshold(&InstancePtr->SendChannel,
-						   Threshold);
-
-	case XEM_RECV:
-		return XDmaChannel_SetPktThreshold(&InstancePtr->RecvChannel,
-						   Threshold);
-
-	default:
-		return XST_INVALID_PARAM;
-	}
-}
-
-/*****************************************************************************/
-/**
-*
-* Get the value of the packet count threshold for this driver/device. The packet
-* count threshold is used for interrupt coalescing, which reduces the frequency
-* of interrupts from the device to the processor. In this case, the
-* scatter-gather DMA engine only interrupts when the packet count threshold is
-* reached, instead of interrupting for each packet. A packet is a generic term
-* used by the scatter-gather DMA engine, and is equivalent to an Ethernet frame
-* in our case.
-*
-* @param InstancePtr is a pointer to the XEmac instance to be worked on.
-* @param Direction indicates the channel, send or receive, from which the
-*        threshold register is read.
-* @param ThreshPtr is a pointer to the byte into which the current value of the
-*        packet threshold register will be copied. An output parameter. A value
-*        of 0 indicates the use of packet threshold by the hardware is disabled.
-*
-* @return
-*
-* - XST_SUCCESS if the packet threshold was retrieved successfully
-* - XST_NOT_SGDMA if the MAC is not configured for scatter-gather DMA
-* - XST_INVALID_PARAM if the Direction parameter is invalid. Turning on
-*   asserts would also catch this error.
-*
-* @note
-*
-* None.
-*
-******************************************************************************/
-int XEmac_GetPktThreshold(XEmac * InstancePtr, u32 Direction, u8 *ThreshPtr)
-{
-	XASSERT_NONVOID(InstancePtr != NULL);
-	XASSERT_NONVOID(Direction == XEM_SEND || Direction == XEM_RECV);
-	XASSERT_NONVOID(ThreshPtr != NULL);
-	XASSERT_NONVOID(InstancePtr->IsReady == XCOMPONENT_IS_READY);
-
-	if (!XEmac_mIsSgDma(InstancePtr)) {
-		return XST_NOT_SGDMA;
-	}
-
-	/*
-	 * Based on the direction, return the packet threshold set in the
-	 * corresponding DMA channel component.  Default to the value in
-	 * the receive channel threshold register (if an invalid Direction
-	 * is passed).
-	 */
-	switch (Direction) {
-	case XEM_SEND:
-		*ThreshPtr =
-			XDmaChannel_GetPktThreshold(&InstancePtr->SendChannel);
-		break;
-
-	case XEM_RECV:
-		*ThreshPtr =
-			XDmaChannel_GetPktThreshold(&InstancePtr->RecvChannel);
-		break;
-
-	default:
-		return XST_INVALID_PARAM;
-	}
-
-	return XST_SUCCESS;
-}
-
-/*****************************************************************************/
-/**
-*
-* Set the packet wait bound timer for this driver/device. The device must be
-* stopped before setting the timer value. The packet wait bound is used during
-* interrupt coalescing to trigger an interrupt when not enough packets have been
-* received to reach the packet count threshold. A packet is a generic term used
-* by the scatter-gather DMA engine, and is equivalent to an Ethernet frame in
-* our case. The timer is in milliseconds.
-*
-* @param InstancePtr is a pointer to the XEmac instance to be worked on.
-* @param Direction indicates the channel, send or receive, from which the
-*        threshold register is read.
-* @param TimerValue is the value of the packet wait bound used during interrupt
-*        coalescing. It is in milliseconds in the range 0  - 1023. A value of 0
-*        disables the packet wait bound timer.
-*
-* @return
-*
-* - XST_SUCCESS if the packet wait bound was set successfully
-* - XST_NOT_SGDMA if the MAC is not configured for scatter-gather DMA
-* - XST_DEVICE_IS_STARTED if the device has not been stopped
-* - XST_INVALID_PARAM if the Direction parameter is invalid. Turning on
-*   asserts would also catch this error.
-*
-* @note
-*
-* None.
-*
-******************************************************************************/
-int XEmac_SetPktWaitBound(XEmac * InstancePtr, u32 Direction, u32 TimerValue)
-{
-	XASSERT_NONVOID(InstancePtr != NULL);
-	XASSERT_NONVOID(Direction == XEM_SEND || Direction == XEM_RECV);
-	XASSERT_NONVOID(TimerValue <= XEM_SGDMA_MAX_WAITBOUND);
-	XASSERT_NONVOID(InstancePtr->IsReady == XCOMPONENT_IS_READY);
-
-	/*
-	 * Be sure device is configured for scatter-gather DMA and has been stopped
-	 */
-	if (!XEmac_mIsSgDma(InstancePtr)) {
-		return XST_NOT_SGDMA;
-	}
-
-	if (InstancePtr->IsStarted == XCOMPONENT_IS_STARTED) {
-		return XST_DEVICE_IS_STARTED;
-	}
-
-	/*
-	 * Based on the direction, set the packet wait bound in the
-	 * corresponding DMA channel component.  Default to the receive
-	 * channel wait bound register (if an invalid Direction is passed).
-	 */
-	switch (Direction) {
-	case XEM_SEND:
-		XDmaChannel_SetPktWaitBound(&InstancePtr->SendChannel,
-					    TimerValue);
-		break;
-
-	case XEM_RECV:
-		XDmaChannel_SetPktWaitBound(&InstancePtr->RecvChannel,
-					    TimerValue);
-		break;
-
-	default:
-		return XST_INVALID_PARAM;
-	}
-
-	return XST_SUCCESS;
-}
-
-/*****************************************************************************/
-/**
-*
-* Get the packet wait bound timer for this driver/device. The packet wait bound
-* is used during interrupt coalescing to trigger an interrupt when not enough
-* packets have been received to reach the packet count threshold. A packet is a
-* generic term used by the scatter-gather DMA engine, and is equivalent to an
-* Ethernet frame in our case. The timer is in milliseconds.
-*
-* @param InstancePtr is a pointer to the XEmac instance to be worked on.
-* @param Direction indicates the channel, send or receive, from which the
-*        threshold register is read.
-* @param WaitPtr is a pointer to the byte into which the current value of the
-*        packet wait bound register will be copied. An output parameter. Units
-*        are in milliseconds in the range 0  - 1023. A value of 0 indicates the
-*        packet wait bound timer is disabled.
-*
-* @return
-*
-* - XST_SUCCESS if the packet wait bound was retrieved successfully
-* - XST_NOT_SGDMA if the MAC is not configured for scatter-gather DMA
-* - XST_INVALID_PARAM if the Direction parameter is invalid. Turning on
-*   asserts would also catch this error.
-*
-* @note
-*
-* None.
-*
-******************************************************************************/
-int XEmac_GetPktWaitBound(XEmac * InstancePtr, u32 Direction, u32 *WaitPtr)
-{
-	XASSERT_NONVOID(InstancePtr != NULL);
-	XASSERT_NONVOID(Direction == XEM_SEND || Direction == XEM_RECV);
-	XASSERT_NONVOID(WaitPtr != NULL);
-	XASSERT_NONVOID(InstancePtr->IsReady == XCOMPONENT_IS_READY);
-
-	if (!XEmac_mIsSgDma(InstancePtr)) {
-		return XST_NOT_SGDMA;
-	}
-
-	/*
-	 * Based on the direction, return the packet wait bound set in the
-	 * corresponding DMA channel component.  Default to the value in
-	 * the receive channel wait bound register (if an invalid Direction
-	 * is passed).
-	 */
-	switch (Direction) {
-	case XEM_SEND:
-		*WaitPtr =
-			XDmaChannel_GetPktWaitBound(&InstancePtr->SendChannel);
-		break;
-
-	case XEM_RECV:
-		*WaitPtr =
-			XDmaChannel_GetPktWaitBound(&InstancePtr->RecvChannel);
-		break;
-
-	default:
-		return XST_INVALID_PARAM;
-	}
-
-	return XST_SUCCESS;
-}
-
-/*****************************************************************************/
-/**
-*
-* Give the driver the memory space to be used for the scatter-gather DMA
-* receive descriptor list. This function should only be called once, during
-* initialization of the Ethernet driver. The memory space must be big enough
-* to hold some number of descriptors, depending on the needs of the system.
-* The xemac.h file defines minimum and default numbers of descriptors
-* which can be used to allocate this memory space.
-*
-* The memory space must be 32-bit aligned. An assert will occur if asserts
-* are turned on and the memory is not aligned.
-*
-* @param InstancePtr is a pointer to the XEmac instance to be worked on.
-* @param MemoryPtr is a pointer to the aligned memory.
-* @param ByteCount is the length, in bytes, of the memory space.
-*
-* @return
-*
-* - XST_SUCCESS if the space was initialized successfully
-* - XST_NOT_SGDMA if the MAC is not configured for scatter-gather DMA
-* - XST_DMA_SG_LIST_EXISTS if this list space has already been created
-*
-* @note
-*
-* If the device is configured for scatter-gather DMA, this function must be
-* called AFTER the XEmac_Initialize() function because the DMA channel
-* components must be initialized before the memory space is set.
-*
-******************************************************************************/
-int XEmac_SetSgRecvSpace(XEmac * InstancePtr, u32 *MemoryPtr,
-			 u32 ByteCount, void *PhyPtr)
-{
-	XASSERT_NONVOID(InstancePtr != NULL);
-	XASSERT_NONVOID(MemoryPtr != NULL);
-	XASSERT_NONVOID(ByteCount != 0);
-	XASSERT_NONVOID(InstancePtr->IsReady == XCOMPONENT_IS_READY);
-
-	if (!XEmac_mIsSgDma(InstancePtr)) {
-		return XST_NOT_SGDMA;
-	}
-
-	return XDmaChannel_CreateSgList(&InstancePtr->RecvChannel, MemoryPtr,
-					ByteCount, PhyPtr);
-}
-
-/*****************************************************************************/
-/**
-*
-* Give the driver the memory space to be used for the scatter-gather DMA
-* transmit descriptor list. This function should only be called once, during
-* initialization of the Ethernet driver. The memory space must be big enough
-* to hold some number of descriptors, depending on the needs of the system.
-* The xemac.h file defines minimum and default numbers of descriptors
-* which can be used to allocate this memory space.
-*
-* The memory space must be 32-bit aligned. An assert will occur if asserts
-* are turned on and the memory is not aligned.
-*
-* @param InstancePtr is a pointer to the XEmac instance to be worked on.
-* @param MemoryPtr is a pointer to the aligned memory.
-* @param ByteCount is the length, in bytes, of the memory space.
-*
-* @return
-*
-* - XST_SUCCESS if the space was initialized successfully
-* - XST_NOT_SGDMA if the MAC is not configured for scatter-gather DMA
-* - XST_DMA_SG_LIST_EXISTS if this list space has already been created
-*
-* @note
-*
-* If the device is configured for scatter-gather DMA, this function must be
-* called AFTER the XEmac_Initialize() function because the DMA channel
-* components must be initialized before the memory space is set.
-*
-******************************************************************************/
-int XEmac_SetSgSendSpace(XEmac * InstancePtr, u32 *MemoryPtr,
-			 u32 ByteCount, void *PhyPtr)
-{
-	XASSERT_NONVOID(InstancePtr != NULL);
-	XASSERT_NONVOID(MemoryPtr != NULL);
-	XASSERT_NONVOID(ByteCount != 0);
-	XASSERT_NONVOID(InstancePtr->IsReady == XCOMPONENT_IS_READY);
-
-	if (!XEmac_mIsSgDma(InstancePtr)) {
-		return XST_NOT_SGDMA;
-	}
-
-	return XDmaChannel_CreateSgList(&InstancePtr->SendChannel, MemoryPtr,
-					ByteCount, PhyPtr);
-}
-
-/*****************************************************************************/
-/**
-*
-* Return the number of free buffer descriptor slots that can be added to the
-* send descriptor ring with XEmac_SgSend() before filling it up.
-*
-* @param InstancePtr is a pointer to the XEmac instance to be worked on.
-*
-* @return
-*
-* - The number of descriptors that can be given to the HW with XEmac_SgSend()
-* - 0 if no room is left or the device is not configured for SG DMA
-*
-* @note
-*
-* None.
-*
-******************************************************************************/
-unsigned XEmac_GetSgSendFreeDesc(XEmac * InstancePtr)
-{
-	unsigned Slots;
-
-	XASSERT_NONVOID(InstancePtr != NULL);
-	XASSERT_NONVOID(InstancePtr->IsReady == XCOMPONENT_IS_READY);
-
-	Slots = InstancePtr->SendChannel.TotalDescriptorCount -
-		InstancePtr->SendChannel.ActiveDescriptorCount;
-
-	return Slots;
-}
-
-
-/*****************************************************************************/
-/**
-*
-* Return the number of free buffer descriptor slots that can be added to the
-* receive descriptor ring with XEmac_SgRecv() before filling it up.
-*
-* @param InstancePtr is a pointer to the XEmac instance to be worked on.
-*
-* @return
-*
-* - The number of descriptors that can be given to the HW with XEmac_SgRecv()
-* - 0 if no room is left or the device is not configured for SG DMA
-*
-* @note
-*
-* None.
-*
-******************************************************************************/
-unsigned XEmac_GetSgRecvFreeDesc(XEmac * InstancePtr)
-{
-	unsigned Slots;
-
-	XASSERT_NONVOID(InstancePtr != NULL);
-	XASSERT_NONVOID(InstancePtr->IsReady == XCOMPONENT_IS_READY);
-
-	Slots = InstancePtr->RecvChannel.TotalDescriptorCount -
-		InstancePtr->RecvChannel.ActiveDescriptorCount;
-
-	return Slots;
-}
-
-
-/*****************************************************************************/
-/**
-*
-* Set the callback function for handling received frames in scatter-gather DMA
-* mode.  The upper layer software should call this function during
-* initialization.  The callback is called once per frame received. The head of
-* a descriptor list is passed in along with the number of descriptors in the
-* list. Before leaving the callback, the upper layer software should attach a
-* new buffer to each descriptor in the list.
-*
-* The callback is invoked by the driver within interrupt context, so it needs
-* to do its job quickly. Sending the received frame up the protocol stack
-* should be done at task-level. If there are other potentially slow operations
-* within the callback, these too should be done at task-level.
-*
-* @param InstancePtr is a pointer to the XEmac instance to be worked on.
-* @param CallBackRef is a reference pointer to be passed back to the adapter in
-*        the callback. This helps the adapter correlate the callback to a
-*        particular driver.
-* @param FuncPtr is the pointer to the callback function.
-*
-* @return
-*
-* None.
-*
-* @note
-*
-* None.
-*
-******************************************************************************/
-void XEmac_SetSgRecvHandler(XEmac * InstancePtr, void *CallBackRef,
-			    XEmac_SgHandler FuncPtr)
-{
-	/*
-	 * Asserted IsDmaSg here instead of run-time check because there is really
-	 * no ill-effects of setting these when not configured for scatter-gather.
-	 */
-	XASSERT_VOID(InstancePtr != NULL);
-	XASSERT_VOID(FuncPtr != NULL);
-	XASSERT_VOID(XEmac_mIsSgDma(InstancePtr));
-	XASSERT_VOID(InstancePtr->IsReady == XCOMPONENT_IS_READY);
-
-	InstancePtr->SgRecvHandler = FuncPtr;
-	InstancePtr->SgRecvRef = CallBackRef;
-}
-
-/*****************************************************************************/
-/**
-*
-* Set the callback function for handling confirmation of transmitted frames in
-* scatter-gather DMA mode.  The upper layer software should call this function
-* during initialization.  The callback is called once per frame sent. The head
-* of a descriptor list is passed in along with the number of descriptors in
-* the list. The callback is responsible for freeing buffers attached to these
-* descriptors.
-*
-* The callback is invoked by the driver within interrupt context, so it needs
-* to do its job quickly. If there are potentially slow operations within the
-* callback, these should be done at task-level.
-*
-* @param InstancePtr is a pointer to the XEmac instance to be worked on.
-* @param CallBackRef is a reference pointer to be passed back to the adapter in
-*        the callback. This helps the adapter correlate the callback to a
-*        particular driver.
-* @param FuncPtr is the pointer to the callback function.
-*
-* @return
-*
-* None.
-*
-* @note
-*
-* None.
-*
-******************************************************************************/
-void XEmac_SetSgSendHandler(XEmac * InstancePtr, void *CallBackRef,
-			    XEmac_SgHandler FuncPtr)
-{
-	/*
-	 * Asserted IsDmaSg here instead of run-time check because there is really
-	 * no ill-effects of setting these when not configured for scatter-gather.
-	 */
-	XASSERT_VOID(InstancePtr != NULL);
-	XASSERT_VOID(FuncPtr != NULL);
-	XASSERT_VOID(XEmac_mIsSgDma(InstancePtr));
-	XASSERT_VOID(InstancePtr->IsReady == XCOMPONENT_IS_READY);
-
-	InstancePtr->SgSendHandler = FuncPtr;
-	InstancePtr->SgSendRef = CallBackRef;
-}
-
-/*****************************************************************************/
-/*
-*
-* Handle an interrupt from the DMA receive channel. DMA interrupts are:
-*
-* - DMA error. DMA encountered a bus error or timeout. This is a fatal error
-*   that requires reset of the channel.  The driver calls the error handler
-*   of the upper layer software with an error code indicating the device should
-*   be reset.
-* - Packet count threshold reached.  For scatter-gather operations, indicates
-*   the threshold for the number of packets not serviced by software has been
-*   reached. The driver behaves as follows:
-*       - Get the value of the packet counter, which tells us how many packets
-*         are ready to be serviced
-*       - For each packet
-*           - For each descriptor, remove it from the scatter-gather list
-*           - Check for the last descriptor in the frame, and if set
-*               - Bump frame statistics
-*               - Decrement the packet counter by one
-*       - Call the scatter-gather receive callback function
-*       Note that there are no receive errors reported in the status word of
-*       the buffer descriptor.  If receive errors occur, the MAC drops the
-*       packet, and we only find out about the errors through various error
-*       count registers.
-* - Packet wait bound reached.  For scatter-gather, indicates the time to wait
-*   for the next packet has expired.  The driver follows the same logic as when
-*   the packet count threshold interrupt is received.
-* - Scatter-gather end acknowledge.  Hardware has reached the end of the
-*   descriptor list.  The driver follows the same logic as when the packet count
-*   threshold interrupt is received. In addition, the driver restarts the DMA
-*   scatter-gather channel in case there are newly inserted descriptors.
-*
-* @param InstancePtr is a pointer to the XEmac instance to be worked on.
-*
-* @return
-*
-* Although the function returns void, there are asynchronous errors that can
-* be generated (by calling the ErrorHandler) from this function.  These are:
-* - XST_DMA_SG_LIST_EMPTY indicates we tried to get a buffer descriptor from the
-*   DMA channel, but there was not one ready for software.
-* - XST_DMA_ERROR indicates a DMA bus error or timeout occurred. This is a fatal
-*   error that requires reset.
-*
-* @note
-*
-* None.
-*
-******************************************************************************/
-static void HandleDmaRecvIntr(XEmac * InstancePtr)
-{
-	int Result;
-	u32 IntrStatus;
-	u32 NumBds;
-	u32 PacketsLeft;
-	XBufDescriptor *BdHeadPtr;
-	XBufDescriptor *BdPtr;
-
-	/*
-	 * Read the interrupt status
-	 */
-	IntrStatus = XDmaChannel_GetIntrStatus(&InstancePtr->RecvChannel);
-
-	/*
-	 * For packet threshold or wait bound interrupts, process desciptors. Also
-	 * process descriptors on a SG end acknowledgement, which means the end of
-	 * the descriptor list has been reached by the hardware. For receive, this
-	 * is potentially trouble since it means the descriptor list is full,
-	 * unless software can process enough packets quickly enough so the
-	 * hardware has room to put new packets.
-	 */
-	if (IntrStatus & (XDC_IXR_PKT_THRESHOLD_MASK |
-			  XDC_IXR_PKT_WAIT_BOUND_MASK | XDC_IXR_SG_END_MASK)) {
-		/* Get the number of packets that need processing */
-		PacketsLeft =
-			XDmaChannel_GetPktCount(&InstancePtr->RecvChannel);
-
-		if (PacketsLeft) {
-			/* Get the buffer descriptor at the head of the list */
-			Result = XDmaChannel_GetDescriptor(&InstancePtr->
-							   RecvChannel,
-							   &BdHeadPtr);
-			BdPtr = BdHeadPtr;
-			NumBds = 0;
-
-			/* Loop until all packets have been pulled or an error occurs */
-			while (1) {
-				NumBds++;
-
-				/*
-				 * An error getting a buffer descriptor from the list.
-				 * This should not happen, but if it does, report it to
-				 * the error callback and break out of the loop to service
-				 * other interrupts.
-				 */
-				if (Result != XST_SUCCESS) {
-					InstancePtr->ErrorHandler(InstancePtr->
-								  ErrorRef,
-								  Result);
-					break;
-				}
-
-				/* Bump statistics */
-				InstancePtr->Stats.RecvBytes +=
-					XBufDescriptor_GetLength(BdPtr);
-
-				/* Have all BDs been read for this packet */
-				if (XBufDescriptor_IsLastStatus(BdPtr)) {
-					/*
-					 * Decrement the packet count register to reflect the fact
-					 * we just processed a packet
-					 */
-					XDmaChannel_DecrementPktCount
-						(&InstancePtr->RecvChannel);
-
-					/* Bump statistics */
-					InstancePtr->Stats.RecvFrames++;
-
-					/* Test loop exit condition */
-					if (--PacketsLeft == 0) {
-						break;
-					}
-				}
-
-				/* Get the next buffer descriptor in the list */
-				Result = XDmaChannel_GetDescriptor
-					(&InstancePtr->RecvChannel, &BdPtr);
-			}	/* while */
-
-			/*
-			 * Check for error that occurred inside the while loop, and break
-			 * out of the for loop if there was one so other interrupts can
-			 * be serviced.
-			 */
-			if (Result == XST_SUCCESS) {
-				/*
-				 * Make the callback to the upper layers, passing it the first
-				 * descriptor in the first packet and the number of descriptors
-				 * in the list.
-				 */
-				InstancePtr->SgRecvHandler(InstancePtr->
-							   SgRecvRef, BdHeadPtr,
-							   NumBds);
-			}
-		}		/* if (PacketsLeft) */
-
-		/*
-		 * If the interrupt was an end-ack, check the descriptor list again to
-		 * see if it is empty. If not, go ahead and restart the scatter-gather
-		 * channel. This is to fix a possible race condition where, on receive,
-		 * the driver attempted to start a scatter-gather channel that was
-		 * already started, which resulted in no action from the XDmaChannel
-		 * component. But, just after the XDmaChannel component saw that the
-		 * hardware was already started, the hardware stopped because it
-		 * reached the end of the list.  In that case, this interrupt is
-		 * generated and we can restart the hardware here.
-		 */
-		if (IntrStatus & XDC_IXR_SG_END_MASK) {
-			/*
-			 * Ignore the return status since we know the list exists and we
-			 * don't care if the list is empty or the channel is already started.
-			 */
-			(void) XDmaChannel_SgStart(&InstancePtr->RecvChannel);
-		}
-	}
-
-	/*
-	 * All interrupts are handled (except the error below) so acknowledge
-	 * (clear) the interrupts by writing the value read above back to the status
-	 * register. The packet count interrupt must be acknowledged after the
-	 * decrement, otherwise it will come right back. We clear the interrupts
-	 * before we handle the error interrupt because the ErrorHandler should
-	 * result in a reset, which clears the interrupt status register. So we
-	 * don't want to toggle the interrupt back on by writing the interrupt
-	 * status register with an old value after a reset.
-	 */
-	XDmaChannel_SetIntrStatus(&InstancePtr->RecvChannel, IntrStatus);
-
-	/*
-	 * Check for DMA errors and call the error callback function if an error
-	 * occurred (DMA bus or timeout error), which should result in a reset of
-	 * the device by the upper layer software.
-	 */
-	if (IntrStatus & XDC_IXR_DMA_ERROR_MASK) {
-		InstancePtr->Stats.DmaErrors++;
-		InstancePtr->ErrorHandler(InstancePtr->ErrorRef, XST_DMA_ERROR);
-	}
-}
-
-/*****************************************************************************/
-/*
-*
-* Handle an interrupt from the DMA send channel. DMA interrupts are:
-*
-* - DMA error. DMA encountered a bus error or timeout. This is a fatal error
-*   that requires reset of the channel.  The driver calls the error handler
-*   of the upper layer software with an error code indicating the device should
-*   be reset.
-* - Packet count threshold reached.  For scatter-gather operations, indicates
-*   the threshold for the number of packets not serviced by software has been
-*   reached. The driver behaves as follows:
-*       - Get the value of the packet counter, which tells us how many packets
-*         are ready to be serviced
-*       - For each packet
-*           - For each descriptor, remove it from the scatter-gather list
-*           - Check for the last descriptor in the frame, and if set
-*               - Bump frame statistics
-*               - Decrement the packet counter by one
-*       - Call the scatter-gather receive callback function
-*       Note that there are no receive errors reported in the status word of
-*       the buffer descriptor.  If receive errors occur, the MAC drops the
-*       packet, and we only find out about the errors through various error
-*       count registers.
-* - Packet wait bound reached.  For scatter-gather, indicates the time to wait
-*   for the next packet has expired.  The driver follows the same logic as when
-*   the packet count threshold interrupt is received.
-* - Scatter-gather end acknowledge.  Hardware has reached the end of the
-*   descriptor list.  The driver follows the same logic as when the packet count
-*   threshold interrupt is received. In addition, the driver restarts the DMA
-*   scatter-gather channel in case there are newly inserted descriptors.
-*
-* @param InstancePtr is a pointer to the XEmac instance to be worked on.
-*
-* @return
-*
-* Although the function returns void, there are asynchronous errors
-* that can be generated from this function.  These are:
-* - XST_DMA_SG_LIST_EMPTY indicates we tried to get a buffer descriptor from
-*   the DMA channel, but there was not one ready for software.
-* - XST_DMA_ERROR indicates a DMA bus error or timeout occurred. This is a
-*   fatal error that requires reset.
-*
-* @note
-*
-* None.
-*
-******************************************************************************/
-static void HandleDmaSendIntr(XEmac * InstancePtr)
-{
-	int Result;
-	u32 IntrStatus;
-	u32 NumBds;
-	u32 PacketsLeft;
-	u32 XmitStatus;
-	int PacketStart;
-	XBufDescriptor *BdHeadPtr;
-	XBufDescriptor *BdPtr;
-
-	/*
-	 * Read the interrupt status
-	 */
-	IntrStatus = XDmaChannel_GetIntrStatus(&InstancePtr->SendChannel);
-
-	/*
-	 * For packet threshold or wait bound interrupt, process descriptors. Also
-	 * process descriptors on a SG end acknowledgement, which means the end of
-	 * the descriptor list has been reached by the hardware. For transmit,
-	 * this is a normal condition during times of light traffic.  In fact, the
-	 * wait bound interrupt may be masked for transmit since the end-ack would
-	 * always occur before the wait bound expires.
-	 */
-	if (IntrStatus & (XDC_IXR_PKT_THRESHOLD_MASK |
-			  XDC_IXR_PKT_WAIT_BOUND_MASK | XDC_IXR_SG_END_MASK)) {
-		/* Get the number of packets that need processing */
-		PacketsLeft =
-			XDmaChannel_GetPktCount(&InstancePtr->SendChannel);
-
-		if (PacketsLeft) {
-			/* Get the buffer descriptor at the head of the list */
-			Result = XDmaChannel_GetDescriptor(&InstancePtr->
-							   SendChannel,
-							   &BdHeadPtr);
-			BdPtr = BdHeadPtr;
-			NumBds = 0;
-			PacketStart = 1;
-
-			/* Loop until all packets have been pulled or an error occurs */
-			while (1) {
-				NumBds++;
-
-				/*
-				 * An error getting a buffer descriptor from the list.
-				 * This should not happen, but if it does, report it to
-				 * the error callback and break out of the loop to service
-				 * other interrupts.
-				 */
-				if (Result != XST_SUCCESS) {
-					InstancePtr->ErrorHandler(InstancePtr->
-								  ErrorRef,
-								  Result);
-					break;
-				}
-
-				/* Bump statistics */
-				InstancePtr->Stats.XmitBytes +=
-					XBufDescriptor_GetLength(BdPtr);
-
-				/* If 1st BD in a packet, then check xmit status */
-				if (PacketStart) {
-					XmitStatus =
-						XBufDescriptor_GetDeviceStatus
-						(BdPtr);
-					if (XmitStatus &
-					    XEM_TSR_EXCESS_DEFERRAL_MASK) {
-						InstancePtr->Stats.
-							XmitExcessDeferral++;
-					}
-
-					if (XmitStatus &
-					    XEM_TSR_LATE_COLLISION_MASK) {
-						InstancePtr->Stats.
-							XmitLateCollisionErrors++;
-					}
-
-					PacketStart = 0;
-				}
-
-				/* Have all BDs been read for this packet */
-				if (XBufDescriptor_IsLastStatus(BdPtr)) {
-					/*
-					 * Decrement the packet count register to reflect the fact
-					 * we just processed a packet
-					 */
-					XDmaChannel_DecrementPktCount
-						(&InstancePtr->SendChannel);
-
-					/* Bump statistics */
-					InstancePtr->Stats.XmitFrames++;
-
-					/* Test loop exit condition */
-					if (--PacketsLeft == 0) {
-						break;
-					}
-
-					/* Next BD will mark the beginning of a new packet */
-					PacketStart = 1;
-				}
-
-				/* Get the next buffer descriptor in the list */
-				Result = XDmaChannel_GetDescriptor
-					(&InstancePtr->SendChannel, &BdPtr);
-			}	/* while */
-
-			/*
-			 * Check for error that occurred inside the while loop, and break
-			 * out of the for loop if there was one so other interrupts can
-			 * be serviced.
-			 */
-			if (Result == XST_SUCCESS) {
-				/*
-				 * Make the callback to the upper layers, passing it the first
-				 * descriptor in the first packet and the number of descriptors
-				 * in the list.
-				 */
-				InstancePtr->SgSendHandler(InstancePtr->
-							   SgSendRef, BdHeadPtr,
-							   NumBds);
-			}
-		}		/* if (PacketsLeft) */
-
-		/*
-		 * If the interrupt was an end-ack, check the descriptor list again to
-		 * see if it is empty. If not, go ahead and restart the scatter-gather
-		 * channel. This is to fix a possible race condition where, on transmit,
-		 * the driver attempted to start a scatter-gather channel that was
-		 * already started, which resulted in no action from the XDmaChannel
-		 * component. But, just after the XDmaChannel component saw that the
-		 * hardware was already started, the hardware stopped because it
-		 * reached the end of the list.  In that case, this interrupt is
-		 * generated and we can restart the hardware here.
-		 */
-		if (IntrStatus & XDC_IXR_SG_END_MASK) {
-			/*
-			 * Ignore the return status since we know the list exists and we
-			 * don't care if the list is empty or the channel is already started.
-			 */
-			(void) XDmaChannel_SgStart(&InstancePtr->SendChannel);
-		}
-	}
-
-	/*
-	 * All interrupts are handled (except the error below) so acknowledge
-	 * (clear) the interrupts by writing the value read above back to the status
-	 * register. The packet count interrupt must be acknowledged after the
-	 * decrement, otherwise it will come right back. We clear the interrupts
-	 * before we handle the error interrupt because the ErrorHandler should
-	 * result in a reset, which clears the interrupt status register. So we
-	 * don't want to toggle the interrupt back on by writing the interrupt
-	 * status register with an old value after a reset.
-	 */
-	XDmaChannel_SetIntrStatus(&InstancePtr->SendChannel, IntrStatus);
-
-	/*
-	 * Check for DMA errors and call the error callback function if an error
-	 * occurred (DMA bus or timeout error), which should result in a reset of
-	 * the device by the upper layer software.
-	 */
-	if (IntrStatus & XDC_IXR_DMA_ERROR_MASK) {
-		InstancePtr->Stats.DmaErrors++;
-		InstancePtr->ErrorHandler(InstancePtr->ErrorRef, XST_DMA_ERROR);
-	}
-}
-
-/*****************************************************************************/
-/*
-*
-* Handle an interrupt from the Ethernet MAC when configured with scatter-gather
-* DMA. The only interrupts handled in this case are errors.
-*
-* @param InstancePtr is a pointer to the XEmac instance to be worked on.
-*
-* @return
-*
-* None.
-*
-* @note
-*
-* None.
-*
-******************************************************************************/
-static void HandleEmacDmaIntr(XEmac * InstancePtr)
-{
-	u32 IntrStatus;
-
-	/*
-	 * When configured with DMA, the EMAC generates interrupts only when errors
-	 * occur. We clear the interrupts immediately so that any latched status
-	 * interrupt bits will reflect the true status of the device, and so any
-	 * pulsed interrupts (non-status) generated during the Isr will not be lost.
-	 */
-	IntrStatus = XIIF_V123B_READ_IISR(InstancePtr->BaseAddress);
-	XIIF_V123B_WRITE_IISR(InstancePtr->BaseAddress, IntrStatus);
-
-	/*
-	 * Check the MAC for errors
-	 */
-	XEmac_CheckEmacError(InstancePtr, IntrStatus);
-}
diff --git a/drivers/net/ethernet/xilinx/xilinx_emac/xemac_intr_fifo.c b/drivers/net/ethernet/xilinx/xilinx_emac/xemac_intr_fifo.c
deleted file mode 100644
index ad5685c..0000000
--- a/drivers/net/ethernet/xilinx/xilinx_emac/xemac_intr_fifo.c
+++ /dev/null
@@ -1,668 +0,0 @@
-/* $Id: xemac_intr_fifo.c,v 1.2 2007/05/15 00:52:28 wre Exp $ */
-/******************************************************************************
-*
-*       XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS"
-*       AS A COURTESY TO YOU, SOLELY FOR USE IN DEVELOPING PROGRAMS AND
-*       SOLUTIONS FOR XILINX DEVICES.  BY PROVIDING THIS DESIGN, CODE,
-*       OR INFORMATION AS ONE POSSIBLE IMPLEMENTATION OF THIS FEATURE,
-*       APPLICATION OR STANDARD, XILINX IS MAKING NO REPRESENTATION
-*       THAT THIS IMPLEMENTATION IS FREE FROM ANY CLAIMS OF INFRINGEMENT,
-*       AND YOU ARE RESPONSIBLE FOR OBTAINING ANY RIGHTS YOU MAY REQUIRE
-*       FOR YOUR IMPLEMENTATION.  XILINX EXPRESSLY DISCLAIMS ANY
-*       WARRANTY WHATSOEVER WITH RESPECT TO THE ADEQUACY OF THE
-*       IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OR
-*       REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE FROM CLAIMS OF
-*       INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
-*       FOR A PARTICULAR PURPOSE.
-*
-*       (c) Copyright 2003 Xilinx Inc.
-*       All rights reserved.
-*
-******************************************************************************/
-/*****************************************************************************/
-/**
-*
-* @file xemac_intr_fifo.c
-*
-* Contains functions related to interrupt mode using direct FIFO I/O or simple
-* DMA. The driver uses simple DMA if the device is configured with DMA,
-* otherwise it uses direct FIFO access.
-*
-* The interrupt handler, XEmac_IntrHandlerFifo(), must be connected by the user
-* to the interrupt controller.
-*
-* <pre>
-* MODIFICATION HISTORY:
-*
-* Ver   Who  Date     Changes
-* ----- ---- -------- -----------------------------------------------
-* 1.00a rpm  07/31/01 First release
-* 1.00b rpm  02/20/02 Repartitioned files and functions
-* 1.00c rpm  12/05/02 New version includes support for simple DMA
-* 1.00c rpm  04/01/03 Added check in FifoSend for room in the data FIFO
-*                     before starting a simple DMA transfer.
-* 1.00d rpm  09/26/03 New version includes support PLB Ethernet and v2.00a of
-*                     the packet fifo driver.
-* 1.11a wgr  03/22/07 Converted to new coding style.
-* </pre>
-*
-******************************************************************************/
-
-/***************************** Include Files *********************************/
-
-#include "xbasic_types.h"
-#include "xemac_i.h"
-#include "xio.h"
-
-/************************** Constant Definitions *****************************/
-
-
-/**************************** Type Definitions *******************************/
-
-
-/***************** Macros (Inline Functions) Definitions *********************/
-
-
-/************************** Variable Definitions *****************************/
-
-
-/************************** Function Prototypes ******************************/
-
-static void HandleEmacFifoIntr(XEmac * InstancePtr);
-
-/*****************************************************************************/
-/**
-*
-* Send an Ethernet frame using direct FIFO I/O or simple DMA with interrupts.
-* The caller provides a contiguous-memory buffer and its length. The buffer
-* must be 32-bit aligned. If using simple DMA and the PLB 10/100 Ethernet core,
-* the buffer must be 64-bit aligned. The callback function set by using
-* SetFifoSendHandler is invoked when the transmission is complete.
-*
-* It is assumed that the upper layer software supplies a correctly formatted
-* Ethernet frame, including the destination and source addresses, the
-* type/length field, and the data field.
-*
-* If the device is configured with DMA, simple DMA will be used to transfer
-* the buffer from memory to the Emac. This means that this buffer should not
-* be cached.  See the comment section "Simple DMA" in xemac.h for more
-* information.
-*
-* @param InstancePtr is a pointer to the XEmac instance to be worked on.
-* @param BufPtr is a pointer to a aligned buffer containing the Ethernet
-*        frame to be sent.
-* @param ByteCount is the size of the Ethernet frame.
-*
-* @return
-*
-* - XST_SUCCESS if the frame was successfully sent. An interrupt is generated
-*   when the EMAC transmits the frame and the driver calls the callback set
-*   with XEmac_SetFifoSendHandler()
-* - XST_DEVICE_IS_STOPPED  if the device has not yet been started
-* - XST_NOT_INTERRUPT if the device is not in interrupt mode
-* - XST_FIFO_NO_ROOM if there is no room in the FIFO for this frame
-* - XST_DEVICE_BUSY if configured for simple DMA and the DMA engine is busy
-* - XST_DMA_ERROR if an error occurred during the DMA transfer (simple DMA).
-*   The user should treat this as a fatal error that requires a reset of the
-*   EMAC device.
-*
-* @note
-*
-* This function is not thread-safe. The user must provide mutually exclusive
-* access to this function if there are to be multiple threads that can call it.
-*
-* @internal
-*
-* The Ethernet MAC uses FIFOs behind its length and status registers. For this
-* reason, it is important to keep the length, status, and data FIFOs in sync
-* when reading or writing to them.
-*
-******************************************************************************/
-int XEmac_FifoSend(XEmac * InstancePtr, u8 *BufPtr, u32 ByteCount)
-{
-	int Result;
-	volatile u32 StatusReg;
-
-	XASSERT_NONVOID(InstancePtr != NULL);
-	XASSERT_NONVOID(BufPtr != NULL);
-	XASSERT_NONVOID(ByteCount > XEM_HDR_SIZE);	/* send at least 1 byte */
-	XASSERT_NONVOID(InstancePtr->IsReady == XCOMPONENT_IS_READY);
-
-	/*
-	 * Be sure the device is configured for interrupt mode and it is started
-	 */
-	if (InstancePtr->IsPolled) {
-		return XST_NOT_INTERRUPT;
-	}
-
-	if (InstancePtr->IsStarted != XCOMPONENT_IS_STARTED) {
-		return XST_DEVICE_IS_STOPPED;
-	}
-
-	/*
-	 * Before writing to the data FIFO, make sure the length FIFO is not
-	 * full.  The data FIFO might not be full yet even though the length FIFO
-	 * is. This avoids an overrun condition on the length FIFO and keeps the
-	 * FIFOs in sync.
-	 */
-	StatusReg = XEMAC_READ_IISR(InstancePtr->BaseAddress);
-	if (StatusReg & XEM_EIR_XMIT_LFIFO_FULL_MASK) {
-		return XST_FIFO_NO_ROOM;
-	}
-
-	/*
-	 * Send either by directly writing to the FIFOs or using the DMA engine
-	 */
-	if (!XEmac_mIsDma(InstancePtr)) {
-		/*
-		 * This is a non-blocking write. The packet FIFO returns an error if there
-		 * is not enough room in the FIFO for this frame.
-		 */
-		Result = XPacketFifoV200a_Write(&InstancePtr->SendFifo, BufPtr,
-						ByteCount);
-		if (Result != XST_SUCCESS) {
-			return Result;
-		}
-	}
-	else {
-		u32 Vacancy;
-
-		/*
-		 * Need to make sure there is room in the data FIFO for the packet
-		 * before trying to DMA into it. Get the vacancy count (in words)
-		 * and make sure the packet will fit.
-		 */
-		Vacancy = XPF_V200A_GET_COUNT(&InstancePtr->SendFifo);
-		if ((Vacancy * sizeof(u32)) < ByteCount) {
-			return XST_FIFO_NO_ROOM;
-		}
-
-		/*
-		 * Check the DMA engine to make sure it is not already busy
-		 */
-		if (XDmaChannel_GetStatus(&InstancePtr->SendChannel) &
-		    XDC_DMASR_BUSY_MASK) {
-			return XST_DEVICE_BUSY;
-		}
-
-		/*
-		 * Set the DMA control register up properly
-		 */
-		XDmaChannel_SetControl(&InstancePtr->SendChannel,
-				       XDC_DMACR_SOURCE_INCR_MASK |
-				       XDC_DMACR_DEST_LOCAL_MASK |
-				       XDC_DMACR_SG_DISABLE_MASK);
-
-		/*
-		 * Now transfer the data from the buffer to the FIFO
-		 */
-		XDmaChannel_Transfer(&InstancePtr->SendChannel, (u32 *) BufPtr,
-				     (u32 *) (InstancePtr->BaseAddress +
-					      XEM_PFIFO_TXDATA_OFFSET),
-				     ByteCount);
-
-		/*
-		 * Poll here waiting for DMA to be not busy. We think this will
-		 * typically be a single read since DMA should be ahead of the SW.
-		 */
-		do {
-			StatusReg =
-				XDmaChannel_GetStatus(&InstancePtr->
-						      SendChannel);
-		}
-		while (StatusReg & XDC_DMASR_BUSY_MASK);
-
-		/* Return an error if there was a problem with DMA */
-		if ((StatusReg & XDC_DMASR_BUS_ERROR_MASK) ||
-		    (StatusReg & XDC_DMASR_BUS_TIMEOUT_MASK)) {
-			InstancePtr->Stats.DmaErrors++;
-			return XST_DMA_ERROR;
-		}
-	}
-
-	/*
-	 * Set the MAC's transmit packet length register to tell it to transmit
-	 */
-	XIo_Out32(InstancePtr->BaseAddress + XEM_TPLR_OFFSET, ByteCount);
-
-	/*
-	 * Bump stats here instead of the Isr since we know the byte count
-	 * here but would have to save it in the instance in order to know the
-	 * byte count at interrupt time.
-	 */
-	InstancePtr->Stats.XmitFrames++;
-	InstancePtr->Stats.XmitBytes += ByteCount;
-
-	return XST_SUCCESS;
-}
-
-/*****************************************************************************/
-/**
-*
-* Receive an Ethernet frame into the buffer passed as an argument. This
-* function is called in response to the callback function for received frames
-* being called by the driver. The callback function is set up using
-* SetFifoRecvHandler, and is invoked when the driver receives an interrupt
-* indicating a received frame. The driver expects the upper layer software to
-* call this function, FifoRecv, to receive the frame. The buffer supplied
-* should be large enough to hold a maximum-size Ethernet frame.
-*
-* The buffer into which the frame will be received must be 32-bit aligned. If
-* using simple DMA and the PLB 10/100 Ethernet core, the buffer must be 64-bit
-* aligned.
-*
-* If the device is configured with DMA, simple DMA will be used to transfer
-* the buffer from the Emac to memory. This means that this buffer should not
-* be cached. See the comment section "Simple DMA" in xemac.h for more
-* information.
-*
-* @param InstancePtr is a pointer to the XEmac instance to be worked on.
-* @param BufPtr is a pointer to a aligned buffer into which the received
-*        Ethernet frame will be copied.
-* @param ByteCountPtr is both an input and an output parameter. It is a pointer
-*        to a 32-bit word that contains the size of the buffer on entry into
-*        the function and the size the received frame on return from the
-*        function.
-*
-* @return
-*
-* - XST_SUCCESS if the frame was sent successfully
-* - XST_DEVICE_IS_STOPPED if the device has not yet been started
-* - XST_NOT_INTERRUPT if the device is not in interrupt mode
-* - XST_NO_DATA if there is no frame to be received from the FIFO
-* - XST_BUFFER_TOO_SMALL if the buffer to receive the frame is too small for
-*   the frame waiting in the FIFO.
-* - XST_DEVICE_BUSY if configured for simple DMA and the DMA engine is busy
-* - XST_DMA_ERROR if an error occurred during the DMA transfer (simple DMA).
-*   The user should treat this as a fatal error that requires a reset of the
-*   EMAC device.
-*
-* @note
-*
-* The input buffer must be big enough to hold the largest Ethernet frame.
-*
-* @internal
-*
-* The Ethernet MAC uses FIFOs behind its length and status registers. For this
-* reason, it is important to keep the length, status, and data FIFOs in sync
-* when reading or writing to them.
-*
-******************************************************************************/
-int XEmac_FifoRecv(XEmac * InstancePtr, u8 *BufPtr, u32 *ByteCountPtr)
-{
-	int Result;
-	u32 PktLength;
-	u32 StatusReg;
-
-	XASSERT_NONVOID(InstancePtr != NULL);
-	XASSERT_NONVOID(BufPtr != NULL);
-	XASSERT_NONVOID(ByteCountPtr != NULL);
-	XASSERT_NONVOID(InstancePtr->IsReady == XCOMPONENT_IS_READY);
-
-	/*
-	 * Be sure the device is not configured for polled mode and it is started
-	 */
-	if (InstancePtr->IsPolled) {
-		return XST_NOT_INTERRUPT;
-	}
-
-	if (InstancePtr->IsStarted != XCOMPONENT_IS_STARTED) {
-		return XST_DEVICE_IS_STOPPED;
-	}
-
-	/*
-	 * Make sure the buffer is big enough to hold the maximum frame size.
-	 * We need to do this because as soon as we read the MAC's packet length
-	 * register, which is actually a FIFO, we remove that length from the
-	 * FIFO.  We do not want to read the length FIFO without also reading the
-	 * data FIFO since this would get the FIFOs out of sync.  So we have to
-	 * make this restriction.
-	 */
-	if (*ByteCountPtr < XEM_MAX_FRAME_SIZE) {
-		return XST_BUFFER_TOO_SMALL;
-	}
-
-	/*
-	 * Before reading from the length FIFO, make sure the length FIFO is not
-	 * empty. We could cause an underrun error if we try to read from an
-	 * empty FIFO.
-	 */
-	StatusReg = XEMAC_READ_IISR(InstancePtr->BaseAddress);
-	if (StatusReg & XEM_EIR_RECV_LFIFO_EMPTY_MASK) {
-		/*
-		 * Clear the empty status so the next time through the current status
-		 * of the hardware is reflected (we have to do this because the status
-		 * is level in the device but latched in the interrupt status register).
-		 */
-		XEMAC_WRITE_IISR(InstancePtr->BaseAddress,
-				      XEM_EIR_RECV_LFIFO_EMPTY_MASK);
-		return XST_NO_DATA;
-	}
-
-	/*
-	 * If configured with DMA, make sure the DMA engine is not busy
-	 */
-	if (XEmac_mIsDma(InstancePtr)) {
-		if (XDmaChannel_GetStatus(&InstancePtr->RecvChannel) &
-		    XDC_DMASR_BUSY_MASK) {
-			return XST_DEVICE_BUSY;
-		}
-	}
-
-	/*
-	 * Determine, from the MAC, the length of the next packet available
-	 * in the data FIFO (there should be a non-zero length here)
-	 */
-	PktLength = XIo_In32(InstancePtr->BaseAddress + XEM_RPLR_OFFSET);
-	if (PktLength == 0) {
-		return XST_NO_DATA;
-	}
-
-	/*
-	 * We assume that the MAC never has a length bigger than the largest
-	 * Ethernet frame, so no need to make another check here.
-	 *
-	 * Receive either by directly reading the FIFO or using the DMA engine
-	 */
-	if (!XEmac_mIsDma(InstancePtr)) {
-		/*
-		 * This is a non-blocking read. The FIFO returns an error if there is
-		 * not at least the requested amount of data in the FIFO.
-		 */
-		Result = XPacketFifoV200a_Read(&InstancePtr->RecvFifo, BufPtr,
-					       PktLength);
-		if (Result != XST_SUCCESS) {
-			return Result;
-		}
-	}
-	else {
-		/*
-		 * Call on DMA to transfer from the FIFO to the buffer. First set up
-		 * the DMA control register.
-		 */
-		XDmaChannel_SetControl(&InstancePtr->RecvChannel,
-				       XDC_DMACR_DEST_INCR_MASK |
-				       XDC_DMACR_SOURCE_LOCAL_MASK |
-				       XDC_DMACR_SG_DISABLE_MASK);
-
-		/*
-		 * Now transfer the data
-		 */
-		XDmaChannel_Transfer(&InstancePtr->RecvChannel,
-				     (u32 *) (InstancePtr->BaseAddress +
-					      XEM_PFIFO_RXDATA_OFFSET),
-				     (u32 *) BufPtr, PktLength);
-
-		/*
-		 * Poll here waiting for DMA to be not busy. We think this will
-		 * typically be a single read since DMA should be ahead of the SW.
-		 */
-		do {
-			StatusReg =
-				XDmaChannel_GetStatus(&InstancePtr->
-						      RecvChannel);
-		}
-		while (StatusReg & XDC_DMASR_BUSY_MASK);
-
-		/* Return an error if there was a problem with DMA */
-		if ((StatusReg & XDC_DMASR_BUS_ERROR_MASK) ||
-		    (StatusReg & XDC_DMASR_BUS_TIMEOUT_MASK)) {
-			InstancePtr->Stats.DmaErrors++;
-			return XST_DMA_ERROR;
-		}
-	}
-
-	*ByteCountPtr = PktLength;
-
-	InstancePtr->Stats.RecvFrames++;
-	InstancePtr->Stats.RecvBytes += PktLength;
-
-	return XST_SUCCESS;
-}
-
-/*****************************************************************************/
-/**
-*
-* The interrupt handler for the Ethernet driver when configured for direct FIFO
-* communication or simple DMA.
-*
-* Get the interrupt status from the IpIf to determine the source of the
-* interrupt.  The source can be: MAC, Recv Packet FIFO, or Send Packet FIFO.
-* The packet FIFOs only interrupt during "deadlock" conditions.  All other
-* FIFO-related interrupts are generated by the MAC.
-*
-* @param InstancePtr is a pointer to the XEmac instance that just interrupted.
-*
-* @return
-*
-* None.
-*
-* @note
-*
-* None.
-*
-******************************************************************************/
-void XEmac_IntrHandlerFifo(void *InstancePtr)
-{
-	u32 IntrStatus;
-	XEmac *EmacPtr = (XEmac *) InstancePtr;
-
-	EmacPtr->Stats.TotalIntrs++;
-
-	/*
-	 * Get the interrupt status from the IPIF. There is no clearing of
-	 * interrupts in the IPIF. Interrupts must be cleared at the source.
-	 */
-	IntrStatus = XEMAC_READ_DIPR(EmacPtr->BaseAddress);
-
-	if (IntrStatus & XEM_IPIF_EMAC_MASK) {	/* MAC interrupt */
-		EmacPtr->Stats.EmacInterrupts++;
-		HandleEmacFifoIntr(EmacPtr);
-	}
-
-	if (IntrStatus & XEM_IPIF_RECV_FIFO_MASK) {	/* Receive FIFO interrupt */
-		EmacPtr->Stats.RecvInterrupts++;
-		XEmac_CheckFifoRecvError(EmacPtr);
-	}
-
-	if (IntrStatus & XEM_IPIF_SEND_FIFO_MASK) {	/* Send FIFO interrupt */
-		EmacPtr->Stats.XmitInterrupts++;
-		XEmac_CheckFifoSendError(EmacPtr);
-	}
-
-	if (IntrStatus & XEMAC_ERROR_MASK) {
-		/*
-		 * An error occurred internal to the IPIF. This is more of a debug and
-		 * integration issue rather than a production error. Don't do anything
-		 * other than clear it, which provides a spot for software to trap
-		 * on the interrupt and begin debugging.
-		 */
-		XEMAC_WRITE_DISR(EmacPtr->BaseAddress,
-				      XEMAC_ERROR_MASK);
-	}
-}
-
-/*****************************************************************************/
-/**
-*
-* Set the callback function for handling confirmation of transmitted frames when
-* configured for direct memory-mapped I/O using FIFOs. The upper layer software
-* should call this function during initialization. The callback is called by the
-* driver once per frame sent. The callback is responsible for freeing the
-* transmitted buffer if necessary.
-*
-* The callback is invoked by the driver within interrupt context, so it needs
-* to do its job quickly. If there are potentially slow operations within the
-* callback, these should be done at task-level.
-*
-* @param InstancePtr is a pointer to the XEmac instance to be worked on.
-* @param CallBackRef is a reference pointer to be passed back to the driver in
-*        the callback. This helps the driver correlate the callback to a
-*        particular driver.
-* @param FuncPtr is the pointer to the callback function.
-*
-* @return
-*
-* None.
-*
-* @note
-*
-* None.
-*
-******************************************************************************/
-void XEmac_SetFifoRecvHandler(XEmac * InstancePtr, void *CallBackRef,
-			      XEmac_FifoHandler FuncPtr)
-{
-	XASSERT_VOID(InstancePtr != NULL);
-	XASSERT_VOID(FuncPtr != NULL);
-	XASSERT_VOID(InstancePtr->IsReady == XCOMPONENT_IS_READY);
-
-	InstancePtr->FifoRecvHandler = FuncPtr;
-	InstancePtr->FifoRecvRef = CallBackRef;
-}
-
-/*****************************************************************************/
-/**
-*
-* Set the callback function for handling received frames when configured for
-* direct memory-mapped I/O using FIFOs. The upper layer software should call
-* this function during initialization. The callback is called once per frame
-* received. During the callback, the upper layer software should call FifoRecv
-* to retrieve the received frame.
-*
-* The callback is invoked by the driver within interrupt context, so it needs
-* to do its job quickly. Sending the received frame up the protocol stack
-* should be done at task-level. If there are other potentially slow operations
-* within the callback, these too should be done at task-level.
-*
-* @param InstancePtr is a pointer to the XEmac instance to be worked on.
-* @param CallBackRef is a reference pointer to be passed back to the driver in
-*        the callback. This helps the driver correlate the callback to a
-*        particular driver.
-* @param FuncPtr is the pointer to the callback function.
-*
-* @return
-*
-* None.
-*
-* @note
-*
-* None.
-*
-******************************************************************************/
-void XEmac_SetFifoSendHandler(XEmac * InstancePtr, void *CallBackRef,
-			      XEmac_FifoHandler FuncPtr)
-{
-	XASSERT_VOID(InstancePtr != NULL);
-	XASSERT_VOID(FuncPtr != NULL);
-	XASSERT_VOID(InstancePtr->IsReady == XCOMPONENT_IS_READY);
-
-	InstancePtr->FifoSendHandler = FuncPtr;
-	InstancePtr->FifoSendRef = CallBackRef;
-}
-
-/******************************************************************************
-*
-* Handle an interrupt from the Ethernet MAC when configured for direct FIFO
-* communication.  The interrupts handled are:
-* - Transmit done (transmit status FIFO is non-empty). Used to determine when
-*   a transmission has been completed.
-* - Receive done (receive length FIFO is non-empty). Used to determine when a
-*   valid frame has been received.
-*
-* In addition, the interrupt status is checked for errors.
-*
-* @param InstancePtr is a pointer to the XEmac instance to be worked on.
-*
-* @return
-*
-* None.
-*
-* @note
-*
-* None.
-*
-******************************************************************************/
-static void HandleEmacFifoIntr(XEmac * InstancePtr)
-{
-	u32 IntrStatus;
-
-	/*
-	 * The EMAC generates interrupts for errors and generates the transmit
-	 * and receive done interrupts for data. We clear the interrupts
-	 * immediately so that any latched status interrupt bits will reflect the
-	 * true status of the device, and so any pulsed interrupts (non-status)
-	 * generated during the Isr will not be lost.
-	 */
-	IntrStatus = XEMAC_READ_IISR(InstancePtr->BaseAddress);
-	XEMAC_WRITE_IISR(InstancePtr->BaseAddress, IntrStatus);
-
-	if (IntrStatus & XEM_EIR_RECV_DONE_MASK) {
-		/*
-		 * Configured for direct memory-mapped I/O using FIFO with interrupts.
-		 * This interrupt means the RPLR is non-empty, indicating a frame has
-		 * arrived.
-		 */
-		InstancePtr->Stats.RecvInterrupts++;
-
-		InstancePtr->FifoRecvHandler(InstancePtr->FifoRecvRef);
-
-		/*
-		 * The upper layer has removed as many frames as it wants to, so we
-		 * need to clear the RECV_DONE bit before leaving the ISR so that it
-		 * reflects the current state of the hardware (because it's a level
-		 * interrupt that is latched in the IPIF interrupt status register).
-		 * Note that if we've reached this point the bit is guaranteed to be
-		 * set because it was cleared at the top of this ISR before any frames
-		 * were serviced, so the bit was set again immediately by hardware
-		 * because the RPLR was not yet emptied by software.
-		 */
-		XEMAC_WRITE_IISR(InstancePtr->BaseAddress,
-				      XEM_EIR_RECV_DONE_MASK);
-	}
-
-	/*
-	 * If configured for direct memory-mapped I/O using FIFO, the xmit status
-	 * FIFO must be read and the callback invoked regardless of success or not.
-	 */
-	if (IntrStatus & XEM_EIR_XMIT_DONE_MASK) {
-		u32 XmitStatus;
-
-		InstancePtr->Stats.XmitInterrupts++;
-
-		XmitStatus =
-			XIo_In32(InstancePtr->BaseAddress + XEM_TSR_OFFSET);
-
-		/*
-		 * Collision errors are stored in the transmit status register
-		 * instead of the interrupt status register
-		 */
-		if (XmitStatus & XEM_TSR_EXCESS_DEFERRAL_MASK) {
-			InstancePtr->Stats.XmitExcessDeferral++;
-		}
-
-		if (XmitStatus & XEM_TSR_LATE_COLLISION_MASK) {
-			InstancePtr->Stats.XmitLateCollisionErrors++;
-		}
-
-		InstancePtr->FifoSendHandler(InstancePtr->FifoSendRef);
-
-		/*
-		 * Only one status is retrieved per interrupt. We need to clear the
-		 * XMIT_DONE bit before leaving the ISR so that it reflects the current
-		 * state of the hardware (because it's a level interrupt that is latched
-		 * in the IPIF interrupt status register). Note that if we've reached
-		 * this point the bit is guaranteed to be set because it was cleared at
-		 * the top of this ISR before any statuses were serviced, so the bit was
-		 * set again immediately by hardware because the TSR was not yet emptied
-		 * by software.
-		 */
-		XEMAC_WRITE_IISR(InstancePtr->BaseAddress,
-				      XEM_EIR_XMIT_DONE_MASK);
-	}
-
-	/*
-	 * Check the MAC for errors
-	 */
-	XEmac_CheckEmacError(InstancePtr, IntrStatus);
-}
diff --git a/drivers/net/ethernet/xilinx/xilinx_emac/xemac_linux.c b/drivers/net/ethernet/xilinx/xilinx_emac/xemac_linux.c
deleted file mode 100644
index c302be9..0000000
--- a/drivers/net/ethernet/xilinx/xilinx_emac/xemac_linux.c
+++ /dev/null
@@ -1,2802 +0,0 @@
-/*
- * emac_linux.c
- *
- * Xilinx Ethernet Adapter component to interface XEmac component to Linux
- *
- * Author: MontaVista Software, Inc.
- *         source@mvista.com
- *
- * 2002 (c) MontaVista, Software, Inc.  This file is licensed under the terms
- * of the GNU General Public License version 2.1.  This program is licensed
- * "as is" without any warranty of any kind, whether express or implied.
- * MODIFICATION HISTORY:
- *
- * Ver   Who  Date     Changes
- * ----- ---- -------- -----------------------------------------------
- * 1.01a ecm  12/19/04 Added TX and RX DRE and Checksum offload functionality.
- *                     This adapter now only works with v1.01.a of the XEmac
- *                     driver. Also enables stripping of the PAD and FCS and
- *                     The adpater requires this feature to function properly
- *
- * 1.01a rpm  06/09/06 Fixed the FCS subtraction above for bridging by using
- *                     skb_put when setting the skb length instead of directly
- *                     assigning the skb->len field. Directly assigning it
- *                     broke IP forwarding.
- * 1.01a wgr  09/14/06 Ported to Linux 2.6
- * 1.01a xd   10/13/06 Add support to change MTU on the fly using tools like
- *                     ifconfig
- * 1.01a wgr  10/13/06 Added workaround for PHY detection
- * 1.11a wgr  03/22/07 Converted to new coding style.
- */
-
-/*
- * This driver is a bit unusual in that it is composed of two logical
- * parts where one part is the OS independent code and the other part is
- * the OS dependent code.  Xilinx provides their drivers split in this
- * fashion.  This file represents the Linux OS dependent part known as
- * the Linux adapter.  The other files in this directory are the OS
- * independent files as provided by Xilinx with no changes made to them.
- * The names exported by those files begin with XEmac_.  All functions
- * in this file that are called by Linux have names that begin with
- * xenet_.  The functions in this file that have Handler in their name
- * are registered as callbacks with the underlying Xilinx OS independent
- * layer.  Any other functions are static helper functions.
- */
-
-#include <linux/module.h>
-#include <asm/uaccess.h>
-#include <linux/init.h>
-#include <linux/netdevice.h>
-#include <linux/etherdevice.h>
-#include <linux/skbuff.h>
-#include <linux/mii.h>
-#include <linux/pci.h>
-#include <linux/string.h>
-#include <asm/io.h>
-#include <asm/irq.h>
-#include <asm/atomic.h>
-#include <asm/checksum.h>
-#include <linux/ethtool.h>
-
-#include <linux/xilinx_devices.h>
-
-#include <xbasic_types.h>
-#include "xemac.h"
-#include "xemac_i.h"
-#include "xipif_v1_23_b.h"
-
-#ifdef CONFIG_OF
-// For open firmware.
-#include <linux/of_device.h>
-#include <linux/of_platform.h>
-#endif
-
-/*
- * Add a delay (in ms) after resetting the EMAC since it
- * also resets the PHY - which needs a delay before using it. - RPM
- */
-#define RESET_DELAY 1500
-
-#ifdef RESET_DELAY
-#   include <linux/delay.h>
-#endif
-
-#undef XEM_DFT_SEND_DESC
-#define XEM_DFT_SEND_DESC       256
-#define DFT_LOCAL_SEND_DESC     64
-
-#undef XEM_DFT_RECV_DESC
-#define XEM_DFT_RECV_DESC       256
-
-#define DRIVER_NAME "xilinx_emac"
-#define DRIVER_VERSION "1.0"
-
-MODULE_AUTHOR("MontaVista Software, Inc. <source@mvista.com>");
-MODULE_DESCRIPTION("Xilinx Ethernet MAC driver");
-MODULE_LICENSE("GPL");
-
-#define TX_TIMEOUT   (60*HZ)	/* Transmission timeout is 60 seconds. */
-
-/* On the OPB, the 10/100 EMAC requires data to be aligned to 4 bytes.
- * On the PLB, the 10/100 EMAC requires data to be aligned to 8 bytes.
- * For simplicity, we always align to 8 bytes.
- */
-#define ALIGNMENT           32
-
-/* BUFFER_ALIGN(adr) calculates the number of bytes to the next alignment. */
-#define BUFFER_ALIGN(adr) ((ALIGNMENT - ((u32) adr)) % ALIGNMENT)
-
-#define ENET_HDR_SIZ        14
-#define ETHERTYPE_IP        0x0800	/* IP protocol */
-
-#define RX_PSEUDO_HEADER_DATA_START     12
-#define RX_PSEUDO_HEADER_DATA_END       18
-
-/* physical to virtual pointer conversion */
-#define P_TO_V(InstancePtr, p) \
-    ((p) ? \
-     ((InstancePtr)->VirtPtr + ((u32)(p) - (u32)(InstancePtr)->PhyPtr)) : \
-     0)
-
-int bh_entry = 0;
-
-/*
- * Our private per device data.  When a net_device is allocated we will
- * ask for enough extra space for this.
- */
-struct net_local {
-	struct list_head rcv;
-	XBufDescriptor *rcvBdPtr;
-	int rcvBds;
-	struct list_head xmit;
-	XBufDescriptor *xmitBdPtr;
-	int xmitBds;
-
-	struct net_device_stats stats;	/* Statistics for this device */
-	struct net_device *ndev;	/* this device */
-	struct timer_list phy_timer;	/* PHY monitoring timer */
-	XInterruptHandler Isr;	/* Pointer to the XEmac ISR routine */
-	u8 mii_addr;		/* The MII address of the PHY */
-	/*
-	 * The underlying OS independent code needs space as well.  A
-	 * pointer to the following XEmac structure will be passed to
-	 * any XEmac_ function that requires it.  However, we treat the
-	 * data as an opaque object in this file (meaning that we never
-	 * reference any of the fields inside of the structure).
-	 */
-	XEmac Emac;
-
-	void *desc_space;		/* Virtual address */
-	dma_addr_t desc_space_handle;	/* Physical address */
-	int desc_space_size;
-
-	u8 *ddrVirtPtr;
-	u32 ddrOffset;
-	u32 ddrSize;
-
-	struct sk_buff *deferred_skb;
-
-	atomic_t availSendBds;
-};
-
-/* for exclusion of all program flows (processes, ISRs and BHs) possible to share data with current one */
-static spinlock_t reset_lock = __SPIN_LOCK_UNLOCKED(reset_lock);
-
-/* Helper function to determine if a given XEmac error warrants a reset. */
-extern inline int status_requires_reset(int s)
-{
-	return (s == XST_DMA_ERROR || s == XST_FIFO_ERROR ||
-		s == XST_RESET_ERROR || s == XST_DMA_SG_NO_LIST ||
-		s == XST_DMA_SG_LIST_EMPTY);
-}
-
-/* BH statics */
-static LIST_HEAD(receivedQueue);
-static spinlock_t rcvSpin = __SPIN_LOCK_UNLOCKED(rcvSpin);
-
-static LIST_HEAD(sentQueue);
-static spinlock_t xmitSpin = __SPIN_LOCK_UNLOCKED(xmitSpin);
-
-/*
- * The following are notes regarding the critical sections in this
- * driver and how they are protected.
- *
- *
- * XEmac_Start, XEmac_Stop and XEmac_SetOptions are not thread safe.
- * These functions are called from xenet_open(), xenet_close(), reset(),
- * and xenet_set_multicast_list().  xenet_open() and xenet_close()
- * should be safe because when they do start and stop, they don't have
- * interrupts or timers enabled.  The other side is that they won't be
- * called while a timer or interrupt is being handled.
- *
- * XEmac_PhyRead and XEmac_PhyWrite are not thread safe.
- * These functions are called from get_phy_status(), xenet_ioctl() and
- * xenet_probe().  xenet_probe() is only called from xenet_init() so it is not
- * an issue (nothing is really up and running yet).  get_phy_status() is called
- * from both poll_mii() (a timer bottom half) and xenet_open().  These
- * shouldn't interfere with each other because xenet_open() is what starts the
- * poll_mii() timer.  xenet_open() and xenet_ioctl() should be safe as well
- * because they will be sequential.  That leaves the interaction between
- * poll_mii() and xenet_ioctl().  While the timer bottom half is executing, a
- * new ioctl won't come in so that is taken care of.  That leaves the one case
- * of the poll_mii timer popping while handling an ioctl.  To take care of that
- * case, the timer is deleted when the ioctl comes in and then added back in
- * after the ioctl is finished.
- */
-
-typedef enum DUPLEX { UNKNOWN_DUPLEX, HALF_DUPLEX, FULL_DUPLEX } DUPLEX;
-static void reset(struct net_device *dev, DUPLEX duplex)
-{
-	struct net_local *lp = (struct net_local *) netdev_priv(dev);
-	u32 Options;
-	u8 IfgPart1;
-	u8 IfgPart2;
-	u8 SendThreshold;
-	u32 SendWaitBound;
-	u8 RecvThreshold;
-	u32 RecvWaitBound;
-	int dma_works;
-
-	/* Shouldn't really be necessary, but shouldn't hurt. */
-	netif_stop_queue(dev);
-
-	/*
-	 * XEmac_Reset puts the device back to the default state.  We need
-	 * to save all the settings we don't already know, reset, restore
-	 * the settings, and then restart the emac.
-	 */
-	XEmac_GetInterframeGap(&lp->Emac, &IfgPart1, &IfgPart2);
-	Options = XEmac_GetOptions(&lp->Emac);
-	switch (duplex) {
-	case HALF_DUPLEX:
-		Options &= ~XEM_FDUPLEX_OPTION;
-		break;
-	case FULL_DUPLEX:
-		Options |= XEM_FDUPLEX_OPTION;
-		break;
-	case UNKNOWN_DUPLEX:
-		break;
-	}
-
-	if (XEmac_mIsSgDma(&lp->Emac)) {
-		/*
-		 * The following four functions will return an error if we are
-		 * not doing scatter-gather DMA.  We just checked that so we
-		 * can safely ignore the return values.  We cast them to void
-		 * to make that explicit.
-		 */
-		dma_works = 1;
-		(void) XEmac_GetPktThreshold(&lp->Emac, XEM_SEND,
-					     &SendThreshold);
-		(void) XEmac_GetPktWaitBound(&lp->Emac, XEM_SEND,
-					     &SendWaitBound);
-		(void) XEmac_GetPktThreshold(&lp->Emac, XEM_RECV,
-					     &RecvThreshold);
-		(void) XEmac_GetPktWaitBound(&lp->Emac, XEM_RECV,
-					     &RecvWaitBound);
-	}
-	else
-		dma_works = 0;
-
-	XEmac_Reset(&lp->Emac);
- 
-#ifdef RESET_DELAY
-	mdelay(RESET_DELAY);
-#endif
-
-	/*
-	 * The following three functions will return an error if the
-	 * EMAC is already started.  We just stopped it by calling
-	 * XEmac_Reset() so we can safely ignore the return values.
-	 * We cast them to void to make that explicit.
-	 */
-	(void) XEmac_SetMacAddress(&lp->Emac, dev->dev_addr);
-	(void) XEmac_SetInterframeGap(&lp->Emac, IfgPart1, IfgPart2);
-	(void) XEmac_SetOptions(&lp->Emac, Options);
-	if (XEmac_mIsSgDma(&lp->Emac)) {
-		/*
-		 * The following four functions will return an error if
-		 * we are not doing scatter-gather DMA or if the EMAC is
-		 * already started.  We just checked that we are indeed
-		 * doing scatter-gather and we just stopped the EMAC so
-		 * we can safely ignore the return values.  We cast them
-		 * to void to make that explicit.
-		 */
-		(void) XEmac_SetPktThreshold(&lp->Emac, XEM_SEND,
-					     SendThreshold);
-		(void) XEmac_SetPktWaitBound(&lp->Emac, XEM_SEND,
-					     SendWaitBound);
-		(void) XEmac_SetPktThreshold(&lp->Emac, XEM_RECV,
-					     RecvThreshold);
-		(void) XEmac_SetPktWaitBound(&lp->Emac, XEM_RECV,
-					     RecvWaitBound);
-	}
-
-	/*
-	 * XEmac_Start returns an error when: it is already started, the send
-	 * and receive handlers are not set, or a scatter-gather DMA list is
-	 * missing.  None of these can happen at this point, so we cast the
-	 * return to void to make that explicit.
-	 */
-
-	if (dma_works) {
-		int avail_plus = 0;
-
-		while (!(XDmaChannel_IsSgListEmpty(&(lp->Emac.SendChannel)))) {	/* list isn't empty, has to be cleared */
-			int ret;
-			XBufDescriptor *BdPtr;
-
-			if ((ret =
-			     XDmaChannel_GetDescriptor(&(lp->Emac.SendChannel),
-						       &BdPtr)) !=
-			    XST_SUCCESS) {
-				printk(KERN_ERR
-				       "SgDma ring structure ERROR %d\n", ret);
-				break;
-			}
-			avail_plus++;
-			XBufDescriptor_Unlock(BdPtr);
-			pci_unmap_single(NULL,
-					 (u32)
-					 XBufDescriptor_GetSrcAddress(BdPtr),
-					 XBufDescriptor_GetLength(BdPtr),
-					 DMA_TO_DEVICE);
-			lp->stats.tx_errors++;
-		}
-		atomic_add(avail_plus, &lp->availSendBds);
-	}
-	else {
-		if (lp->deferred_skb) {
-			dev_kfree_skb(lp->deferred_skb);
-			lp->deferred_skb = NULL;
-			lp->stats.tx_errors++;
-		}
-	}
-
-	dev->trans_start = 0xffffffff - TX_TIMEOUT - TX_TIMEOUT;	/* to exclude tx timeout */
-	(void) XEmac_Start(&lp->Emac);
-	/* We're all ready to go.  Start the queue in case it was stopped. */
-	if (!bh_entry)
-		netif_wake_queue(dev);
-}
-
-/******************************************************************************
-*
-* FUNCTION:
-*
-* AddCsumRxPseudoHeader
-*
-* DESCRIPTION:
-*
-* Calculate the Pseudo header checksum of the provided IP packet
-*
-* ARGUMENTS:
-*
-* skb is the buffer containing the received packet. The entire packet is
-* within this skb.
-*
-* Initial Checksum - Checksum to start with, InitCSum
-*
-* Length of the Data, IpPayloadLen
-*
-* ProtoTTL is the data from the IP header containing the Time To Live (TTL)
-*          and the protocol type, 6 = TCP and 16 = UDP
-*
-*
-* RETURN VALUE:
-*
-* Completed checksum or 0 if not an IP/TCP or IP/UDP packet
-*
-******************************************************************************/
-inline static u16 AddCsumRxPseudoHeader(struct sk_buff *skb, u16 InitCSum,
-					u16 IpPayloadLen, u16 ProtoTTL)
-{
-	register u32 Csum;
-	int i;
-
-	Csum = InitCSum;
-
-	/*
-	 * Add in the pseudoheader source address and destination address info
-	 */
-
-	for (i = RX_PSEUDO_HEADER_DATA_START;
-	     i <= RX_PSEUDO_HEADER_DATA_END; i = i + 2) {
-		Csum += (u32) (*(u16 *) (skb->data + i));
-	}
-
-	Csum += (u32) (ProtoTTL & 0x00FF);
-
-	/* Add in the length of the TCP/UDP data payload */
-	Csum += (u32) (IpPayloadLen);
-
-	/* Handle the carries */
-	Csum += ((Csum & 0xFFFF0000) >> 16);
-
-
-	return (Csum);
-
-}
-
-static int get_phy_status(struct net_device *dev, DUPLEX * duplex, int *linkup)
-{
-	struct net_local *lp = (struct net_local *) netdev_priv(dev);
-	u16 reg;
-	int xs;
-
-	xs = XEmac_PhyRead(&lp->Emac, lp->mii_addr, MII_BMCR, &reg);
-	if (xs != XST_SUCCESS) {
-		printk(KERN_ERR
-		       "%s: Could not read PHY control register; error %d\n",
-		       dev->name, xs);
-		return -1;
-	}
-
-	if (!(reg & BMCR_ANENABLE)) {
-		/*
-		 * Auto-negotiation is disabled so the full duplex bit in
-		 * the control tells us if the PHY is running
-		 * half or full duplex.
-		 */
-		*duplex = (reg & BMCR_FULLDPLX) ? FULL_DUPLEX : HALF_DUPLEX;
-	}
-	else {
-		/*
-		 * Auto-negotiation is enabled.  Figure out what was
-		 * negotiated by looking for the best mode in the union
-		 * of what we and our partner advertise.
-		 */
-		u16 advertise, partner, negotiated;
-
-		xs = XEmac_PhyRead(&lp->Emac, lp->mii_addr,
-				   MII_ADVERTISE, &advertise);
-		if (xs != XST_SUCCESS) {
-			printk(KERN_ERR
-			       "%s: Could not read PHY advertisement; error %d\n",
-			       dev->name, xs);
-			return -1;
-		}
-		xs = XEmac_PhyRead(&lp->Emac, lp->mii_addr, MII_LPA, &partner);
-		if (xs != XST_SUCCESS) {
-			printk(KERN_ERR
-			       "%s: Could not read PHY LPA; error %d\n",
-			       dev->name, xs);
-			return -1;
-		}
-
-		negotiated = advertise & partner & ADVERTISE_ALL;
-		if (negotiated & ADVERTISE_100FULL)
-			*duplex = FULL_DUPLEX;
-		else if (negotiated & ADVERTISE_100HALF)
-			*duplex = HALF_DUPLEX;
-		else if (negotiated & ADVERTISE_10FULL)
-			*duplex = FULL_DUPLEX;
-		else
-			*duplex = HALF_DUPLEX;
-	}
-
-	xs = XEmac_PhyRead(&lp->Emac, lp->mii_addr, MII_BMSR, &reg);
-	if (xs != XST_SUCCESS) {
-		printk(KERN_ERR
-		       "%s: Could not read PHY status register; error %d\n",
-		       dev->name, xs);
-		return -1;
-	}
-
-	*linkup = (reg & BMSR_LSTATUS) != 0;
-
-	return 0;
-}
-
-/*
- * This routine is used for two purposes.  The first is to keep the
- * EMAC's duplex setting in sync with the PHY's.  The second is to keep
- * the system apprised of the state of the link.  Note that this driver
- * does not configure the PHY.  Either the PHY should be configured for
- * auto-negotiation or it should be handled by something like mii-tool.
- */
-static void poll_mii(unsigned long data)
-{
-	struct net_device *dev = (struct net_device *) data;
-	struct net_local *lp = (struct net_local *) netdev_priv(dev);
-	u32 Options;
-	DUPLEX phy_duplex, mac_duplex;
-	int phy_carrier, netif_carrier;
-	unsigned long flags;
-
-	/* First, find out what's going on with the PHY. */
-	if (get_phy_status(dev, &phy_duplex, &phy_carrier)) {
-		printk(KERN_ERR "%s: Terminating link monitoring.\n",
-		       dev->name);
-		return;
-	}
-
-	/* Second, figure out if we have the EMAC in half or full duplex. */
-	Options = XEmac_GetOptions(&lp->Emac);
-	mac_duplex = (Options & XEM_FDUPLEX_OPTION) ? FULL_DUPLEX : HALF_DUPLEX;
-
-	/* Now see if there is a mismatch. */
-	if (mac_duplex != phy_duplex) {
-		/*
-		 * Make sure that no interrupts come in that could cause
-		 * reentrancy problems in reset.
-		 */
-		spin_lock_irqsave(&reset_lock, flags);
-		reset(dev, phy_duplex);	/* the function sets Emac options to match the PHY */
-		spin_unlock_irqrestore(&reset_lock, flags);
-		if (mac_duplex == FULL_DUPLEX)
-			printk(KERN_INFO
-			       "%s: Duplex has been changed: now %s\n",
-			       dev->name, "HALF_DUPLEX");
-		else
-			printk(KERN_INFO
-			       "%s: Duplex has been changed: now %s\n",
-			       dev->name, "FULL_DUPLEX");
-	}
-	netif_carrier = netif_carrier_ok(dev) != 0;
-
-	if (phy_carrier != netif_carrier) {
-		if (phy_carrier) {
-			printk(KERN_INFO "%s: Link carrier restored.\n",
-			       dev->name);
-			netif_carrier_on(dev);
-		}
-		else {
-			printk(KERN_INFO "%s: Link carrier lost.\n", dev->name);
-			netif_carrier_off(dev);
-		}
-	}
-
-	/* Set up the timer so we'll get called again in 2 seconds. */
-	lp->phy_timer.expires = jiffies + 2 * HZ;
-	add_timer(&lp->phy_timer);
-}
-
-/*
- * This routine is registered with the OS as the function to call when
- * the EMAC interrupts.  It in turn, calls the Xilinx OS independent
- * interrupt function.  There are different interrupt functions for FIFO
- * and scatter-gather so we just set a pointer (Isr) into our private
- * data so we don't have to figure it out here.  The Xilinx OS
- * independent interrupt function will in turn call any callbacks that
- * we have registered for various conditions.
- */
-static irqreturn_t xenet_interrupt(int irq, void *dev_id)
-{
-	struct net_device *dev = dev_id;
-	struct net_local *lp = (struct net_local *) netdev_priv(dev);
-
-	/* Call it. */
-	(*(lp->Isr)) (&lp->Emac);
-
-	/* Right now, our IRQ handlers do not return a status. Let's always return
-	 * IRQ_HANDLED here for now.
-	 */
-	return IRQ_HANDLED;
-}
-
-static int xenet_open(struct net_device *dev)
-{
-	struct net_local *lp = (struct net_local *) netdev_priv(dev);
-	u32 Options;
-	DUPLEX phy_duplex, mac_duplex;
-	int phy_carrier;
-
-	/*
-	 * Just to be safe, stop the device first.  If the device is already
-	 * stopped, an error will be returned.  In this case, we don't really
-	 * care, so cast it to void to make it explicit.
-	 */
-	(void) XEmac_Stop(&lp->Emac);
-	/* Set the MAC address each time opened. */
-	if (XEmac_SetMacAddress(&lp->Emac, dev->dev_addr) != XST_SUCCESS) {
-		printk(KERN_ERR "%s: Could not set MAC address.\n", dev->name);
-		return -EIO;
-	}
-
-	/*
-	 * If the device is not configured for polled mode, connect to the
-	 * interrupt controller and enable interrupts.  Currently, there
-	 * isn't any code to set polled mode, so this check is probably
-	 * superfluous.
-	 */
-	Options = XEmac_GetOptions(&lp->Emac);
-	if ((Options & XEM_POLLED_OPTION) == 0) {
-		int retval;
-
-		/* Grab the IRQ */
-		retval = request_irq(dev->irq, xenet_interrupt, 0, dev->name, dev);
-		if (retval) {
-			printk(KERN_ERR
-			       "%s: Could not allocate interrupt %d.\n",
-			       dev->name, dev->irq);
-			return retval;
-		}
-	}
-
-        /* Only advertise 10/100 modes, since we can't talk to a
-         * Tri-mode PHY if it autonegotiates a gigabit link. (e.g. ML403, ML410)
-         */
-        XEmac_PhyWrite(&lp->Emac, lp->mii_addr, MII_ADVERTISE, ADVERTISE_ALL | ADVERTISE_CSMA);
-        XEmac_PhyWrite(&lp->Emac, lp->mii_addr, MII_CTRL1000, 0);
-
-        /* Give the system enough time to establish a link */
-        mdelay(2000);
-
-	/* Set the EMAC's duplex setting based upon what the PHY says. */
-	if (!get_phy_status(dev, &phy_duplex, &phy_carrier)) {
-		/* We successfully got the PHY status. */
-		mac_duplex = ((Options & XEM_FDUPLEX_OPTION)
-			      ? FULL_DUPLEX : HALF_DUPLEX);
-		if (mac_duplex != phy_duplex) {
-			switch (phy_duplex) {
-			case HALF_DUPLEX:
-				Options &= ~XEM_FDUPLEX_OPTION;
-				break;
-			case FULL_DUPLEX:
-				Options |= XEM_FDUPLEX_OPTION;
-				break;
-			case UNKNOWN_DUPLEX:
-				break;
-			}
-			/*
-			 * The following function will return an error
-			 * if the EMAC is already started.  We know it
-			 * isn't started so we can safely ignore the
-			 * return value.  We cast it to void to make
-			 * that explicit.
-			 */
-		}
-	}
-	Options |= XEM_FLOW_CONTROL_OPTION;
-	(void) XEmac_SetOptions(&lp->Emac, Options);
-
-	INIT_LIST_HEAD(&(lp->rcv));
-	lp->rcvBds = 0;
-	INIT_LIST_HEAD(&(lp->xmit));
-	lp->xmitBds = 0;
-
-	if (XEmac_Start(&lp->Emac) != XST_SUCCESS) {
-		printk(KERN_ERR "%s: Could not start device.\n", dev->name);
-		free_irq(dev->irq, dev);
-		return -EBUSY;
-	}
-
-	/* We're ready to go. */
-	netif_start_queue(dev);
-
-	/* Set up the PHY monitoring timer. */
-	lp->phy_timer.expires = jiffies + 2 * HZ;
-	lp->phy_timer.data = (unsigned long) dev;
-	lp->phy_timer.function = &poll_mii;
-	init_timer(&lp->phy_timer);
-	add_timer(&lp->phy_timer);
-	return 0;
-}
-static int xenet_close(struct net_device *dev)
-{
-	struct net_local *lp = (struct net_local *) netdev_priv(dev);
-	unsigned long flags;
-
-	/* Shut down the PHY monitoring timer. */
-	del_timer_sync(&lp->phy_timer);
-
-	netif_stop_queue(dev);
-
-	/*
-	 * If not in polled mode, free the interrupt.  Currently, there
-	 * isn't any code to set polled mode, so this check is probably
-	 * superfluous.
-	 */
-	if ((XEmac_GetOptions(&lp->Emac) & XEM_POLLED_OPTION) == 0)
-		free_irq(dev->irq, dev);
-
-	spin_lock_irqsave(&rcvSpin, flags);
-	list_del(&(lp->rcv));
-	spin_unlock_irqrestore(&rcvSpin, flags);
-	spin_lock_irqsave(&xmitSpin, flags);
-	list_del(&(lp->xmit));
-	spin_unlock_irqrestore(&xmitSpin, flags);
-
-	if (XEmac_Stop(&lp->Emac) != XST_SUCCESS) {
-		printk(KERN_ERR "%s: Could not stop device.\n", dev->name);
-		return -EBUSY;
-	}
-
-	return 0;
-}
-static int xenet_change_mtu(struct net_device *dev, int new_mtu)
-{
-	int head_size = XEM_HDR_SIZE;
-	int max_frame = new_mtu + head_size + XEM_TRL_SIZE;
-	int min_frame = 1 + head_size + XEM_TRL_SIZE;
-
-	if ((max_frame < min_frame) || (max_frame > XEM_MAX_FRAME_SIZE))
-		return -EINVAL;
-
-	dev->mtu = new_mtu;	/* change mtu in net_device structure */
-	return 0;
-}
-static struct net_device_stats *xenet_get_stats(struct net_device *dev)
-{
-	struct net_local *lp = (struct net_local *) netdev_priv(dev);
-
-	return &lp->stats;
-}
-
-static int xenet_FifoSend(struct sk_buff *orig_skb, struct net_device *dev)
-{
-	struct net_local *lp = (struct net_local *) netdev_priv(dev);
-	struct sk_buff *new_skb;
-	unsigned int len, align;
-	unsigned long flags;
-
-	len = orig_skb->len;
-
-	/* PR FIXME: what follows can be removed if the asserts in the Xilinx
-	 * independent drivers change. There is really no need to align the
-	 * buffers in FIFO mode. The story is different for simple DMA.
-	 */
-
-	/*
-	 * The packet FIFO requires the buffers to be 32/64 bit aligned.
-	 * The sk_buff data is not 32/64 bit aligned, so we have to do this
-	 * copy.  As you probably well know, this is not optimal.
-	 */
-	if (!(new_skb = alloc_skb(len + ALIGNMENT, GFP_ATOMIC))) {
-		/* We couldn't get another skb. */
-		dev_kfree_skb(orig_skb);
-		lp->stats.tx_dropped++;
-		printk(KERN_ERR "%s: Could not allocate transmit buffer.\n",
-		       dev->name);
-		netif_wake_queue(dev);
-		return -EBUSY;
-	}
-	/*
-	 * A new skb should have the data word aligned, but this code is
-	 * here just in case that isn't true...  Calculate how many
-	 * bytes we should reserve to get the data to start on a word
-	 * boundary.  */
-	align = BUFFER_ALIGN(new_skb->data);
-	if (align)
-		skb_reserve(new_skb, align);
-
-	/* Copy the data from the original skb to the new one. */
-	skb_put(new_skb, len);
-	memcpy(new_skb->data, orig_skb->data, len);
-
-	/* Get rid of the original skb. */
-	dev_kfree_skb(orig_skb);
-	spin_lock_irqsave(&reset_lock, flags);
-	if (XEmac_FifoSend(&lp->Emac, (u8 *) new_skb->data, len) != XST_SUCCESS) {
-		netif_stop_queue(dev);
-		lp->deferred_skb = new_skb;
-		spin_unlock_irqrestore(&reset_lock, flags);
-		return 0;
-	}
-	spin_unlock_irqrestore(&reset_lock, flags);
-
-	lp->stats.tx_bytes += len;
-	dev_kfree_skb(new_skb);
-	dev->trans_start = jiffies;
-
-	return 0;
-}
-
-/* The callback function for completed frames sent in FIFO mode. */
-static void FifoSendHandler(void *CallbackRef)
-{
-	struct net_device *dev = (struct net_device *) CallbackRef;
-	struct net_local *lp = (struct net_local *) netdev_priv(dev);
-
-	if (lp->deferred_skb) {
-		if (XEmac_FifoSend
-		    (&lp->Emac, (u8 *) lp->deferred_skb->data,
-		     lp->deferred_skb->len) != XST_SUCCESS) {
-			return;
-		}
-		else {
-			dev_kfree_skb(lp->deferred_skb);
-			lp->deferred_skb = NULL;
-			netif_wake_queue(dev);
-		}
-	}
-	lp->stats.tx_packets++;
-}
-
-/* The send function for frames sent in DMA mode. */
-static int xenet_SgSend(struct sk_buff *skb, struct net_device *dev)
-{
-	struct net_local *lp = (struct net_local *) netdev_priv(dev);
-	unsigned int len;
-	XBufDescriptor bd;
-	int result;
-	u32 physAddr;
-	unsigned long flags;
-	u8 *virtAddr;
-
-	len = skb->len;
-	virtAddr = lp->ddrVirtPtr + lp->ddrOffset;
-
-	if (skb->ip_summed == CHECKSUM_NONE)
-#ifdef CONFIG_PPC32
-		cacheable_memcpy(virtAddr, skb->data, len);
-#else
-		memcpy(virtAddr, skb->data, len);
-#endif
-	else
-		skb_copy_and_csum_dev(skb, virtAddr);
-
-	dev_kfree_skb(skb);
-	physAddr = (u32) dma_map_single(NULL, virtAddr, len, DMA_TO_DEVICE);
-
-	/*
-	 * lock the buffer descriptor to prevent lower layers from reusing
-	 * it before the adapter has a chance to deallocate the buffer
-	 * attached to it. The adapter will unlock it in the callback function
-	 * that handles confirmation of transmits
-	 */
-	XBufDescriptor_Initialize(&bd);
-	XBufDescriptor_Lock(&bd);
-	XBufDescriptor_SetSrcAddress(&bd, physAddr);
-	XBufDescriptor_SetLength(&bd, len);
-	XBufDescriptor_SetLast(&bd);
-
-	lp->ddrOffset += len + BUFFER_ALIGN(len);
-	if (lp->ddrOffset + XEM_MAX_FRAME_SIZE > lp->ddrSize)
-		lp->ddrOffset = 0;
-
-	spin_lock_irqsave(&reset_lock, flags);
-
-	result = XEmac_SgSend(&lp->Emac, &bd, XEM_SGDMA_NODELAY);
-	if (result != XST_SUCCESS) {
-		lp->stats.tx_dropped++;
-		printk(KERN_ERR
-		       "%s: ERROR, could not send transmit buffer (%d).\n",
-		       dev->name, result);
-		/* we should never get here in the first place, but
-		 * for some reason the kernel doesn't like -EBUSY here,
-		 * so just return 0 and let the stack handle dropped packets.
-		 */
-		/*      return -EBUSY; */
-		spin_unlock_irqrestore(&reset_lock, flags);
-		return 0;
-	}
-
-	if (atomic_dec_and_test(&lp->availSendBds)) {
-		netif_stop_queue(dev);
-	}
-
-	dev->trans_start = jiffies;
-	spin_unlock_irqrestore(&reset_lock, flags);
-	return 0;
-}
-
-/*
- * The send function for frames sent in DMA mode using DRE and
- * Checksum offload in the DMA.
- */
-
-static XBufDescriptor bd[10];
-
-static int xenet_SgSendDre(struct sk_buff *skb, struct net_device *dev)
-{
-	struct net_local *lp = (struct net_local *) netdev_priv(dev);
-	unsigned int len;
-	int result;
-	u32 physAddr;
-	u8 *virtAddr;
-	u32 i;
-	unsigned long flags;
-	u16 csum_insert_offset;
-	u16 IpHeaderLength;
-	u16 ProtoTTL;
-	volatile u32 num_frag;
-	skb_frag_t *frag;
-	XBufDescriptor *prev_p;
-	XBufDescriptor *cur_p;
-
-	virtAddr = lp->ddrVirtPtr + lp->ddrOffset;
-
-	num_frag = skb_shinfo(skb)->nr_frags;
-	frag = &skb_shinfo(skb)->frags[0];
-
-	cur_p = &bd[0];
-	prev_p = 0;
-
-	if (num_frag > 9) {
-		printk("num_frag:%8.8x \n", num_frag);
-	}
-
-	/*
-	 * Return to the default configuration for the driver
-	 */
-	XEmac_mDisableTxHwCsum(&lp->Emac);
-
-	/*
-	 * Queue up the buffer descriptors only if there is space in the ring for this
-	 * batch with extra room. The netif_stop_queue will not occur until after the
-	 * next call to this function, therefore I need to leave enough for at least
-	 * one more call in the descriptor ring.
-	 */
-	if ((lp->availSendBds.counter) < (num_frag + 4)) {
-		netif_stop_queue(dev);
-	}
-
-
-	/* Assign dummy values to 'csum_insert_offset', 'IpHeaderLength' and 'len'.
-	 * This will quiet down gcc warnings about unassigned variables in the
-	 * "else" case of "if (i==0)" below.
-	 *
-	 * 'csum_insert_offset', 'IpHeaderLength' and 'len' are assigned in the
-	 * iteration for the first fragment (i==0) case and will not change for
-	 * subsequent fragments. As we ALWAYS execute the (i==0) case the variables
-	 * will never be uninitialized.
-	 */
-	csum_insert_offset = 0;
-	IpHeaderLength = 0;
-	len = 0;
-
-	for (i = 0; i < (num_frag + 1); ++i) {
-		/*
-		 * Initialize the buffer desctiptor and then
-		 * lock the buffer descriptor to prevent lower layers from reusing
-		 * it before the adapter has a chance to deallocate the buffer
-		 * attached to it. The adapter will unlock it in the callback function
-		 * that handles confirmation of transmits
-		 */
-		XBufDescriptor_Initialize(cur_p);
-		XBufDescriptor_Lock(cur_p);
-
-		if (prev_p) {
-			XBufDescriptor_SetNextPtr(prev_p, cur_p);
-		}
-
-		if (i == 0) {
-
-			/*
-			 * Set the ID for the first descriptor to be the
-			 * address of the skbuffer to be freed in the BH
-			 */
-			XBufDescriptor_SetId(cur_p, skb);
-
-			/* Grab protocol */
-			ProtoTTL = (*(u16 *) (skb->data + 22));
-
-			/*
-			 * The kernel does not send frames down with
-			 * CHECKSUM_COMPLETE set unless they are TCP, UDP is
-			 * always CHECKSUM_NONE due to the TCP_SENDFILE test
-			 * requirement
-			 */
-			virtAddr = skb->data;
-			len = skb_headlen(skb);
-
-			if ((XEmac_mIsTxHwCsum(&lp->Emac)) &&
-			    ((ProtoTTL & 0x00FF) == 6)) {
-
-				if (skb->ip_summed == CHECKSUM_COMPLETE) {
-					XEmac_mEnableTxHwCsum(&lp->Emac);
-
-					/*
-					 * Determine the length of the IP header which is used
-					 * for the offset into the data for the protocol field.
-					 */
-
-					IpHeaderLength =
-						((((*(u16 *) (skb->data + 14)) &
-						   0x0F00) >> 8) * 4);
-
-					/*
-					 * Determine the proper offset for the insert
-					 * TCP offset is 16, UDP offset is 6 but the
-					 * 2.4 stack does not use this for UDP
-					 */
-					csum_insert_offset =
-						IpHeaderLength + 16 +
-						ENET_HDR_SIZ;
-
-					/*
-					 * 0 works for the TCP TX checksum offload initial value
-					 */
-					XBufDescriptor_SetCSInit(cur_p, 0);
-					XBufDescriptor_SetCSInsertLoc(cur_p,
-								      csum_insert_offset);
-					XBufDescriptor_SetCSBegin(cur_p,
-								  IpHeaderLength
-								  +
-								  ENET_HDR_SIZ);
-
-				}
-
-				XBufDescriptor_SetLength(cur_p, len);
-
-				physAddr =
-					(u32) dma_map_single(NULL, virtAddr,
-							     len,
-							     DMA_TO_DEVICE);
-				XBufDescriptor_SetSrcAddress(cur_p, physAddr);
-
-			}
-			else {
-				/*
-				 * First fragment, no hardware checksum offload or is it not TCP
-				 */
-				XBufDescriptor_SetLength(cur_p, len);
-
-				physAddr =
-					(u32) dma_map_single(NULL, virtAddr,
-							     len,
-							     DMA_TO_DEVICE);
-				XBufDescriptor_SetSrcAddress(cur_p, physAddr);
-			}
-		}
-		else {
-			/*
-			 * Fragment is not number 0
-			 */
-			virtAddr = ((void *) page_address(frag->page) +
-				    frag->page_offset);
-
-			len = frag->size;
-
-			/* NOTE:
-			 *   'csum_insert_offset', 'IpHeaderLength' and 'len' will be
-			 *   initialized in the first iteration of the loop in the (i==0)
-			 *   case, so they are valid in this iteration of the loop.
-			 */
-			physAddr =
-				(u32) dma_map_single(NULL, virtAddr, len,
-						     DMA_TO_DEVICE);
-			XBufDescriptor_SetSrcAddress(cur_p, physAddr);
-			XBufDescriptor_SetCSInit(cur_p, 0);
-
-			XBufDescriptor_SetCSInsertLoc(cur_p,
-						      csum_insert_offset);
-			XBufDescriptor_SetCSBegin(cur_p,
-						  IpHeaderLength +
-						  ENET_HDR_SIZ);
-			XBufDescriptor_SetLength(cur_p, len);
-
-			frag++;
-		}
-
-		if (i == num_frag) {
-			/*
-			 * This is the last descriptor in the chain
-			 */
-			XBufDescriptor_SetLast(cur_p);
-		}
-		prev_p = cur_p;
-		cur_p++;
-	}
-
-	spin_lock_irqsave(&reset_lock, flags);
-	for (i = 0; i < (num_frag + 1); ++i) {
-
-		result = XEmac_SgSend(&lp->Emac, &bd[i], XEM_SGDMA_NODELAY);
-		if (result != XST_SUCCESS) {
-			lp->stats.tx_dropped++;
-			printk( /*KERN_ERR */
-			       "%s: ERROR, could not send transmit buffer (%d).\n",
-			       dev->name, result);
-			/* we should never get here in the first place, but
-			 * for some reason the kernel doesn't like -EBUSY here,
-			 * so just return 0 and let the stack handle dropped packets.
-			 */
-			/*      return -EBUSY; */
-			spin_unlock_irqrestore(&reset_lock, flags);
-			return 0;
-		}
-
-	}
-
-	if ((atomic_sub_return((num_frag + 1), &lp->availSendBds)) == 0) {
-		netif_stop_queue(dev);
-	}
-
-	spin_unlock_irqrestore(&reset_lock, flags);
-	dev->trans_start = jiffies;
-
-	return 0;
-}
-
-
-/* The callback function for completed frames sent in DMA mode. */
-static void SgSendHandlerBH(unsigned long p);
-static void SgRecvHandlerBH(unsigned long p);
-
-DECLARE_TASKLET(SgSendBH, SgSendHandlerBH, 0);
-DECLARE_TASKLET(SgRecvBH, SgRecvHandlerBH, 0);
-
-static void SgSendHandlerBH(unsigned long p)
-{
-	struct net_device *dev;
-	struct net_local *lp;
-	XBufDescriptor *BdPtr;
-	u32 NumBds;
-	u32 len;
-	XBufDescriptor *curbd;
-	unsigned long flags;
-	struct sk_buff *skb;
-
-	while (1) {
-		spin_lock_irqsave(&xmitSpin, flags);
-		if (list_empty(&sentQueue)) {
-			spin_unlock_irqrestore(&xmitSpin, flags);
-			break;
-		}
-		lp = list_entry(sentQueue.next, struct net_local, xmit);
-
-		list_del_init(&(lp->xmit));
-		NumBds = lp->xmitBds;
-		BdPtr = lp->xmitBdPtr;
-		dev = lp->ndev;
-		atomic_add(NumBds, &lp->availSendBds);
-		while (NumBds != 0) {
-			NumBds--;
-
-			len = XBufDescriptor_GetLength(BdPtr);
-			pci_unmap_single(NULL,
-					 (u32)
-					 XBufDescriptor_GetSrcAddress(BdPtr),
-					 len, DMA_TO_DEVICE);
-
-			lp->stats.tx_bytes += len;
-			lp->stats.tx_packets++;
-
-			curbd = BdPtr;
-			BdPtr = P_TO_V(&lp->Emac.SendChannel,
-				       XBufDescriptor_GetNextPtr(BdPtr));
-			XBufDescriptor_Unlock(curbd);
-			/*
-			 * If the descriptor was part of a fragment list, the ID is
-			 * the skbuffer which can be freed at this point
-			 */
-			skb = (struct sk_buff *) XBufDescriptor_GetId(curbd);
-			if (skb != 0UL) {
-				dev_kfree_skb(skb);
-			}
-
-		}
-		spin_unlock_irqrestore(&xmitSpin, flags);
-		netif_wake_queue(dev);
-	}
-	bh_entry = 0;
-}
-
-static void SgSendHandler(void *CallBackRef, XBufDescriptor * BdPtr, u32 NumBds)
-{
-	struct net_device *dev = (struct net_device *) CallBackRef;
-	struct net_local *lp = (struct net_local *) netdev_priv(dev);
-	struct list_head *cur_lp = NULL;
-
-	spin_lock(&xmitSpin);
-	list_for_each(cur_lp, &sentQueue) {
-		if (cur_lp == &(lp->xmit)) {
-			lp->xmitBds += NumBds;
-			break;
-		}
-	}
-	if (cur_lp != &(lp->xmit)) {
-		lp->xmitBds = NumBds;
-		lp->xmitBdPtr = BdPtr;
-		list_add_tail(&lp->xmit, &sentQueue);
-		bh_entry++;
-		tasklet_schedule(&SgSendBH);
-	}
-	spin_unlock(&xmitSpin);
-}
-
-static void SgRecvHandlerBH(unsigned long p)
-{
-	struct net_device *dev;
-	struct net_local *lp;
-	XBufDescriptor *BdPtr;
-	int NumBds;
-	struct sk_buff *skb, *new_skb;
-	u32 len, new_skb_vaddr;
-	dma_addr_t skb_vaddr;
-	u32 align;
-	int result;
-	XBufDescriptor *curbd;
-	unsigned long flags;
-	u16 HwCSum, PhCSum;
-	u16 IpDataLen, IpHeaderLength, ProtoTTL;
-	u32 CalcCSum;
-	u32 EmacFCS;
-	u8 *EmacFCSPtr;
-
-	while (1) {
-		spin_lock_irqsave(&rcvSpin, flags);
-		if (list_empty(&receivedQueue)) {
-			spin_unlock_irqrestore(&rcvSpin, flags);
-			break;
-		}
-		lp = list_entry(receivedQueue.next, struct net_local, rcv);
-
-		list_del_init(&(lp->rcv));
-		NumBds = lp->rcvBds;
-		BdPtr = lp->rcvBdPtr;
-		dev = lp->ndev;
-		spin_unlock_irqrestore(&rcvSpin, flags);
-		while (NumBds != 0) {
-			NumBds--;
-
-			/* get ptr to skb */
-			skb = (struct sk_buff *) XBufDescriptor_GetId(BdPtr);
-			len = XBufDescriptor_GetLength(BdPtr);
-
-			/*
-			 * Retrieve hardware Checksum regardless, check later if
-			 * valid to use
-			 */
-
-			HwCSum = XBufDescriptor_GetCSRaw(BdPtr);
-
-			/* we have all the information we need - move on */
-			curbd = BdPtr;
-			BdPtr = P_TO_V(&lp->Emac.RecvChannel,
-				       XBufDescriptor_GetNextPtr(curbd));
-
-			skb_vaddr =
-				(dma_addr_t)
-				XBufDescriptor_GetDestAddress(curbd);
-			pci_unmap_single(NULL, skb_vaddr, len, DMA_FROM_DEVICE);
-
-			/* replace skb with a new one */
-			new_skb =
-				alloc_skb(XEM_MAX_FRAME_SIZE + ALIGNMENT,
-					  GFP_ATOMIC);
-			if (new_skb == 0) {
-				printk("SgRecvHandler: no mem for new_skb\n");
-				return;
-			}
-
-			if (!(XEmac_mIsRxDre(&lp->Emac))) {
-				/* make sure we're long-word aligned */
-				align = BUFFER_ALIGN(new_skb->data);
-				if (align) {
-					skb_reserve(new_skb, align);
-				}
-			}
-
-			new_skb_vaddr =
-				(u32) dma_map_single(NULL, new_skb->data,
-						     XEM_MAX_FRAME_SIZE,
-						     DMA_FROM_DEVICE);
-
-			XBufDescriptor_SetDestAddress(curbd, new_skb_vaddr);
-			XBufDescriptor_SetLength(curbd, XEM_MAX_FRAME_SIZE);
-			XBufDescriptor_SetId(curbd, new_skb);
-			XBufDescriptor_Unlock(curbd);
-
-			/* give the descriptor back to the driver */
-			result = XEmac_SgRecv(&lp->Emac, curbd);
-			if (result != XST_SUCCESS) {
-				printk("SgRecvHandler: SgRecv unsuccessful\n");
-				return;
-			}
-
-			/* back to the original skb
-			 * NOTE:
-			 *   The following line should read
-			 *     skb_put(skb, len);
-			 *   However, doing this causes the driver not to work
-			 *   anymore.  If you want to fix this and put in the
-			 *   skb_pu() again, you need to delete the
-			 *     skb->len -= 4;
-			 *   line below.
-			 * wgr 09/14/2006
-			 */
-			skb->len = len;
-			skb->dev = dev;
-			skb->protocol = eth_type_trans(skb, dev);
-			skb->ip_summed = CHECKSUM_NONE;
-
-			lp->stats.rx_packets++;
-			lp->stats.rx_bytes += len;
-
-			/*
-			 * Check if Checksum offload in in the hardware, if so
-			 * verify the checksum here and then sent up the stack
-			 */
-			if ((len > 76 /*64 */ ) &&
-			    (skb->protocol == ETHERTYPE_IP) &&
-			    (XEmac_mIsRxHwCsum(&lp->Emac))) {
-
-				EmacFCS = 0;
-				EmacFCSPtr = (u8 *) &EmacFCS;
-
-				IpHeaderLength = ((((*(u16 *) (skb->data)) & 0x0F00) >> 8) * 4);
-
-				/* Grab protocol */
-				ProtoTTL = (*(u16 *) (skb->data + 8)) & 0x00FF;
-
-				/*
-				 * Set the length of the IP payload for the CS calculation
-				 */
-				IpDataLen = len - IpHeaderLength - ENET_HDR_SIZ;
-
-				/*
-				 * Adjust the hardware checksum due to the fact that it ALWAYS includes
-				 * the FCS field in the RX data, regardless of whether the.
-				 * XEM_STRIP_PAD_FCS_OPTION is set or not set around 2400.
-				 */
-
-				CalcCSum = HwCSum;
-
-				if (((IpDataLen & 0x0003) == 2) ||
-				    ((IpDataLen & 0x0003) == 0)) {
-					/*
-					 * 16-bit alignment case
-					 */
-					EmacFCSPtr[0] = skb_mac_header(skb)[len-4];
-					EmacFCSPtr[1] = skb_mac_header(skb)[len-3];
-					EmacFCSPtr[2] = skb_mac_header(skb)[len-2];
-					EmacFCSPtr[3] = skb_mac_header(skb)[len-1];
-				}
-				else if ((IpDataLen & 0x0003) == 1) {
-					/*
-					 * 8-bit alignment case one
-					 */
-					EmacFCSPtr[0] = skb_mac_header(skb)[len-3];
-					EmacFCSPtr[1] = skb_mac_header(skb)[len-2];
-					EmacFCSPtr[2] = skb_mac_header(skb)[len-1];
-					EmacFCSPtr[3] = skb_mac_header(skb)[len-4];
-				}
-				else if ((IpDataLen & 0x0003) == 3) {
-					/*
-					 * 8-bit alignment case two
-					 */
-					EmacFCSPtr[0] = skb_mac_header(skb)[len-1];
-					EmacFCSPtr[1] = skb_mac_header(skb)[len-4];
-					EmacFCSPtr[2] = skb_mac_header(skb)[len-3];
-					EmacFCSPtr[3] = skb_mac_header(skb)[len-2];
-				}
-
-				CalcCSum +=
-					(u32) ((*(u16 *) (&(EmacFCSPtr[0]))) ^
-					       0xFFFF);
-				CalcCSum +=
-					(u32) ((*(u16 *) (&(EmacFCSPtr[2]))) ^
-					       0xFFFF);
-				CalcCSum += (u32) (0xFFFB);	/* this is the subtraction of 4, trust me */
-
-				HwCSum = ((CalcCSum >> 16) +
-					  (CalcCSum & 0x0000FFFF));
-
-				PhCSum = AddCsumRxPseudoHeader(skb, HwCSum,
-							       IpDataLen,
-							       ProtoTTL);
-
-				/*
-				 * The resulting checksum should be equal to 0xFFFF. If not, the upper
-				 * layers can calculate where the error is and retransmit if needed.
-				 */
-
-				if (PhCSum == 0xFFFF) {
-
-					skb->ip_summed = CHECKSUM_UNNECESSARY;
-					/* NOTE:
-					 *   The following line goes together with the changed
-					 *     skb_put(skb, len);
-					 *   line above. If you change the line above to skb_put(),
-					 *   you need to delete the following line.
-					 * wgr 09/14/2006
-					 */
-					skb->len -= 4;
-					skb->csum = 0xFFFF;
-				}
-			}
-
-			netif_rx(skb);	/* Send the packet upstream. */
-		}
-	}
-}
-
-static void SgRecvHandler(void *CallBackRef, XBufDescriptor * BdPtr, u32 NumBds)
-{
-	struct net_device *dev = (struct net_device *) CallBackRef;
-	struct net_local *lp = (struct net_local *) netdev_priv(dev);
-	struct list_head *cur_lp = NULL;
-
-	spin_lock(&rcvSpin);
-	list_for_each(cur_lp, &receivedQueue) {
-		if (cur_lp == &(lp->rcv)) {
-			lp->rcvBds += NumBds;
-			break;
-		}
-	}
-	if (cur_lp != &(lp->rcv)) {
-		lp->rcvBds = NumBds;
-		lp->rcvBdPtr = BdPtr;
-		list_add_tail(&lp->rcv, &receivedQueue);
-		tasklet_schedule(&SgRecvBH);
-	}
-	spin_unlock(&rcvSpin);
-}
-
-static void xenet_tx_timeout(struct net_device *dev)
-{
-	struct net_local *lp = (struct net_local *) netdev_priv(dev);
-	unsigned long flags;
-
-	printk("%s: Exceeded transmit timeout of %lu ms.\n",
-	       dev->name, TX_TIMEOUT * 1000UL / HZ);
-
-	lp->stats.tx_errors++;
-	spin_lock_irqsave(&reset_lock, flags);
-	reset(dev, UNKNOWN_DUPLEX);
-	spin_unlock_irqrestore(&reset_lock, flags);
-}
-
-/* The callback function for frames received when in FIFO mode. */
-static void FifoRecvHandler(void *CallbackRef)
-{
-	struct net_device *dev = (struct net_device *) CallbackRef;
-	struct net_local *lp = (struct net_local *) netdev_priv(dev);
-	struct sk_buff *skb;
-	unsigned int align;
-	u32 len;
-	int Result;
-
-	/*
-	 * The OS independent Xilinx EMAC code does not provide a
-	 * function to get the length of an incoming packet and a
-	 * separate call to actually get the packet data.  It does this
-	 * because they didn't add any code to keep the hardware's
-	 * receive length and data FIFOs in sync.  Instead, they require
-	 * that you send a maximal length buffer so that they can read
-	 * the length and data FIFOs in a single chunk of code so that
-	 * they can't get out of sync.  So, we need to allocate an skb
-	 * that can hold a maximal sized packet.  The OS independent
-	 * code needs to see the data 32/64-bit aligned, so we tack on an
-	 * extra four just in case we need to do an skb_reserve to get
-	 * it that way.
-	 */
-	len = XEM_MAX_FRAME_SIZE;
-	if (!(skb = alloc_skb(len + ALIGNMENT, GFP_ATOMIC))) {
-		/* Couldn't get memory. */
-		lp->stats.rx_dropped++;
-		printk(KERN_ERR "%s: Could not allocate receive buffer.\n",
-		       dev->name);
-		return;
-	}
-
-	/*
-	 * A new skb should have the data word aligned, but this code is
-	 * here just in case that isn't true...  Calculate how many
-	 * bytes we should reserve to get the data to start on a word
-	 * boundary.  */
-	align = BUFFER_ALIGN(skb->data);
-	if (align)
-		skb_reserve(skb, align);
-
-	Result = XEmac_FifoRecv(&lp->Emac, (u8 *) skb->data, &len);
-	if (Result != XST_SUCCESS) {
-		int need_reset = status_requires_reset(Result);
-
-		lp->stats.rx_errors++;
-		dev_kfree_skb(skb);
-		printk(KERN_ERR "%s: Could not receive buffer, error=%d%s.\n",
-		       dev->name, Result,
-		       need_reset ? ", resetting device." : "");
-		if (need_reset) {
-			spin_lock(&reset_lock);
-			reset(dev, UNKNOWN_DUPLEX);
-			spin_unlock(&reset_lock);
-		}
-
-		return;
-	}
-
-	skb_put(skb, len - 4);	/* Tell the skb how much data we got,
-				   crop FCS (the last four bytes). */
-	skb->dev = dev;		/* Fill out required meta-data. */
-	skb->protocol = eth_type_trans(skb, dev);
-	skb->ip_summed = CHECKSUM_NONE;
-
-	lp->stats.rx_packets++;
-	lp->stats.rx_bytes += len;
-
-	netif_rx(skb);		/* Send the packet upstream. */
-}
-
-/* The callback function for errors. */
-static void ErrorHandler(void *CallbackRef, int Code)
-{
-	struct net_device *dev = (struct net_device *) CallbackRef;
-	int need_reset = status_requires_reset(Code);
-	unsigned long flags;
-
-	/* ignore some errors */
-	if (Code == XST_DMA_ERROR)
-		return;
-	printk(KERN_ERR "%s: device error %d%s\n",
-	       dev->name, Code, need_reset ? ", resetting device." : "");
-	if (need_reset) {
-		spin_lock_irqsave(&reset_lock, flags);
-		reset(dev, UNKNOWN_DUPLEX);
-		spin_unlock_irqrestore(&reset_lock, flags);
-	}
-}
-
-static int descriptor_init(struct net_device *dev)
-{
-	struct net_local *lp = (struct net_local *) netdev_priv(dev);
-	int i, recvsize, sendsize;
-	int dftsize;
-	u32 *recvpoolptr, *sendpoolptr;
-	void *recvpoolphy, *sendpoolphy;
-
-	/* calc size of descriptor space pool; alloc from non-cached memory */
-	dftsize = (XEM_DFT_RECV_DESC + XEM_DFT_SEND_DESC) *
-		sizeof(XBufDescriptor);
-
-	lp->desc_space = dma_alloc_coherent(NULL, dftsize,
-					    &lp->desc_space_handle, GFP_KERNEL);
-	if (lp->desc_space == 0) {
-		return -1;
-	}
-
-	lp->desc_space_size = dftsize;
-
-	lp->ddrSize = DFT_LOCAL_SEND_DESC * (XEM_MAX_FRAME_SIZE + ALIGNMENT);
-	lp->ddrOffset = 0;
-	lp->ddrVirtPtr = kmalloc(lp->ddrSize, GFP_ATOMIC);
-
-	if (lp->ddrVirtPtr == 0)
-		return -1;
-
-	if (XEmac_mIsTxDre(&lp->Emac)) {
-		atomic_set(&lp->availSendBds, XEM_DFT_SEND_DESC);
-	}
-	else {
-		atomic_set(&lp->availSendBds, DFT_LOCAL_SEND_DESC);
-	}
-
-
-
-	/* calc size of send and recv descriptor space */
-	recvsize = XEM_DFT_RECV_DESC * sizeof(XBufDescriptor);
-	sendsize = XEM_DFT_SEND_DESC * sizeof(XBufDescriptor);
-
-	recvpoolptr = lp->desc_space;
-	sendpoolptr = (void *) ((u32) lp->desc_space + recvsize);
-
-	recvpoolphy = (void *) lp->desc_space_handle;
-	sendpoolphy = (void *) ((u32) lp->desc_space_handle + recvsize);
-
-	/* add ptr to descriptor space to the driver */
-	XEmac_SetSgRecvSpace(&lp->Emac, recvpoolptr, recvsize, recvpoolphy);
-	XEmac_SetSgSendSpace(&lp->Emac, sendpoolptr, sendsize, sendpoolphy);
-
-	/* allocate skb's and give them to the dma engine */
-	for (i = 0; i < XEM_DFT_RECV_DESC; i++) {
-		struct sk_buff *skb;
-		XBufDescriptor bd;
-		int result;
-		u32 skb_vaddr, align;
-
-		skb = alloc_skb(XEM_MAX_FRAME_SIZE + ALIGNMENT, GFP_ATOMIC);
-		if (skb == 0) {
-			return -1;
-		}
-
-		align = BUFFER_ALIGN(skb->data);
-		if (align)
-			skb_reserve(skb, align);
-
-		skb_vaddr = (u32) dma_map_single(NULL, skb->data,
-						 XEM_MAX_FRAME_SIZE,
-						 DMA_FROM_DEVICE);
-
-		/*
-		 * initialize descriptors and set buffer address
-		 * buffer length gets max frame size
-		 */
-		XBufDescriptor_Initialize(&bd);
-		XBufDescriptor_Lock(&bd);
-		XBufDescriptor_SetDestAddress(&bd, skb_vaddr);
-		XBufDescriptor_SetLength(&bd, XEM_MAX_FRAME_SIZE);
-		XBufDescriptor_SetId(&bd, skb);
-
-		/*
-		 * descriptor with attached buffer to the driver and
-		 * let it make it ready for frame reception
-		 */
-		result = XEmac_SgRecv(&lp->Emac, &bd);
-		if (result != XST_SUCCESS) {
-			return -1;
-		}
-	}
-
-	return 0;
-}
-
-static void free_descriptor_skb(struct net_device *dev)
-{
-	struct net_local *lp = (struct net_local *) netdev_priv(dev);
-	int i;
-	XBufDescriptor *BdPtr;
-	struct sk_buff *skb;
-
-	BdPtr = (XBufDescriptor *) lp->Emac.RecvChannel.VirtPtr;
-	for (i = 0; i < XEM_DFT_RECV_DESC; i++) {
-		skb = (struct sk_buff *) XBufDescriptor_GetId(BdPtr);
-		pci_unmap_single(NULL, virt_to_bus(skb->data),
-				 XBufDescriptor_GetLength(BdPtr),
-				 DMA_FROM_DEVICE);
-		dev_kfree_skb(skb);
-		BdPtr = P_TO_V(&lp->Emac.RecvChannel,
-			       XBufDescriptor_GetNextPtr(BdPtr));
-	}
-}
-
-static void xenet_set_multicast_list(struct net_device *dev)
-{
-	struct net_local *lp = (struct net_local *) netdev_priv(dev);
-	u32 Options;
-	unsigned long flags;
-	int ret = 0;
-
-	/*
-	 * XEmac_Start, XEmac_Stop and XEmac_SetOptions are supposed to
-	 * be protected by a semaphore. We do have one area in which
-	 * this is a problem.
-	 *
-	 * xenet_set_multicast_list() is called while the link is up and
-	 * interrupts are enabled, so at any point in time we could get
-	 * an error that causes our reset() to be called.  reset() calls
-	 * the aforementioned functions, and we need to call them from
-	 * here as well.
-	 *
-	 * The solution is to make sure that we don't get interrupts or
-	 * timers popping while we are in this function.
-	 */
-	spin_lock_irqsave(&reset_lock, flags);
-
-	if ((ret = XEmac_Stop(&lp->Emac)) == XST_SUCCESS) {
-
-		Options = XEmac_GetOptions(&lp->Emac);
-
-		/* Clear out the bits we may set. */
-		Options &= ~(XEM_PROMISC_OPTION | XEM_MULTICAST_OPTION);
-
-		if (dev->flags & IFF_PROMISC)
-			Options |= XEM_PROMISC_OPTION;
-#if 0
-		else {
-			/*
-			 * SAATODO: Xilinx is going to add multicast support to their
-			 * VxWorks adapter and OS independent layer.  After that is done,
-			 * this skeleton code should be fleshed out.  Note that
-			 * IFF_MULTICAST is being masked out from dev->flags in
-			 * xenet_probe, so that will need to be removed to actually do
-			 * multidrop.
-			 */
-			if ((dev->flags & IFF_ALLMULTI)
-			    || dev->mc_count > MAX_MULTICAST ? ? ?) {
-				xemac_get_all_multicast ? ? ? ();
-				Options |= XEM_MULTICAST_OPTION;
-			}
-			else if (dev->mc_count != 0) {
-				struct dev_mc_list *mc;
-
-				XEmac_MulticastClear(&lp->Emac);
-				for (mc = dev->mc_list; mc; mc = mc->next)
-					XEmac_MulticastAdd(&lp->Emac,
-							   mc->dmi_addr);
-				Options |= XEM_MULTICAST_OPTION;
-			}
-		}
-#endif
-
-		/*
-		 * The following function will return an error if the EMAC is already
-		 * started.  We know it isn't started so we can safely ignore the
-		 * return value.  We cast it to void to make that explicit.
-		 */
-		(void) XEmac_SetOptions(&lp->Emac, Options);
-
-		/*
-		 * XEmac_Start returns an error when: it is already started, the send
-		 * and receive handlers are not set, or a scatter-gather DMA list is
-		 * missing.  None of these can happen at this point, so we cast the
-		 * return to void to make that explicit.
-		 */
-		(void) XEmac_Start(&lp->Emac);
-	}
-	/* All done, get those interrupts and timers going again. */
-	spin_unlock_irqrestore(&reset_lock, flags);
-}
-
-
-static int
-xenet_ethtool_get_settings(struct net_device *dev, struct ethtool_cmd *ecmd)
-{
-	int ret;
-	struct net_local *lp = (struct net_local *) netdev_priv(dev);
-	u32 mac_options;
-	u8 threshold;
-	u16 mii_cmd;
-	u16 mii_status;
-	u16 mii_advControl;
-	int xs;
-
-	memset(ecmd, 0, sizeof(struct ethtool_cmd));
-	mac_options = XEmac_GetOptions(&(lp->Emac));
-	xs = XEmac_PhyRead(&lp->Emac, lp->mii_addr, MII_BMCR, &mii_cmd);
-	if (xs != XST_SUCCESS) {
-		printk(KERN_ERR
-		       "%s: Could not read mii command register; error %d\n",
-		       dev->name, xs);
-		return -1;
-	}
-	xs = XEmac_PhyRead(&lp->Emac, lp->mii_addr, MII_BMSR, &mii_status);
-	if (xs != XST_SUCCESS) {
-		printk(KERN_ERR
-		       "%s: Could not read mii status register; error %d\n",
-		       dev->name, xs);
-		return -1;
-	}
-	xs = XEmac_PhyRead(&lp->Emac, lp->mii_addr, MII_ADVERTISE,
-			   &mii_advControl);
-	if (xs != XST_SUCCESS) {
-		printk(KERN_ERR
-		       "%s: Could not read mii advertisement control register; error %d\n",
-		       dev->name, xs);
-		return -1;
-	}
-
-	if (mac_options & XEM_FDUPLEX_OPTION)
-		ecmd->duplex = DUPLEX_FULL;
-	else
-		ecmd->duplex = DUPLEX_HALF;
-	if (mii_status & BMSR_100FULL)
-		ecmd->supported |= SUPPORTED_100baseT_Full;
-	if (mii_status & BMSR_100HALF)
-		ecmd->supported |= SUPPORTED_100baseT_Half;
-	if (mii_status & BMSR_10FULL)
-		ecmd->supported |= SUPPORTED_10baseT_Full;
-	if (mii_status & BMSR_10HALF)
-		ecmd->supported |= SUPPORTED_10baseT_Half;
-	if (lp->Emac.Config.HasMii)
-		ecmd->supported |= SUPPORTED_MII;
-	else
-		ecmd->supported &= (~SUPPORTED_MII);
-	if (mii_status & BMSR_ANEGCAPABLE)
-		ecmd->supported |= SUPPORTED_Autoneg;
-	if (mii_status & BMSR_ANEGCOMPLETE) {
-		ecmd->autoneg = AUTONEG_ENABLE;
-		ecmd->advertising |= ADVERTISED_Autoneg;
-		if ((mii_advControl & ADVERTISE_100FULL) ||
-		    (mii_advControl & ADVERTISE_100HALF))
-			ecmd->speed = SPEED_100;
-		else
-			ecmd->speed = SPEED_10;
-	}
-	else {
-		ecmd->autoneg = AUTONEG_DISABLE;
-		if (mii_cmd & BMCR_SPEED100)
-			ecmd->speed = SPEED_100;
-		else
-			ecmd->speed = SPEED_10;
-	}
-	if (mii_advControl & ADVERTISE_10FULL)
-		ecmd->advertising |= ADVERTISED_10baseT_Full;
-	if (mii_advControl & ADVERTISE_10HALF)
-		ecmd->advertising |= ADVERTISED_10baseT_Half;
-	if (mii_advControl & ADVERTISE_100FULL)
-		ecmd->advertising |= ADVERTISED_100baseT_Full;
-	if (mii_advControl & ADVERTISE_100HALF)
-		ecmd->advertising |= ADVERTISED_100baseT_Half;
-	ecmd->advertising |= ADVERTISED_MII;
-	ecmd->port = PORT_MII;
-	ecmd->phy_address = lp->Emac.PhysAddress;
-	ecmd->transceiver = XCVR_INTERNAL;
-	if (XEmac_mIsSgDma(&lp->Emac)) {
-		if ((ret =
-		     XEmac_GetPktThreshold(&lp->Emac, XEM_SEND,
-					   &threshold)) == XST_SUCCESS) {
-			ecmd->maxtxpkt = threshold;
-		}
-		else
-			return -EIO;
-		if ((ret =
-		     XEmac_GetPktThreshold(&lp->Emac, XEM_RECV,
-					   &threshold)) == XST_SUCCESS) {
-			ecmd->maxrxpkt = threshold;
-		}
-		else
-			return -EIO;
-	}
-	return 0;
-}
-
-static int
-xenet_ethtool_get_coalesce(struct net_device *dev, struct ethtool_coalesce *ec)
-{
-	int ret;
-	struct net_local *lp = (struct net_local *) netdev_priv(dev);
-	u8 threshold;
-
-	memset(ec, 0, sizeof(struct ethtool_coalesce));
-	if ((ret =
-	     XEmac_GetPktThreshold(&lp->Emac, XEM_RECV,
-				   &threshold)) != XST_SUCCESS) {
-		printk(KERN_INFO "XEmac_GetPktThreshold error %d\n", ret);
-		return -EIO;
-	}
-	ec->rx_max_coalesced_frames = threshold;
-	if ((ret =
-	     XEmac_GetPktWaitBound(&lp->Emac, XEM_RECV,
-				   &(ec->rx_coalesce_usecs))) != XST_SUCCESS) {
-		printk(KERN_INFO "XEmac_GetPktWaitBound error %d\n", ret);
-		return -EIO;
-	}
-	if ((ret =
-	     XEmac_GetPktThreshold(&lp->Emac, XEM_SEND,
-				   &threshold)) != XST_SUCCESS) {
-		printk(KERN_INFO "XEmac_GetPktThreshold send error %d\n", ret);
-		return -EIO;
-	}
-	ec->tx_max_coalesced_frames = threshold;
-	if ((ret =
-	     XEmac_GetPktWaitBound(&lp->Emac, XEM_SEND,
-				   &(ec->tx_coalesce_usecs))) != XST_SUCCESS) {
-		printk(KERN_INFO "XEmac_GetPktWaitBound send error %d\n", ret);
-		return -EIO;
-	}
-	return 0;
-}
-
-static int
-xenet_ethtool_set_coalesce(struct net_device *dev, struct ethtool_coalesce *ec)
-{
-	int ret;
-	struct net_local *lp = (struct net_local *) netdev_priv(dev);
-	unsigned long flags;
-
-	spin_lock_irqsave(&reset_lock, flags);
-	if ((ret = XEmac_Stop(&lp->Emac)) != XST_SUCCESS)
-		return -EIO;
-	if ((ret =
-	     XEmac_SetPktThreshold(&lp->Emac, XEM_RECV,
-				   ec->rx_max_coalesced_frames)) !=
-	    XST_SUCCESS) {
-		printk(KERN_INFO "XEmac_SetPktThreshold error %d\n", ret);
-		return -EIO;
-	}
-	if ((ret =
-	     XEmac_SetPktWaitBound(&lp->Emac, XEM_RECV,
-				   ec->rx_coalesce_usecs)) != XST_SUCCESS) {
-		printk(KERN_INFO "XEmac_SetPktWaitBound error %d\n", ret);
-		return -EIO;
-	}
-	if ((ret =
-	     XEmac_SetPktThreshold(&lp->Emac, XEM_SEND,
-				   ec->tx_max_coalesced_frames)) !=
-	    XST_SUCCESS) {
-		printk(KERN_INFO "XEmac_SetPktThreshold send error %d\n", ret);
-		return -EIO;
-	}
-	if ((ret =
-	     XEmac_SetPktWaitBound(&lp->Emac, XEM_SEND,
-				   ec->tx_coalesce_usecs)) != XST_SUCCESS) {
-		printk(KERN_INFO "XEmac_SetPktWaitBound send error %d\n", ret);
-		return -EIO;
-	}
-	if ((ret = XEmac_Start(&lp->Emac)) != XST_SUCCESS)
-		return -EIO;
-	spin_unlock_irqrestore(&reset_lock, flags);
-	return 0;
-}
-
-static int
-xenet_ethtool_get_drvinfo(struct net_device *dev, struct ethtool_drvinfo *ed)
-{
-	memset(ed, 0, sizeof(struct ethtool_drvinfo));
-	strcpy(ed->driver, DRIVER_NAME);
-	strcpy(ed->version, DRIVER_VERSION);
-	return 0;
-}
-
-static int
-xenet_ethtool_get_ringparam(struct net_device *dev,
-			    struct ethtool_ringparam *erp)
-{
-	memset(erp, 0, sizeof(struct ethtool_ringparam));
-	erp->rx_max_pending = XEM_DFT_RECV_DESC;
-	erp->tx_max_pending = XEM_DFT_SEND_DESC;
-	erp->rx_pending = XEM_DFT_RECV_DESC;
-	erp->tx_pending = XEM_DFT_SEND_DESC;
-	return 0;
-}
-
-#define EMAG_REGS_N 32
-struct mac_regsDump {
-	struct ethtool_regs hd;
-	u16 data[EMAG_REGS_N];
-};
-
-static void
-xenet_ethtool_get_regs(struct net_device *dev, struct ethtool_regs *regs,
-		       void *ret)
-{
-	struct net_local *lp = (struct net_local *) netdev_priv(dev);
-	struct mac_regsDump *dump = (struct mac_regsDump *) regs;
-	int i;
-	int r;
-
-	dump->hd.version = 0;
-	dump->hd.len = EMAG_REGS_N * sizeof(dump->data);
-	for (i = 0; i < EMAG_REGS_N; i++) {
-		if ((r =
-		     XEmac_PhyRead(&(lp->Emac), lp->mii_addr, i,
-				   &(dump->data[i]))) != XST_SUCCESS) {
-			printk(KERN_INFO "PhyRead ERROR %d\n", r);
-			*(int *) ret = -EIO;
-			return;
-		}
-	}
-	*(int *) ret = 0;
-}
-
-static int xenet_do_ethtool_ioctl(struct net_device *dev, struct ifreq *rq)
-{
-	struct net_local *lp = (struct net_local *) netdev_priv(dev);
-	struct ethtool_cmd ecmd;
-	struct ethtool_coalesce eco;
-	struct ethtool_drvinfo edrv;
-	struct ethtool_ringparam erp;
-	struct ethtool_pauseparam epp;
-	struct mac_regsDump regs;
-	int ret = -EOPNOTSUPP;
-	int result;
-	u32 Options;
-	u16 mii_reg_sset;
-	u16 mii_reg_spause;
-	u16 mii_reg_autoneg;
-	unsigned long flags;
-
-	if (copy_from_user(&ecmd, rq->ifr_data, sizeof(ecmd.cmd)))
-		return -EFAULT;
-	switch (ecmd.cmd) {
-	case ETHTOOL_GSET:
-		ret = xenet_ethtool_get_settings(dev, &ecmd);
-		if (ret >= 0) {
-			if (copy_to_user(rq->ifr_data, &ecmd, sizeof(ecmd)))
-				ret = -EFAULT;
-		}
-		break;
-	case ETHTOOL_SSET:
-		if (copy_from_user
-		    (&ecmd, rq->ifr_data, sizeof(struct ethtool_cmd)))
-			return -EFAULT;
-		mii_reg_sset = 0;
-		if (ecmd.speed == SPEED_100)
-			mii_reg_sset |= BMCR_SPEED100;
-		if (ecmd.duplex == DUPLEX_FULL)
-			mii_reg_sset |= BMCR_FULLDPLX;
-		if (ecmd.autoneg == AUTONEG_ENABLE) {
-			mii_reg_sset |= (BMCR_ANENABLE | BMCR_ANRESTART);
-			spin_lock_irqsave(&reset_lock, flags);
-			result = XEmac_PhyWrite(&lp->Emac, lp->mii_addr,
-						MII_BMCR, mii_reg_sset);
-			if (result != XST_SUCCESS) {
-				spin_unlock_irqrestore(&reset_lock, flags);
-				ret = -EIO;
-				break;
-			}
-			result = XEmac_PhyRead(&lp->Emac, lp->mii_addr,
-					       MII_ADVERTISE, &mii_reg_sset);
-			if (result != XST_SUCCESS) {
-				spin_unlock_irqrestore(&reset_lock, flags);
-				ret = -EIO;
-				break;
-			}
-			if (ecmd.speed == SPEED_100) {
-				if (ecmd.duplex == DUPLEX_FULL) {
-					mii_reg_sset |=
-						(ADVERTISE_10FULL |
-						 ADVERTISE_100FULL |
-						 ADVERTISE_10HALF |
-						 ADVERTISE_100HALF);
-				}
-				else {
-					mii_reg_sset |=
-						(ADVERTISE_10HALF |
-						 ADVERTISE_100HALF);
-					mii_reg_sset &=
-						~(ADVERTISE_10FULL |
-						  ADVERTISE_100FULL);
-				}
-			}
-			else {
-				if (ecmd.duplex == DUPLEX_FULL) {
-					mii_reg_sset |=
-						(ADVERTISE_10FULL |
-						 ADVERTISE_10HALF);
-					mii_reg_sset &=
-						~(ADVERTISE_100FULL |
-						  ADVERTISE_100HALF);
-				}
-				else {
-					mii_reg_sset |= (ADVERTISE_10HALF);
-					mii_reg_sset &=
-						~(ADVERTISE_100FULL |
-						  ADVERTISE_100HALF |
-						  ADVERTISE_10FULL);
-				}
-			}
-			result = XEmac_PhyWrite(&lp->Emac, lp->mii_addr,
-						MII_ADVERTISE, mii_reg_sset);
-			spin_unlock_irqrestore(&reset_lock, flags);
-			if (result != XST_SUCCESS) {
-				ret = -EIO;
-				break;
-			}
-		}
-		else {
-			mii_reg_sset &= ~(BMCR_ANENABLE | BMCR_ANRESTART);
-			if (ecmd.duplex == DUPLEX_FULL) {
-				mii_reg_sset |= BMCR_FULLDPLX;
-			}
-			else {
-				mii_reg_sset &= ~BMCR_FULLDPLX;
-			}
-			if (ecmd.speed == SPEED_100) {
-				mii_reg_sset |= BMCR_SPEED100;
-			}
-			else {
-				mii_reg_sset &= ~BMCR_SPEED100;
-			}
-			spin_lock_irqsave(&reset_lock, flags);
-			result = XEmac_PhyWrite(&lp->Emac, lp->mii_addr,
-						MII_BMCR, mii_reg_sset);
-			spin_unlock_irqrestore(&reset_lock, flags);
-			if (result != XST_SUCCESS) {
-				ret = -EIO;
-				break;
-			}
-		}
-		ret = 0;
-		break;
-	case ETHTOOL_GPAUSEPARAM:
-		ret = xenet_ethtool_get_settings(dev, &ecmd);
-		if (ret < 0) {
-			break;
-		}
-		epp.cmd = ecmd.cmd;
-		epp.autoneg = ecmd.autoneg;
-		Options = XEmac_GetOptions(&lp->Emac);
-		if (Options & XEM_INSERT_PAD_OPTION) {
-			epp.rx_pause = 1;
-			epp.tx_pause = 1;
-		}
-		else {
-			epp.rx_pause = 0;
-			epp.tx_pause = 0;
-		}
-		if (copy_to_user
-		    (rq->ifr_data, &epp, sizeof(struct ethtool_pauseparam)))
-			ret = -EFAULT;
-		else
-			ret = 0;
-		break;
-	case ETHTOOL_SPAUSEPARAM:
-		if (copy_from_user
-		    (&epp, rq->ifr_data, sizeof(struct ethtool_pauseparam)))
-			return -EFAULT;
-		ret = xenet_ethtool_get_settings(dev, &ecmd);
-		if (ret < 0) {
-			break;
-		}
-		epp.cmd = ecmd.cmd;
-		mii_reg_spause = 0;
-		if (epp.autoneg == AUTONEG_ENABLE) {
-			mii_reg_spause |= (BMCR_ANENABLE | BMCR_ANRESTART);
-		}
-		else {
-			if (ecmd.speed == SPEED_100)
-				mii_reg_spause |= BMCR_SPEED100;
-			if (ecmd.duplex == DUPLEX_FULL)
-				mii_reg_spause |= BMCR_FULLDPLX;
-		}
-		spin_lock_irqsave(&reset_lock, flags);
-		result = XEmac_PhyWrite(&lp->Emac, lp->mii_addr,
-					MII_BMCR, mii_reg_spause);
-		spin_unlock_irqrestore(&reset_lock, flags);
-		if (result != XST_SUCCESS) {
-			ret = -EIO;
-			break;
-		}
-		if (epp.rx_pause != epp.tx_pause) {
-			ret = 0;
-			break;
-		}
-		else {
-			spin_lock_irqsave(&reset_lock, flags);
-			(void) XEmac_Stop(&(lp->Emac));
-			Options = XEmac_GetOptions(&lp->Emac);
-			if (epp.rx_pause)
-				Options |= XEM_INSERT_PAD_OPTION;
-			else
-				Options &= ~XEM_INSERT_PAD_OPTION;
-			(void) XEmac_SetOptions(&lp->Emac, Options);
-			(void) XEmac_Start(&(lp->Emac));
-			spin_unlock_irqrestore(&reset_lock, flags);
-		}
-		ret = 0;
-		break;
-	case ETHTOOL_GCOALESCE:
-		eco.cmd = ecmd.cmd;
-		ret = xenet_ethtool_get_coalesce(dev, &eco);
-		if (ret >= 0) {
-			if (copy_to_user
-			    (rq->ifr_data, &eco,
-			     sizeof(struct ethtool_coalesce)))
-				ret = -EFAULT;
-		}
-		break;
-	case ETHTOOL_SCOALESCE:
-		if (copy_from_user
-		    (&eco, rq->ifr_data, sizeof(struct ethtool_coalesce)))
-			return -EFAULT;
-		ret = xenet_ethtool_set_coalesce(dev, &eco);
-		break;
-	case ETHTOOL_GDRVINFO:
-		edrv.cmd = edrv.cmd;
-		ret = xenet_ethtool_get_drvinfo(dev, &edrv);
-		if (ret >= 0) {
-			if (copy_to_user
-			    (rq->ifr_data, &edrv,
-			     sizeof(struct ethtool_drvinfo)))
-				ret = -EFAULT;
-		}
-		break;
-	case ETHTOOL_GREGS:
-		regs.hd.cmd = edrv.cmd;
-		xenet_ethtool_get_regs(dev, &(regs.hd), &ret);
-		if (ret >= 0) {
-			if (copy_to_user
-			    (rq->ifr_data, &regs, sizeof(struct mac_regsDump)))
-				ret = -EFAULT;
-		}
-		break;
-	case ETHTOOL_GRINGPARAM:
-		erp.cmd = edrv.cmd;
-		ret = xenet_ethtool_get_ringparam(dev, &(erp));
-		if (ret >= 0) {
-			if (copy_to_user
-			    (rq->ifr_data, &erp,
-			     sizeof(struct ethtool_ringparam)))
-				ret = -EFAULT;
-		}
-		break;
-	case ETHTOOL_NWAY_RST:
-		epp.cmd = ecmd.cmd;
-		mii_reg_autoneg = 0;
-		mii_reg_autoneg |= (BMCR_ANENABLE | BMCR_ANRESTART);
-		spin_lock_irqsave(&reset_lock, flags);
-		result = XEmac_PhyWrite(&lp->Emac, lp->mii_addr,
-					MII_BMCR, mii_reg_autoneg);
-		spin_unlock_irqrestore(&reset_lock, flags);
-		if (result != XST_SUCCESS) {
-			ret = -EIO;
-			break;
-		}
-		ret = 0;
-		break;
-	default:
-		break;
-	}
-	return ret;
-}
-
-static int xenet_ioctl(struct net_device *dev, struct ifreq *rq, int cmd)
-{
-	struct net_local *lp = (struct net_local *) netdev_priv(dev);
-
-	/* mii_ioctl_data has 4 u16 fields: phy_id, reg_num, val_in & val_out */
-	struct mii_ioctl_data *data = (struct mii_ioctl_data *) &rq->ifr_data;
-	struct {
-		__u8 threshold;
-		__u32 direction;
-	} thr_arg;
-	struct {
-		__u32 waitbound;
-		__u32 direction;
-	} wbnd_arg;
-	int ret;
-	unsigned long flags;
-
-	int Result;
-
-	switch (cmd) {
-	case SIOCETHTOOL:
-		return xenet_do_ethtool_ioctl(dev, rq);
-	case SIOCGMIIPHY:	/* Get address of MII PHY in use. */
-	case SIOCDEVPRIVATE:	/* for binary compat, remove in 2.5 */
-		data->phy_id = lp->mii_addr;
-		/* Fall Through */
-
-	case SIOCGMIIREG:	/* Read MII PHY register. */
-	case SIOCDEVPRIVATE + 1:	/* for binary compat, remove in 2.5 */
-		if (data->phy_id > 31 || data->reg_num > 31)
-			return -ENXIO;
-
-		/* Stop the PHY timer to prevent reentrancy. */
-		del_timer_sync(&lp->phy_timer);
-		spin_lock_irqsave(&reset_lock, flags);
-		Result = XEmac_PhyRead(&lp->Emac, data->phy_id,
-				       data->reg_num, &data->val_out);
-		/* Start the PHY timer up again. */
-		spin_unlock_irqrestore(&reset_lock, flags);
-		lp->phy_timer.expires = jiffies + 2 * HZ;
-		add_timer(&lp->phy_timer);
-
-		if (Result != XST_SUCCESS) {
-			printk(KERN_ERR
-			       "%s: Could not read from PHY, error=%d.\n",
-			       dev->name, Result);
-			return (Result == XST_EMAC_MII_BUSY) ? -EBUSY : -EIO;
-		}
-		return 0;
-
-	case SIOCSMIIREG:	/* Write MII PHY register. */
-	case SIOCDEVPRIVATE + 2:	/* for binary compat, remove in 2.5 */
-		if (!capable(CAP_NET_ADMIN))
-			return -EPERM;
-
-		if (data->phy_id > 31 || data->reg_num > 31)
-			return -ENXIO;
-
-		/* Stop the PHY timer to prevent reentrancy. */
-		del_timer_sync(&lp->phy_timer);
-		spin_lock_irqsave(&reset_lock, flags);
-		Result = XEmac_PhyWrite(&lp->Emac, data->phy_id,
-					data->reg_num, data->val_in);
-		spin_unlock_irqrestore(&reset_lock, flags);
-		/* Start the PHY timer up again. */
-		lp->phy_timer.expires = jiffies + 2 * HZ;
-		add_timer(&lp->phy_timer);
-
-		if (Result != XST_SUCCESS) {
-			printk(KERN_ERR
-			       "%s: Could not write to PHY, error=%d.\n",
-			       dev->name, Result);
-			return (Result == XST_EMAC_MII_BUSY) ? -EBUSY : -EIO;
-		}
-		return 0;
-
-	case SIOCDEVPRIVATE + 3:	/* set THRESHOLD */
-		if (copy_from_user(&thr_arg, rq->ifr_data, sizeof(thr_arg))) {
-			return -EFAULT;
-		}
-		spin_lock_irqsave(&reset_lock, flags);
-		if ((ret = XEmac_Stop(&lp->Emac)) != XST_SUCCESS) {
-			return -EIO;
-		}
-		if ((ret =
-		     XEmac_SetPktThreshold(&lp->Emac, thr_arg.direction,
-					   thr_arg.threshold)) != XST_SUCCESS) {
-			return -EIO;
-		}
-		if ((ret = XEmac_Start(&lp->Emac)) != XST_SUCCESS) {
-			return -EIO;
-		}
-		spin_unlock_irqrestore(&reset_lock, flags);
-		return 0;
-
-	case SIOCDEVPRIVATE + 4:	/* set WAITBOUND */
-		if (copy_from_user(&wbnd_arg, rq->ifr_data, sizeof(wbnd_arg))) {
-			return -EFAULT;
-		}
-		spin_lock_irqsave(&reset_lock, flags);
-		if ((ret = XEmac_Stop(&lp->Emac)) != XST_SUCCESS) {
-			return -EIO;
-		}
-		if ((ret =
-		     XEmac_SetPktWaitBound(&lp->Emac, wbnd_arg.direction,
-					   wbnd_arg.waitbound)) !=
-		    XST_SUCCESS) {
-			return -EIO;
-		}
-		if ((ret = XEmac_Start(&lp->Emac)) != XST_SUCCESS) {
-			return -EIO;
-		}
-		spin_unlock_irqrestore(&reset_lock, flags);
-		return 0;
-
-	case SIOCDEVPRIVATE + 5:	/* get THRESHOLD */
-		if (copy_from_user(&thr_arg, rq->ifr_data, sizeof(thr_arg))) {
-			return -EFAULT;
-		}
-		if ((ret =
-		     XEmac_GetPktThreshold(&lp->Emac, thr_arg.direction,
-					   &(thr_arg.threshold))) !=
-		    XST_SUCCESS) {
-			return -EIO;
-		}
-		if (copy_to_user(rq->ifr_data, &thr_arg, sizeof(thr_arg))) {
-			return -EFAULT;
-		}
-		return 0;
-
-
-	case SIOCDEVPRIVATE + 6:	/* get WAITBOUND */
-		if (copy_from_user(&wbnd_arg, rq->ifr_data, sizeof(wbnd_arg))) {
-			return -EFAULT;
-		}
-		if ((ret =
-		     XEmac_GetPktWaitBound(&lp->Emac, wbnd_arg.direction,
-					   &(wbnd_arg.waitbound))) !=
-		    XST_SUCCESS) {
-			return -EIO;
-		}
-		if (copy_to_user(rq->ifr_data, &wbnd_arg, sizeof(wbnd_arg))) {
-			return -EFAULT;
-		}
-		return 0;
-
-	default:
-		return -EOPNOTSUPP;
-	}
-}
-
-
-static void xenet_remove_ndev(struct net_device *ndev)
-{
-	if (ndev) {
-		struct net_local *lp = netdev_priv(ndev);
-
-		if (XEmac_mIsSgDma(&lp->Emac) && (lp->desc_space)) {
-			free_descriptor_skb(ndev);
-			dma_free_coherent(NULL,
-					  lp->desc_space_size,
-					  lp->desc_space,
-					  lp->desc_space_handle);
-		}
-
-		if (lp->ddrVirtPtr) {
-			kfree(lp->ddrVirtPtr);
-		}
-
-		iounmap((void *) (lp->Emac.BaseAddress));
-		free_netdev(ndev);
-	}
-}
-
-/** Shared device initialization code */
-static int xenet_setup(
-		struct device *dev,
-		struct resource *r_mem,
-		struct resource *r_irq,
-		struct xemac_platform_data *pdata) {
-
-	u32 virt_baddr;		/* virtual base address of emac */
-
-	XEmac_Config Config;
-
-	struct net_device *ndev = NULL;
-	struct net_local *lp = NULL;
-
-	int rc;
-
-	u32 phy_addr;		/* used for scanning PHY address */
-	u32 hwid;		/* used for informational HW ID output */
-
-	/* Create an ethernet device instance */
-	ndev = alloc_etherdev(sizeof(struct net_local));
-	if (!ndev) {
-		dev_err(dev, "XEmac: Could not allocate net device.\n");
-		rc = -ENOMEM;
-		goto error;
-	}
-	dev_set_drvdata(dev, ndev);
-
-	ndev->irq = r_irq->start;
-        ndev->mem_start = r_mem->start;
-        ndev->mem_end = r_mem->end;
-
-	if (!request_mem_region(ndev->mem_start,ndev->mem_end - ndev->mem_start+1, DRIVER_NAME)) {
-		dev_err(dev, "Couldn't lock memory region at %p\n",
-			(void *)ndev->mem_start);
-		rc = -EBUSY;
-		goto error;
-	}
-
-	/* Initialize the private netdev structure
-	 */
-	lp = netdev_priv(ndev);
-	lp->ndev = ndev;
-
-	/* Setup the Config structure for the XEmac_CfgInitialize() call. */
-	Config.BaseAddress	= r_mem->start;	/* Physical address */
-	Config.IpIfDmaConfig	= pdata->dma_mode;
-	Config.HasMii		= pdata->has_mii;
-	Config.HasCam		= pdata->has_cam;
-	Config.HasJumbo		= pdata->has_jumbo;
-	Config.TxDre		= pdata->tx_dre;
-	Config.RxDre		= pdata->rx_dre;
-	Config.TxHwCsum		= pdata->tx_hw_csum;
-	Config.RxHwCsum		= pdata->rx_hw_csum;
-
-
-	/* Get the virtual base address for the device */
-	virt_baddr = (u32) ioremap(r_mem->start, r_mem->end - r_mem->start + 1);
-	if (0 == virt_baddr) {
-		dev_err(dev, "XEmac: Could not allocate iomem.\n");
-		rc = -EIO;
-		goto error;
-	}
-
-
-	if (XEmac_CfgInitialize(&lp->Emac, &Config, virt_baddr) != XST_SUCCESS) {
-		dev_err(dev, "XEmac: Could not initialize device.\n");
-		rc = -ENODEV;
-		goto error;
-	}
-
-	/* Set the MAC address */
-	memcpy(ndev->dev_addr, pdata->mac_addr, 6);
-	if (XEmac_SetMacAddress(&lp->Emac, ndev->dev_addr) != XST_SUCCESS) {
-		/* should not fail right after an initialize */
-		dev_err(dev, "XEmac: could not set MAC address.\n");
-		rc = -EIO;
-		goto error;
-	}
-	dev_info(dev,
-			"MAC address is now %2x:%2x:%2x:%2x:%2x:%2x\n",
-			pdata->mac_addr[0], pdata->mac_addr[1],
-			pdata->mac_addr[2], pdata->mac_addr[3],
-			pdata->mac_addr[4], pdata->mac_addr[5]);
-
-	if (XEmac_mIsSgDma(&lp->Emac)) {
-		int result;
-
-		printk(KERN_ERR "XEmac: using sgDMA mode.\n");
-		XEmac_SetSgSendHandler(&lp->Emac, ndev, SgSendHandler);
-		XEmac_SetSgRecvHandler(&lp->Emac, ndev, SgRecvHandler);
-
-		if (XEmac_mIsTxDre(&lp->Emac) == TRUE) {
-			printk(KERN_INFO "XEmac: using TxDRE mode\n");
-			ndev->hard_start_xmit = xenet_SgSendDre;
-		}
-		else {
-			printk(KERN_INFO "XEmac: not using TxDRE mode\n");
-			if (XEmac_mIsTxHwCsum(&lp->Emac)) {
-				printk(KERN_ERR
-				       "XEmac: HW CONFIGURATION ERROR, "
-				       "Checksum offload without TX DRE!\n");
-				rc = -EIO;
-				goto error;
-			}
-			ndev->hard_start_xmit = xenet_SgSend;
-		}
-		if (XEmac_mIsRxDre(&lp->Emac) == TRUE) {
-			printk(KERN_INFO "XEmac: using RxDRE mode\n");
-		}
-		else {
-			printk(KERN_INFO "XEmac: not using RxDRE mode\n");
-		}
-
-		if (XEmac_mIsTxHwCsum(&lp->Emac)) {
-			printk(KERN_ERR
-			       "XEmac: TX Checksum offload Mode enabled.\n");
-		}
-
-		if (XEmac_mIsRxHwCsum(&lp->Emac)) {
-			printk(KERN_ERR
-			       "XEmac: RX Checksum offload Mode enabled.\n");
-		}
-
-
-		/* Set up Interrupt handler.
-		 */
-		lp->Isr = XEmac_IntrHandlerDma;
-
-		/* Set up SG DMA descriptors.
-		 */
-		result = descriptor_init(ndev);
-		if (result) {
-			rc = -EIO;
-			goto error;
-		}
-
-		/* set the packet threshold and waitbound */
-		XEmac_SetPktThreshold(&lp->Emac, XEM_SEND, 31);
-		XEmac_SetPktThreshold(&lp->Emac, XEM_RECV, 31);
-		(void) XEmac_SetPktWaitBound(&lp->Emac, XEM_SEND, 5);
-		(void) XEmac_SetPktWaitBound(&lp->Emac, XEM_RECV, 5);
-
-
-		/* disable SGEND interrupt and enable stripping of FCS and PAD */
-		XEmac_SetOptions(&lp->Emac, XEmac_GetOptions(&lp->Emac) |
-				 (XEM_NO_SGEND_INT_OPTION
-				  /*| XEM_STRIP_PAD_FCS_OPTION */ ));
-
-	}
-	else {
-		printk(KERN_ERR "XEmac: using fifo mode.\n");
-		XEmac_SetFifoRecvHandler(&lp->Emac, ndev, FifoRecvHandler);
-		XEmac_SetFifoSendHandler(&lp->Emac, ndev, FifoSendHandler);
-		ndev->hard_start_xmit = xenet_FifoSend;
-		lp->Isr = XEmac_IntrHandlerFifo;
-	}
-	XEmac_SetErrorHandler(&lp->Emac, ndev, ErrorHandler);
-
-
-	/* Scan for the PHY.
-	 */
-	lp->mii_addr = 0xFF;
-	for (phy_addr = 0; phy_addr < 31; phy_addr++) {
-		int Result;
-		u16 reg;
-		int repeat;
-
-		Result = XEmac_PhyRead(&lp->Emac, phy_addr, MII_PHYSID1, &reg);
-		if (XST_SUCCESS != Result) {
-			continue;
-		}
-
-		/* Even if we get here, we can not be sure that we actually found a PHY
-		 * at this address. Once in a while, XEmac_PhyRead() returns
-		 * XST_SUCCESS for reads at non-exsiting PHY addresses. This seems to
-		 * be a bug in the hardware.  Fortunately, we can work around this
-		 * problem by reading the PHY register several times and checking that
-		 * we always get the same value. If we do, it is VERY likely that a PHY
-		 * exists at that address.
-		 */
-		for (repeat = 0; repeat < 4; repeat++) {
-			u16 check_reg;
-
-			Result = XEmac_PhyRead(&lp->Emac, phy_addr, MII_PHYSID1,
-					       &check_reg);
-			if ((XST_SUCCESS != Result) || (check_reg != reg)) {
-				break;
-			}
-		}
-
-		/* If we read the same value 4 times, we can be pretty sure that there
-		 * is a PHY out there at this address.
-		 */
-		if (4 == repeat) {
-			u16 rev;
-
-			/* Reading the revision # after successfully reading the
-			 * manufacturer ID should NEVER fail. If it does, something really
-			 * bad is happening.
-			 */
-			Result = XEmac_PhyRead(&lp->Emac, phy_addr, MII_PHYSID2,
-					       &rev);
-			if (XST_SUCCESS != Result) {
-				printk("XEmac: Error reading PHY revision for PHY at address %d! " "THIS SHOULD NOT HAPPEN! Ignoring this PHY.\n", phy_addr);
-				continue;
-			}
-
-			/* If we get here, we know that we successfully detected a PHY.
-			 */
-			printk("XEmac: Detected PHY at address %d, ManufID 0x%04x, Rev. 0x%04x.\n", phy_addr, reg, rev);
-			lp->mii_addr = phy_addr;
-			break;
-		}
-		/* If we get here, the repeated reads returned inconsistent results ->
-		 * No PHY.
-		 */
-	}
-	if (lp->mii_addr == 0xFF) {
-		printk(KERN_WARNING
-		       "XEmac: No PHY detected. Assuming PHY at address 0.\n");
-		lp->mii_addr = 0;
-	}
-
-	/* initialize the netdev structure */
-	ndev->open = xenet_open;
-	ndev->stop = xenet_close;
-	ndev->change_mtu = xenet_change_mtu;
-	ndev->get_stats = xenet_get_stats;
-	ndev->set_multicast_list = xenet_set_multicast_list;
-	ndev->do_ioctl = xenet_ioctl;
-	ndev->watchdog_timeo = TX_TIMEOUT;
-	ndev->flags &= ~IFF_MULTICAST;
-	ndev->tx_timeout = xenet_tx_timeout;
-	ndev->features = NETIF_F_SG | NETIF_F_FRAGLIST;
-
-	if ((XEmac_mIsTxHwCsum(&lp->Emac)) && (XEmac_mIsTxDre(&lp->Emac))) {
-		ndev->features |= NETIF_F_IP_CSUM;
-	}
-
-	/* Finally, register the device.
-	 */
-	rc = register_netdev(ndev);
-	if (rc) {
-		printk(KERN_ERR
-		       "%s: Cannot register net device, aborting.\n",
-		       ndev->name);
-		goto error;	/* rc is already set here... */
-	}
-
-	printk(KERN_INFO
-               "%s: Xilinx 10/100 EMAC at 0x%08X mapped to 0x%08X, irq=%d\n",
-               ndev->name,
-               lp->Emac.PhysAddress,
-               lp->Emac.BaseAddress, ndev->irq);
-
-	/* print h/w id  */
-	hwid = XIo_In32((lp->Emac).BaseAddress + XEM_EMIR_OFFSET);
-
-	printk(KERN_INFO
-	       "%s: XEmac id %d.%d%c, block id %d, type %d\n",
-	       ndev->name, (hwid >> 28) & 0xf, (hwid >> 21) & 0x7f,
-	       ((hwid >> 16) & 0x1f) + 'a', (hwid >> 16) & 0xff,
-	       (hwid >> 0) & 0xff);
-
-	return 0;
-
-error:
-	return rc;
-}
-
-static int xenet_remove(struct device *dev)
-{
-	struct net_device *ndev = dev_get_drvdata(dev);
-
-	unregister_netdev(ndev);
-	xenet_remove_ndev(ndev);
-
-        release_mem_region(ndev->mem_start, ndev->mem_end-ndev->mem_start+1);
-
-	free_netdev(ndev);
-
-	dev_set_drvdata(dev, NULL);
-
-	return 0;		/* success */
-}
-
-
-static int xenet_probe(struct device *dev)
-{
-	struct resource *r_irq = NULL;	/* Interrupt resources */
-	struct resource *r_mem = NULL;	/* IO mem resources */
-	struct xemac_platform_data *pdata;
-	struct platform_device *pdev = to_platform_device(dev);
-
-	/* param check */
-	if (!pdev) {
-		printk(KERN_ERR
-		       "XEmac: Internal error. Probe called with NULL param.\n");
-		return -ENODEV;
-	}
-
-	pdata = (struct xemac_platform_data *) pdev->dev.platform_data;
-	if (!pdata) {
-		printk(KERN_ERR "XEmac %d: Couldn't find platform data.\n",
-		       pdev->id);
-
-		return -ENODEV;
-	}
-
-	/* Get iospace and an irq for the device */
-	r_irq = platform_get_resource(pdev, IORESOURCE_IRQ, 0);
-	r_mem = platform_get_resource(pdev, IORESOURCE_MEM, 0);
-	if (!r_irq || !r_mem) {
-		printk(KERN_ERR "XEmac %d: IO resource(s) not found.\n",
-		       pdev->id);
-		return -ENODEV;
-	}
-
-        return xenet_setup(dev, r_mem, r_irq, pdata);
-}
-
-static struct device_driver xenet_driver = {
-	.name = DRIVER_NAME,
-	.bus = &platform_bus_type,
-
-	.probe = xenet_probe,
-	.remove = xenet_remove
-};
-
-#ifdef CONFIG_OF
-static u32 get_u32(struct of_device *ofdev, const char *s) {
-	u32 *p = (u32 *)of_get_property(ofdev->node, s, NULL);
-	if(p) {
-		return *p;
-	} else {
-		dev_warn(&ofdev->dev, "Parameter %s not found, defaulting to false.\n", s);
-		return FALSE;
-	}
-}
-
-static bool get_bool(struct of_device *ofdev, const char *s) {
-	u32 *p = (u32 *)of_get_property(ofdev->node, s, NULL);
-	if(p) {
-		return (bool)*p;
-	} else {
-		dev_warn(&ofdev->dev, "Parameter %s not found, defaulting to false.\n", s);
-		return FALSE;
-	}
-}
-
-static int __devinit xenet_of_probe(struct of_device *ofdev, const struct of_device_id *match)
-{
-	struct xemac_platform_data pdata_struct;
-	struct resource r_irq_struct;
-	struct resource r_mem_struct;
-
-	struct resource *r_irq = &r_irq_struct;	/* Interrupt resources */
-	struct resource *r_mem = &r_mem_struct;	/* IO mem resources */
-	struct xemac_platform_data *pdata = &pdata_struct;
-        void *mac_address;
-	int rc = 0;
-
-	printk(KERN_ERR "Device Tree Probing \'%s\'\n",
-                        ofdev->node->name);
-
-	/* Get iospace for the device */
-	rc = of_address_to_resource(ofdev->node, 0, r_mem);
-	if(rc) {
-		dev_warn(&ofdev->dev, "invalid address\n");
-		return rc;
-	}
-
-	/* Get IRQ for the device */
-	rc = of_irq_to_resource(ofdev->node, 0, r_irq);
-	if(rc == NO_IRQ) {
-		dev_warn(&ofdev->dev, "no IRQ found.\n");
-		return rc;
-	}
-
-        /* Many of these features do not exist in all versions of the
-           ethernet core.  We accept if these attributes are not
-           present and do not attempt to exercise the corresponding
-           feature. */
-	pdata_struct.dma_mode           = get_u32(ofdev, "xlnx,dma-present");
-	pdata_struct.has_mii		= get_bool(ofdev, "xlnx,mii-exist");
-	pdata_struct.has_cam		= get_bool(ofdev, "xlnx,cam-exist");
-	pdata_struct.has_err_cnt	= get_bool(ofdev, "xlnx,err-count-exist");
-	pdata_struct.has_jumbo		= get_bool(ofdev, "xlnx,jumbo-exist");
-	pdata_struct.tx_dre		= get_u32(ofdev, "xlnx,tx-dre-type");
-	pdata_struct.rx_dre		= get_u32(ofdev, "xlnx,rx-dre-type");
-	pdata_struct.tx_hw_csum		= get_bool(ofdev, "xlnx,tx-include-csum");
-	pdata_struct.rx_hw_csum		= get_bool(ofdev, "xlnx,rx-include-csum");
-        mac_address = of_get_mac_address(ofdev->node);
-        if(mac_address) {
-            memcpy(pdata_struct.mac_addr, mac_address, 6);
-        } else {
-            dev_warn(&ofdev->dev, "No MAC address found.\n");
-        }
-
-        return xenet_setup(&ofdev->dev, r_mem, r_irq, pdata);
-}
-
-static int __devexit xenet_of_remove(struct of_device *dev)
-{
-	return xenet_remove(&dev->dev);
-}
-
-static struct of_device_id xenet_of_match[] = {
-	{ .compatible = "xlnx,opb-ethernet-1.01.a", },
-	{ .compatible = "xlnx,opb-ethernet-1.02.a", },
-	{ .compatible = "xlnx,opb-ethernet-1.04.a", },
-	{ .compatible = "xlnx,plb-ethernet-1.00.a", },
-	{ .compatible = "xlnx,plb-ethernet-1.01.a", },
-	{ /* end of list */ },
-};
-
-MODULE_DEVICE_TABLE(of, xenet_of_match);
-
-static struct of_platform_driver xenet_of_driver = {
-	.name		= DRIVER_NAME,
-	.match_table	= xenet_of_match,
-	.probe		= xenet_of_probe,
-	.remove		= __devexit_p(xenet_of_remove),
-};
-#endif
-
-static int __init xenet_init(void)
-{
-	/*
-	 * No kernel boot options used,
-	 * so we just need to register the driver
-	 */
-	int status = driver_register(&xenet_driver);
-#ifdef CONFIG_OF
-	status |= platform_driver_register(&xenet_of_driver);
-#endif
-	return status;
-}
-
-static void __exit xenet_cleanup(void)
-{
-	driver_unregister(&xenet_driver);
-#ifdef CONFIG_OF
-	platform_driver_unregister(&xenet_of_driver);
-#endif
-}
-
-module_init(xenet_init);
-module_exit(xenet_cleanup);
diff --git a/drivers/net/ethernet/xilinx/xilinx_emac/xemac_options.c b/drivers/net/ethernet/xilinx/xilinx_emac/xemac_options.c
deleted file mode 100644
index 91eca41..0000000
--- a/drivers/net/ethernet/xilinx/xilinx_emac/xemac_options.c
+++ /dev/null
@@ -1,325 +0,0 @@
-/* $Id: xemac_options.c,v 1.1 2007/04/04 18:27:45 wre Exp $ */
-/******************************************************************************
-*
-*       XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS"
-*       AS A COURTESY TO YOU, SOLELY FOR USE IN DEVELOPING PROGRAMS AND
-*       SOLUTIONS FOR XILINX DEVICES.  BY PROVIDING THIS DESIGN, CODE,
-*       OR INFORMATION AS ONE POSSIBLE IMPLEMENTATION OF THIS FEATURE,
-*       APPLICATION OR STANDARD, XILINX IS MAKING NO REPRESENTATION
-*       THAT THIS IMPLEMENTATION IS FREE FROM ANY CLAIMS OF INFRINGEMENT,
-*       AND YOU ARE RESPONSIBLE FOR OBTAINING ANY RIGHTS YOU MAY REQUIRE
-*       FOR YOUR IMPLEMENTATION.  XILINX EXPRESSLY DISCLAIMS ANY
-*       WARRANTY WHATSOEVER WITH RESPECT TO THE ADEQUACY OF THE
-*       IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OR
-*       REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE FROM CLAIMS OF
-*       INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
-*       FOR A PARTICULAR PURPOSE.
-*
-*       (c) Copyright 2003 Xilinx Inc.
-*       All rights reserved.
-*
-******************************************************************************/
-/*****************************************************************************/
-/**
-*
-* @file xemac_options.c
-*
-* Functions in this file handle configuration of the XEmac driver.
-*
-* <pre>
-* MODIFICATION HISTORY:
-*
-* Ver   Who  Date     Changes
-* ----- ---- -------- -----------------------------------------------
-* 1.00a rpm  07/31/01 First release
-* 1.00b rpm  02/20/02 Repartitioned files and functions
-* 1.00c rpm  12/05/02 New version includes support for simple DMA
-* 1.00d rpm  09/26/03 New version includes support PLB Ethernet and v2.00a of
-*                     the packet fifo driver.
-* 1.00e rmm  04/06/04 Added XEM_NO_SGEND_INT_OPTION processing. Relocated
-*                     XEM_MAX_IFG definition from here to xemac_hw.h as XEM_IFGP_
-*                     PART1_MAX and XEM_IFGP_PART2_MAX.
-* 1.00f rmm  10/19/04 Added options to control CAM and jumbo frames.
-* 1.11a wgr  03/22/07 Converted to new coding style.
-* </pre>
-*
-******************************************************************************/
-
-/***************************** Include Files *********************************/
-
-#include "xbasic_types.h"
-#include "xemac_i.h"
-#include "xio.h"
-
-/************************** Constant Definitions *****************************/
-
-
-/**************************** Type Definitions *******************************/
-
-
-/***************** Macros (Inline Functions) Definitions *********************/
-
-
-/************************** Function Prototypes ******************************/
-
-
-/************************** Variable Definitions *****************************/
-
-/*
- * A table of options and masks. This table maps the user-visible options with
- * the control register masks. It is used in Set/GetOptions as an alternative
- * to a series of if/else pairs. Note that the polled options does not have a
- * corresponding entry in the control register, so it does not exist in the
- * table.
- */
-typedef struct {
-	u32 Option;
-	u32 Mask;
-} OptionMap;
-
-static OptionMap OptionsTable[] = {
-	{XEM_UNICAST_OPTION, XEM_ECR_UNICAST_ENABLE_MASK},
-	{XEM_BROADCAST_OPTION, XEM_ECR_BROAD_ENABLE_MASK},
-	{XEM_PROMISC_OPTION, XEM_ECR_PROMISC_ENABLE_MASK},
-	{XEM_FDUPLEX_OPTION, XEM_ECR_FULL_DUPLEX_MASK},
-	{XEM_LOOPBACK_OPTION, XEM_ECR_LOOPBACK_MASK},
-	{XEM_MULTICAST_OPTION, XEM_ECR_MULTI_ENABLE_MASK},
-	{XEM_FLOW_CONTROL_OPTION, XEM_ECR_PAUSE_FRAME_MASK},
-	{XEM_INSERT_PAD_OPTION, XEM_ECR_XMIT_PAD_ENABLE_MASK},
-	{XEM_INSERT_FCS_OPTION, XEM_ECR_XMIT_FCS_ENABLE_MASK},
-	{XEM_INSERT_ADDR_OPTION, XEM_ECR_XMIT_ADDR_INSERT_MASK},
-	{XEM_OVWRT_ADDR_OPTION, XEM_ECR_XMIT_ADDR_OVWRT_MASK},
-	{XEM_STRIP_PAD_FCS_OPTION, XEM_ECR_RECV_STRIP_ENABLE_MASK},
-	{XEM_MULTICAST_CAM_OPTION, XEM_ECR_CAM_ENABLE_MASK},
-	{XEM_JUMBO_OPTION, XEM_ECR_RECV_JUMBO_ENABLE_MASK}
-};
-
-#define XEM_NUM_OPTIONS     (sizeof(OptionsTable) / sizeof(OptionMap))
-
-/*****************************************************************************/
-/**
-*
-* Set Ethernet driver/device options.  The device must be stopped before
-* calling this function.  The options are contained within a bit-mask with each
-* bit representing an option (i.e., you can OR the options together). A one (1)
-* in the bit-mask turns an option on, and a zero (0) turns the option off.
-*
-* @param InstancePtr is a pointer to the XEmac instance to be worked on.
-* @param OptionsFlag is a bit-mask representing the Ethernet options to turn on
-*        or off. See xemac.h for a description of the available options.
-*
-* @return
-*
-* - XST_SUCCESS if the options were set successfully
-* - XST_DEVICE_IS_STARTED if the device has not yet been stopped
-*
-* @note
-*
-* This function is not thread-safe and makes use of internal resources that are
-* shared between the Start, Stop, and SetOptions functions, so if one task
-* might be setting device options while another is trying to start the device,
-* protection of this shared data (typically using a semaphore) is required.
-*
-******************************************************************************/
-int XEmac_SetOptions(XEmac * InstancePtr, u32 OptionsFlag)
-{
-	u32 ControlReg;
-	u32 Index;
-
-	XASSERT_NONVOID(InstancePtr != NULL);
-	XASSERT_NONVOID(InstancePtr->IsReady == XCOMPONENT_IS_READY);
-
-	if (InstancePtr->IsStarted == XCOMPONENT_IS_STARTED) {
-		return XST_DEVICE_IS_STARTED;
-	}
-
-	ControlReg = XIo_In32(InstancePtr->BaseAddress + XEM_ECR_OFFSET);
-
-	/*
-	 * Loop through the options table, turning the option on or off
-	 * depending on whether the bit is set in the incoming options flag.
-	 */
-	for (Index = 0; Index < XEM_NUM_OPTIONS; Index++) {
-		if (OptionsFlag & OptionsTable[Index].Option) {
-			ControlReg |= OptionsTable[Index].Mask;	/* turn it on */
-		}
-		else {
-			ControlReg &= ~OptionsTable[Index].Mask;	/* turn it off */
-		}
-	}
-
-	/*
-	 * TODO: need to validate addr-overwrite only if addr-insert?
-	 */
-
-	/*
-	 * Now write the control register. Leave it to the upper layers
-	 * to restart the device.
-	 */
-	XIo_Out32(InstancePtr->BaseAddress + XEM_ECR_OFFSET, ControlReg);
-
-	/*
-	 * Check the polled option
-	 */
-	if (OptionsFlag & XEM_POLLED_OPTION) {
-		InstancePtr->IsPolled = TRUE;
-	}
-	else {
-		InstancePtr->IsPolled = FALSE;
-	}
-
-	/*
-	 * Check the No SGEND option
-	 */
-	if (OptionsFlag & XEM_NO_SGEND_INT_OPTION) {
-		InstancePtr->IsSgEndDisable = TRUE;
-	}
-	else {
-		InstancePtr->IsSgEndDisable = FALSE;
-	}
-
-	return XST_SUCCESS;
-}
-
-/*****************************************************************************/
-/**
-*
-* Get Ethernet driver/device options. The 32-bit value returned is a bit-mask
-* representing the options.  A one (1) in the bit-mask means the option is on,
-* and a zero (0) means the option is off.
-*
-* @param InstancePtr is a pointer to the XEmac instance to be worked on.
-*
-* @return
-*
-* The 32-bit value of the Ethernet options. The value is a bit-mask
-* representing all options that are currently enabled. See xemac.h for a
-* description of the available options.
-*
-* @note
-*
-* None.
-*
-******************************************************************************/
-u32 XEmac_GetOptions(XEmac * InstancePtr)
-{
-	u32 OptionsFlag = 0;
-	u32 ControlReg;
-	u32 Index;
-
-	XASSERT_NONVOID(InstancePtr != NULL);
-	XASSERT_NONVOID(InstancePtr->IsReady == XCOMPONENT_IS_READY);
-
-	/*
-	 * Get the control register to determine which options are currently set.
-	 */
-	ControlReg = XIo_In32(InstancePtr->BaseAddress + XEM_ECR_OFFSET);
-
-	/*
-	 * Loop through the options table to determine which options are set
-	 */
-	for (Index = 0; Index < XEM_NUM_OPTIONS; Index++) {
-		if (ControlReg & OptionsTable[Index].Mask) {
-			OptionsFlag |= OptionsTable[Index].Option;
-		}
-	}
-
-	if (InstancePtr->IsPolled) {
-		OptionsFlag |= XEM_POLLED_OPTION;
-	}
-
-	if (InstancePtr->IsSgEndDisable) {
-		OptionsFlag |= XEM_NO_SGEND_INT_OPTION;
-	}
-
-	return OptionsFlag;
-}
-
-
-/*****************************************************************************/
-/**
-*
-* Set the Interframe Gap (IFG), which is the time the MAC delays between
-* transmitting frames.  There are two parts required.  The total interframe gap
-* is the total of the two parts.  The values provided for the Part1 and Part2
-* parameters are multiplied by 4 to obtain the bit-time interval. The first
-* part should be the first 2/3 of the total interframe gap. The MAC will reset
-* the interframe gap timer if carrier sense becomes true during the period
-* defined by interframe gap Part1. Part1 may be shorter than 2/3 the total and
-* can be as small as zero. The second part should be the last 1/3 of the total
-* interframe gap, but can be as large as the total interframe gap. The MAC
-* will not reset the interframe gap timer if carrier sense becomes true during
-* the period defined by interframe gap Part2.
-*
-* The device must be stopped before setting the interframe gap.
-*
-* @param InstancePtr is a pointer to the XEmac instance to be worked on.
-* @param Part1 is the interframe gap part 1 (which will be multiplied by 4 to
-*        get the bit-time interval).
-* @param Part2 is the interframe gap part 2 (which will be multiplied by 4 to
-*        get the bit-time interval).
-*
-* @return
-*
-* - XST_SUCCESS if the interframe gap was set successfully
-* - XST_DEVICE_IS_STARTED if the device has not been stopped
-*
-* @note
-*
-* None.
-*
-******************************************************************************/
-int XEmac_SetInterframeGap(XEmac * InstancePtr, u8 Part1, u8 Part2)
-{
-	u32 Ifg;
-
-	XASSERT_NONVOID(InstancePtr != NULL);
-	XASSERT_NONVOID(Part1 <= XEM_IFGP_PART1_MAX);
-	XASSERT_NONVOID(Part2 <= XEM_IFGP_PART2_MAX);
-	XASSERT_NONVOID(InstancePtr->IsReady == XCOMPONENT_IS_READY);
-
-	/*
-	 * Be sure device has been stopped
-	 */
-	if (InstancePtr->IsStarted == XCOMPONENT_IS_STARTED) {
-		return XST_DEVICE_IS_STARTED;
-	}
-
-	Ifg = Part1 << XEM_IFGP_PART1_SHIFT;
-	Ifg |= (Part2 << XEM_IFGP_PART2_SHIFT);
-	XIo_Out32(InstancePtr->BaseAddress + XEM_IFGP_OFFSET, Ifg);
-
-	return XST_SUCCESS;
-}
-
-/*****************************************************************************/
-/**
-*
-* Get the interframe gap, parts 1 and 2. See the description of interframe gap
-* above in XEmac_SetInterframeGap().
-*
-* @param InstancePtr is a pointer to the XEmac instance to be worked on.
-* @param Part1Ptr is a pointer to an 8-bit buffer into which the interframe gap
-*        part 1 value will be copied.
-* @param Part2Ptr is a pointer to an 8-bit buffer into which the interframe gap
-*        part 2 value will be copied.
-*
-* @return
-*
-* None. The values of the interframe gap parts are copied into the
-* output parameters.
-*
-******************************************************************************/
-void XEmac_GetInterframeGap(XEmac * InstancePtr, u8 *Part1Ptr, u8 *Part2Ptr)
-{
-	u32 Ifg;
-
-	XASSERT_VOID(InstancePtr != NULL);
-	XASSERT_VOID(Part1Ptr != NULL);
-	XASSERT_VOID(Part2Ptr != NULL);
-	XASSERT_VOID(InstancePtr->IsReady == XCOMPONENT_IS_READY);
-
-	Ifg = XIo_In32(InstancePtr->BaseAddress + XEM_IFGP_OFFSET);
-	*Part1Ptr = (Ifg & XEM_IFGP_PART1_MASK) >> XEM_IFGP_PART1_SHIFT;
-	*Part2Ptr = (Ifg & XEM_IFGP_PART2_MASK) >> XEM_IFGP_PART2_SHIFT;
-}
diff --git a/drivers/net/ethernet/xilinx/xilinx_emac/xemac_phy.c b/drivers/net/ethernet/xilinx/xilinx_emac/xemac_phy.c
deleted file mode 100644
index 4b28ef5..0000000
--- a/drivers/net/ethernet/xilinx/xilinx_emac/xemac_phy.c
+++ /dev/null
@@ -1,300 +0,0 @@
-/* $Id: xemac_phy.c,v 1.1 2007/04/04 18:27:45 wre Exp $ */
-/******************************************************************************
-*
-*       XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS"
-*       AS A COURTESY TO YOU, SOLELY FOR USE IN DEVELOPING PROGRAMS AND
-*       SOLUTIONS FOR XILINX DEVICES.  BY PROVIDING THIS DESIGN, CODE,
-*       OR INFORMATION AS ONE POSSIBLE IMPLEMENTATION OF THIS FEATURE,
-*       APPLICATION OR STANDARD, XILINX IS MAKING NO REPRESENTATION
-*       THAT THIS IMPLEMENTATION IS FREE FROM ANY CLAIMS OF INFRINGEMENT,
-*       AND YOU ARE RESPONSIBLE FOR OBTAINING ANY RIGHTS YOU MAY REQUIRE
-*       FOR YOUR IMPLEMENTATION.  XILINX EXPRESSLY DISCLAIMS ANY
-*       WARRANTY WHATSOEVER WITH RESPECT TO THE ADEQUACY OF THE
-*       IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OR
-*       REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE FROM CLAIMS OF
-*       INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
-*       FOR A PARTICULAR PURPOSE.
-*
-*       (c) Copyright 2003 Xilinx Inc.
-*       All rights reserved.
-*
-******************************************************************************/
-/*****************************************************************************/
-/**
-*
-* @file xemac_phy.c
-*
-* Contains functions to read and write the PHY through the Ethernet MAC MII
-* registers.  These assume an MII-compliant PHY.
-*
-* <pre>
-* MODIFICATION HISTORY:
-*
-* Ver   Who  Date     Changes
-* ----- ---- -------- -----------------------------------------------
-* 1.00a rpm  07/31/01 First release
-* 1.00b rpm  02/20/02 Repartitioned files and functions
-* 1.00c rpm  12/05/02 New version includes support for simple DMA
-* 1.00d rpm  09/26/03 New version includes support PLB Ethernet and v2.00a of
-*                     the packet fifo driver.
-* 1.00e rmm  04/06/04 Moved XEM_MAX_PHY constants to xemac_hw.h
-* 1.00f rmm  10/19/04 Added XEmac_PhyReset() function.
-* 1.11a wgr  03/22/07 Converted to new coding style.
-* </pre>
-*
-******************************************************************************/
-
-/***************************** Include Files *********************************/
-
-#include "xbasic_types.h"
-#include "xemac_i.h"
-#include "xio.h"
-
-/************************** Constant Definitions *****************************/
-
-
-/**************************** Type Definitions *******************************/
-
-
-/***************** Macros (Inline Functions) Definitions *********************/
-
-
-/************************** Function Prototypes ******************************/
-
-
-/************************** Variable Definitions *****************************/
-
-
-/*****************************************************************************/
-/**
-*
-* Assert the PHY reset signal. This function will work only when the external
-* PHY supports the reset_n signal. See EMAC spec for more information.
-*
-* @param InstancePtr is a pointer to the XEmac instance to be worked on.
-*
-* @note
-*
-* This function will always leave the PHY enabled.
-*
-******************************************************************************/
-void XEmac_PhyReset(XEmac * InstancePtr)
-{
-	u32 RegECR;
-
-	XASSERT_VOID(InstancePtr != NULL);
-
-	/* Disable/reset the PHY */
-	RegECR = XIo_In32(InstancePtr->BaseAddress + XEM_ECR_OFFSET);
-	XIo_Out32(InstancePtr->BaseAddress + XEM_ECR_OFFSET,
-		  RegECR & ~XEM_ECR_PHY_ENABLE_MASK);
-
-	/* Re-enable the PHY */
-	XIo_Out32(InstancePtr->BaseAddress + XEM_ECR_OFFSET,
-		  RegECR | XEM_ECR_PHY_ENABLE_MASK);
-}
-
-
-
-/*****************************************************************************/
-/**
-*
-* Read the current value of the PHY register indicated by the PhyAddress and
-* the RegisterNum parameters. The MAC provides the driver with the ability to
-* talk to a PHY that adheres to the Media Independent Interface (MII) as
-* defined in the IEEE 802.3 standard.
-*
-* @param InstancePtr is a pointer to the XEmac instance to be worked on.
-* @param PhyAddress is the address of the PHY to be read (supports multiple
-*        PHYs)
-* @param RegisterNum is the register number, 0-31, of the specific PHY register
-*        to read
-* @param PhyDataPtr is an output parameter, and points to a 16-bit buffer into
-*        which the current value of the register will be copied.
-*
-* @return
-*
-* - XST_SUCCESS if the PHY was read from successfully
-* - XST_NO_FEATURE if the device is not configured with MII support
-* - XST_EMAC_MII_BUSY if there is another PHY operation in progress
-* - XST_EMAC_MII_READ_ERROR if a read error occurred between the MAC and the PHY
-*
-* @note
-*
-* This function is not thread-safe. The user must provide mutually exclusive
-* access to this function if there are to be multiple threads that can call it.
-* <br><br>
-* There is the possibility that this function will not return if the hardware
-* is broken (i.e., it never sets the status bit indicating that the read is
-* done). If this is of concern to the user, the user should provide protection
-* from this problem - perhaps by using a different timer thread to monitor the
-* PhyRead thread.
-*
-******************************************************************************/
-int XEmac_PhyRead(XEmac * InstancePtr, u32 PhyAddress,
-		  u32 RegisterNum, u16 *PhyDataPtr)
-{
-	u32 MiiControl;
-	u32 MiiData;
-
-	XASSERT_NONVOID(InstancePtr != NULL);
-	XASSERT_NONVOID(PhyAddress <= XEM_MGTCR_MAX_PHY_ADDR);
-	XASSERT_NONVOID(RegisterNum <= XEM_MGTCR_MAX_PHY_REG);
-	XASSERT_NONVOID(PhyDataPtr != NULL);
-	XASSERT_NONVOID(InstancePtr->IsReady == XCOMPONENT_IS_READY);
-
-	/*
-	 * Make sure the device has the management interface
-	 */
-	if (!XEmac_mHasMii(InstancePtr)) {
-		return XST_NO_FEATURE;
-	}
-
-	/*
-	 * Verify that there is no operation in progress already
-	 */
-	MiiControl = XIo_In32(InstancePtr->BaseAddress + XEM_MGTCR_OFFSET);
-	if (MiiControl & XEM_MGTCR_START_MASK) {
-		/* operation in progress */
-		return XST_EMAC_MII_BUSY;
-	}
-
-	/*
-	 * Set up the MII control register first.  We set up a control word with
-	 * the PHY address and register number, then indicate the direction (read),
-	 * then start the operation.
-	 */
-	MiiControl = PhyAddress << XEM_MGTCR_PHY_ADDR_SHIFT;
-	MiiControl |= (RegisterNum << XEM_MGTCR_REG_ADDR_SHIFT);
-	MiiControl |= (XEM_MGTCR_RW_NOT_MASK | XEM_MGTCR_START_MASK |
-		       XEM_MGTCR_MII_ENABLE_MASK);
-
-	XIo_Out32(InstancePtr->BaseAddress + XEM_MGTCR_OFFSET, MiiControl);
-
-	/*
-	 * Wait for the operation to complete
-	 */
-	do {
-		MiiControl =
-			XIo_In32(InstancePtr->BaseAddress + XEM_MGTCR_OFFSET);
-	}
-	while (MiiControl & XEM_MGTCR_START_MASK);
-
-	/*
-	 * Now read the resulting MII data register.  First check to see if
-	 * an error occurred before reading and returning the value in
-	 * the MII data register.
-	 */
-	if (MiiControl & XEM_MGTCR_RD_ERROR_MASK) {
-		/*
-		 * MII read error occurred.  Upper layer will need to retry.
-		 */
-		return XST_EMAC_MII_READ_ERROR;
-	}
-
-	/*
-	 * Retrieve the data from the 32-bit register, then copy it to
-	 * the 16-bit output parameter.
-	 */
-	MiiData = XIo_In32(InstancePtr->BaseAddress + XEM_MGTDR_OFFSET);
-
-	*PhyDataPtr = (u16) MiiData;
-
-	return XST_SUCCESS;
-}
-
-/*****************************************************************************/
-/**
-*
-* Write data to the specified PHY register. The Ethernet driver does not
-* require the device to be stopped before writing to the PHY.  Although it is
-* probably a good idea to stop the device, it is the responsibility of the
-* application to deem this necessary. The MAC provides the driver with the
-* ability to talk to a PHY that adheres to the Media Independent Interface
-* (MII) as defined in the IEEE 802.3 standard.
-*
-* @param InstancePtr is a pointer to the XEmac instance to be worked on.
-* @param PhyAddress is the address of the PHY to be written (supports multiple
-*        PHYs)
-* @param RegisterNum is the register number, 0-31, of the specific PHY register
-*        to write
-* @param PhyData is the 16-bit value that will be written to the register
-*
-* @return
-*
-* - XST_SUCCESS if the PHY was written to successfully. Since there is no error
-*   status from the MAC on a write, the user should read the PHY to verify the
-*   write was successful.
-* - XST_NO_FEATURE if the device is not configured with MII support
-* - XST_EMAC_MII_BUSY if there is another PHY operation in progress
-*
-* @note
-*
-* This function is not thread-safe. The user must provide mutually exclusive
-* access to this function if there are to be multiple threads that can call it.
-* <br><br>
-* There is the possibility that this function will not return if the hardware
-* is broken (i.e., it never sets the status bit indicating that the write is
-* done). If this is of concern to the user, the user should provide protection
-* from this problem - perhaps by using a different timer thread to monitor the
-* PhyWrite thread.
-*
-******************************************************************************/
-int XEmac_PhyWrite(XEmac * InstancePtr, u32 PhyAddress,
-		   u32 RegisterNum, u16 PhyData)
-{
-	u32 MiiControl;
-
-	XASSERT_NONVOID(InstancePtr != NULL);
-	XASSERT_NONVOID(PhyAddress <= XEM_MGTCR_MAX_PHY_ADDR);
-	XASSERT_NONVOID(RegisterNum <= XEM_MGTCR_MAX_PHY_REG);
-	XASSERT_NONVOID(InstancePtr->IsReady == XCOMPONENT_IS_READY);
-
-	/*
-	 * Make sure the device has the management interface
-	 */
-	if (!XEmac_mHasMii(InstancePtr)) {
-		return XST_NO_FEATURE;
-	}
-
-	/*
-	 * Verify that there is no operation in progress already
-	 */
-	MiiControl = XIo_In32(InstancePtr->BaseAddress + XEM_MGTCR_OFFSET);
-	if (MiiControl & XEM_MGTCR_START_MASK) {
-		/* operation in progress */
-		return XST_EMAC_MII_BUSY;
-	}
-
-	/*
-	 * Set up the MII data register first.  Write the 16-bit input
-	 * value to the 32-bit data register.
-	 */
-	XIo_Out32(InstancePtr->BaseAddress + XEM_MGTDR_OFFSET, (u32) PhyData);
-
-	/*
-	 * Now set up the MII control register.  We set up a control
-	 * word with the PHY address and register number, then indicate
-	 * the direction (write), then start the operation.
-	 */
-	MiiControl = PhyAddress << XEM_MGTCR_PHY_ADDR_SHIFT;
-	MiiControl |= (RegisterNum << XEM_MGTCR_REG_ADDR_SHIFT);
-	MiiControl |= (XEM_MGTCR_START_MASK | XEM_MGTCR_MII_ENABLE_MASK);
-
-	XIo_Out32(InstancePtr->BaseAddress + XEM_MGTCR_OFFSET, MiiControl);
-
-	/*
-	 * Wait for the operation to complete
-	 */
-	do {
-		MiiControl =
-			XIo_In32(InstancePtr->BaseAddress + XEM_MGTCR_OFFSET);
-	}
-	while (MiiControl & XEM_MGTCR_START_MASK);
-
-	/*
-	 * There is no status indicating whether the operation was
-	 * successful or not.
-	 */
-	return XST_SUCCESS;
-}
diff --git a/drivers/net/ethernet/xilinx/xilinx_temac/Makefile b/drivers/net/ethernet/xilinx/xilinx_temac/Makefile
deleted file mode 100644
index 08669c1..0000000
--- a/drivers/net/ethernet/xilinx/xilinx_temac/Makefile
+++ /dev/null
@@ -1,19 +0,0 @@
-#
-# Makefile for the Xilinx Tri-mode ethernet driver
-#
-
-EXTRA_CFLAGS		+= -Idrivers/xilinx_common -Iarch/ppc/platforms/4xx/xparameters
-#ifeq ($(CONFIG_PPC32),y)
-#EXTRA_CFLAGS		+= -I$(TOPDIR)/arch/ppc/platforms/xilinx_ocp
-#endif
-
-# The Linux version for the Xilinx driver code.
-xilinx_temac-objs	:= xtemac_linux.o
-
-# The Xilinx OS independent code.
-xilinx_temac-objs	+= xtemac.o xtemac_fifo.o xtemac_intr.o \
-			   xtemac_intr_sgdma.o xtemac_sgdma.o \
-			   xtemac_control.o xtemac_intr_fifo.o \
-			   xtemac_l.o xtemac_selftest.o xtemac_stats.o
-
-obj-$(CONFIG_XILINX_TEMAC) := xilinx_temac.o
diff --git a/drivers/net/ethernet/xilinx/xilinx_temac/xtemac.c b/drivers/net/ethernet/xilinx/xilinx_temac/xtemac.c
deleted file mode 100644
index ba8e33a..0000000
--- a/drivers/net/ethernet/xilinx/xilinx_temac/xtemac.c
+++ /dev/null
@@ -1,464 +0,0 @@
-/* $Id: */
-/******************************************************************************
-*
-*       XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS"
-*       AS A COURTESY TO YOU, SOLELY FOR USE IN DEVELOPING PROGRAMS AND
-*       SOLUTIONS FOR XILINX DEVICES.  BY PROVIDING THIS DESIGN, CODE,
-*       OR INFORMATION AS ONE POSSIBLE IMPLEMENTATION OF THIS FEATURE,
-*       APPLICATION OR STANDARD, XILINX IS MAKING NO REPRESENTATION
-*       THAT THIS IMPLEMENTATION IS FREE FROM ANY CLAIMS OF INFRINGEMENT,
-*       AND YOU ARE RESPONSIBLE FOR OBTAINING ANY RIGHTS YOU MAY REQUIRE
-*       FOR YOUR IMPLEMENTATION.  XILINX EXPRESSLY DISCLAIMS ANY
-*       WARRANTY WHATSOEVER WITH RESPECT TO THE ADEQUACY OF THE
-*       IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OR
-*       REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE FROM CLAIMS OF
-*       INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
-*       FOR A PARTICULAR PURPOSE.
-*
-*       (c) Copyright 2005-2006 Xilinx Inc.
-*       All rights reserved.
-* This program is free software; you can redistribute it and/or modify it
-* under the terms of the GNU General Public License as published by the
-* Free Software Foundation; either version 2 of the License, or (at your
-* option) any later version.
-*
-* You should have received a copy of the GNU General Public License
-* along with this program; if not, write to the Free Software
-* Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-*
-******************************************************************************/
-/*****************************************************************************/
-/**
-*
-* @file xtemac.c
-*
-* The XTemac driver. Functions in this file are the minimum required functions
-* for this driver. See xtemac.h for a detailed description of the driver.
-*
-* <pre>
-* MODIFICATION HISTORY:
-*
-* Ver   Who  Date     Changes
-* ----- ---- -------- -------------------------------------------------------
-* 1.00a rmm  06/01/05 First release
-* 2.00a rmm  11/21/05 Switched to local link DMA driver, removed simple
-*                     DMA code, relocated XTemac_Initialize(),
-*                     XTemac_VmInitialize(), and XTemac_LookupConfig() to
-*                     xtemac_init.c, added XTemac_CfgInitialize().
-* </pre>
-******************************************************************************/
-
-/***************************** Include Files *********************************/
-
-#include <linux/string.h>
-
-#include "xtemac.h"
-#include "xtemac_i.h"
-
-/************************** Constant Definitions *****************************/
-
-
-/**************************** Type Definitions *******************************/
-
-
-/***************** Macros (Inline Functions) Definitions *********************/
-
-
-/************************** Function Prototypes ******************************/
-
-void XTemac_StubHandler(void);	/* Default handler routine */
-static void InitHw(XTemac *InstancePtr);	/* HW reset */
-
-/************************** Variable Definitions *****************************/
-
-
-/*****************************************************************************/
-/**
-* Initialize a specific XTemac instance/driver. The initialization entails:
-* - Initialize fields of the XTemac instance structure
-* - Reset HW and apply default options
-* - Configure the packet FIFOs if present
-* - Configure the DMA channels if present
-*
-* The PHY is setup independently from the TEMAC. Use the MII or whatever other
-* interface may be present for setup.
-*
-* @param InstancePtr is a pointer to the instance to be worked on.
-* @param CfgPtr is the device configuration structure containing required HW
-*        build data.
-* @param VirtualAddress is the base address of the device. If address
-*        translation is not utilized, this parameter can be passed in using
-*        CfgPtr->BaseAddress to specify the physical base address.
-*
-* @return
-* - XST_SUCCESS if initialization was successful
-* - XST_FAILURE if initialization of packet FIFOs or DMA channels failed, or
-*   device operating mode cannot be determined
-*
-******************************************************************************/
-int XTemac_CfgInitialize(XTemac *InstancePtr, XTemac_Config *CfgPtr,
-			 u32 VirtualAddress)
-{
-	int Result;
-
-	/* Verify arguments */
-	XASSERT_NONVOID(InstancePtr != NULL);
-
-	/* Clear instance memory and make copy of configuration */
-	memset(InstancePtr, 0, sizeof(XTemac));
-	memcpy(&InstancePtr->Config, CfgPtr, sizeof(XTemac_Config));
-
-	/* Set device base address */
-	InstancePtr->BaseAddress = VirtualAddress;
-
-	/* Set callbacks to an initial stub routine */
-	InstancePtr->FifoRecvHandler =
-		(XTemac_FifoRecvHandler) XTemac_StubHandler;
-	InstancePtr->FifoSendHandler =
-		(XTemac_FifoSendHandler) XTemac_StubHandler;
-	InstancePtr->ErrorHandler = (XTemac_ErrorHandler) XTemac_StubHandler;
-	InstancePtr->AnegHandler = (XTemac_AnegHandler) XTemac_StubHandler;
-	InstancePtr->SgRecvHandler = (XTemac_SgHandler) XTemac_StubHandler;
-	InstancePtr->SgSendHandler = (XTemac_SgHandler) XTemac_StubHandler;
-
-	/* FIFO mode */
-	if (XTemac_mIsFifo(InstancePtr)) {
-		/* Select best processor based transfer method to/from FIFOs */
-		Result = XTemac_ConfigureFifoAccess(InstancePtr);
-		if (Result != XST_SUCCESS) {
-			return (XST_FAILURE);
-		}
-	}
-
-	/* SGDMA mode */
-	else if (XTemac_mIsSgDma(InstancePtr)) {
-		Result = XDmaV3_Initialize(&InstancePtr->RecvDma,
-					   InstancePtr->BaseAddress +
-					   XTE_DMA_RECV_OFFSET);
-		if (Result != XST_SUCCESS) {
-			return (XST_FAILURE);
-		}
-
-		Result = XDmaV3_Initialize(&InstancePtr->SendDma,
-					   InstancePtr->BaseAddress +
-					   XTE_DMA_SEND_OFFSET);
-		if (Result != XST_SUCCESS) {
-			return (XST_FAILURE);
-		}
-	}
-
-	/* Unknown mode */
-	else {
-		return (XST_FAILURE);
-	}
-
-	/* Reset the hardware and set default options */
-	InstancePtr->IsReady = XCOMPONENT_IS_READY;
-	XTemac_Reset(InstancePtr, XTE_NORESET_HARD);
-
-	return (XST_SUCCESS);
-}
-
-
-/*****************************************************************************/
-/**
-* Start the Ethernet controller as follows:
-*   - Enable transmitter if XTE_TRANSMIT_ENABLE_OPTION is set
-*   - Enable receiver if XTE_RECEIVER_ENABLE_OPTION is set
-*   - If not polled mode, then start the SG DMA send and receive channels (if
-*     configured) and enable the global device interrupt
-*
-* If starting for the first time after calling XTemac_Initialize() or
-* XTemac_Reset(), send and receive interrupts will not be generated until
-* XTemac_IntrFifoEnable() or XTemac_IntrSgEnable() are called. Otherwise,
-* interrupt settings made by these functions will be restored.
-*
-* @param InstancePtr is a pointer to the instance to be worked on.
-*
-* @return
-* - XST_SUCCESS if the device was started successfully
-* - XST_DMA_SG_NO_LIST if configured for scatter-gather DMA and a descriptor
-*   list has not yet been created for the send or receive channel
-*
-* @note
-* The driver tries to match the hardware configuration. So if the hardware
-* is configured with scatter-gather DMA, the driver expects to start the
-* scatter-gather channels and expects that the user has previously set up
-* the buffer descriptor lists.
-*
-* This function makes use of internal resources that are shared between the
-* Start, Stop, and Set/ClearOptions functions. So if one task might be setting
-* device options while another is trying to start the device, the user is
-* required to provide protection of this shared data (typically using a
-* semaphore).
-*
-* This function must not be preempted by an interrupt that may service the
-* device.
-*
-******************************************************************************/
-int XTemac_Start(XTemac *InstancePtr)
-{
-	u32 Reg;
-	int Result;
-
-	/* Assert bad arguments and conditions */
-	XASSERT_NONVOID(InstancePtr != NULL);
-	XASSERT_NONVOID(InstancePtr->IsReady == XCOMPONENT_IS_READY);
-
-	/* If already started, then there is nothing to do */
-	if (InstancePtr->IsStarted == XCOMPONENT_IS_STARTED) {
-		return (XST_SUCCESS);
-	}
-
-	/* Start SG DMA */
-	if (XTemac_mIsSgDma(InstancePtr)) {
-		/* When starting the DMA channels, both transmit and receive sides
-		 * need an initialized BD list.
-		 */
-		Result = XDmaV3_SgStart(&InstancePtr->RecvDma);
-		if (Result == XST_DMA_SG_NO_LIST) {
-			return (Result);
-		}
-
-		Result = XDmaV3_SgStart(&InstancePtr->SendDma);
-		if (Result == XST_DMA_SG_NO_LIST) {
-			return (Result);
-		}
-	}
-
-	/* Enable transmitter if not already enabled */
-	if (InstancePtr->Options & XTE_TRANSMITTER_ENABLE_OPTION) {
-		Reg = XTemac_mGetHostReg(XTE_TXC_OFFSET);
-		if (!(Reg & XTE_TXC_TXEN_MASK)) {
-			XTemac_mSetHostReg(XTE_TXC_OFFSET,
-					   Reg | XTE_TXC_TXEN_MASK);
-		}
-	}
-
-	/* Enable receiver? */
-	if (InstancePtr->Options & XTE_RECEIVER_ENABLE_OPTION) {
-		Reg = XTemac_mGetHostReg(XTE_RXC1_OFFSET) | XTE_RXC1_RXEN_MASK;
-		XTemac_mSetHostReg(XTE_RXC1_OFFSET, Reg);
-	}
-
-	/* Mark as started */
-	InstancePtr->IsStarted = XCOMPONENT_IS_STARTED;
-
-	/* Allow interrupts (if not in polled mode) and exit */
-	if ((InstancePtr->Options & XTE_POLLED_OPTION) == 0) {
-		XTemac_mSetIpifReg(XTE_DGIE_OFFSET, XTE_DGIE_ENABLE_MASK);
-	}
-
-	return (XST_SUCCESS);
-}
-
-/*****************************************************************************/
-/**
-* Gracefully stop the Ethernet MAC as follows:
-*   - Disable all interrupts from this device
-*   - Stop DMA channels (if configured)
-*   - Disable the receiver
-*
-* Device options currently in effect are not changed.
-*
-* This function will disable all interrupts by clearing the global interrupt
-* enable. Any interrupts settings that had been enabled through
-* XTemac_IntrFifoEnable(), XTemac_IntrFifoDmaEnable(), or
-* XTemac_IntrSgEnable() will be restored when XTemac_Start() is called.
-*
-* Since the transmitter is not disabled, frames currently in the packet FIFO
-* or in process by the SGDMA engine are allowed to be transmitted. XTemac API
-* functions that place new data in the packet FIFOs will not be allowed to do
-* so until XTemac_Start() is called.
-*
-* @param InstancePtr is a pointer to the instance to be worked on.
-*
-* @note
-* This function makes use of internal resources that are shared between the
-* Start, Stop, SetOptions, and ClearOptions functions. So if one task might be
-* setting device options while another is trying to start the device, the user
-* is required to provide protection of this shared data (typically using a
-* semaphore).
-*
-* Stopping the DMA channels may cause this function to block until the DMA
-* operation is complete. This function will not block waiting for frame data to
-* to exit the packet FIFO to the transmitter.
-*
-******************************************************************************/
-void XTemac_Stop(XTemac *InstancePtr)
-{
-	volatile u32 Reg;
-
-	XASSERT_VOID(InstancePtr != NULL);
-	XASSERT_VOID(InstancePtr->IsReady == XCOMPONENT_IS_READY);
-
-	/* If already stopped, then there is nothing to do */
-	if (InstancePtr->IsStarted == 0) {
-		return;
-	}
-
-	/* Disable interrupts */
-	XTemac_mSetIpifReg(XTE_DGIE_OFFSET, 0);
-
-	/* For SGDMA, use the DMA driver function to stop the channels */
-	if (XTemac_mIsSgDma(InstancePtr)) {
-		(void) XDmaV3_SgStop(&InstancePtr->SendDma);
-		(void) XDmaV3_SgStop(&InstancePtr->RecvDma);
-	}
-
-	/* Disable the receiver */
-	Reg = XTemac_mGetHostReg(XTE_RXC1_OFFSET);
-	Reg &= ~XTE_RXC1_RXEN_MASK;
-	XTemac_mSetHostReg(XTE_RXC1_OFFSET, Reg);
-
-	/* Stopping the receiver in mid-packet causes a dropped packet indication
-	 * from HW. Clear it.
-	 */
-	Reg = XTemac_mGetIpifReg(XTE_IPISR_OFFSET);
-	if (Reg & XTE_IPXR_RECV_REJECT_MASK) {
-		XTemac_mSetIpifReg(XTE_IPISR_OFFSET, XTE_IPXR_RECV_REJECT_MASK);
-	}
-
-	/* Mark as stopped */
-	InstancePtr->IsStarted = 0;
-}
-
-
-/*****************************************************************************/
-/**
-* Perform a graceful reset of the Ethernet MAC. Resets the DMA channels, the
-* FIFOs, the transmitter, and the receiver.
-*
-* All options are placed in their default state. Any frames in the scatter-
-* gather descriptor lists will remain in the lists. The side effect of doing
-* this is that after a reset and following a restart of the device, frames that
-* were in the list before the reset may be transmitted or received.
-*
-* The upper layer software is responsible for re-configuring (if necessary)
-* and restarting the MAC after the reset. Note also that driver statistics
-* are not cleared on reset. It is up to the upper layer software to clear the
-* statistics if needed.
-*
-* When a reset is required due to an internal error, the driver notifies the
-* upper layer software of this need through the ErrorHandler callback and
-* specific status codes.  The upper layer software is responsible for calling
-* this Reset function and then re-configuring the device.
-*
-* Resetting the IPIF should suffice in most circumstances. As a last resort
-* however, the hard TEMAC core can be reset as well using the HardCoreAction
-* parameter. In systems with two TEMACs, the reset signal is shared between
-* both devices resulting in BOTH being reset. This requires the user save the
-* state of both TEMAC's prior to resetting the hard core on either device
-* instance.
-
-* @param InstancePtr is a pointer to the instance to be worked on.
-* @param HardCoreAction describes how the hard core part of the TEMAC should
-*        be managed. If XTE_RESET_HARD is passed in, then the reset signal is
-*        asserted to the hard core block. This will reset both hard cores.
-*        If any other value is passed in, then only the IPIF of the given
-*        instance is reset.
-*
-******************************************************************************/
-void XTemac_Reset(XTemac *InstancePtr, int HardCoreAction)
-{
-	u32 Data;
-
-	XASSERT_VOID(InstancePtr != NULL);
-	XASSERT_VOID(InstancePtr->IsReady == XCOMPONENT_IS_READY);
-
-	/* Stop the device and reset HW */
-	XTemac_Stop(InstancePtr);
-	InstancePtr->Options = XTE_DEFAULT_OPTIONS;
-
-	/* Reset IPIF */
-	XTemac_mSetIpifReg(XTE_DSR_OFFSET, XTE_DSR_RESET_MASK);
-	udelay(XTE_RESET_IPIF_DELAY_US);
-
-	/* Reset hard core if required */
-	if (HardCoreAction == XTE_RESET_HARD) {
-		Data = XTemac_mGetIpifReg(XTE_CR_OFFSET);
-		XTemac_mSetIpifReg(XTE_CR_OFFSET, Data | XTE_CR_HRST_MASK);
-		udelay(XTE_RESET_HARD_DELAY_US);
-	}
-
-	/* Setup HW */
-	InitHw(InstancePtr);
-}
-
-
-/******************************************************************************
- * Perform one-time setup of HW. The setups performed here only need to occur
- * once after any reset.
- *
- * @param InstancePtr is a pointer to the instance to be worked on.
- *
- ******************************************************************************/
-static void InitHw(XTemac *InstancePtr)
-{
-	u32 Reg;
-
-	/* Disable the receiver */
-	Reg = XTemac_mGetHostReg(XTE_RXC1_OFFSET);
-	Reg &= ~XTE_RXC1_RXEN_MASK;
-	XTemac_mSetHostReg(XTE_RXC1_OFFSET, Reg);
-
-	/* Stopping the receiver in mid-packet causes a dropped packet indication
-	 * from HW. Clear it.
-	 */
-	Reg = XTemac_mGetIpifReg(XTE_IPISR_OFFSET);
-	if (Reg & XTE_IPXR_RECV_REJECT_MASK) {
-		XTemac_mSetIpifReg(XTE_IPISR_OFFSET, XTE_IPXR_RECV_REJECT_MASK);
-	}
-
-	/* Default IPIF interrupt block enable mask */
-	Reg = (XTE_DXR_CORE_MASK | XTE_DXR_DPTO_MASK | XTE_DXR_TERR_MASK);
-
-	if (XTemac_mIsFifo(InstancePtr)) {
-		Reg |= (XTE_DXR_RECV_FIFO_MASK | XTE_DXR_SEND_FIFO_MASK);
-	}
-
-	XTemac_mSetIpifReg(XTE_DIER_OFFSET, Reg);
-
-	if (XTemac_mIsSgDma(InstancePtr)) {
-		/* Setup SGDMA interupt coalescing defaults */
-		(void) XTemac_IntrSgCoalSet(InstancePtr, XTE_SEND,
-					    XTE_SGDMA_DFT_THRESHOLD,
-					    XTE_SGDMA_DFT_WAITBOUND);
-		(void) XTemac_IntrSgCoalSet(InstancePtr, XTE_RECV,
-					    XTE_SGDMA_DFT_THRESHOLD,
-					    XTE_SGDMA_DFT_WAITBOUND);
-
-		/* Setup interrupt enable data for each channel */
-		Reg = (XDMAV3_IPXR_PCTR_MASK |
-		       XDMAV3_IPXR_PWBR_MASK | XDMAV3_IPXR_DE_MASK);
-
-		XDmaV3_SetInterruptEnable(&InstancePtr->SendDma, Reg);
-		XDmaV3_SetInterruptEnable(&InstancePtr->RecvDma, Reg);
-	}
-
-	/* Sync default options with HW but leave receiver and transmitter
-	 * disabled. They get enabled with XTemac_Start() if XTE_TRANSMITTER_ENABLE-
-	 * _OPTION and XTE_RECEIVER_ENABLE_OPTION are set
-	 */
-	XTemac_SetOptions(InstancePtr, InstancePtr->Options &
-			  ~(XTE_TRANSMITTER_ENABLE_OPTION |
-			    XTE_RECEIVER_ENABLE_OPTION));
-
-	XTemac_ClearOptions(InstancePtr, ~InstancePtr->Options);
-
-	/* Set default MDIO divisor */
-	XTemac_PhySetMdioDivisor(InstancePtr, XTE_MDIO_DIV_DFT);
-}
-
-/******************************************************************************/
-/**
- * This is a stub for the asynchronous callbacks. The stub is here in case the
- * upper layer forgot to set the handler(s). On initialization, all handlers are
- * set to this callback. It is considered an error for this handler to be
- * invoked.
- *
- ******************************************************************************/
-void XTemac_StubHandler(void)
-{
-	XASSERT_VOID_ALWAYS();
-}
diff --git a/drivers/net/ethernet/xilinx/xilinx_temac/xtemac.h b/drivers/net/ethernet/xilinx/xilinx_temac/xtemac.h
deleted file mode 100644
index 0656fc2..0000000
--- a/drivers/net/ethernet/xilinx/xilinx_temac/xtemac.h
+++ /dev/null
@@ -1,1459 +0,0 @@
-/* $Id: */
-/******************************************************************************
-*
-*       XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS"
-*       AS A COURTESY TO YOU, SOLELY FOR USE IN DEVELOPING PROGRAMS AND
-*       SOLUTIONS FOR XILINX DEVICES.  BY PROVIDING THIS DESIGN, CODE,
-*       OR INFORMATION AS ONE POSSIBLE IMPLEMENTATION OF THIS FEATURE,
-*       APPLICATION OR STANDARD, XILINX IS MAKING NO REPRESENTATION
-*       THAT THIS IMPLEMENTATION IS FREE FROM ANY CLAIMS OF INFRINGEMENT,
-*       AND YOU ARE RESPONSIBLE FOR OBTAINING ANY RIGHTS YOU MAY REQUIRE
-*       FOR YOUR IMPLEMENTATION.  XILINX EXPRESSLY DISCLAIMS ANY
-*       WARRANTY WHATSOEVER WITH RESPECT TO THE ADEQUACY OF THE
-*       IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OR
-*       REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE FROM CLAIMS OF
-*       INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
-*       FOR A PARTICULAR PURPOSE.
-*
-*       (c) Copyright 2005-2006 Xilinx Inc.
-*       All rights reserved.
-* This program is free software; you can redistribute it and/or modify it
-* under the terms of the GNU General Public License as published by the
-* Free Software Foundation; either version 2 of the License, or (at your
-* option) any later version.
-*
-* You should have received a copy of the GNU General Public License
-* along with this program; if not, write to the Free Software
-* Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-*
-******************************************************************************/
-/*****************************************************************************/
-/**
- *
- * @file xtemac.h
- *
- * The Xilinx Tri-Mode Ethernet driver component. This driver supports the
- * Virtex-4(TM) 10/100/1000 MAC (TEMAC).
- *
- * For a full description of TEMAC features, please see the HW spec. This driver
- * supports the following features:
- *   - Memory mapped access to host interface registers
- *   - API for polled frame transfers (FIFO direct HW configuration only)
- *   - API for interrupt driven frame transfers for HW configured with FIFO
- *     direct, or Scatter Gather DMA
- *   - Virtual memory support
- *   - Unicast, broadcast, and multicast receive address filtering
- *   - Full duplex operation (half duplex not supported)
- *   - Automatic source address insertion or overwrite (programmable)
- *   - Automatic PAD & FCS insertion and stripping (programmable)
- *   - Flow control
- *   - VLAN frame support
- *   - Pause frame support
- *   - Jumbo frame support
- *   - Data Realignment Engine (DRE)
- *   - Checksum offload
- *
- * <b>Driver Description</b>
- *
- * The device driver enables higher layer software (e.g., an application) to
- * communicate to the TEMAC. The driver handles transmission and reception of
- * Ethernet frames, as well as configuration and control. No pre or post
- * processing of frame data is performed. The driver does not validate the
- * contents of an incoming frame in addition to what has already occurred in HW.
- * A single device driver can support multiple devices even when those devices
- * have significantly different configurations.
- *
- * <b>Initialization & Configuration</b>
- *
- * The XTemac_Config structure is used by the driver to configure itself. This
- * configuration structure is typically created by the tool-chain based on HW
- * build properties.
- *
- * To support multiple runtime loading and initialization strategies employed
- * by various operating systems, the driver instance can be initialized in one
- * of the following ways:
- *
- *   - XTemac_Initialize(InstancePtr, DeviceId): The driver looks up its own
- *     configuration structure created by the tool-chain based on an ID provided
- *     by the tool-chain.
- *
- *   - XTemac_VmInitialize(InstancePtr, DeviceId, VirtualAddress): Operates
- *     like XTemac_Initialize() except the physical base address found in the
- *     configuration structure is replaced with the provided virtual address
- *
- *   - XTemac_CfgInitialize(InstancePtr, CfgPtr, VirtualAddress):  Uses a
- *     configuration structure provided by the caller. If running in a system
- *     with address translation, the provided virtual memory base address
- *     replaces the physical address present in the configuration structure.
- *
- * The device can be configured for 2 major modes of operation: FIFO direct,
- * or scatter gather DMA (SGDMA). Each of these modes are independent of one
- * another and have their own frame transfer API. This driver can manage an
- * arbitrary number of devices each with its own operating mode and supporting
- * features and options.
- *
- * The driver tries to use the features built into the device as described
- * by the configuration structure. So if the hardware is configured with
- * SGDMA, the driver expects to start the SGDMA channels and expects that
- * the user has set up the buffer descriptor lists.
- *
- * <b>Interrupts and Asynchronous Callbacks</b>
- *
- * The driver has no dependencies on the interrupt controller. It provides
- * one interrupt handler per mode of operation (FIFO, SGDMA) that can be
- * connected to the system interrupt controller by BSP/OS specific means.
- *
- * When an interrupt occurs, the handler will perform a small amount of
- * housekeeping work, determine the source of the interrupt, and call the
- * appropriate callback function. All callbacks are registered by the user
- * level application.
- *
- * SGDMA implements interrupt coalescing features that reduce the frequency
- * of interrupts. A more complete discussion of this feature occurs in the API
- * section below.
- *
- * <b>Device Reset</b>
- *
- * Some errors that can occur require a device reset. These errors are listed
- * in the XTemac_ErrorHandler() function typedef header. The user's error
- * callback handler is responsible for resetting and re-configuring the device.
- * When a device reset is required, XTemac_Reset() should be utilized.
- *
- * <b>Virtual Memory</b>
- *
- * This driver may be used in systems with virtual memory support by using one
- * of the initialization functions that supply the virtual memory address of
- * the device.
- *
- * All virtual to physical memory mappings must occur prior to accessing the
- * driver API. The driver does not support multiple virtual memory translations
- * that map to the same physical address.
- *
- * For DMA transactions, user buffers supplied to the driver must be in terms
- * of their physical address.
- *
- * <b>Transfer Mode APIs</b>
- *
- * Using the proper API depends on how the HW has been configured. There are
- * two interrupt driven modes (FIFO Direct, and SGDMA). FIFO Direct also
- * supports a polled mode of operation.
- *
- * It is the user's responsibilty to use the API that matches the device
- * configuration. Most API functions do not perform runtime checks to verify
- * proper configuration. If an API function is called in error on a device
- * instance, then that function may attempt to access registers that are not
- * present resulting in bus errors and/or corrupted data. Macros are defined
- * that help the user determine which API can be used.
- *
- * All API functions are prototyped in xtemac.h and are implemented in various
- * xtemac_*.c files by feature.
- *
- * The following sections discuss in more detail each of the available APIs.
- *
- * <b>FIFO Direct API</b>
- *
- * This device mode utilizes the processor to transfer data between user buffers
- * and the packet FIFOs. HW configured in this way uses the least amount of FPGA
- * resources but provides the lowest data throughput.
- *
- * This API allows user independent access to the data packet, packet length,
- * and event FIFOs. While more sophisticated device modes keep these FIFOs
- * in sync automatically, the user has the primary responsibility in FIFO
- * direct mode.
- *
- * The packet FIFOs contain the frame data while the length/status FIFOs contain
- * receive lengths, transmit lengths, and transmit statuses. When these FIFOs
- * go out of sync, then packet data will become corrupted.
- *
- * On the transmit side, the transmit packet FIFO may contain more than one
- * Ethernet packet placed there by XTemac_FifoWrite(). The number of packets it
- * may contain depends on its depth which is controlled at HW build time. For
- * each packet in the FIFO, the user must initiate a transmit by writing into
- * the transmit length FIFO (see XTemac_FifoSend()). The number of bytes
- * specified to transmit must match exactly the lengths of packets in the
- * packet FIFO. For example, if a 76 byte packet was written followed by a
- * 124 byte packet, then the transmit length FIFO must be written with 76
- * followed by 124. At the completion of the transmission, the transmit status
- * FIFO must be read to obtain the outcome of the operation. The first status
- * will be for the 76 byte packet followed by the 124 byte packet.
- *
- * If there is not enough data in the packet FIFO to complete a transmit
- * operation, an underrun condition will be reported. The frame that gets
- * transmitted in this case is forced to a corrupted state so that it
- * will flagged as invalid by other receivers.
- *
- * On the receive side, it is a little easier to keep things in sync because
- * the HW writes to the receive packet FIFO. Just like the transmit packet FIFO,
- * the receive packet FIFO can contain more than one received Ethernet frame.
- * Each time a length is extracted from the receive length FIFO (see
- * XTemac_FifoRecv()), then that many bytes must be read from the receive
- * packet FIFO by XTemac_FifoRead().
- *
- * The easiest way to keep these FIFOs in sync is to process a single frame at
- * a time. But when performance is an issue, it may be desirable to process
- * multiple or even partial frames from non-contiguous memory regions. The
- * examples that accompany this driver illustrate how these advanced frame
- * processing methods can be implemented.
- *
- * In interrupt driven mode, user callbacks are invoked by the interrupt handler
- * to signal that frames have arrived, frames have been transmitted, or an
- * error has occurred. When the XTE_POLLED_OPTION is set, the user must use
- * send and receive query status functions to determine when these events
- * occur.
- *
- * <b>SGDMA API</b>
- *
- * This API utilizes scatter-gather DMA (SGDMA) channels to transfer frame data
- * between user buffers and the packet FIFOs.
- *
- * The SGDMA engine uses buffer descriptors (BDs) to describe Ethernet frames.
- * These BDs are typically chained together into a list the HW follows when
- * transferring data in and out of the packet FIFOs. Each BD describes a memory
- * region containing either a full or partial Ethernet packet.
- *
- * The frequency of interrupts can be controlled with the interrupt coalescing
- * features of the SG DMA engine. These features can be used to optimize
- * interrupt latency and throughput for the user's network traffic conditions.
- * The packet threshold count will delay processor interrupts until a
- * programmable number of packets have arrived or have been transmitted. The
- * packet wait bound timer can be used to cause a processor interrupt even though
- * the packet threshold has not been reached. The timer begins counting after the
- * last packet is processed. If no other packet is processed as the timer
- * expires, then an interrupt will be generated.
- *
- * Another form of interrupt control is provided with the XTE_SGEND_INT_OPTION
- * option. When enabled, an interrupt will occur when SGDMA engine completes the
- * last BD to be processed and transitions to an idle state. This feature may be
- * useful when a set of BDs have been queued up and the user only wants to be
- * notified when they have all been processed by the HW. To use this feature
- * effectively, interrupt coalescing should be disabled (packet threshold = 0,
- * wait bound timer = 0), or the packet threshold should be set to a number
- * larger than the number of packets queued up.
- *
- * By default, the driver will set the packet threshold = 1, wait bound timer =
- * 0, and disable the XTE_SGEND_INT_OPTION. These settings will cause one
- * interrupt per packet.
- *
- * This API requires the user to understand the how the SGDMA driver operates.
- * The following paragraphs provide some explanation, but the user is encouraged
- * to read documentation in xdmav3.h and xdmabdv3.h as well as study example code
- * that accompanies this driver.
- *
- * The API is designed to get BDs to and from the SGDMA engine in the most
- * efficient means possible. The first step is to establish a  memory region to
- * contain all BDs for a specific channel. This is done with XTemac_SgSetSpace()
- * and assumes the memory region is non-cached. This function sets up a BD ring
- * that HW will follow as BDs are processed. The ring will consist of a user
- * defined number of BDs which will all be partially initialized. For example on
- * the transmit channel, the driver will initialize all BDs' so that they are
- * configured for transmit. The more fields that can be permanently setup at
- * initialization, then the fewer accesses will be needed to each BD while the
- * SGDMA engine is in operation resulting in better throughput and CPU
- * utilization. The best case initialization would require the user to set only
- * a frame buffer address and length prior to submitting the BD to the engine.
- *
- * BDs move through the engine with the help of functions XTemac_SgAlloc(),
- * XTemac_SgCommit(), XTemac_SgGetProcessed(), and XTemac_SgFree(). All these
- * functions handle BDs that are in place. That is, there are no copies of BDs
- * kept anywhere and any BD the user interacts with is an actual BD from the
- * same ring HW accesses. Changing fields within BDs is done through an API
- * defined in xdmabdv3.h as well as checksum offloading macros defined in
- * xtemac.h.
- *
- * BDs in the ring go through a series of states as follows:
- *   1. Idle. The driver controls BDs in this state.
- *   2. The user has data to transfer. XTemac_SgAlloc() is called to reserve
- *      BD(s). Once allocated, the user may setup the BD(s) with frame buffer
- *      address, length, and other attributes. The user controls BDs in this
- *      state.
- *   3. The user submits BDs to the SGDMA engine with XTemac_SgCommit. BDs in
- *      this state are either waiting to be processed by HW, are in process, or
- *      have been processed. The SGDMA engine controls BDs in this state.
- *   4. Processed BDs are retrieved with XTemac_SgGetProcessed() by the
- *      user. Once retrieved, the user can examine each BD for the outcome of
- *      the DMA transfer. The user controls BDs in this state. After examining
- *      the BDs the user calls XTemac_SgFree() which places the BDs back into
- *      state 1.
- *
- * Each of the four BD accessor functions operate on a set of BDs. A set is
- * defined as a segment of the BD ring consisting of one or more BDs.  The user
- * views the set as a pointer to the first BD along with the number of BDs for
- * that set. The set can be navigated by using macros XTemac_mSgRecvBdNext() or
- * XTemac_mSgSendBdNext(). The user must exercise extreme caution when changing
- * BDs in a set as there is nothing to prevent doing a mSgRecvBdNext past the
- * end of the set and modifying a BD out of bounds.
- *
- * XTemac_SgAlloc() + XTemac_SgCommit(), as well as XTemac_SgGetProcessed() +
- * XTemac_SgFree() are designed to be used in tandem. The same BD set retrieved
- * with SgAlloc should be the same one provided to HW with SgCommit. Same goes
- * with SgGetProcessed and SgFree.
- *
- * <b>SG DMA Troubleshooting</b>
- *
- * To verify internal structures of BDs and the BD ring, the function
- * XTemac_SgCheck() is provided. This function should be used as a debugging
- * or diagnostic tool. If it returns a failure, the user must perform more
- * in depth debugging to find the root cause.
- *
- * To avoid problems, do not use the following BD macros for transmit channel
- * BDs (XTE_SEND):
- *
- *   - XDmaBdV3_mClear()
- *   - XDmaBdV3_mSetRxDir()
- *
- * and for receive channel BDs (XTE_RECV):
- *
- *   - XDmaBdV3_mClear()
- *   - XDmaBdV3_mSetTxDir()
- *
- * <b>Alignment & Data Cache Restrictions</b>
- *
- * FIFO Direct:
- *
- *   - No frame buffer alignment restrictions for Tx or Rx
- *   - Buffers not aligned on a 4-byte boundary will take longer to process
- *     as the driver uses a small transfer buffer to realign them prior to
- *     packet FIFO access
- *   - Frame buffers may be in cached memory
- *
- * SGDMA Tx with DRE:
- *
- *   - No frame buffer alignment restrictions
- *   - If frame buffers exist in cached memory, then they must be flushed prior
- *     to committing them to HW
- *   - Descriptors must be 4-byte aligned
- *   - Descriptors must be in non-cached memory
- *
- * SGDMA Tx without DRE:
- *
- *   - Frame buffers must be 8-byte aligned
- *   - If frame buffers exist in cached memory, then they must be flushed prior
- *     to committing them to HW
- *   - Descriptors must be 4-byte aligned
- *   - Descriptors must be in non-cached memory
- *
- * SGDMA Rx with DRE:
- *
- *   - No frame buffer alignment restrictions
- *   - If frame buffers exist in cached memory, then the cache must be
- *     invalidated for the memory region containing the frame prior to data
- *     access
- *   - Descriptors must be 4-byte aligned
- *   - Descriptors must be in non-cached memory
- *
- * SGDMA Rx without DRE:
- *
- *   - Frame buffers must be 8-byte aligned
- *   - If frame buffers exist in cached memory, then the cache must be
- *     invalidated for the memory region containing the frame prior to data
- *     access
- *   - Descriptors must be 4-byte aligned
- *   - Descriptors must be in non-cached memory
- *
- * <b>Buffer Copying</b>
- *
- * The driver is designed for a zero-copy buffer scheme. That is, the driver will
- * not copy buffers. This avoids potential throughput bottlenecks within the
- * driver.
- *
- * The only exception to this is when buffers are passed to XTemac_FifoRead() and
- * XTemac_FifoWrite() on 1, 2, or 3 byte alignments. These buffers will be byte
- * copied into a small holding area on their way to or from the packet FIFOs.
- * For PLB TEMAC this holding area is 8 bytes each way. If byte copying is
- * required, then the transfer will take longer to complete.
- *
- * <b>Checksum Offloading</b>
- *
- * If configured, the device can compute a 16-bit checksum from frame data. In
- * most circumstances this can lead to a substantial gain in throughput.
- *
- * For Tx, the SW can specify where in the frame the checksum calculation is
- * to start, where it should be inserted, and a seed value. The checksum is
- * calculated from the start point through the end of frame. For Rx, the 15th
- * byte to end of frame is checksummed. This is the entire Ethernet payload
- * for non-VLAN frames.
- *
- * Setting up and accessing checksum data is done with XTemac API macro calls
- * on buffer descriptors on a per-frame basis.
- *
- * Since this HW implementation is general purpose in nature system SW must
- * perform pre and post frame processing to obtain the desired results for the
- * types of packets being transferred. Most of the time this will be TCP/IP
- * traffic.
- *
- * TCP/IP and UDP/IP frames contain separate checksums for the IP header and
- * UDP/TCP header+data. With this HW implementation, the IP header checksum
- * cannot be offloaded. Many stacks that support offloading will compute the IP
- * header if required and use HW to compute the UDP/TCP header+data checksum.
- * There are other complications concerning the IP pseudo header that must be
- * taken into consideration. Readers should consult a TCP/IP design reference
- * for more details.
- *
- * There are certain device options that will affect the checksum calculation
- * performed by HW for Tx:
- *
- *   - FCS insertion disabled (XTE_FCS_INSERT_OPTION): SW is required to
- *     calculate and insert the FCS value at the end of the frame, but the
- *     checksum must be known ahead of time prior to calculating the FCS.
- *     Therefore checksum offloading cannot be used in this situation.
- *
- * And for Rx:
- *
- *   - FCS/PAD stripping disabled (XTE_FCS_STRIP_OPTION): The 4 byte FCS at the
- *     end of frame will be included in the HW calculated checksum. SW must
- *     subtract out this data.
- *
- *   - FCS/PAD stripping disabled (XTE_FCS_STRIP_OPTION): For frames smaller
- *     than 64 bytes, padding will be included in the HW calculated checksum.
- *     SW must subtract out this data. It may be better to allow the TCP/IP
- *     stack verify checksums for this type of packet.
- *
- *   - VLAN enabled (XTE_VLAN_OPTION): The 4 extra bytes in the Ethernet header
- *     affect the HW calculated checksum. SW must subtract out the 1st two
- *     16-bit words starting at the 15th byte.
- *
- * <b>PHY Communication</b>
- *
- * Prior to PHY access, the MDIO clock must be setup. This driver will set a
- * safe default that should work with PLB bus speeds of up to 150 MHz and keep
- * the MDIO clock below 2.5 MHz. If the user wishes faster access to the PHY
- * then the clock divisor can be set to a different value (see
- * XTemac_PhySetMdioDivisor()).
- *
- * MII register access is performed through the functions XTemac_PhyRead() and
- * XTemac_PhyWrite().
- *
- * <b>Link Sync</b>
- *
- * When the device is used in a multispeed environment, the link speed must be
- * explicitly set using XTemac_SetOperatingSpeed() and must match the speed the
- * PHY has negotiated. If the speeds are mismatched, then the MAC will not pass
- * traffic.
- *
- * Using the XTE_ANEG_OPTION and the provided callback handler, SW can be
- * notified when the PHY has completed auto-negotiation.
- *
- * <b>Asserts</b>
- *
- * Asserts are used within all Xilinx drivers to enforce constraints on argument
- * values. Asserts can be turned off on a system-wide basis by defining, at
- * compile time, the NDEBUG identifier. By default, asserts are turned on and it
- * is recommended that users leave asserts on during development. For deployment
- * use -DNDEBUG compiler switch to remove assert code.
- *
- * <b>Driver Errata</b>
- *
- *   - A dropped receive frame indication may be reported by the driver after
- *     calling XTemac_Stop() followed by XTemac_Start(). This can occur if a
- *     frame is arriving when stop is called.
- *   - On Rx with checksum offloading enabled and FCS/PAD stripping disabled,
- *     FCS and PAD data will be included in the checksum result.
- *   - On Tx with checksum offloading enabled and auto FCS insertion disabled,
- *     the user calculated FCS will be included in the checksum result.
- *
- * @note
- *
- * Xilinx drivers are typically composed of two components, one is the driver
- * and the other is the adapter.  The driver is independent of OS and processor
- * and is intended to be highly portable.  The adapter is OS-specific and
- * facilitates communication between the driver and an OS.
- * <br><br>
- * This driver is intended to be RTOS and processor independent. Any needs for
- * dynamic memory management, threads or thread mutual exclusion, or cache
- * control must be satisfied by the layer above this driver.
- *
- * <pre>
- * MODIFICATION HISTORY:
- *
- * Ver   Who  Date     Changes
- * ----- ---- -------- -------------------------------------------------------
- * 1.00a rmm  06/01/05 First release
- * 1.00b rmm  09/23/05 Replaced XTemac_GetPhysicalInterface() with macro
- *                     XTemac_mGetPhysicalInterface(). Implemented
- *                     XTemac_PhyRead/Write() functions. Redesigned MII/RGMII/
- *                     SGMII status functions. Renamed most of the host
- *                     registers to reflect latest changes in HW spec, added
- *                     XST_FIFO_ERROR return code to polled FIFO query
- *                     functions.
- * 2.00a rmm  11/21/05 Switched to local link DMA driver, removed simple-DMA
- *                     mode, added auto-negotiation callback, added checksum
- *                     offload access macros, removed XST_SEND_ERROR error
- *                     class completely since TSR bits went away, removed
- *                     XST_FAILURE return code for XTemac_FifoQuerySendStatus(),
- *                     added static init feature, changed XTE_FCS_STRIP_OPTION
- *                     to default to set.
- * </pre>
- *
- *****************************************************************************/
-
-#ifndef XTEMAC_H		/* prevent circular inclusions */
-#define XTEMAC_H		/* by using protection macros */
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-/***************************** Include Files *********************************/
-
-#include <asm/delay.h>
-#include "xbasic_types.h"
-#include "xstatus.h"
-#include "xparameters.h"
-#include "xipif_v1_23_b.h"
-#include "xpacket_fifo_v2_00_a.h"
-#include "xdmav3.h"
-#include "xtemac_l.h"
-
-/************************** Constant Definitions *****************************/
-
-/*
- * Device information
- */
-#define XTE_DEVICE_NAME     "xtemac"
-#define XTE_DEVICE_DESC     "Xilinx Tri-speed 10/100/1000 MAC"
-
-
-/** @name Configuration options
- *
- * Device configuration options. See the XTemac_SetOptions(),
- * XTemac_ClearOptions() and XTemac_GetOptions() for information on how to use
- * options.
- *
- * The default state of the options are noted and are what the device and driver
- * will be set to after calling XTemac_Reset() or XTemac_Initialize().
- *
- * @{
- */
-
-#define XTE_PROMISC_OPTION               0x00000001
-/**< Accept all incoming packets.
- *   This option defaults to disabled (cleared) */
-
-#define XTE_JUMBO_OPTION                 0x00000002
-/**< Jumbo frame support for Tx & Rx.
- *   This option defaults to disabled (cleared) */
-
-#define XTE_VLAN_OPTION                  0x00000004
-/**< VLAN Rx & Tx frame support.
- *   This option defaults to disabled (cleared) */
-
-#define XTE_FLOW_CONTROL_OPTION          0x00000010
-/**< Enable recognition of flow control frames on Rx
- *   This option defaults to enabled (set) */
-
-#define XTE_FCS_STRIP_OPTION             0x00000020
-/**< Strip FCS and PAD from incoming frames. Note: PAD from VLAN frames is not
- *   stripped.
- *   This option defaults to disabled (set) */
-
-#define XTE_FCS_INSERT_OPTION            0x00000040
-/**< Generate FCS field and add PAD automatically for outgoing frames.
- *   This option defaults to enabled (set) */
-
-#define XTE_LENTYPE_ERR_OPTION           0x00000080
-/**< Enable Length/Type error checking for incoming frames. When this option is
- *   set, the MAC will filter frames that have a mismatched type/length field
- *   and if XTE_REPORT_RXERR_OPTION is set, the user is notified when these
- *   types of frames are encountered. When this option is cleared, the MAC will
- *   allow these types of frames to be received.
- *
- *   This option defaults to enabled (set) */
-
-#define XTE_SGEND_INT_OPTION             0x00000100
-/**< Enable the SGEND interrupt with SG DMA. When enabled, an interrupt will
- *   be triggered when the end of the buffer descriptor list is reached. The
- *   interrupt will occur despite interrupt coalescing settings.
- *   This option defaults to disabled (cleared) */
-
-#define XTE_POLLED_OPTION                0x00000200
-/**< Polled mode communications. Enables use of XTemac_FifoQuerySendStatus()
- *   and XTemac_FifoQueryRecvStatus(). Users may enter/exit polled mode
- *   from any interrupt driven mode.
- *   This option defaults to disabled (cleared) */
-
-#define XTE_REPORT_RXERR_OPTION          0x00000400
-/**< Enable reporting of dropped receive packets due to errors
- *   This option defaults to enabled (set) */
-
-#define XTE_TRANSMITTER_ENABLE_OPTION    0x00000800
-/**< Enable the transmitter.
- *   This option defaults to enabled (set) */
-
-#define XTE_RECEIVER_ENABLE_OPTION       0x00001000
-/**< Enable the receiver
- *   This option defaults to enabled (set) */
-
-#define XTE_BROADCAST_OPTION             0x00002000
-/**< Allow reception of the broadcast address
- *   This option defaults to enabled (set) */
-
-#define XTE_MULTICAST_CAM_OPTION         0x00004000
-/**< Allows reception of multicast addresses programmed into CAM
- *   This option defaults to disabled (clear) */
-
-#define XTE_REPORT_TXSTATUS_OVERRUN_OPTION 0x00008000
-/**< Enable reporting the overrun of the Transmit status FIFO. This type of
- *   error is latched by HW and can be cleared only by a reset. SGDMA systems,
- *   this option should be enabled since the DMA engine is responsible for
- *   keeping this from occurring. For FIFO direct systems, this error may be
- *   a nuisance because a SW system may be able to transmit frames faster
- *   than the interrupt handler can handle retrieving statuses.
- *   This option defaults to enabled (set) */
-
-#define XTE_ANEG_OPTION                  0x00010000
-/**< Enable autonegotiation interrupt
-     This option defaults to disabled (clear) */
-
-#define XTE_DEFAULT_OPTIONS                     \
-    (XTE_FLOW_CONTROL_OPTION |                  \
-     XTE_BROADCAST_OPTION |                     \
-     XTE_FCS_INSERT_OPTION |                    \
-     XTE_FCS_STRIP_OPTION |                     \
-     XTE_LENTYPE_ERR_OPTION |                   \
-     XTE_TRANSMITTER_ENABLE_OPTION |            \
-     XTE_REPORT_RXERR_OPTION |                  \
-     XTE_REPORT_TXSTATUS_OVERRUN_OPTION |       \
-     XTE_RECEIVER_ENABLE_OPTION)
-/**< Default options set when device is initialized or reset */
-
-/*@}*/
-
-/** @name Direction identifiers
- *
- *  These are used by several functions and callbacks that need
- *  to specify whether an operation specifies a send or receive channel.
- * @{
- */
-#define XTE_SEND    1
-#define XTE_RECV    2
-/*@}*/
-
-/** @name Reset parameters
- *
- *  These are used by function XTemac_Reset().
- * @{
- */
-#define XTE_RESET_HARD    1
-#define XTE_NORESET_HARD  0
-/*@}*/
-
-/** @name XTemac_FifoWrite/Read() function arguments
- *
- *  These are used by XTemac_FifoWrite/Read() End Of Packet (Eop)
- *  parameter.
- * @{
- */
-#define XTE_END_OF_PACKET   1	/**< The data written is the last for the
-                                  *  current packet */
-#define XTE_PARTIAL_PACKET  0	/**< There is more data to come for the
-                                  *  current packet */
-/*@}*/
-
-/** @name Callback identifiers
- *
- * These constants are used as parameters to XTemac_SetHandler()
- * @{
- */
-#define XTE_HANDLER_FIFOSEND     1
-#define XTE_HANDLER_FIFORECV     2
-#define XTE_HANDLER_SGSEND       5
-#define XTE_HANDLER_SGRECV       6
-#define XTE_HANDLER_ERROR        7
-#define XTE_HANDLER_ANEG         8
-/*@}*/
-
-
-/* Constants to determine the configuration of the hardware device. They are
- * used to allow the driver to verify it can operate with the hardware.
- */
-#define XTE_CFG_NO_DMA              1	/* No DMA */
-#define XTE_CFG_SIMPLE_DMA          2	/* Simple DMA (not supported) */
-#define XTE_CFG_DMA_SG              3	/* DMA scatter gather */
-
-#define XTE_MULTI_CAM_ENTRIES       4	/* Number of storable addresses in
-					   the CAM */
-
-#define XTE_MDIO_DIV_DFT            29	/* Default MDIO clock divisor */
-
-/* Some default values for interrupt coalescing within the scatter-gather
- * DMA engine.
- */
-#define XTE_SGDMA_DFT_THRESHOLD     1	/* Default pkt threshold */
-#define XTE_SGDMA_MAX_THRESHOLD     1023	/* Maximum pkt theshold */
-#define XTE_SGDMA_DFT_WAITBOUND     0	/* Default pkt wait bound (msec) */
-#define XTE_SGDMA_MAX_WAITBOUND     1023	/* Maximum pkt wait bound (msec) */
-
-/* The next few constants help upper layers determine the size of memory
- * pools used for Ethernet buffers and descriptor lists.
- */
-#define XTE_MAC_ADDR_SIZE   6	/* six-byte MAC address */
-#define XTE_MTU             1500	/* max MTU size of Ethernet frame */
-#define XTE_JUMBO_MTU       8982	/* max MTU size of jumbo Ethernet frame */
-#define XTE_HDR_SIZE        14	/* size of Ethernet header */
-#define XTE_HDR_VLAN_SIZE   18	/* size of Ethernet header with VLAN */
-#define XTE_TRL_SIZE        4	/* size of Ethernet trailer (FCS) */
-#define XTE_MAX_FRAME_SIZE       (XTE_MTU + XTE_HDR_SIZE + XTE_TRL_SIZE)
-#define XTE_MAX_VLAN_FRAME_SIZE  (XTE_MTU + XTE_HDR_VLAN_SIZE + XTE_TRL_SIZE)
-#define XTE_MAX_JUMBO_FRAME_SIZE (XTE_JUMBO_MTU + XTE_HDR_SIZE + XTE_TRL_SIZE)
-
-/* Constant values returned by XTemac_mGetPhysicalInterface(). Note that these
- * values match design parameters from the PLB_TEMAC spec
- */
-#define XTE_PHY_TYPE_MII         0
-#define XTE_PHY_TYPE_GMII        1
-#define XTE_PHY_TYPE_RGMII_1_3   2
-#define XTE_PHY_TYPE_RGMII_2_0   3
-#define XTE_PHY_TYPE_SGMII       4
-#define XTE_PHY_TYPE_1000BASE_X  5
-
-/**************************** Type Definitions *******************************/
-
-
-/** @name Typedefs for callback functions
- *
- * These callbacks are invoked in interrupt context.
- * @{
- */
-
-/**
- * Callback invoked when frame(s) have been sent in interrupt driven FIFO
- * direct mode. To set this callback, invoke XTemac_SetHander() with
- * XTE_HANDLER_FIFOSEND in the HandlerType parameter.
- *
- * @param CallBackRef is user data assigned when the callback was set.
- * @param StatusCnt is the number of statuses read from the device indicating
- *        a successful frame transmit.
- *
- */
-typedef void (*XTemac_FifoSendHandler) (void *CallBackRef, unsigned StatusCnt);
-
-/**
- * Callback invoked when frame(s) have been received in interrupt driven FIFO
- * direct mode. To set this callback, invoke XTemac_SetHander() with
- * XTE_HANDLER_FIFORECV in the HandlerType parameter.
- *
- * @param CallBackRef is user data assigned when the callback was set.
- *
- */
-typedef void (*XTemac_FifoRecvHandler) (void *CallBackRef);
-
-/**
- * Callback invoked when frame(s) have been sent or received in interrupt
- * driven SGDMA mode. To set the send callback, invoke XTemac_SetHandler()
- * with XTE_HANDLER_SGSEND in the HandlerType parameter. For the receive
- * callback use XTE_HANDLER_SGRECV.
- *
- * @param CallBackRef is user data assigned when the callback was set.
- */
-typedef void (*XTemac_SgHandler) (void *CallBackRef);
-
-/**
- * Callback invoked when auto-negotiation interrupt is asserted
- * To set this callback, invoke XTemac_SetHandler() with XTE_HANDLER_ANEG in
- * the HandlerType parameter.
- *
- * @param CallBackRef is user data assigned when the callback was set.
- */
-typedef void (*XTemac_AnegHandler) (void *CallBackRef);
-
-/**
- * Callback when an asynchronous error occurs. To set this callback, invoke
- * XTemac_SetHandler() with XTE_HANDLER_ERROR in the HandlerType paramter.
- *
- * @param CallBackRef is user data assigned when the callback was set.
- * @param ErrorClass defines what class of error is being reported
- * @param ErrorWord1 definition varies with ErrorClass
- * @param ErrorWord2 definition varies with ErrorClass
- *
- * The following information lists what each ErrorClass is, the source of the
- * ErrorWords, what they mean, and if the device should be reset should it be
- * reported
- *
- * <b>ErrorClass == XST_FIFO_ERROR</b>
- *
- * This error class means there was a fatal error with one of the device FIFOs.
- * This type of error cannot be cleared. The user should initiate a device reset.
- *
- * ErrorWord1 is defined as a bit mask from XTE_IPXR_FIFO_FATAL_ERROR_MASK
- * that originates from the device's IPISR register.
- *
- * ErrorWord2 is reserved.
- *
- *
- * <b>ErrorClass == XST_PFIFO_DEADLOCK</b>
- *
- * This error class indicates that one of the packet FIFOs is reporting a
- * deadlock condition. This means the FIFO is reporting that it is empty and
- * full at the same time. This condition will occur when data being written
- * exceeds the capacity of the packet FIFO. The device should be reset if this
- * error is reported.
- *
- * Note that this error is reported only if the device is configured for FIFO
- * direct mode. For SGDMA, this error is reported in ErrorClass XST_FIFO_ERROR.
- *
- * If ErrorWord1 = XTE_RECV, then the deadlock occurred in the receive channel.
- * If ErrorWord1 = XTE_SEND, then the deadlock occurred in the send channel.
- *
- * ErrorWord2 is reserved.
- *
- *
- * <b>ErrorClass == XST_IPIF_ERROR</b>
- *
- * This error means that a register read or write caused a bus error within the
- * TEMAC's IPIF. This condition is fatal. The user should initiate a device
- * reset.
- *
- * ErrorWord1 is defined as the contents XTE_DISR_OFFSET register where these
- * errors are reported. Bits XTE_DXR_DPTO_MASK and XTE_DXR_TERR_MASK are
- * relevent in this context.
- *
- * ErrorWord2 is reserved.
- *
- *
- * <b>ErrorClass == XST_DMA_ERROR</b>
- *
- * This error class means there was a problem during a DMA transfer.
- *
- * ErrorWord1 defines which channel caused the error XTE_RECV or XTE_SEND.
- *
- * ErrorWord2 is set to the DMA status register XDMAV3_DMASR_OFFSET.
- * The relevent bits to test are XDMAV3_DMASR_DBE_MASK and XDMAV3_DMASR_DBT_MASK.
- * If either of these bits are set, a reset is recommended.
- *
- *
- * <b>ErrorClass == XST_RECV_ERROR</b>
- *
- * This error class means a packet was dropped.
- *
- * ErrorWord1 is defined as the contents of the device's XTE_IPISR_OFFSET
- * relating to receive errors. If any bit is set in the
- * XTE_IPXR_RECV_DROPPED_MASK then a packet was rejected. Refer to xtemac_l.h
- * for more information on what each bit in this mask means.
- *
- * ErrorWord2 is reserved.
- *
- * No action is typically required when this error occurs.
- *
- * Reporting of this error class can be disabled by clearing the
- * XTE_REPORT_RXERR_OPTION.
- *
- * @note
- * See xtemac_l.h for bitmasks definitions and the device hardware spec for
- * further information on their meaning.
- *
- */
-typedef void (*XTemac_ErrorHandler) (void *CallBackRef, int ErrorClass,
-				     u32 ErrorWord1, u32 ErrorWord2);
-/*@}*/
-
-
-/**
- * Statistics maintained by the driver
- */
-typedef struct {
-	u32 TxDmaErrors; /**< Number of Tx DMA errors detected */
-	u32 TxPktFifoErrors;
-			 /**< Number of Tx packet FIFO errors detected */
-	u32 TxStatusErrors;
-			 /**< Number of Tx errors derived from XTE_TSR_OFFSET
-                                  register */
-	u32 RxRejectErrors;
-			 /**< Number of frames discarded due to errors */
-	u32 RxDmaErrors; /**< Number of Rx DMA errors detected */
-	u32 RxPktFifoErrors;
-			 /**< Number of Rx packet FIFO errors detected */
-
-	u32 FifoErrors;	 /**< Number of length/status FIFO errors detected */
-	u32 IpifErrors;	 /**< Number of IPIF transaction and data phase errors
-                                  detected */
-	u32 Interrupts;	 /**< Number of interrupts serviced */
-} XTemac_SoftStats;
-
-
-/**
- * This typedef contains configuration information for a device.
- */
-typedef struct {
-	u16 DeviceId;	/**< Unique ID  of device */
-	u32 BaseAddress;/**< Physical base address of IPIF registers */
-	u32 RxPktFifoDepth;
-			/**< Depth of receive packet FIFO in bits */
-	u32 TxPktFifoDepth;
-			/**< Depth of transmit packet FIFO in bits */
-	u16 MacFifoDepth;
-			/**< Depth of the status/length FIFOs in entries */
-	u8 IpIfDmaConfig;
-			/**< IPIF/DMA hardware configuration */
-	u8 TxDre;	/**< Has data realignment engine on Tx channel */
-	u8 RxDre;	/**< Has data realignment engine on Rx channel */
-	u8 TxCsum;	/**< Has checksum offload on Tx channel */
-	u8 RxCsum;	/**< Has checksum offload on Tx channel */
-	u8 PhyType;	/**< Which type of PHY interface is used (MII,
-                                 GMII, RGMII, ect. */
-} XTemac_Config;
-
-
-/* This type encapsulates a packet FIFO channel and support attributes to
- * allow unaligned data transfers.
- */
-typedef struct XTemac_PacketFifo {
-	u32 Hold[2];		/* Holding register */
-	unsigned ByteIndex;	/* Holding register index */
-	unsigned Width;		/* Width of packet FIFO's keyhole data port in
-				   bytes */
-	XPacketFifoV200a Fifo;	/* Packet FIFO channel */
-	/* Function used to transfer data between
-	   FIFO and a buffer */
-	int (*XferFn) (struct XTemac_PacketFifo *Fptr, void *BufPtr,
-		       u32 ByteCount, int Eop);
-} XTemac_PacketFifo;
-
-
-/**
- * The XTemac driver instance data. The user is required to allocate a
- * structure of this type for every TEMAC device in the system. A pointer
- * to a structure of this type is then passed to the driver API functions.
- */
-typedef struct XTemac {
-	u32 BaseAddress;	/* Base address of IPIF register set */
-	u32 IsStarted;		/* Device is currently started */
-	u32 IsReady;		/* Device is initialized and ready */
-	u32 Options;		/* Current options word */
-	u32 Flags;		/* Internal driver flags */
-	XTemac_Config Config;	/* HW configuration */
-
-	/* Packet FIFO channels */
-	XTemac_PacketFifo RecvFifo;	/* Receive channel */
-	XTemac_PacketFifo SendFifo;	/* Transmit channel */
-
-	/* DMA channels */
-	XDmaV3 RecvDma;		/* Receive channel */
-	XDmaV3 SendDma;		/* Transmit channel */
-
-	/* Callbacks for FIFO direct modes */
-	XTemac_FifoRecvHandler FifoRecvHandler;
-	XTemac_FifoSendHandler FifoSendHandler;
-	void *FifoRecvRef;
-	void *FifoSendRef;
-
-	/* Callbacks for SG DMA mode */
-	XTemac_SgHandler SgRecvHandler;
-	XTemac_SgHandler SgSendHandler;
-	void *SgRecvRef;
-	void *SgSendRef;
-
-	/* Auto negotiation callback */
-	XTemac_AnegHandler AnegHandler;
-	void *AnegRef;
-
-	/* Error callback */
-	XTemac_ErrorHandler ErrorHandler;
-	void *ErrorRef;
-
-	/* Driver maintained statistics */
-	XTemac_SoftStats Stats;
-
-} XTemac;
-
-
-/***************** Macros (Inline Functions) Definitions *********************/
-
-/*****************************************************************************/
-/**
-*
-* This macro can be used to determine if the device is in the started or
-* stopped state. To be in the started state, the user must have made a
-* successful call to XTemac_Start(). To be in the stopped state, XTemac_Stop()
-* or one of the XTemac initialize functions must have been called.
-*
-* @param InstancePtr is a pointer to the XTemac instance to be worked on.
-*
-* @return
-*
-* Boolean TRUE if the device has been started, FALSE otherwise
-*
-* @note
-*
-* Signature: u32 XTemac_mIsStarted(XTemac *InstancePtr)
-*
-******************************************************************************/
-#define XTemac_mIsStarted(InstancePtr) \
-    (((InstancePtr)->IsStarted == XCOMPONENT_IS_STARTED) ? TRUE : FALSE)
-
-/*****************************************************************************/
-/**
-*
-* This macro determines if the device thinks it has received a frame. This
-* function is useful if the device is operating in FIFO direct interrupt driven
-* mode. For polled mode, use XTemac_FifoQueryRecvStatus().
-*
-* @param InstancePtr is a pointer to the XTemac instance to be worked on.
-*
-* @return
-*
-* Boolean TRUE if the device interrupt status register reports that a frame
-* status and length is available. FALSE otherwise.
-*
-* @note
-*
-* Signature: u32 XTemac_mIsRecvFrame(XTemac *InstancePtr)
-*
-******************************************************************************/
-#define XTemac_mIsRecvFrame(InstancePtr)                            \
-    ((XTemac_mReadReg((InstancePtr)->BaseAddress, XTE_IPISR_OFFSET) \
-      & XTE_IPXR_RECV_DONE_MASK) ? TRUE : FALSE)
-
-/*****************************************************************************/
-/**
-*
-* This macro determines if the device thinks it has dropped a receive frame.
-*
-* @param InstancePtr is a pointer to the XTemac instance to be worked on.
-*
-* @return
-*
-* Boolean TRUE if the device interrupt status register reports that a frame
-* has been dropped. FALSE otherwise.
-*
-* @note
-*
-* Signature: u32 XTemac_mIsRecvFrameDropped(XTemac *InstancePtr)
-*
-******************************************************************************/
-#define XTemac_mIsRecvFrameDropped(InstancePtr)                     \
-    ((XTemac_mReadReg((InstancePtr)->BaseAddress, XTE_IPISR_OFFSET) \
-      & XTE_IPXR_RECV_REJECT_MASK) ? TRUE : FALSE)
-
-/*****************************************************************************/
-/**
-*
-* This macro determines if the device is currently configured for
-* FIFO direct mode
-*
-* @param InstancePtr is a pointer to the XTemac instance to be worked on.
-*
-* @return
-*
-* Boolean TRUE if the device is configured for FIFO direct, or FALSE
-* if it is not.
-*
-* @note
-*
-* Signature: u32 XTemac_mIsFifo(XTemac *InstancePtr)
-*
-******************************************************************************/
-#define XTemac_mIsFifo(InstancePtr) \
-    (((InstancePtr)->Config.IpIfDmaConfig == XTE_CFG_NO_DMA) ? TRUE : FALSE)
-
-/*****************************************************************************/
-/**
-*
-* This macro determines if the device is currently configured for
-* scatter-gather DMA.
-*
-* @param InstancePtr is a pointer to the XTemac instance to be worked on.
-*
-* @return
-*
-* Boolean TRUE if the device is configured for scatter-gather DMA, or FALSE
-* if it is not.
-*
-* @note
-*
-* Signature: u32 XTemac_mIsSgDma(XTemac *InstancePtr)
-*
-******************************************************************************/
-#define XTemac_mIsSgDma(InstancePtr) \
-    (((InstancePtr)->Config.IpIfDmaConfig == XTE_CFG_DMA_SG) ? TRUE : FALSE)
-
-/*****************************************************************************/
-/**
-*
-* This macro determines if the device is configured with the Data Realignment
-* Engine (DRE) on the receive channel
-*
-* @param InstancePtr is a pointer to the XTemac instance to be worked on.
-*
-* @return
-*
-* Boolean TRUE if the device is configured with DRE, or FALSE otherwise.
-*
-* @note
-*
-* Signature: u32 XTemac_mIsRxDre(XTemac *InstancePtr)
-*
-******************************************************************************/
-#define XTemac_mIsRxDre(InstancePtr) (((InstancePtr)->Config.RxDre) ?  \
-                                      TRUE : FALSE)
-
-/*****************************************************************************/
-/**
-*
-* This macro determines if the device is configured with the Data Realignment
-* Engine (DRE) on the transmit channel
-*
-* @param InstancePtr is a pointer to the XTemac instance to be worked on.
-*
-* @return
-*
-* Boolean TRUE if the device is configured with DRE, or FALSE otherwise.
-*
-* @note
-*
-* Signature: u32 XTemac_mIsTxDre(XTemac *InstancePtr)
-*
-******************************************************************************/
-#define XTemac_mIsTxDre(InstancePtr) (((InstancePtr)->Config.TxDre) ?  \
-                                      TRUE : FALSE)
-
-/*****************************************************************************/
-/**
-*
-* This macro determines if the device is configured with checksum offloading
-* on the receive channel
-*
-* @param InstancePtr is a pointer to the XTemac instance to be worked on.
-*
-* @return
-*
-* Boolean TRUE if the device is configured with checksum offloading, or
-* FALSE otherwise.
-*
-* @note
-*
-* Signature: u32 XTemac_mIsRxCsum(XTemac *InstancePtr)
-*
-******************************************************************************/
-#define XTemac_mIsRxCsum(InstancePtr) (((InstancePtr)->Config.RxCsum) ?  \
-                                       TRUE : FALSE)
-
-/*****************************************************************************/
-/**
-*
-* This macro determines if the device is configured with checksum offloading
-* on the transmit channel
-*
-* @param InstancePtr is a pointer to the XTemac instance to be worked on.
-*
-* @return
-*
-* Boolean TRUE if the device is configured with checksum offloading, or
-* FALSE otherwise.
-*
-* @note
-*
-* Signature: u32 XTemac_mIsTxCsum(XTemac *InstancePtr)
-*
-******************************************************************************/
-#define XTemac_mIsTxCsum(InstancePtr) (((InstancePtr)->Config.TxCsum) ?  \
-                                       TRUE : FALSE)
-
-/*****************************************************************************/
-/**
-*
-* This macro returns the type of PHY interface being used by the given
-* instance.
-*
-* @param InstancePtr is a pointer to the XTemac instance to be worked on.
-*
-* @return
-*
-* One of XTE_PHY_TYPE_<x> where <x> is MII, GMII, RGMII_1_3, RGMII_2_0,
-* SGMII, or 1000BASE_X.
-*
-* @note
-*
-* Signature: int XTemac_mGetPhysicalInterface(XTemac *InstancePtr)
-*
-******************************************************************************/
-#define XTemac_mGetPhysicalInterface(InstancePtr)       \
-    ((InstancePtr)->Config.PhyType)
-
-/*****************************************************************************/
-/**
-*
-* Return the next buffer descriptor in the list on the send channel.
-*
-* @param InstancePtr is a pointer to the XTemac instance to be worked on.
-* @param BdPtr is the source descriptor
-*
-* @return Next descriptor in the SGDMA transmit ring (i.e. BdPtr->Next)
-*
-* @note
-*
-* Signature: XDmaBdV3 XTemac_mSgSendBdNext(XTemac *InstancePtr,
-*                                          XDmaBdV3 *BdPtr)
-*
-******************************************************************************/
-#define XTemac_mSgSendBdNext(InstancePtr, BdPtr)        \
-    XDmaV3_mSgBdNext(&(InstancePtr)->SendDma, (BdPtr))
-
-/*****************************************************************************/
-/**
-*
-* Return the previous buffer descriptor in the list on the send channel.
-*
-* @param InstancePtr is a pointer to the XTemac instance to be worked on.
-* @param BdPtr is the source descriptor
-*
-* @return Previous descriptor in the SGDMA transmit ring (i.e. BdPtr->Prev)
-*
-* @note
-*
-* Signature: XDmaBdV3 XTemac_mSgSendBdPrev(XTemac *InstancePtr,
-*                                          XDmaBdV3 *BdPtr)
-*
-******************************************************************************/
-#define XTemac_mSgSendBdPrev(InstancePtr, BdPtr)        \
-    XDmaV3_mSgBdPrev(&(InstancePtr)->SendDma, (BdPtr))
-
-/*****************************************************************************/
-/**
-*
-* Return the next buffer descriptor in the list on the receive channel.
-*
-* @param InstancePtr is a pointer to the XTemac instance to be worked on.
-* @param BdPtr is the source descriptor
-*
-* @return Next descriptor in the SGDMA receive ring (i.e. BdPtr->Next)
-*
-* @note
-*
-* Signature: XDmaBdV3 XTemac_mSgRecvBdNext(XTemac *InstancePtr,
-*                                          XDmaBdV3 *BdPtr)
-*
-******************************************************************************/
-#define XTemac_mSgRecvBdNext(InstancePtr, BdPtr)        \
-    XDmaV3_mSgBdNext(&(InstancePtr)->RecvDma, (BdPtr))
-
-/*****************************************************************************/
-/**
-*
-* Return the previous buffer descriptor in the list on the receive channel.
-*
-* @param InstancePtr is a pointer to the XTemac instance to be worked on.
-* @param BdPtr is the source descriptor
-*
-* @return Previous descriptor in the SGDMA receive ring (i.e. BdPtr->Prev)
-*
-* @note
-*
-* Signature: XDmaBdV3 XTemac_mSgRecvBdPrev(XTemac *InstancePtr,
-*                                          XDmaBdV3 *BdPtr)
-*
-******************************************************************************/
-#define XTemac_mSgRecvBdPrev(InstancePtr, BdPtr)        \
-    XDmaV3_mSgBdNext(&(InstancePtr)->RecvDma, (BdPtr))
-
-/*****************************************************************************/
-/**
-*
-* Retrieve the received frame checksum as calculated by HW
-*
-* @param BdPtr is the source descriptor
-*
-* @return 16-bit checksum value
-
-* @note
-*
-* Signature: u16 XTemac_mSgRecvBdCsumGet(XDmaBdV3 *BdPtr)
-*
-******************************************************************************/
-#define XTemac_mSgRecvBdCsumGet(BdPtr)                          \
-    (*(u16*)((u32)(BdPtr) + XTE_BD_RX_CSRAW_OFFSET))
-
-/*****************************************************************************/
-/**
-*
-* Enable transmit side checksum calculation for the given descriptor.
-*
-* @param BdPtr is the source descriptor
-*
-* @note
-*
-* Signature: void XTemac_mSgSendBdCsumEnable(XDmaBdV3 *BdPtr)
-*
-******************************************************************************/
-#define XTemac_mSgSendBdCsumEnable(BdPtr)                       \
-    *(u16*)((u32)(BdPtr) + XTE_BD_TX_CSCNTRL_OFFSET) =  \
-        XTE_BD_TX_CSCNTRL_CALC_MASK
-
-/*****************************************************************************/
-/**
-*
-* Disable transmit side checksum calculation for the given descriptor.
-*
-* @param BdPtr is the source descriptor
-*
-* @note
-*
-* Signature: void XTemac_mSgSendBdCsumDisable(XDmaBdV3 *BdPtr)
-*
-******************************************************************************/
-#define XTemac_mSgSendBdCsumDisable(BdPtr)                              \
-    *(u16*)((u32)(BdPtr) + XTE_BD_TX_CSCNTRL_OFFSET) = 0
-
-/*****************************************************************************/
-/**
-*
-* Setup checksum attributes for a transmit frame. If a seed value is required
-* XTemac_mSgSendBdCsumSeed() can be used
-*
-* @param BdPtr is the source descriptor
-* @param StartOffset is the byte offset where HW will begin checksumming data
-* @param InsertOffset is the byte offset where HW will insert the calculated
-*        checksum value
-*
-* @note
-*
-* Signature: void XTemac_mSgSendBdCsumSetup(XDmaBdV3 *BdPtr,
-*                                           u16 StartOffset,
-*                                           u16 InsertOffset)
-*
-******************************************************************************/
-#define XTemac_mSgSendBdCsumSetup(BdPtr, StartOffset, InsertOffset)     \
-    *(u32*)((u32)(BdPtr) + XTE_BD_TX_CSBEGIN_OFFSET) =          \
-        ((StartOffset) << 16) | (InsertOffset)
-
-/*****************************************************************************/
-/**
-*
-* Set the initial checksum seed for a transmit frame. HW will add this value
-* to the calculated frame checksum. If not required then the seed should be
-* set to 0.
-*
-* @param BdPtr is the source descriptor
-* @param Seed is added to the calculated checksum
-*
-* @note
-*
-* Signature: void XTemac_mSgSendBdCsumSeed(XDmaBdV3 *BdPtr, u16 Seed)
-*
-******************************************************************************/
-#define XTemac_mSgSendBdCsumSeed(BdPtr, Seed)                           \
-    *(u16*)((u32)(BdPtr) + XTE_BD_TX_CSINIT_OFFSET) = (Seed)
-
-
-/************************** Function Prototypes ******************************/
-
-/*
- * Initialization functions in xtemac.c
- */
-int XTemac_CfgInitialize(XTemac *InstancePtr, XTemac_Config *CfgPtr,
-			 u32 VirtualAddress);
-int XTemac_Start(XTemac *InstancePtr);
-void XTemac_Stop(XTemac *InstancePtr);
-void XTemac_Reset(XTemac *InstancePtr, int HardCoreAction);
-
-/*
- * Initialization functions in xtemac_sinit.c
- */
-int XTemac_Initialize(XTemac *InstancePtr, u16 DeviceId);
-int XTemac_VmInitialize(XTemac *InstancePtr, u16 DeviceId, u32 VirtualAddress);
-XTemac_Config *XTemac_LookupConfig(u16 DeviceId);
-
-/*
- * General interrupt-related functions in xtemac_intr.c
- */
-int XTemac_SetHandler(XTemac *InstancePtr, u32 HandlerType,
-		      void *CallbackFunc, void *CallbackRef);
-
-/*
- * Fifo direct mode functions implemented in xtemac_fifo.c
- */
-int XTemac_FifoWrite(XTemac *InstancePtr, void *BufPtr, u32 ByteCount, int Eop);
-int XTemac_FifoSend(XTemac *InstancePtr, u32 TxByteCount);
-
-int XTemac_FifoRecv(XTemac *InstancePtr, u32 *ByteCountPtr);
-int XTemac_FifoRead(XTemac *InstancePtr, void *BufPtr, u32 ByteCount, int Eop);
-u32 XTemac_FifoGetFreeBytes(XTemac *InstancePtr, u32 Direction);
-
-int XTemac_FifoQuerySendStatus(XTemac *InstancePtr, u32 *SendStatusPtr);
-int XTemac_FifoQueryRecvStatus(XTemac *InstancePtr);
-
-/*
- * Interrupt management functions for FIFO direct mode implemented in
- * xtemac_intr_fifo.c.
- */
-void XTemac_IntrFifoEnable(XTemac *InstancePtr, u32 Direction);
-void XTemac_IntrFifoDisable(XTemac *InstancePtr, u32 Direction);
-extern void XTemac_IntrFifoHandler(void *InstancePtr);
-
-/*
- * SG DMA mode functions implemented in xtemac_sgdma.c
- */
-int XTemac_SgAlloc(XTemac *InstancePtr, u32 Direction,
-		   unsigned NumBd, XDmaBdV3 ** BdPtr);
-int XTemac_SgUnAlloc(XTemac *InstancePtr, u32 Direction,
-		     unsigned NumBd, XDmaBdV3 * BdPtr);
-int XTemac_SgCommit(XTemac *InstancePtr, u32 Direction,
-		    unsigned NumBd, XDmaBdV3 * BdPtr);
-unsigned XTemac_SgGetProcessed(XTemac *InstancePtr, u32 Direction,
-			       unsigned NumBd, XDmaBdV3 ** BdPtr);
-int XTemac_SgFree(XTemac *InstancePtr, u32 Direction,
-		  unsigned NumBd, XDmaBdV3 * BdPtr);
-
-int XTemac_SgCheck(XTemac *InstancePtr, u32 Direction);
-
-int XTemac_SgSetSpace(XTemac *InstancePtr, u32 Direction,
-		      u32 PhysicalAddr, u32 VirtualAddr,
-		      u32 Alignment, unsigned BdCount, XDmaBdV3 * BdTemplate);
-
-/*
- * Interrupt management functions for SG DMA mode implemented in
- * xtemac_intr_sgdma.c
- */
-void XTemac_IntrSgEnable(XTemac *InstancePtr, u32 Direction);
-void XTemac_IntrSgDisable(XTemac *InstancePtr, u32 Direction);
-int XTemac_IntrSgCoalSet(XTemac *InstancePtr, u32 Direction,
-			 u16 Threshold, u16 Timer);
-int XTemac_IntrSgCoalGet(XTemac *InstancePtr, u32 Direction,
-			 u16 *ThresholdPtr, u16 *TimerPtr);
-
-extern void XTemac_IntrSgHandler(void *InstancePtr);
-
-/*
- * MAC configuration/control functions in xtemac_control.c
- */
-int XTemac_SetOptions(XTemac *InstancePtr, u32 Options);
-int XTemac_ClearOptions(XTemac *InstancePtr, u32 Options);
-u32 XTemac_GetOptions(XTemac *InstancePtr);
-
-int XTemac_SetMacAddress(XTemac *InstancePtr, void *AddressPtr);
-void XTemac_GetMacAddress(XTemac *InstancePtr, void *AddressPtr);
-
-int XTemac_SetMacPauseAddress(XTemac *InstancePtr, void *AddressPtr);
-void XTemac_GetMacPauseAddress(XTemac *InstancePtr, void *AddressPtr);
-int XTemac_SendPausePacket(XTemac *InstancePtr, u16 PauseValue);
-
-int XTemac_GetSgmiiStatus(XTemac *InstancePtr, u16 *SpeedPtr);
-int XTemac_GetRgmiiStatus(XTemac *InstancePtr, u16 *SpeedPtr,
-			  u32 *IsFullDuplexPtr, u32 *IsLinkUpPtr);
-u16 XTemac_GetOperatingSpeed(XTemac *InstancePtr);
-void XTemac_SetOperatingSpeed(XTemac *InstancePtr, u16 Speed);
-
-void XTemac_PhySetMdioDivisor(XTemac *InstancePtr, u8 Divisor);
-int XTemac_PhyRead(XTemac *InstancePtr, u32 PhyAddress,
-		   u32 RegisterNum, u16 *PhyDataPtr);
-int XTemac_PhyWrite(XTemac *InstancePtr, u32 PhyAddress,
-		    u32 RegisterNum, u16 PhyData);
-int XTemac_MulticastAdd(XTemac *InstancePtr, void *AddressPtr, int Entry);
-void XTemac_MulticastGet(XTemac *InstancePtr, void *AddressPtr, int Entry);
-int XTemac_MulticastClear(XTemac *InstancePtr, int Entry);
-
-/*
- * Statistics in xtemac_stats.c
- */
-void XTemac_GetSoftStats(XTemac *InstancePtr, XTemac_SoftStats *StatsPtr);
-void XTemac_ClearSoftStats(XTemac *InstancePtr);
-
-/*
- * Diagnostic functions in xtemac_selftest.c
- */
-int XTemac_SelfTest(XTemac *InstancePtr);
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif /* end of protection macro */
diff --git a/drivers/net/ethernet/xilinx/xilinx_temac/xtemac_control.c b/drivers/net/ethernet/xilinx/xilinx_temac/xtemac_control.c
deleted file mode 100644
index 56eaa42..0000000
--- a/drivers/net/ethernet/xilinx/xilinx_temac/xtemac_control.c
+++ /dev/null
@@ -1,1160 +0,0 @@
-/* $Id: */
-/******************************************************************************
-*
-*       XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS"
-*       AS A COURTESY TO YOU, SOLELY FOR USE IN DEVELOPING PROGRAMS AND
-*       SOLUTIONS FOR XILINX DEVICES.  BY PROVIDING THIS DESIGN, CODE,
-*       OR INFORMATION AS ONE POSSIBLE IMPLEMENTATION OF THIS FEATURE,
-*       APPLICATION OR STANDARD, XILINX IS MAKING NO REPRESENTATION
-*       THAT THIS IMPLEMENTATION IS FREE FROM ANY CLAIMS OF INFRINGEMENT,
-*       AND YOU ARE RESPONSIBLE FOR OBTAINING ANY RIGHTS YOU MAY REQUIRE
-*       FOR YOUR IMPLEMENTATION.  XILINX EXPRESSLY DISCLAIMS ANY
-*       WARRANTY WHATSOEVER WITH RESPECT TO THE ADEQUACY OF THE
-*       IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OR
-*       REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE FROM CLAIMS OF
-*       INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
-*       FOR A PARTICULAR PURPOSE.
-*
-*       (c) Copyright 2005-2006 Xilinx Inc.
-*       All rights reserved.
-* This program is free software; you can redistribute it and/or modify it
-* under the terms of the GNU General Public License as published by the
-* Free Software Foundation; either version 2 of the License, or (at your
-* option) any later version.
-*
-* You should have received a copy of the GNU General Public License
-* along with this program; if not, write to the Free Software
-* Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-*
-******************************************************************************/
-/*****************************************************************************/
-/**
- *
- * @file xtemac_control.c
- *
- * Functions in this file implement general purpose command and control related
- * functionality. See xtemac.h for a detailed description of the driver.
- *
- * <pre>
- * MODIFICATION HISTORY:
- *
- * Ver   Who  Date     Changes
- * ----- ---- -------- -------------------------------------------------------
- * 1.00a rmm  06/01/05 First release
- * 1.00b rmm  09/23/05 Implemented PhyRead/Write and multicast functions,
- *                     removed Set/Get IFG functions. Redesigned MII/RGMII/
- *                     SGMII status functions.
- * 2.00a rmm  11/21/05 Added auto negotiate to options processing funcs,
- *                     fixed XTE_MGTDR_OFFSET and XTE_MGTCR_OFFSET to be
- *                     accessed with IPIF instead of host macros, removed
- *                     half duplex option processing
- *       rmm  06/22/06 Fixed c++ compiler warnings and errors
- * </pre>
- *****************************************************************************/
-
-/***************************** Include Files *********************************/
-
-#include "xtemac.h"
-#include "xtemac_i.h"
-
-/************************** Constant Definitions *****************************/
-
-
-/**************************** Type Definitions *******************************/
-
-
-/***************** Macros (Inline Functions) Definitions *********************/
-
-
-/************************** Function Prototypes ******************************/
-
-
-/************************** Variable Definitions *****************************/
-
-
-/*****************************************************************************/
-/**
- * Set the MAC address for this driver/device.  The address is a 48-bit value.
- * The device must be stopped before calling this function.
- *
- * @param InstancePtr is a pointer to the instance to be worked on.
- * @param AddressPtr is a pointer to a 6-byte MAC address.
- *
- * @return
- * - XST_SUCCESS if the MAC address was set successfully
- * - XST_DEVICE_IS_STARTED if the device has not yet been stopped
- *
- ******************************************************************************/
-int XTemac_SetMacAddress(XTemac *InstancePtr, void *AddressPtr)
-{
-	u32 MacAddr;
-	u8 *Aptr = (u8 *) AddressPtr;
-
-	XASSERT_NONVOID(InstancePtr != NULL);
-	XASSERT_NONVOID(InstancePtr->IsReady == XCOMPONENT_IS_READY);
-
-	/* Be sure device has been stopped */
-	if (InstancePtr->IsStarted == XCOMPONENT_IS_STARTED) {
-		return (XST_DEVICE_IS_STARTED);
-	}
-
-	/* Set the MAC bits [31:0] in EUAW0 */
-	MacAddr = Aptr[0] & 0x000000FF;
-	MacAddr |= Aptr[1] << 8;
-	MacAddr |= Aptr[2] << 16;
-	MacAddr |= Aptr[3] << 24;
-	XTemac_mSetHostReg(XTE_UAW0_OFFSET, MacAddr);
-
-	/* There are reserved bits in EUAW1 so don't affect them */
-	MacAddr = XTemac_mGetHostReg(XTE_UAW1_OFFSET);
-	MacAddr &= ~XTE_UAW1_MASK;
-
-	/* Set MAC bits [47:32] in EUAW1 */
-	MacAddr |= Aptr[4] & 0x000000FF;
-	MacAddr |= Aptr[5] << 8;
-	XTemac_mSetHostReg(XTE_UAW1_OFFSET, MacAddr);
-
-	return (XST_SUCCESS);
-}
-
-
-/*****************************************************************************/
-/**
- * Get the MAC address for this driver/device.
- *
- * @param InstancePtr is a pointer to the instance to be worked on.
- * @param AddressPtr is an output parameter, and is a pointer to a buffer into
- *        which the current MAC address will be copied. The buffer must be at
- *        least 6 bytes in length.
- *
- ******************************************************************************/
-void XTemac_GetMacAddress(XTemac *InstancePtr, void *AddressPtr)
-{
-	u32 MacAddr;
-	u8 *Aptr = (u8 *) AddressPtr;
-
-	XASSERT_VOID(InstancePtr != NULL);
-	XASSERT_VOID(InstancePtr->IsReady == XCOMPONENT_IS_READY);
-
-	/* Read MAC bits [31:0] in EUAW0 */
-	MacAddr = XTemac_mGetHostReg(XTE_UAW0_OFFSET);
-	Aptr[0] = (u8) MacAddr;
-	Aptr[1] = (u8) (MacAddr >> 8);
-	Aptr[2] = (u8) (MacAddr >> 16);
-	Aptr[3] = (u8) (MacAddr >> 24);
-
-	/* Read MAC bits [47:32] in EUAW1 */
-	MacAddr = XTemac_mGetHostReg(XTE_UAW1_OFFSET);
-	Aptr[4] = (u8) MacAddr;
-	Aptr[5] = (u8) (MacAddr >> 8);
-}
-
-
-/*****************************************************************************/
-/**
- * Add an Ethernet address to the list that will be accepted by the receiver.
- * The address may be any unicast, multicast, or the broadcast address form.
- * Up to XTE_MULTI_CAM_ENTRIES addresses may be filtered in this way. The
- * device must be stopped to use this function.
- *
- * Once an address is programmed, it will be received by the device. There is
- * no control bit to disable multicast filtering. The only way to prevent a
- * CAM address from being received is to clear it with XTemac_MulticastClear().
- *
- * @param InstancePtr is a pointer to the XTemac instance to be worked on.
- * @param AddressPtr is a pointer to a 6-byte Ethernet address. The previous
- *        address at this entry location (if any) is overwritten with the new
- *        one.
- * @param Entry is the storage location the HW uses to program this address.
- *        It must be between 0..XTE_MULTI_CAM_ENTRIES-1.
- *
- * @return
- *
- * - XST_SUCCESS if the address was added successfully
- * - XST_DEVICE_IS_STARTED if the device has not yet been stopped
- ******************************************************************************/
-int XTemac_MulticastAdd(XTemac *InstancePtr, void *AddressPtr, int Entry)
-{
-	u32 Emaw0Reg;
-	u32 Emaw1Reg;
-	u8 *Aptr = (u8 *) AddressPtr;
-
-	XASSERT_NONVOID(InstancePtr != NULL);
-	XASSERT_NONVOID(InstancePtr->IsReady == XCOMPONENT_IS_READY);
-	XASSERT_NONVOID(Entry < XTE_MULTI_CAM_ENTRIES);
-
-	/* The device must be stopped before clearing the multicast hash table */
-	if (InstancePtr->IsStarted == XCOMPONENT_IS_STARTED) {
-		return (XST_DEVICE_IS_STARTED);
-	}
-
-	/* Set MAC bits [31:0] */
-	Emaw0Reg = Aptr[0] & 0x000000FF;
-	Emaw0Reg |= Aptr[1] << 8;
-	Emaw0Reg |= Aptr[2] << 16;
-	Emaw0Reg |= Aptr[3] << 24;
-
-	/* Set MAC bits [47:32] */
-	Emaw1Reg = Aptr[4] & 0x000000FF;
-	Emaw1Reg |= Aptr[5] << 8;
-
-	/* Add in CAM address */
-	Emaw1Reg |= (Entry << XTE_MAW1_CAMMADDR_SHIFT_MASK);
-
-	/* Program HW */
-	XTemac_mSetHostReg(XTE_MAW0_OFFSET, Emaw0Reg);
-	XTemac_mSetHostReg(XTE_MAW1_OFFSET, Emaw1Reg);
-
-	return (XST_SUCCESS);
-}
-
-
-/*****************************************************************************/
-/**
- * Retrieve an Ethernet address set by XTemac_MulticastAdd().
- *
- * @param InstancePtr is a pointer to the XTemac instance to be worked on.
- * @param AddressPtr is an output parameter, and is a pointer to a buffer into
- *        which the current MAC address will be copied. The buffer must be at
- *        least 6 bytes in length.
- * @param Entry is the storage location in the HW. It must be between
- *        0..XTE_MULTI_CAM_ENTRIES-1.
- *
- * @return
- *
- * - XST_SUCCESS if the address was added successfully
- * - XST_DEVICE_IS_STARTED if the device has not yet been stopped
- ******************************************************************************/
-void XTemac_MulticastGet(XTemac *InstancePtr, void *AddressPtr, int Entry)
-{
-	u32 Emaw0Reg;
-	u32 Emaw1Reg;
-	u8 *Aptr = (u8 *) AddressPtr;
-
-	XASSERT_VOID(InstancePtr != NULL);
-	XASSERT_VOID(InstancePtr->IsReady == XCOMPONENT_IS_READY);
-	XASSERT_VOID(Entry < XTE_MULTI_CAM_ENTRIES);
-
-	/* Tell HW to provide address stored in given entry */
-	XTemac_mSetHostReg(XTE_MAW1_OFFSET, XTE_MAW1_CAMRNW_MASK |
-			   (Entry << XTE_MAW1_CAMMADDR_SHIFT_MASK));
-
-	/* The HW should now have provided the CAM entry */
-	Emaw0Reg = XTemac_mGetHostReg(XTE_MAW0_OFFSET);
-	Emaw1Reg = XTemac_mGetHostReg(XTE_MAW1_OFFSET);
-
-	/* Copy the address to the user buffer */
-	Aptr[0] = (u8) Emaw0Reg;
-	Aptr[1] = (u8) (Emaw0Reg >> 8);
-	Aptr[2] = (u8) (Emaw0Reg >> 16);
-	Aptr[3] = (u8) (Emaw0Reg >> 24);
-	Aptr[4] = (u8) Emaw1Reg;
-	Aptr[5] = (u8) (Emaw1Reg >> 8);
-}
-
-/*****************************************************************************/
-/**
-* Clear an address set by XTemac_MulticastAdd(). The device must be stopped
-* before calling this function.
-*
-* @param InstancePtr is a pointer to the XTemac instance to be worked on.
-* @param Entry is the HW storage location used when this address was added.
-*        It must be between 0..XTE_MULTI_CAM_ENTRIES-1.
-*
-* @return
-*
-* - XST_SUCCESS if the address was cleared
-* - XST_DEVICE_IS_STARTED if the device has not yet been stopped
-*
-******************************************************************************/
-int XTemac_MulticastClear(XTemac *InstancePtr, int Entry)
-{
-	XASSERT_NONVOID(InstancePtr != NULL);
-	XASSERT_NONVOID(InstancePtr->IsReady == XCOMPONENT_IS_READY);
-	XASSERT_NONVOID(Entry < XTE_MULTI_CAM_ENTRIES);
-
-	/* The device must be stopped before clearing the multicast hash table */
-	if (InstancePtr->IsStarted == XCOMPONENT_IS_STARTED) {
-		return (XST_DEVICE_IS_STARTED);
-	}
-
-	/* Clear the entry by writing 0:0:0:0:0:0 to it */
-	XTemac_mSetHostReg(XTE_MAW0_OFFSET, 0);
-	XTemac_mSetHostReg(XTE_MAW1_OFFSET,
-			   Entry << XTE_MAW1_CAMMADDR_SHIFT_MASK);
-
-	return (XST_SUCCESS);
-}
-
-
-/*****************************************************************************/
-/**
- * Set the MAC address for pause frames. This is the address the device will
- * recognize as pause frames. Pause frames transmitted with
- * XTemac_SendPausePacket() will also use this address.
- *
- * @param InstancePtr is a pointer to the instance to be worked on.
- * @param AddressPtr is a pointer to a 6-byte MAC address.
- *
- * @return
- * - XST_SUCCESS if the MAC address was set successfully
- * - XST_DEVICE_IS_STARTED if the device has not yet been stopped
- *
- ******************************************************************************/
-int XTemac_SetMacPauseAddress(XTemac *InstancePtr, void *AddressPtr)
-{
-	u32 MacAddr;
-	u8 *Aptr = (u8 *) AddressPtr;
-
-	XASSERT_NONVOID(InstancePtr != NULL);
-	XASSERT_NONVOID(InstancePtr->IsReady == XCOMPONENT_IS_READY);
-
-	/* Be sure device has been stopped */
-	if (InstancePtr->IsStarted == XCOMPONENT_IS_STARTED) {
-		return (XST_DEVICE_IS_STARTED);
-	}
-
-	/* Set the MAC bits [31:0] in ERXC0 */
-	MacAddr = Aptr[0] & 0x000000FF;
-	MacAddr |= Aptr[1] << 8;
-	MacAddr |= Aptr[2] << 16;
-	MacAddr |= Aptr[3] << 24;
-	XTemac_mSetHostReg(XTE_RXC0_OFFSET, MacAddr);
-
-	/* ERXC1 contains other info that must be preserved */
-	MacAddr = XTemac_mGetHostReg(XTE_RXC1_OFFSET);
-	MacAddr &= ~XTE_RXC1_ERXC1_MASK;;
-
-	/* Set MAC bits [47:32] */
-	MacAddr |= Aptr[4] & 0x000000FF;
-	MacAddr |= Aptr[5] << 8;
-	XTemac_mSetHostReg(XTE_RXC1_OFFSET, MacAddr);
-
-	return (XST_SUCCESS);
-}
-
-
-/*****************************************************************************/
-/**
- * Get the MAC address for pause frames for this driver/device.
- *
- * @param InstancePtr is a pointer to the instance to be worked on.
- * @param AddressPtr is an output parameter, and is a pointer to a buffer into
- *        which the current MAC address will be copied. The buffer must be at
- *        least 6 bytes in length.
- *
- ******************************************************************************/
-void XTemac_GetMacPauseAddress(XTemac *InstancePtr, void *AddressPtr)
-{
-	u32 MacAddr;
-	u8 *Aptr = (u8 *) AddressPtr;
-
-	XASSERT_VOID(InstancePtr != NULL);
-	XASSERT_VOID(InstancePtr->IsReady == XCOMPONENT_IS_READY);
-
-	/* Read MAC bits [31:0] in ERXC0 */
-	MacAddr = XTemac_mGetHostReg(XTE_RXC0_OFFSET);
-	Aptr[0] = (u8) MacAddr;
-	Aptr[1] = (u8) (MacAddr >> 8);
-	Aptr[2] = (u8) (MacAddr >> 16);
-	Aptr[3] = (u8) (MacAddr >> 24);
-
-	/* Read MAC bits [47:32] in RXC1 */
-	MacAddr = XTemac_mGetHostReg(XTE_RXC1_OFFSET);
-	Aptr[4] = (u8) MacAddr;
-	Aptr[5] = (u8) (MacAddr >> 8);
-}
-
-
-/*****************************************************************************/
-/**
- * Set options for the driver/device. The driver should be stopped with
- * XTemac_Stop() before changing options.
- *
- * @param InstancePtr is a pointer to the instance to be worked on.
- * @param Options are the options to set. Multiple options can be set by OR'ing
- *        XTE_*_OPTIONS constants together. Options not specified are not
- *        affected.
- *
- * @return
- * - XST_SUCCESS if the options were set successfully
- * - XST_DEVICE_IS_STARTED if the device has not yet been stopped
- * - XST_NO_FEATURE if setting an option requires HW support not present
- *
- * @note
- * See xtemac.h for a description of the available options.
- *
- ******************************************************************************/
-int XTemac_SetOptions(XTemac *InstancePtr, u32 Options)
-{
-	u32 Reg;		/* Generic register contents */
-	u32 RegErxc1;		/* Reflects original contents of ERXC1 */
-	u32 RegEtxc;		/* Reflects original contents of ETXC  */
-	u32 RegNewErxc1;	/* Reflects new contents of ERXC1 */
-	u32 RegNewEtxc;		/* Reflects new contents of ETXC  */
-
-	XASSERT_NONVOID(InstancePtr != NULL);
-	XASSERT_NONVOID(InstancePtr->IsReady == XCOMPONENT_IS_READY);
-
-	/* Be sure device has been stopped */
-	if (InstancePtr->IsStarted == XCOMPONENT_IS_STARTED) {
-		return (XST_DEVICE_IS_STARTED);
-	}
-
-	/* Polled mode requires FIFO direct */
-	if ((Options & XTE_POLLED_OPTION) && (!XTemac_mIsFifo(InstancePtr))) {
-		return (XST_NO_FEATURE);
-	}
-
-	/* Many of these options will change the ERXC1 or ETXC registers.
-	 * To reduce the amount of IO to the device, group these options here
-	 * and change them all at once.
-	 */
-
-	/* Grab current register contents */
-	RegErxc1 = XTemac_mGetHostReg(XTE_RXC1_OFFSET);
-	RegEtxc = XTemac_mGetHostReg(XTE_TXC_OFFSET);
-	RegNewErxc1 = RegErxc1;
-	RegNewEtxc = RegEtxc;
-
-	/* Turn on jumbo packet support for both Rx and Tx */
-	if (Options & XTE_JUMBO_OPTION) {
-		RegNewEtxc |= XTE_TXC_TXJMBO_MASK;
-		RegNewErxc1 |= XTE_RXC1_RXJMBO_MASK;
-	}
-
-	/* Turn on VLAN packet support for both Rx and Tx */
-	if (Options & XTE_VLAN_OPTION) {
-		RegNewEtxc |= XTE_TXC_TXVLAN_MASK;
-		RegNewErxc1 |= XTE_RXC1_RXVLAN_MASK;
-	}
-
-	/* Turn on FCS stripping on receive packets */
-	if (Options & XTE_FCS_STRIP_OPTION) {
-		RegNewErxc1 &= ~XTE_RXC1_RXFCS_MASK;
-	}
-
-	/* Turn on FCS insertion on transmit packets */
-	if (Options & XTE_FCS_INSERT_OPTION) {
-		RegNewEtxc &= ~XTE_TXC_TXFCS_MASK;
-	}
-
-	/* Turn on length/type field checking on receive packets */
-	if (Options & XTE_LENTYPE_ERR_OPTION) {
-		RegNewErxc1 &= ~XTE_RXC1_RXLT_MASK;
-	}
-
-	/* Officially change the ETXC or ERXC1 registers if they need to be
-	 * modified
-	 */
-	if (RegEtxc != RegNewEtxc) {
-		XTemac_mSetHostReg(XTE_TXC_OFFSET, RegNewEtxc);
-	}
-
-	if (RegErxc1 != RegNewErxc1) {
-		XTemac_mSetHostReg(XTE_RXC1_OFFSET, RegNewErxc1);
-	}
-
-	/* Rest of options twiddle bits of other registers. Handle them one at
-	 * a time
-	 */
-
-	/* Turn on flow control */
-	if (Options & XTE_FLOW_CONTROL_OPTION) {
-		Reg = XTemac_mGetHostReg(XTE_FCC_OFFSET);
-		Reg |= XTE_FCC_RXFLO_MASK;
-		XTemac_mSetHostReg(XTE_FCC_OFFSET, Reg);
-	}
-
-	/* Turn on promiscuous frame filtering (all frames are received ) */
-	if (Options & XTE_PROMISC_OPTION) {
-		Reg = XTemac_mGetHostReg(XTE_AFM_OFFSET);
-		Reg |= XTE_AFM_EPPRM_MASK;
-		XTemac_mSetHostReg(XTE_AFM_OFFSET, Reg);
-	}
-
-	/* Allow broadcast address filtering */
-	if (Options & XTE_BROADCAST_OPTION) {
-		Reg = XTemac_mGetIpifReg(XTE_CR_OFFSET);
-		Reg &= ~XTE_CR_BCREJ_MASK;
-		XTemac_mSetIpifReg(XTE_CR_OFFSET, Reg);
-	}
-
-	/* Allow multicast address filtering */
-	if (Options & XTE_MULTICAST_CAM_OPTION) {
-		Reg = XTemac_mGetIpifReg(XTE_CR_OFFSET);
-		Reg &= ~XTE_CR_MCREJ_MASK;
-		XTemac_mSetIpifReg(XTE_CR_OFFSET, Reg);
-	}
-
-	/* Enable interrupts related to rejection of bad frames */
-	if (Options & XTE_REPORT_RXERR_OPTION) {
-		/* Clear out any previous error conditions that may have existed
-		 * prior to enabling the reporting of these types of errors
-		 */
-		Reg = XTemac_mGetIpifReg(XTE_IPISR_OFFSET);
-		XTemac_mSetIpifReg(XTE_IPISR_OFFSET,
-				   Reg & XTE_IPXR_RECV_DROPPED_MASK);
-
-		/* Whether these are enabled here are based on the last call to
-		 * XTemac_IntrFifoEnable/Disable() and XTemac_IntrSgDmaEnable/Disable()
-		 * for the receive channel.
-		 *
-		 * If receive interrupts are enabled, then enable these interrupts. This
-		 * way, when XTemac_Start() is called, these interrupt enables take
-		 * effect right away.
-		 *
-		 * If receive interrupts are disabled, then don't do anything here. The
-		 * XTemac_IntrFifoEnable() and XTemac_IntrSgDmaEnable() functions when
-		 * called will check this option and enable these interrupts if needed.
-		 */
-		if (InstancePtr->Flags &
-		    (XTE_FLAGS_RECV_FIFO_INT_ENABLE |
-		     XTE_FLAGS_RECV_SGDMA_INT_ENABLE)) {
-			Reg = XTemac_mGetIpifReg(XTE_IPIER_OFFSET);
-			Reg |= XTE_IPXR_RECV_DROPPED_MASK;
-			XTemac_mSetIpifReg(XTE_IPIER_OFFSET, Reg);
-		}
-	}
-
-	/* Enable interrrupt related to assertion of auto-negotiate HW interrupt */
-	if (Options & XTE_ANEG_OPTION) {
-		/* Clear out any previous interupt condition that may have existed
-		 * prior to enabling the reporting of auto negotiation
-		 */
-		Reg = XTemac_mGetIpifReg(XTE_IPISR_OFFSET);
-		XTemac_mSetIpifReg(XTE_IPISR_OFFSET,
-				   Reg & XTE_IPXR_AUTO_NEG_MASK);
-
-		/* Make this interupt source enabled when XTemac_Start() is called */
-		Reg = XTemac_mGetIpifReg(XTE_IPIER_OFFSET);
-		XTemac_mSetIpifReg(XTE_IPIER_OFFSET,
-				   Reg & XTE_IPXR_AUTO_NEG_MASK);
-	}
-
-	/* Enable interrupts upon completing a SG list */
-	if ((Options & XTE_SGEND_INT_OPTION) && XTemac_mIsSgDma(InstancePtr)) {
-		Reg = XDmaV3_GetInterruptEnable(&InstancePtr->SendDma);
-		Reg |= XDMAV3_IPXR_SGEND_MASK;
-		XDmaV3_SetInterruptEnable(&InstancePtr->SendDma, Reg);
-
-		Reg = XDmaV3_GetInterruptEnable(&InstancePtr->RecvDma);
-		Reg |= XDMAV3_IPXR_SGEND_MASK;
-		XDmaV3_SetInterruptEnable(&InstancePtr->RecvDma, Reg);
-	}
-
-	/* The remaining options not handled here are managed elsewhere in the
-	 * driver. No register modifications are needed at this time. Reflecting the
-	 * option in InstancePtr->Options is good enough for now.
-	 */
-
-	/* Set options word to its new value */
-	InstancePtr->Options |= Options;
-
-	return (XST_SUCCESS);
-}
-
-
-/*****************************************************************************/
-/**
- * Clear options for the driver/device
- *
- * @param InstancePtr is a pointer to the instance to be worked on.
- * @param Options are the options to clear. Multiple options can be cleared by
- *        OR'ing XTE_*_OPTIONS constants together. Options not specified are not
- *        affected.
- *
- * @return
- * - XST_SUCCESS if the options were set successfully
- * - XST_DEVICE_IS_STARTED if the device has not yet been stopped
- *
- * @note
- * See xtemac.h for a description of the available options.
- *
- ******************************************************************************/
-int XTemac_ClearOptions(XTemac *InstancePtr, u32 Options)
-{
-	volatile u32 Reg;	/* Generic */
-	u32 RegErxc1;		/* Reflects original contents of ERXC1 */
-	u32 RegEtxc;		/* Reflects original contents of ETXC  */
-	u32 RegNewErxc1;	/* Reflects new contents of ERXC1 */
-	u32 RegNewEtxc;		/* Reflects new contents of ETXC  */
-
-	XASSERT_NONVOID(InstancePtr != NULL);
-	XASSERT_NONVOID(InstancePtr->IsReady == XCOMPONENT_IS_READY);
-
-	/* Be sure device has been stopped */
-	if (InstancePtr->IsStarted == XCOMPONENT_IS_STARTED) {
-		return (XST_DEVICE_IS_STARTED);
-	}
-
-	/* Many of these options will change the ERXC1 or ETXC registers.
-	 * Group these options here and change them all at once. What we are
-	 * trying to accomplish is to reduce the amount of IO to the device
-	 */
-
-	/* Grab current register contents */
-	RegErxc1 = XTemac_mGetHostReg(XTE_RXC1_OFFSET);
-	RegEtxc = XTemac_mGetHostReg(XTE_TXC_OFFSET);
-	RegNewErxc1 = RegErxc1;
-	RegNewEtxc = RegEtxc;
-
-	/* Turn off jumbo packet support for both Rx and Tx */
-	if (Options & XTE_JUMBO_OPTION) {
-		RegNewEtxc &= ~XTE_TXC_TXJMBO_MASK;
-		RegNewErxc1 &= ~XTE_RXC1_RXJMBO_MASK;
-	}
-
-	/* Turn off VLAN packet support for both Rx and Tx */
-	if (Options & XTE_VLAN_OPTION) {
-		RegNewEtxc &= ~XTE_TXC_TXVLAN_MASK;
-		RegNewErxc1 &= ~XTE_RXC1_RXVLAN_MASK;
-	}
-
-	/* Turn off FCS stripping on receive packets */
-	if (Options & XTE_FCS_STRIP_OPTION) {
-		RegNewErxc1 |= XTE_RXC1_RXFCS_MASK;
-	}
-
-	/* Turn off FCS insertion on transmit packets */
-	if (Options & XTE_FCS_INSERT_OPTION) {
-		RegNewEtxc |= XTE_TXC_TXFCS_MASK;
-	}
-
-	/* Turn off length/type field checking on receive packets */
-	if (Options & XTE_LENTYPE_ERR_OPTION) {
-		RegNewErxc1 |= XTE_RXC1_RXLT_MASK;
-	}
-
-	/* Disable transmitter */
-	if (Options & XTE_TRANSMITTER_ENABLE_OPTION) {
-		RegNewEtxc &= ~XTE_TXC_TXEN_MASK;
-	}
-
-	/* Disable receiver */
-	if (Options & XTE_RECEIVER_ENABLE_OPTION) {
-		RegNewErxc1 &= ~XTE_RXC1_RXEN_MASK;
-	}
-
-	/* Officially change the ETXC or ERXC1 registers if they need to be
-	 * modified
-	 */
-	if (RegEtxc != RegNewEtxc) {
-		XTemac_mSetHostReg(XTE_TXC_OFFSET, RegNewEtxc);
-	}
-
-	if (RegErxc1 != RegNewErxc1) {
-		XTemac_mSetHostReg(XTE_RXC1_OFFSET, RegNewErxc1);
-	}
-
-	/* Rest of options twiddle bits of other registers. Handle them one at
-	 * a time
-	 */
-
-	/* Turn off flow control */
-	if (Options & XTE_FLOW_CONTROL_OPTION) {
-		Reg = XTemac_mGetHostReg(XTE_FCC_OFFSET);
-		Reg &= ~XTE_FCC_RXFLO_MASK;
-		XTemac_mSetHostReg(XTE_FCC_OFFSET, Reg);
-	}
-
-	/* Turn off promiscuous frame filtering */
-	if (Options & XTE_PROMISC_OPTION) {
-		Reg = XTemac_mGetHostReg(XTE_AFM_OFFSET);
-		Reg &= ~XTE_AFM_EPPRM_MASK;
-		XTemac_mSetHostReg(XTE_AFM_OFFSET, Reg);
-	}
-
-	/* Disable broadcast address filtering */
-	if (Options & XTE_BROADCAST_OPTION) {
-		Reg = XTemac_mGetIpifReg(XTE_CR_OFFSET);
-		Reg |= XTE_CR_BCREJ_MASK;
-		XTemac_mSetIpifReg(XTE_CR_OFFSET, Reg);
-	}
-
-	/* Disable multicast address filtering */
-	if (Options & XTE_MULTICAST_CAM_OPTION) {
-		Reg = XTemac_mGetIpifReg(XTE_CR_OFFSET);
-		Reg |= XTE_CR_MCREJ_MASK;
-		XTemac_mSetIpifReg(XTE_CR_OFFSET, Reg);
-	}
-
-	/* Disable interrupts related to rejection of bad frames */
-	if (Options & XTE_REPORT_RXERR_OPTION) {
-		Reg = XTemac_mGetIpifReg(XTE_IPIER_OFFSET);
-		Reg &= ~XTE_IPXR_RECV_DROPPED_MASK;
-		XTemac_mSetIpifReg(XTE_IPIER_OFFSET, Reg);
-	}
-
-	/* Disable interrupts related to auto negotiate */
-	if (Options & XTE_ANEG_OPTION) {
-		Reg = XTemac_mGetIpifReg(XTE_IPIER_OFFSET);
-		Reg &= ~XTE_IPXR_AUTO_NEG_MASK;
-		XTemac_mSetIpifReg(XTE_IPIER_OFFSET, Reg);
-	}
-
-	/* Disable interrupts upon completing a SG list */
-	if ((Options & XTE_SGEND_INT_OPTION) && XTemac_mIsSgDma(InstancePtr)) {
-		Reg = XDmaV3_GetInterruptEnable(&InstancePtr->SendDma);
-		Reg &= ~XDMAV3_IPXR_SGEND_MASK;
-		XDmaV3_SetInterruptEnable(&InstancePtr->SendDma, Reg);
-
-		Reg = XDmaV3_GetInterruptEnable(&InstancePtr->RecvDma);
-		Reg &= ~XDMAV3_IPXR_SGEND_MASK;
-		XDmaV3_SetInterruptEnable(&InstancePtr->RecvDma, Reg);
-	}
-
-	/* The remaining options not handled here are managed elsewhere in the
-	 * driver. No register modifications are needed at this time. Reflecting the
-	 * option in InstancePtr->Options is good enough for now.
-	 */
-
-	/* Set options word to its new value */
-	InstancePtr->Options &= ~Options;
-
-	return (XST_SUCCESS);
-}
-
-
-/*****************************************************************************/
-/**
- * Get current option settings
- *
- * @param InstancePtr is a pointer to the instance to be worked on.
- *
- * @return
- * A bitmask of XTE_*_OPTION constants. Any bit set to 1 is to be interpreted
- * as a set opion.
- *
- * @note
- * See xtemac.h for a description of the available options.
- *
- ******************************************************************************/
-u32 XTemac_GetOptions(XTemac *InstancePtr)
-{
-	XASSERT_NONVOID(InstancePtr != NULL);
-	XASSERT_NONVOID(InstancePtr->IsReady == XCOMPONENT_IS_READY);
-
-	return (InstancePtr->Options);
-}
-
-
-/*****************************************************************************/
-/**
- * Send a pause packet
- *
- * @param InstancePtr is a pointer to the instance to be worked on.
- * @param PauseValue is the pause value in units of 512 bit times.
- *
- * @return
- * - XST_SUCCESS if pause frame transmission was initiated
- * - XST_DEVICE_IS_STOPPED if the device has not been started.
- *
- ******************************************************************************/
-int XTemac_SendPausePacket(XTemac *InstancePtr, u16 PauseValue)
-{
-	XASSERT_NONVOID(InstancePtr != NULL);
-	XASSERT_NONVOID(InstancePtr->IsReady == XCOMPONENT_IS_READY);
-
-	/* Make sure device is ready for this operation */
-	if (InstancePtr->IsStarted != XCOMPONENT_IS_STARTED) {
-		return (XST_DEVICE_IS_STOPPED);
-	}
-
-	/* Send flow control frame */
-	XTemac_mSetIpifReg(XTE_TPPR_OFFSET, (u32) PauseValue);
-	return (XST_SUCCESS);
-}
-
-
-/*****************************************************************************/
-/**
- * Get the current operating link speed. This may be the value set by
- * XTemac_SetOperatingSpeed() or a HW default.
- *
- * @param InstancePtr is a pointer to the instance to be worked on.
- *
- * @return Link speed in units of megabits per second
- *
- ******************************************************************************/
-u16 XTemac_GetOperatingSpeed(XTemac *InstancePtr)
-{
-	XASSERT_NONVOID(InstancePtr != NULL);
-	XASSERT_NONVOID(InstancePtr->IsReady == XCOMPONENT_IS_READY);
-
-	switch (XTemac_mGetHostReg(XTE_EMCFG_OFFSET) & XTE_EMCFG_LINKSPD_MASK) {
-	case XTE_EMCFG_LINKSPD_1000:
-		return (1000);
-
-	case XTE_EMCFG_LINKSPD_100:
-		return (100);
-
-	case XTE_EMCFG_LINKSPD_10:
-		return (10);
-
-	default:
-		return (0);
-	}
-}
-
-
-/*****************************************************************************/
-/**
- * Set the current operating link speed. For any traffic to be passed, this
- * speed must match the current MII/GMII/SGMII/RGMII link speed.
- *
- * @param InstancePtr is a pointer to the instance to be worked on.
- * @param Speed is the speed to set in units of Mbps. Valid values are 10, 100,
- *        or 1000. Invalid values result in no change to the device.
- *
- ******************************************************************************/
-void XTemac_SetOperatingSpeed(XTemac *InstancePtr, u16 Speed)
-{
-	u32 EcfgReg;
-
-	XASSERT_VOID(InstancePtr != NULL);
-	XASSERT_VOID(InstancePtr->IsReady == XCOMPONENT_IS_READY);
-	XASSERT_VOID((Speed == 10) || (Speed == 100) || (Speed == 1000));
-
-	/* Get the current contents of the EMAC config register and zero out
-	 * speed bits
-	 */
-	EcfgReg =
-		XTemac_mGetHostReg(XTE_EMCFG_OFFSET) & ~XTE_EMCFG_LINKSPD_MASK;
-
-	switch (Speed) {
-	case 10:
-		break;
-
-	case 100:
-		EcfgReg |= XTE_EMCFG_LINKSPD_100;
-		break;
-
-	case 1000:
-		EcfgReg |= XTE_EMCFG_LINKSPD_1000;
-		break;
-
-	default:
-		return;
-	}
-
-	/* Set register and return */
-	XTemac_mSetHostReg(XTE_EMCFG_OFFSET, EcfgReg);
-}
-
-/*****************************************************************************/
-/**
- * Get the current state of the link when media interface is of the SGMII type
- *
- * @param InstancePtr is a pointer to the instance to be worked on.
- * @param SpeedPtr is a return value set to either 0, 10, 100, or 1000. Units
- *        are in Mbits/sec.
- *
- * @return
- *   - XST_SUCCESS if the SGMII status was read and return values set.
- *   - XST_NO_FEATURE if the device is not using SGMII.
- *
- ******************************************************************************/
-int XTemac_GetSgmiiStatus(XTemac *InstancePtr, u16 *SpeedPtr)
-{
-	int PhyType;
-	u32 EgmicReg;
-
-	XASSERT_NONVOID(InstancePtr != NULL);
-	XASSERT_NONVOID(InstancePtr->IsReady == XCOMPONENT_IS_READY);
-
-	/* Make sure PHY is SGMII */
-	PhyType = XTemac_mGetPhysicalInterface(InstancePtr);
-	if (PhyType != XTE_PHY_TYPE_SGMII) {
-		return (XST_NO_FEATURE);
-	}
-
-	/* Get the current contents of RGMII/SGMII config register */
-	EgmicReg = XTemac_mGetHostReg(XTE_GMIC_OFFSET);
-
-	/* Extract speed */
-	switch (EgmicReg & XTE_GMIC_RGLINKSPD_MASK) {
-	case XTE_GMIC_RGLINKSPD_10:
-		*SpeedPtr = 10;
-		break;
-
-	case XTE_GMIC_RGLINKSPD_100:
-		*SpeedPtr = 100;
-		break;
-
-	case XTE_GMIC_RGLINKSPD_1000:
-		*SpeedPtr = 1000;
-		break;
-
-	default:
-		*SpeedPtr = 0;
-	}
-
-	return (XST_SUCCESS);
-}
-
-
-/*****************************************************************************/
-/**
- * Get the current state of the link when media interface is of the RGMII type
- *
- * @param InstancePtr is a pointer to the instance to be worked on.
- * @param SpeedPtr is a return value set to either 0, 10, 100, or 1000. Units
- *        are in Mbits/sec.
- * @param IsFullDuplexPtr is a return value set to TRUE if the RGMII link
- *        is operating in full duplex, or FALSE if operating in half duplex.
- *        XTE_RGMII_LINK_UP.
- * @param IsLinkUpPtr is a return value set to TRUE if the RGMII link is up,
- *        or FALSE if the link is down.
- *
- * @return
- *   - XST_SUCCESS if the RGMII status was read and return values set.
- *   - XST_NO_FEATURE if the device is not using RGMII.
- *
- ******************************************************************************/
-int XTemac_GetRgmiiStatus(XTemac *InstancePtr, u16 *SpeedPtr,
-			  u32 *IsFullDuplexPtr, u32 *IsLinkUpPtr)
-{
-	int PhyType;
-	u32 EgmicReg;
-
-	XASSERT_NONVOID(InstancePtr != NULL);
-	XASSERT_NONVOID(InstancePtr->IsReady == XCOMPONENT_IS_READY);
-
-	/* Make sure PHY is RGMII */
-	PhyType = XTemac_mGetPhysicalInterface(InstancePtr);
-	if ((PhyType != XTE_PHY_TYPE_RGMII_1_3) &&
-	    (PhyType != XTE_PHY_TYPE_RGMII_2_0)) {
-		return (XST_NO_FEATURE);
-	}
-
-	/* Get the current contents of RGMII/SGMII config register */
-	EgmicReg = XTemac_mGetHostReg(XTE_GMIC_OFFSET);
-
-	/* Extract speed */
-	switch (EgmicReg & XTE_GMIC_RGLINKSPD_MASK) {
-	case XTE_GMIC_RGLINKSPD_10:
-		*SpeedPtr = 10;
-		break;
-
-	case XTE_GMIC_RGLINKSPD_100:
-		*SpeedPtr = 100;
-		break;
-
-	case XTE_GMIC_RGLINKSPD_1000:
-		*SpeedPtr = 1000;
-		break;
-
-	default:
-		*SpeedPtr = 0;
-	}
-
-	/* Extract duplex and link status */
-	if (EgmicReg & XTE_GMIC_RGHALFDUPLEX_MASK) {
-		*IsFullDuplexPtr = FALSE;
-	}
-	else {
-		*IsFullDuplexPtr = TRUE;
-	}
-
-	if (EgmicReg & XTE_GMIC_RGSTATUS_MASK) {
-		*IsLinkUpPtr = TRUE;
-	}
-	else {
-		*IsLinkUpPtr = FALSE;
-	}
-
-	return (XST_SUCCESS);
-}
-
-
-/*****************************************************************************/
-/**
- * Set the MDIO clock divisor. This function must be called once after each
- * reset prior to accessing MII PHY registers.
- *
- * Calculating the divisor:
- *
- * From the Virtex-4 Embedded Tri-Mode Ethernet MAC User's Guide, the
- * following equation governs the MDIO clock to the PHY:
- *
- * <pre>
- *              f[HOSTCLK]
- *   f[MDC] = -----------------
- *            (1 + Divisor) * 2
- * </pre>
- *
- * where f[HOSTCLK] is the bus clock frequency in MHz, and f[MDC] is the
- * MDIO clock frequency in MHz to the PHY. Typically, f[MDC] should not
- * exceed 2.5 MHz. Some PHYs can tolerate faster speeds which means faster
- * access.
- *
- * @param InstancePtr is a pointer to the instance to be worked on.
- * @param Divisor is the divisor to set. Range is 0 to XTE_MC_CLK_DVD_MAX.
- *
- ******************************************************************************/
-void XTemac_PhySetMdioDivisor(XTemac *InstancePtr, u8 Divisor)
-{
-	XASSERT_VOID(InstancePtr != NULL);
-	XASSERT_VOID(InstancePtr->IsReady == XCOMPONENT_IS_READY)
-		XASSERT_VOID(Divisor <= XTE_MC_CLK_DVD_MAX);
-
-	XTemac_mSetHostReg(XTE_MC_OFFSET, (u32) Divisor | XTE_MC_MDIO_MASK);
-}
-
-
-/*****************************************************************************/
-/*
-*
-* Read the current value of the PHY register indicated by the PhyAddress and
-* the RegisterNum parameters. The MAC provides the driver with the ability to
-* talk to a PHY that adheres to the Media Independent Interface (MII) as
-* defined in the IEEE 802.3 standard.
-*
-* Prior to PHY access with this function, the user should have setup the MDIO
-* clock with XTemac_PhySetMdioDivisor().
-*
-* @param InstancePtr is a pointer to the XTemac instance to be worked on.
-* @param PhyAddress is the address of the PHY to be read (supports multiple
-*        PHYs)
-* @param RegisterNum is the register number, 0-31, of the specific PHY register
-*        to read
-* @param PhyDataPtr is an output parameter, and points to a 16-bit buffer into
-*        which the current value of the register will be copied.
-*
-* @return
-*
-* - XST_SUCCESS if the PHY was read from successfully
-* - XST_NO_FEATURE if the device is not configured with MII support
-* - XST_EMAC_MII_BUSY if there is another PHY operation in progress
-*
-* @note
-*
-* This function is not thread-safe. The user must provide mutually exclusive
-* access to this function if there are to be multiple threads that can call it.
-* <br><br>
-* There is the possibility that this function will not return if the hardware
-* is broken (i.e., it never sets the status bit indicating that the read is
-* done). If this is of concern to the user, the user should provide a mechanism
-* suitable to their needs for recovery.
-* <br><br>
-* For the duration of this function, all host interface reads and writes are
-* blocked to the current Temac instance and also the 2nd instance if it exists
-* in the system. This is a HW limitation. See xtemac.h for a list of functions
-* that will be blocked until this operation completes.
-*
-******************************************************************************/
-int XTemac_PhyRead(XTemac *InstancePtr, u32 PhyAddress,
-		   u32 RegisterNum, u16 *PhyDataPtr)
-{
-	u32 Mgtcr;
-	volatile u32 Ipisr;
-
-	XASSERT_NONVOID(InstancePtr != NULL);
-
-	/* Make sure no other PHY operation is currently in progress */
-	if (XTemac_mGetIpifReg(XTE_IPISR_OFFSET) & XTE_IPXR_MII_PEND_MASK) {
-		return (XST_EMAC_MII_BUSY);
-	}
-
-	/* Construct Mgtcr mask for the operation */
-	Mgtcr = RegisterNum & XTE_MGTCR_REGAD_MASK;
-	Mgtcr |= ((PhyAddress << XTE_MGTCR_PHYAD_SHIFT_MASK) &
-		  XTE_MGTCR_PHYAD_MASK);
-	Mgtcr |= XTE_MGTCR_RWN_MASK;
-
-	/* Write Mgtcr and wait for completion */
-	XTemac_mSetIpifReg(XTE_MGTCR_OFFSET, Mgtcr);
-
-	do {
-		Ipisr = XTemac_mGetIpifReg(XTE_IPISR_OFFSET);
-	} while (!(Ipisr & XTE_IPXR_MII_DONE_MASK));
-
-	/* Read data */
-	*PhyDataPtr = XTemac_mGetIpifReg(XTE_MGTDR_OFFSET);
-
-	/* Clear MII status bits */
-	XTemac_mSetIpifReg(XTE_IPISR_OFFSET,
-			   Ipisr & (XTE_IPXR_MII_DONE_MASK |
-				    XTE_IPXR_MII_PEND_MASK));
-
-	return (XST_SUCCESS);
-}
-
-
-/*****************************************************************************/
-/*
-* Write data to the specified PHY register. The Ethernet driver does not
-* require the device to be stopped before writing to the PHY.  Although it is
-* probably a good idea to stop the device, it is the responsibility of the
-* application to deem this necessary. The MAC provides the driver with the
-* ability to talk to a PHY that adheres to the Media Independent Interface
-* (MII) as defined in the IEEE 802.3 standard.
-*
-* Prior to PHY access with this function, the user should have setup the MDIO
-* clock with XTemac_PhySetMdioDivisor().
-*
-* @param InstancePtr is a pointer to the XTemac instance to be worked on.
-* @param PhyAddress is the address of the PHY to be written (supports multiple
-*        PHYs)
-* @param RegisterNum is the register number, 0-31, of the specific PHY register
-*        to write
-* @param PhyData is the 16-bit value that will be written to the register
-*
-* @return
-*
-* - XST_SUCCESS if the PHY was written to successfully. Since there is no error
-*   status from the MAC on a write, the user should read the PHY to verify the
-*   write was successful.
-* - XST_NO_FEATURE if the device is not configured with MII support
-* - XST_EMAC_MII_BUSY if there is another PHY operation in progress
-*
-* @note
-*
-* This function is not thread-safe. The user must provide mutually exclusive
-* access to this function if there are to be multiple threads that can call it.
-* <br><br>
-* There is the possibility that this function will not return if the hardware
-* is broken (i.e., it never sets the status bit indicating that the write is
-* done). If this is of concern to the user, the user should provide a mechanism
-* suitable to their needs for recovery.
-* <br><br>
-* For the duration of this function, all host interface reads and writes are
-* blocked to the current Temac instance and also the 2nd instance if it exists
-* in the system. This is a HW limitation. See xtemac.h for a list of functions
-* that will be blocked until this operation completes.
-*
-******************************************************************************/
-int XTemac_PhyWrite(XTemac *InstancePtr, u32 PhyAddress,
-		    u32 RegisterNum, u16 PhyData)
-{
-	u32 Mgtcr;
-	volatile u32 Ipisr;
-
-	XASSERT_NONVOID(InstancePtr != NULL);
-
-	/* Make sure no other PHY operation is currently in progress */
-	if (XTemac_mGetIpifReg(XTE_IPISR_OFFSET) & XTE_IPXR_MII_PEND_MASK) {
-		return (XST_EMAC_MII_BUSY);
-	}
-
-	/* Construct Mgtcr mask for the operation */
-	Mgtcr = RegisterNum & XTE_MGTCR_REGAD_MASK;
-	Mgtcr |= ((PhyAddress << XTE_MGTCR_PHYAD_SHIFT_MASK) &
-		  XTE_MGTCR_PHYAD_MASK);
-
-	/* Write Mgtdr and Mgtcr and wait for completion */
-	XTemac_mSetIpifReg(XTE_MGTDR_OFFSET, (u32) PhyData);
-	XTemac_mSetIpifReg(XTE_MGTCR_OFFSET, Mgtcr);
-
-	do {
-		Ipisr = XTemac_mGetIpifReg(XTE_IPISR_OFFSET);
-	} while (!(Ipisr & XTE_IPXR_MII_DONE_MASK));
-
-	/* Clear MII status bits */
-	XTemac_mSetIpifReg(XTE_IPISR_OFFSET,
-			   Ipisr & (XTE_IPXR_MII_DONE_MASK |
-				    XTE_IPXR_MII_PEND_MASK));
-
-	return (XST_SUCCESS);
-}
diff --git a/drivers/net/ethernet/xilinx/xilinx_temac/xtemac_fifo.c b/drivers/net/ethernet/xilinx/xilinx_temac/xtemac_fifo.c
deleted file mode 100644
index 2501ccd..0000000
--- a/drivers/net/ethernet/xilinx/xilinx_temac/xtemac_fifo.c
+++ /dev/null
@@ -1,1173 +0,0 @@
-/* $Id: */
-/******************************************************************************
-*
-*       XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS"
-*       AS A COURTESY TO YOU, SOLELY FOR USE IN DEVELOPING PROGRAMS AND
-*       SOLUTIONS FOR XILINX DEVICES.  BY PROVIDING THIS DESIGN, CODE,
-*       OR INFORMATION AS ONE POSSIBLE IMPLEMENTATION OF THIS FEATURE,
-*       APPLICATION OR STANDARD, XILINX IS MAKING NO REPRESENTATION
-*       THAT THIS IMPLEMENTATION IS FREE FROM ANY CLAIMS OF INFRINGEMENT,
-*       AND YOU ARE RESPONSIBLE FOR OBTAINING ANY RIGHTS YOU MAY REQUIRE
-*       FOR YOUR IMPLEMENTATION.  XILINX EXPRESSLY DISCLAIMS ANY
-*       WARRANTY WHATSOEVER WITH RESPECT TO THE ADEQUACY OF THE
-*       IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OR
-*       REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE FROM CLAIMS OF
-*       INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
-*       FOR A PARTICULAR PURPOSE.
-*
-*       (c) Copyright 2005-2006 Xilinx Inc.
-*       All rights reserved.
-* This program is free software; you can redistribute it and/or modify it
-* under the terms of the GNU General Public License as published by the
-* Free Software Foundation; either version 2 of the License, or (at your
-* option) any later version.
-*
-* You should have received a copy of the GNU General Public License
-* along with this program; if not, write to the Free Software
-* Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-*
-******************************************************************************/
-/*****************************************************************************/
-/**
-*
-* @file xtemac_fifo.c
-*
-* Functions in this file implement FIFO direct and Simple DMA frame transfer
-* mode. See xtemac.h for a detailed description of the driver.
-*
-* <pre>
-* MODIFICATION HISTORY:
-*
-* Ver   Who  Date     Changes
-* ----- ---- -------- -------------------------------------------------------
-* 1.00a rmm  06/01/05 First release
-* 1.00b rmm  09/23/05 Fixed void* arithmetic usage, added XST_FIFO_ERROR
-*                     return code to send/recv query functions.
-* 2.00a rmm  11/21/05 Removed XST_FAILURE return code for XTemac_FifoQuery-
-*                     SendStatus, removed simple dma code
-*       rmm  06/22/06 Fixed C++ compiler warnings
-* </pre>
-******************************************************************************/
-
-/***************************** Include Files *********************************/
-
-#include "xtemac.h"
-#include "xtemac_i.h"
-#include "xio.h"
-
-/************************** Constant Definitions *****************************/
-
-#define PFIFO_64BIT_WIDTH_BYTES 8
-
-/**************************** Type Definitions *******************************/
-
-
-/***************** Macros (Inline Functions) Definitions *********************/
-
-/*******************************************************************************
- * Primitives that modify the hold structure for XTemac_PacketFifo. All F
- * parameters refer to a pointer to XTemac_PacketFifo.
- *
- * mHold_GetIndex(F) - Get the ByteIndex of Hold
- * mHold_SetIndex(F,D) - Set the ByteIndex of Hold to D
- * mHold_Advance(F,D) - Advance the ByteIndex of Hold by D bytes
- * mHold_CopyIn(F,I,D) - Set Hold[I] to D
- * mHold_CopyOut(F,I,D) - Set D to Hold[I]
- * mHoldS_IsFull(F) - Is a write channel Hold full of data
- * mHoldS_IsEmpty(F) - Is a write channel Hold empty
- * mHoldS_SetEmpty(F) - Set a write channel Hold empty
- * mHoldR_IsFull(F) - Is a read channel Hold full of data
- * mHoldR_IsEmpty(F) - Is a read channel Hold empty
- * mHoldR_SetEmpty(F) - Set a read channel Hold empty
- *
- * @param F - Address to a XTemac_PacketFifo structure
- * @param SrcPtr - Source data address aligned on 4 byte boundary
- *
- ******************************************************************************/
-#define mHold_GetIndex(F)      ((F)->ByteIndex)
-#define mHold_SetIndex(F, D)   ((F)->ByteIndex = (D))
-#define mHold_Advance(F, D)    ((F)->ByteIndex += (D))
-#define mHold_CopyIn(F, I, D)  (*(u8*)(((u8*)(&(F)->Hold[0])) + (I)) = (D))
-#define mHold_CopyOut(F, I, D) ((D) = (*(u8*)(((u8*)(&(F)->Hold[0])) + (I))))
-
-#define mHoldS_IsFull(F)    ((F)->ByteIndex >= (F)->Width)
-#define mHoldS_IsEmpty(F)   ((F)->ByteIndex == 0)
-#define mHoldS_SetEmpty(F)  ((F)->ByteIndex = 0)
-
-#define mHoldR_IsFull(F)    ((F)->ByteIndex == 0)
-#define mHoldR_IsEmpty(F)   ((F)->ByteIndex >= (F)->Width)
-#define mHoldR_SetEmpty(F)  ((F)->ByteIndex = (F)->Width)
-
-/*******************************************************************************
- * Primitive write to 64 bit FIFO. Use two 32-bit wide I/O accesses.
- *
- * @param F - Address to a XTemac_PacketFifo structure
- * @param SrcPtr - Source data address aligned on 4 byte boundary
- *
- ******************************************************************************/
-#define mWriteFifo64(F, SrcPtr)                                \
-    {                                                          \
-        register u32 Faddr = F->Fifo.DataBaseAddress;      \
-        XIo_Out32(Faddr, (SrcPtr)[0]);                         \
-        XIo_Out32(Faddr + 4, (SrcPtr)[1]);                     \
-    }
-
-/*******************************************************************************
- * Primitive read from 64 bit FIFO. Use two 32-bit wide I/O accesses.
- *
- * @param F - Address to a XTemac_PacketFifo structure
- * @param DestPtr - Destination data address aligned on 4 byte boundary
- *
- ******************************************************************************/
-#define mReadFifo64(F, DestPtr)                                \
-    (DestPtr)[0] = XIo_In32(F->Fifo.DataBaseAddress);          \
-    (DestPtr)[1] = XIo_In32(F->Fifo.DataBaseAddress + 4);
-
-/*******************************************************************************
- * Primitive to transfer the holding data to the FIFO 64 bits at a time
- *
- * @param F - Address to a XTemac_PacketFifo structure
- *
- ******************************************************************************/
-#define mPush64(F) mWriteFifo64(F, &F->Hold[0])
-
-/*******************************************************************************
- * Primitive to tranfer FIFO contents into the holding data 64 bits at a time
- *
- * @param F - Address to a XTemac_PacketFifo structure
- *
- ******************************************************************************/
-#define mPop64(F) mReadFifo64(F, &F->Hold[0])
-
-
-/************************** Function Prototypes ******************************/
-
-/* The following functions will be attached to the FifoRead and FifoWrite
- * attribute of an instance by XTemac_ConfigureFifoAccess
- */
-static int Write_64(XTemac_PacketFifo *Fptr, void *BufPtr,
-		    u32 ByteCount, int Eop);
-static int Read_64(XTemac_PacketFifo *Fptr, void *BufPtr,
-		   u32 ByteCount, int Eop);
-
-/* 64 bit wide FIFO support functions */
-static void Write64_Unaligned(XTemac_PacketFifo *F, void *BufPtr,
-			      u32 ByteCount);
-static void Write64_Aligned(XTemac_PacketFifo *F, u32 *BufPtr, u32 ByteCount);
-static void Read64_Unaligned(XTemac_PacketFifo *F, void *BufPtr, u32 ByteCount);
-static void Read64_Aligned(XTemac_PacketFifo *F, u32 *BufPtr, u32 ByteCount);
-
-
-/*******************************************************************************
- * Select the best method for accessing the read and write FIFOs for FIFO direct
- * frame transfer mode. On the write (transmit) side, the choices are DRE or via
- * the holding structure. Both methods allow unaligned transfers. On the read
- * (receive) side, the only choice is the holding structure.
- *
- * This function should be called only from XTemac_Initialize().
- *
- * @param InstancePtr is a pointer to the instance to be worked on.
- *
- * @return XST_SUCCESS or XST_FAILURE if an error was detected
- *
- ******************************************************************************/
-int XTemac_ConfigureFifoAccess(XTemac *InstancePtr)
-{
-	int Result;
-
-	/* Initialize the packet FIFOs */
-	Result = XPacketFifoV200a_Initialize(&InstancePtr->RecvFifo.Fifo,
-					     InstancePtr->BaseAddress +
-					     XTE_PFIFO_RXREG_OFFSET,
-					     InstancePtr->BaseAddress +
-					     XTE_PFIFO_RXDATA_OFFSET);
-	if (Result != XST_SUCCESS) {
-		return (XST_FAILURE);
-	}
-
-	Result = XPacketFifoV200a_Initialize(&InstancePtr->SendFifo.Fifo,
-					     InstancePtr->BaseAddress +
-					     XTE_PFIFO_TXREG_OFFSET,
-					     InstancePtr->BaseAddress +
-					     XTE_PFIFO_TXDATA_OFFSET);
-
-	if (Result != XST_SUCCESS) {
-		return (XST_FAILURE);
-	}
-
-	/* Choose an access algorithm.
-	 * Note: 64-bit wide FIFO is the only width supported at this time
-	 */
-	InstancePtr->RecvFifo.Width = PFIFO_64BIT_WIDTH_BYTES;
-	InstancePtr->RecvFifo.XferFn = Read_64;
-	InstancePtr->SendFifo.Width = PFIFO_64BIT_WIDTH_BYTES;
-	InstancePtr->SendFifo.XferFn = Write_64;
-
-	/* Initialize the holds */
-	mHoldS_SetEmpty(&InstancePtr->SendFifo);
-	mHoldR_SetEmpty(&InstancePtr->RecvFifo);
-
-	return (XST_SUCCESS);
-}
-
-/******************************************************************************/
-/**
- * Copy data from a user buffer to the transmit packet FIFO. The data copied
- * may comprise of single, multiple, or partial packets. The data is not
- * transmitted until XTemac_FifoSend() is called.
- *
- * If the user buffer contains multiple packets, then extra care must be taken.
- * In this special situation, the end of one packet and the beginning of a new
- * packet is specified within the user buffer. The beginning of each NEW packet
- * must begin on a 4 byte alignment. The user is responsible for adding filler
- * data between packets to acheive this alignment. The amount of filler data
- * depends on what byte the end of the previous packet falls on. When calling
- * XTemac_FifoSend() to transmit the packets, DO NOT specify the filler bytes
- * in the TxByteCount parameter. For example, if a user buffer contains two
- * complete packets of 15 bytes each with 1 byte of filler between them, then
- * XTemac_FifoWrite() is called once to write all 31 bytes to the FIFO.
- * XTemac_FifoSend() is called twice specifying 15 bytes each time to transmit
- * the packets (the 1 byte of filler data is ignored by the TEMAC). Of course
- * you could also just call XTemac_FifoWrite() once for each packet. This way,
- * the driver will manage the filler data.
- *
- * If the user's buffer is not aligned on a 4 byte boundary, then the transfer
- * may take longer to complete.
- *
- * @param InstancePtr is a pointer to the instance to be worked on.
- * @param BufPtr is the buffer containing user data that will be transferred
- *        into the transmit FIFO. The buffer may be on any alignment.
- * @param ByteCount is the number of bytes to transfer from 1 to the number
- *        of bytes available in the FIFO at the time of invocation. See usage
- *        note for situations when a value of 0 is legal.
- * @param Eop specifies whether the last byte of BufPtr marks the End Of Packet.
- *        If set to XTE_END_OF_PACKET, then any partial bytes being buffered by
- *        the driver are flushed into the packet FIFO. If set to
- *        XTE_PARTIAL_PACKET, then more packet data is expected to be written
- *        through more calls to this function. Failure to use XTE_END_OF_PACKET
- *        prior to calling XTemac_FifoSend() may cause a packet FIFO underrun.
- *
- * @return
- * - XST_SUCCESS if the data was transferred to the FIFO.
- * - XST_DEVICE_IS_STOPPED if the device has not been started.
- * - XST_PFIFO_ERROR if there was a packet FIFO overflow during the transfer.
- *   This is a fatal condition. If this value is returned in polled mode, then
- *   the device must be reset. For interrupt driven modes, an interrupt will be
- *   asserted resulting in a call to the registered error handler which should
- *   handle reset of the device.
- * - XST_IPIF_ERROR if a data or bus error occurred within the TEMAC's IPIF.
- *   Like the PFIFO error, this is a fatal condition and should be handled
- *   in the same manner.
- *
- * @note
- * Calling this function with ByteCount = 0 will not result in the transfer of
- * data from BufPtr to the FIFO. However, if at the same time Eop is set to
- * XTE_END_OF_PACKET, then all data previously written with this function is
- * guaranteed to be flushed into the packet FIFO and available for transmission
- * with XTemac_FifoSend().
- ******************************************************************************/
-int XTemac_FifoWrite(XTemac *InstancePtr, void *BufPtr, u32 ByteCount, int Eop)
-{
-	u32 RegDISR;
-
-	XASSERT_NONVOID(InstancePtr != NULL);
-	XASSERT_NONVOID(InstancePtr->IsReady == XCOMPONENT_IS_READY);
-	XASSERT_NONVOID(!
-			((Eop != XTE_END_OF_PACKET) &&
-			 (Eop != XTE_PARTIAL_PACKET)));
-
-	/* Make sure device is ready for this operation */
-	if (InstancePtr->IsStarted != XCOMPONENT_IS_STARTED) {
-		return (XST_DEVICE_IS_STOPPED);
-	}
-
-	/* Transfer the data using the best/fastest method */
-	InstancePtr->SendFifo.XferFn(&InstancePtr->SendFifo, BufPtr, ByteCount,
-				     Eop);
-
-	/* Make sure the packet FIFO didn't report an error */
-	RegDISR = XTemac_mGetIpifReg(XTE_DISR_OFFSET);
-	if (RegDISR & XTE_DXR_SEND_FIFO_MASK) {
-		/* Only bump stats in polled mode. For interrupt driven mode, this stat
-		 * is bumped in XTemac_IntrFifoHandler()
-		 */
-		if (InstancePtr->Options & XTE_POLLED_OPTION) {
-			XTemac_mBumpStats(TxPktFifoErrors, 1);
-		}
-		return (XST_PFIFO_ERROR);
-	}
-
-	/* Verify no IPIF errors */
-	if (RegDISR & (XTE_DXR_DPTO_MASK | XTE_DXR_TERR_MASK)) {
-		/* Only bump stats in polled mode. For interrupt driven mode, this stat
-		 * is bumped in XTemac_IntrFifoHandler()
-		 */
-		if (InstancePtr->Options & XTE_POLLED_OPTION) {
-			XTemac_mBumpStats(IpifErrors, 1);
-		}
-		return (XST_IPIF_ERROR);
-	}
-
-	return (XST_SUCCESS);
-}
-
-
-/******************************************************************************/
-/**
- * Initiate a transmit of one packet of data previously written with
- * XTemac_FifoWrite(). The given length in bytes is written to the transmit
- * length FIFO. There should be at least this many bytes in the packet FIFO
- * ready for transmit.
- *
- * If FIFO interrupts are enabled (see XTemac_IntrFifoEnable()), then upon
- * completion of the transmit, the registered XTemac_FifoSendHandler() is
- * invoked.
- *
- * If more bytes that are in the packet FIFO are specified in the TxByteCount
- * parameter, then a packet FIFO underrun error will result.
- *
- * @param InstancePtr is a pointer to the instance to be worked on.
- * @param TxByteCount is the number of bytes to transmit. Range is 1 to the
- *        total number of bytes available in the packet FIFO to be transmitted.
- *
- * @return
- * - XST_SUCCESS if transmit was initiated.
- * - XST_DEVICE_IS_STOPPED if the device has not been started.
- * - XST_FIFO_NO_ROOM if the transmit was not initiated because the transmit
- *   length FIFO was full. This is not a fatal condition. The user may need to
- *   wait for other packets to transmit before this condition clears itself.
- *
- ******************************************************************************/
-int XTemac_FifoSend(XTemac *InstancePtr, u32 TxByteCount)
-{
-	u32 RegIPISR;
-
-	XASSERT_NONVOID(InstancePtr != NULL);
-	XASSERT_NONVOID(InstancePtr->IsReady == XCOMPONENT_IS_READY);
-	XASSERT_NONVOID(TxByteCount != 0);
-
-	/* Make sure device is ready for this operation */
-	if (InstancePtr->IsStarted != XCOMPONENT_IS_STARTED) {
-		return (XST_DEVICE_IS_STOPPED);
-	}
-
-	/* See if transmit length FIFO is full. If it is, try to clear the
-	 * status. If it the status remains, then return an error
-	 */
-	RegIPISR = XTemac_mGetIpifReg(XTE_IPISR_OFFSET);
-	if (RegIPISR & XTE_IPXR_XMIT_LFIFO_FULL_MASK) {
-		XTemac_mSetIpifReg(XTE_IPISR_OFFSET,
-				   XTE_IPXR_XMIT_LFIFO_FULL_MASK);
-
-		RegIPISR = XTemac_mGetIpifReg(XTE_IPISR_OFFSET);
-		if (RegIPISR & XTE_IPXR_XMIT_LFIFO_FULL_MASK) {
-			XTemac_mBumpStats(FifoErrors, 1);
-			return (XST_FIFO_NO_ROOM);
-		}
-	}
-
-	/* Start transmit */
-	XTemac_mSetIpifReg(XTE_TPLR_OFFSET, TxByteCount);
-
-	/* Return sucess */
-	return (XST_SUCCESS);
-}
-
-
-/******************************************************************************/
-/**
- * Return the length of a received packet. If a packet is waiting in the
- * receive packet FIFO, then it may be copied to a user buffer with
- * XTemac_FifoRead().
- *
- * @param InstancePtr is a pointer to the instance to be worked on.
- * @param ByteCountPtr is the length of the next received packet if the return
- *        status is XST_SUCCESS.
- *
- * @return
- * - XST_SUCCESS if a packet has been received and a value has been written to
- *   ByteCountPtr.
- * - XST_DEVICE_IS_STOPPED if the device has been stopped.
- * - XST_NO_DATA if no packet length is available. ByteCountPtr is not modified.
- *
- ******************************************************************************/
-int XTemac_FifoRecv(XTemac *InstancePtr, u32 *ByteCountPtr)
-{
-	u32 RegIPISR;
-	volatile u32 RegRSR;
-
-	XASSERT_NONVOID(InstancePtr != NULL);
-	XASSERT_NONVOID(InstancePtr->IsReady == XCOMPONENT_IS_READY);
-	XASSERT_NONVOID(ByteCountPtr != NULL);
-
-	/* Make sure device is ready for this operation */
-	if (InstancePtr->IsStarted != XCOMPONENT_IS_STARTED) {
-		return (XST_DEVICE_IS_STOPPED);
-	}
-
-	/* If the receive length FIFO is empty, then there's no packet waiting */
-	RegIPISR = XTemac_mGetIpifReg(XTE_IPISR_OFFSET);
-	if (!(RegIPISR & XTE_IPXR_RECV_DONE_MASK)) {
-		return (XST_NO_DATA);
-	}
-
-	/* Get the length */
-	*ByteCountPtr = XTemac_mGetIpifReg(XTE_RPLR_OFFSET);
-
-	/* The IPXR_RECV_DONE_MASK status bit is tied to the RSR register. To clear
-	 * this condition, read from the RSR (which has no information) then write
-	 * to the IPISR register to ack the status.
-	 */
-	RegRSR = XTemac_mGetIpifReg(XTE_RSR_OFFSET);
-	XTemac_mSetIpifReg(XTE_IPISR_OFFSET, XTE_IPXR_RECV_DONE_MASK);
-
-	/* Return sucess */
-	return (XST_SUCCESS);
-}
-
-
-/******************************************************************************/
-/**
- * Copy data from the receive packet FIFO into a user buffer. The number of
- * bytes to copy is derived from XTemac_FifoRecv(). The packet data may be
- * copied out of the FIFO all at once or with multiple calls to this function.
- * The latter method supports systems that keep packet data in non-contiguous
- * memory regions. For example:
- * <pre>
- *    if (XTemac_FifoRecv(Tptr, &PacketLength) == XST_SUCCESS)
- *    {
- *       if (PacketLength > 14)
- *       {
- *          HeaderLength = 14;
- *          PayloadLength = PacketLength - HeaderLength;
- *
- *          Status =  XTemac_FifoRead(Tptr, UserHeaderBuf, HeaderLength,
- *                                    XTE_PARTIAL_PACKET);
- *          Status |= XTemac_FifoRead(Tptr, UserPayloadBuf, PayloadLength,
- *                                    XTE_END_OF_PACKET);
- *
- *          if (Status != XST_SUCCESS)
- *          {
- *             // handle error
- *          }
- *       }
- *    }
- * </pre>
- *
- * If the user's buffer is not aligned on a 4 byte boundary, then the transfer
- * may take longer to complete.
- *
- * @param InstancePtr is a pointer to the instance to be worked on.
- * @param BufPtr is the user buffer that will recieve packet data from the FIFO.
- *        The buffer may be on any alignment.
- * @param ByteCount is the number of bytes to transfer
- * @param Eop specifies whether the last byte read is the last byte of a packet.
- *        If set to XTE_END_OF_PACKET, then any partial bytes being buffered by
- *        the driver at the end of the transfer are discarded. These discarded
- *        bytes are filler provided by the hardware and have no meaning. If set
- *        to XTE_PARTIAL_PACKET, then more packet data is expected to be read
- *        through more calls to this function. Failure to use this parameter
- *        properly will result in undefined filler bytes being copied into
- *        BufPtr.
- *
- * @return
- * - XST_SUCCESS if the data was transferred to the user buffer
- * - XST_DEVICE_IS_STOPPED if the device has not been started.
- * - XST_NO_DATA if there was not enough data in the packet FIFO to satisfy the
- *   request.
- *
- * @note
- * Do not attempt to read more than one packets worth of data at a time with
- * this function.
- ******************************************************************************/
-int XTemac_FifoRead(XTemac *InstancePtr, void *BufPtr, u32 ByteCount, int Eop)
-{
-	int Status;
-
-	XASSERT_NONVOID(InstancePtr != NULL);
-	XASSERT_NONVOID(InstancePtr->IsReady == XCOMPONENT_IS_READY);
-	XASSERT_NONVOID(!
-			((Eop != XTE_END_OF_PACKET) &&
-			 (Eop != XTE_PARTIAL_PACKET)));
-
-	/* Make sure device is ready for this operation */
-	if (InstancePtr->IsStarted != XCOMPONENT_IS_STARTED) {
-		return (XST_DEVICE_IS_STOPPED);
-	}
-
-	/* Transfer the data using the best/fastest method */
-	Status = InstancePtr->RecvFifo.XferFn(&InstancePtr->RecvFifo, BufPtr,
-					      ByteCount, Eop);
-
-	/* Return correct status */
-	if (Status == XST_NO_DATA) {
-		return (XST_NO_DATA);
-	}
-	else {
-		return (XST_SUCCESS);
-	}
-}
-
-
-/******************************************************************************/
-/**
- * Retrieve the number of free bytes in the packet FIFOs.
- *
- * For the transmit packet FIFO, the number returned is the number of bytes
- * that can be written by XTemac_FifoWrite(). If a non-zero number is returned,
- * then at least 1 packet of that size can be transmitted.
- *
- * For the receive packet FIFO, the number returned is the number of bytes that
- * can arrive from an external Ethernet device. This number does not reflect
- * the state of the receive length FIFO. If this FIFO is full, then arriving
- * packets will get dropped by the HW if there is no place to store the length.
- *
- * @param InstancePtr is a pointer to the instance to be worked on.
- * @param Direction selects which packet FIFO to examine. If XTE_SEND, then
- *        the transmit packet FIFO is selected. If XTE_RECV, then the receive
- *        packet FIFO is selected.
- *
- * @return
- * Number of bytes available in the selected packet FIFO.
- *
- ******************************************************************************/
-u32 XTemac_FifoGetFreeBytes(XTemac *InstancePtr, u32 Direction)
-{
-	u32 RegIPISR;
-	u32 Count;
-
-	XASSERT_NONVOID(InstancePtr != NULL);
-	XASSERT_NONVOID(InstancePtr->IsReady == XCOMPONENT_IS_READY);
-	XASSERT_NONVOID(!(Direction & ~(XTE_SEND | XTE_RECV)));
-
-	/* For the send direction, even though there may be room in the
-	 * packet FIFO, the length FIFO may be full. When this is the case,
-	 * another packet cannot be transmiited so return 0.
-	 */
-	if (Direction == XTE_SEND) {
-		/* Check length FIFO */
-		RegIPISR = XTemac_mGetIpifReg(XTE_IPISR_OFFSET);
-		if (RegIPISR & XTE_IPXR_XMIT_LFIFO_FULL_MASK) {
-			return (0);
-		}
-
-		/* Get FIFO entries */
-		Count = XPF_V200A_GET_COUNT(&InstancePtr->SendFifo.Fifo);
-	}
-
-	/* Handle receive direction */
-	else {
-		Count = XPF_V200A_COUNT_MASK -
-			XPF_V200A_GET_COUNT(&InstancePtr->RecvFifo.Fifo);
-	}
-
-	/* Multiply free entries by the width of the packet FIFO to arrive at
-	 * bytes
-	 */
-	return (Count * InstancePtr->RecvFifo.Width);
-}
-
-
-/******************************************************************************/
-/**
- * Query the device for the latest transmit status for FIFO direct frame
- * transfer mode. This function should be used for polled mode operation only.
- *
- * @param InstancePtr is a pointer to the instance to be worked on.
- * @param SendStatusPtr is the contents of the XTE_TSR_OFFSET register when the
- *        return code is XST_FAILURE. Otherwise 0 is returned.
- *
- * @return
- * - XST_NO_DATA if a transmit status is not currently available.
- * - XST_DEVICE_IS_STOPPED if the device has not been started.
- * - XST_NOT_POLLED if the device has not been set to polled mode.
- * - XST_SUCCESS if a transmit status was found and indicates that there was
- *   no error.
- * - XST_FIFO_ERROR if the transmit length or transmit status FIFOs error has
- *   been detected. If this error is returned, then the device must be reset
- *   before this function will return a valid transmit status indication.
- * - XST_PFIFO_ERROR if the transmit packet FIFO is deadlocked. If this error
- *   is returned, then the device must be reset before this function will
- *   return a valid transmit status indication
- * - XST_IPIF_ERROR if there has been a data phase timeout or transaction error
- *   in the IPIF. This is a fatal error.
- *
- * @note
- * When XST_FAILURE is returned with the XTE_TSR_PFIFOU_MASK bit set in the
- * SendStatusPtr parameter, then an attempt was made to transmit more data than
- * was present in the packet FIFO. No reset is required in this situation.
- *
- ******************************************************************************/
-int XTemac_FifoQuerySendStatus(XTemac *InstancePtr, u32 *SendStatusPtr)
-{
-	u32 RegDISR;
-	u32 RegIPISR;
-
-	XASSERT_NONVOID(InstancePtr != NULL);
-	XASSERT_NONVOID(InstancePtr->IsReady == XCOMPONENT_IS_READY);
-	XASSERT_NONVOID(SendStatusPtr != NULL);
-
-	/* Make sure device is ready for this operation */
-	if (InstancePtr->IsStarted != XCOMPONENT_IS_STARTED) {
-		return (XST_DEVICE_IS_STOPPED);
-	}
-
-	/* Have to be in polled mode to use this function */
-	if (!(InstancePtr->Options & XTE_POLLED_OPTION)) {
-		return (XST_NOT_POLLED);
-	}
-
-	/* Make sure send packet FIFO isn't deadlocked */
-	RegDISR = XTemac_mGetIpifReg(XTE_DISR_OFFSET);
-	if (RegDISR & XTE_DXR_SEND_FIFO_MASK) {
-		XTemac_mBumpStats(TxPktFifoErrors, 1);
-		return (XST_PFIFO_ERROR);
-	}
-
-	/* Make sure no IPIF errors are present */
-	if (RegDISR & (XTE_DXR_TERR_MASK | XTE_DXR_DPTO_MASK)) {
-		XTemac_mBumpStats(IpifErrors, 1);
-		return (XST_IPIF_ERROR);
-	}
-
-	/* Read the IPISR
-	 * If any errors are detetected, try to clear and return error
-	 */
-	RegIPISR = XTemac_mGetIpifReg(XTE_IPISR_OFFSET);
-	if (RegIPISR & XTE_IPXR_XMIT_ERROR_MASK) {
-		XTemac_mSetIpifReg(XTE_IPISR_OFFSET,
-				   RegIPISR & XTE_IPXR_XMIT_ERROR_MASK);
-		XTemac_mBumpStats(FifoErrors, 1);
-		return (XST_FIFO_ERROR);
-	}
-
-	/* No FIFO errors, so see of a transmit has completed */
-	if (!(RegIPISR & XTE_IPXR_XMIT_DONE_MASK)) {
-		return (XST_NO_DATA);
-	}
-
-	/* Transmit has completed, get the status, ack the condition */
-	*SendStatusPtr = XTemac_mGetIpifReg(XTE_TSR_OFFSET);
-	XTemac_mSetIpifReg(XTE_IPISR_OFFSET, XTE_IPXR_XMIT_DONE_MASK);
-
-	/* no errors to report */
-	return (XST_SUCCESS);
-}
-
-
-/******************************************************************************/
-/**
- * Query the device for the latest receive status for FIFO direct frame
- * transfer mode. This function should be used for polled mode operation only.
- *
- * @param InstancePtr is a pointer to the instance to be worked on.
- *
- * @return
- * - XST_SUCCESS if a frame has been received and no receive error was detected.
- * - XST_DEVICE_IS_STOPPED if the device has not been started.
- * - XST_NO_DATA if no frame has been received and no receive related error has
- *   been detected.
- * - XST_NOT_POLLED if the device has not been set to polled mode.
- * - XST_DATA_LOST if the device reports that it dropped a receive frame. This
- *   is not a serious problem but may indicate that frames are arriving faster
- *   than the system can process them.
- * - XST_FIFO_ERROR if an error was detected with the receive length FIFO. If
- *   this error is returned, then the device must be reset before any new frame
- *   can be received.
- * - XST_PFIFO_ERROR if the receive packet FIFO is deadlocked. If this error is
- *   returned, then the device must be reset before any new frame can be
- *   received.
- * - XST_IPIF_ERROR if there has been a data phase timeout or transaction error
- *   in the IPIF. This is a fatal error.
- *
- * @note
- * In situations where simultaneously a frame has been received for which an
- * XST_SUCCESS can be returned and a dropped frame for which an XST_DATA_LOST
- * can be returned, then this function will give priority to XST_SUCCESS so the
- * user can receive the frame.
- ******************************************************************************/
-int XTemac_FifoQueryRecvStatus(XTemac *InstancePtr)
-{
-	u32 RegDISR;
-	u32 RegIPISR;
-
-	XASSERT_NONVOID(InstancePtr != NULL);
-	XASSERT_NONVOID(InstancePtr->IsReady == XCOMPONENT_IS_READY);
-
-	/* Make sure device is ready for this operation */
-	if (InstancePtr->IsStarted != XCOMPONENT_IS_STARTED) {
-		return (XST_DEVICE_IS_STOPPED);
-	}
-
-	/* Have to be in polled mode to use this function */
-	if (!(InstancePtr->Options & XTE_POLLED_OPTION)) {
-		return (XST_NOT_POLLED);
-	}
-
-	/* Read the DISR */
-	RegDISR = XTemac_mGetIpifReg(XTE_DISR_OFFSET);
-
-	/* Make sure recv packet FIFO isn't deadlocked */
-	if (RegDISR & XTE_DXR_RECV_FIFO_MASK) {
-		XTemac_mBumpStats(RxPktFifoErrors, 1);
-		return (XST_PFIFO_ERROR);
-	}
-
-	/* Make sure no IPIF errors are present */
-	if (RegDISR & (XTE_DXR_TERR_MASK | XTE_DXR_DPTO_MASK)) {
-		XTemac_mBumpStats(IpifErrors, 1);
-		return (XST_IPIF_ERROR);
-	}
-
-	/* Read the IPISR */
-	RegIPISR = XTemac_mGetIpifReg(XTE_IPISR_OFFSET);
-
-	/* Check for other recv related FIFO errors */
-	if (RegIPISR & (XTE_IPXR_RECV_ERROR_MASK - XTE_IPXR_RECV_DROPPED_MASK)) {
-		XTemac_mSetIpifReg(XTE_IPISR_OFFSET,
-				   RegIPISR & XTE_IPXR_RECV_ERROR_MASK);
-		XTemac_mBumpStats(FifoErrors, 1);
-		return (XST_FIFO_ERROR);
-	}
-
-	/* See if a frame has been received */
-	if (RegIPISR & XTE_IPXR_RECV_DONE_MASK) {
-		return (XST_SUCCESS);
-	}
-
-	/* If option to detect recv reject errors is set, check for rejected
-	 * receive frames. If one is detected, clear it and return error.
-	 */
-	if (InstancePtr->Options & XTE_REPORT_RXERR_OPTION) {
-		if (RegIPISR & XTE_IPXR_RECV_DROPPED_MASK) {
-			XTemac_mSetIpifReg(XTE_IPISR_OFFSET,
-					   RegIPISR &
-					   XTE_IPXR_RECV_DROPPED_MASK);
-			return (XST_DATA_LOST);
-		}
-	}
-
-	/* No frame has been received and no errors detected */
-	return (XST_NO_DATA);
-}
-
-
-/*******************************************************************************
-* Algorithm to write to a 64 bit wide transmit packet FIFO through the holding
-* buffer.
-*
-* @param FPtr is a pointer to a Temac FIFO instance to worked on.
-* @param BufPtr is the source buffer address on any alignment
-* @param ByteCount is the number of bytes to transfer
-* @param Eop specifies whether the last byte written is the last byte of the
-*        packet.
-*
-* @return XST_SUCCESS
-*******************************************************************************/
-static int Write_64(XTemac_PacketFifo *Fptr, void *BufPtr,
-		    u32 ByteCount, int Eop)
-{
-	unsigned BufAlignment = (unsigned) BufPtr & 3;
-	unsigned PartialBytes;
-	unsigned HoldAlignment = mHold_GetIndex(Fptr);
-
-	/* Case 1: Buffer aligned on 4-byte boundary and Hold is empty
-	 *
-	 *   1. Write all bytes using the fastest transfer method
-	 */
-	if ((BufAlignment == 0) && (mHoldS_IsEmpty(Fptr))) {
-		Write64_Aligned(Fptr, (u32 *) BufPtr, ByteCount);
-	}
-
-	/* Case 2: Buffer and Hold are byte aligned with each other
-	 *
-	 *   1. Transfer enough bytes from the buffer to the Hold to trigger a flush
-	 *      to the FIFO.
-	 *
-	 *   2. The state of the buffer and Hold are as described by Case 1 so
-	 *      write remaining bytes using the fastest transfer method
-	 */
-	else if (BufAlignment == (HoldAlignment % PFIFO_64BIT_WIDTH_BYTES)) {
-		PartialBytes = PFIFO_64BIT_WIDTH_BYTES - HoldAlignment;
-
-		if (ByteCount < PartialBytes) {
-			PartialBytes = ByteCount;
-		}
-
-		Write64_Unaligned(Fptr, BufPtr, PartialBytes);
-		Write64_Aligned(Fptr, (u32 *) ((u32) BufPtr + PartialBytes),
-				ByteCount - PartialBytes);
-	}
-
-	/* Case 3: No alignment to take advantage of
-	 *
-	 *    1. Read FIFOs using the slower method.
-	 */
-	else {
-		Write64_Unaligned(Fptr, BufPtr, ByteCount);
-	}
-
-	/* If TxBytes is non-zero then the caller wants to transmit data from the
-	 * FIFO
-	 */
-	if (Eop == XTE_END_OF_PACKET) {
-		/* Push the hold to the FIFO if data is present */
-		if (!mHoldS_IsEmpty(Fptr)) {
-			mPush64(Fptr);
-			mHoldS_SetEmpty(Fptr);
-		}
-	}
-
-	return (XST_SUCCESS);
-}
-
-
-/*******************************************************************************
-* Algorithm to read from a 64 bit wide receive packet FIFO with through the
-* holding buffer.
-*
-* @param Fptr is a pointer to a Temac FIFO instance to worked on.
-* @param BufPtr is the destination address on any alignment
-* @param ByteCount is the number of bytes to transfer
-*
-* @return XST_SUCCESS if transfer completed or XST_NO_DATA if the amount of
-*         data being buffered by the driver plus the amount of data in the
-*         packet FIFO is not enough to satisfy the number of bytes requested
-*         by the ByteCount parameter.
-*******************************************************************************/
-static int Read_64(XTemac_PacketFifo *Fptr, void *BufPtr,
-		   u32 ByteCount, int Eop)
-{
-	unsigned BufAlignment = (unsigned) BufPtr & 3;
-	unsigned PartialBytes;
-	unsigned MaxBytes;
-	unsigned HoldAlignment = mHold_GetIndex(Fptr);
-
-	/* Determine how many bytes can be read from the packet FIFO */
-	MaxBytes = XPF_V200A_COUNT_MASK & XPF_V200A_GET_COUNT(&Fptr->Fifo);
-	MaxBytes *= PFIFO_64BIT_WIDTH_BYTES;
-
-	/* Case 1: Buffer aligned on 4-byte boundary and Hold is empty
-	 *
-	 *   1. Read all bytes using the fastest transfer method
-	 */
-	if ((BufAlignment == 0) && (mHoldR_IsEmpty(Fptr))) {
-		/* Enough data in fifo? */
-		if (ByteCount > MaxBytes) {
-			return (XST_NO_DATA);
-		}
-
-		Read64_Aligned(Fptr, (u32 *) BufPtr, ByteCount);
-	}
-
-	/* Case 2: Buffer and Hold are byte aligned with each other
-	 *
-	 *   1. Transfer enough bytes from the Hold to the buffer to trigger a
-	 *      read from the FIFO.
-	 *
-	 *   2. The state of the buffer and Hold are now as described by Case 1 so
-	 *      read remaining bytes using the fastest transfer method
-	 */
-	else if (BufAlignment == (HoldAlignment % PFIFO_64BIT_WIDTH_BYTES)) {
-		PartialBytes = PFIFO_64BIT_WIDTH_BYTES - HoldAlignment;
-
-		if (ByteCount < PartialBytes) {
-			PartialBytes = ByteCount;
-		}
-
-		/* Enough data in fifo? Must account for the number of bytes the driver
-		 * is currently buffering
-		 */
-		if (ByteCount > (MaxBytes + PartialBytes)) {
-			return (XST_NO_DATA);
-		}
-
-		Read64_Unaligned(Fptr, BufPtr, PartialBytes);
-		Read64_Aligned(Fptr, (u32 *) ((u32) BufPtr + PartialBytes),
-			       ByteCount - PartialBytes);
-	}
-
-	/* Case 3: No alignment to take advantage of
-	 *
-	 *    1. Read FIFOs using the slower method.
-	 */
-	else {
-		/* Enough data in fifo? Must account for the number of bytes the driver
-		 * is currently buffering
-		 */
-		PartialBytes = PFIFO_64BIT_WIDTH_BYTES - HoldAlignment;
-		if (ByteCount > (MaxBytes + PartialBytes)) {
-			return (XST_NO_DATA);
-		}
-
-		Read64_Unaligned(Fptr, BufPtr, ByteCount);
-	}
-
-	/* If this marks the end of packet, then dump any remaining data in the
-	 * hold. The dumped data in this context is meaningless.
-	 */
-	if (Eop == XTE_END_OF_PACKET) {
-		mHoldR_SetEmpty(Fptr);
-	}
-
-	return (XST_SUCCESS);
-}
-
-
-/*******************************************************************************
-* Write to the 64 bit holding buffer. Each time it becomes full, then it is
-* pushed to the transmit FIFO.
-*
-* @param F is a pointer to the packet FIFO instance to be worked on.
-* @param BufPtr is the source buffer address on any alignment
-* @param ByteCount is the number of bytes to transfer
-*
-*******************************************************************************/
-static void Write64_Unaligned(XTemac_PacketFifo *F, void *BufPtr, u32 ByteCount)
-{
-	u8 *SrcPtr = (u8 *) BufPtr;
-	unsigned FifoTransfersLeft;
-	unsigned PartialBytes;
-	unsigned BytesLeft;
-	unsigned i;
-
-	/* Stage 1: The hold may be partially full. Write enough bytes to it to
-	 * cause a push to the FIFO
-	 */
-
-	/* Calculate the number of bytes needed to trigger a push, if not enough
-	 * bytes have been specified to cause a push, then adjust accordingly
-	 */
-	i = mHold_GetIndex(F);
-	PartialBytes = PFIFO_64BIT_WIDTH_BYTES - i;
-	if (PartialBytes > ByteCount) {
-		PartialBytes = ByteCount;
-	}
-
-	/* Calculate the number of bytes remaining after the first push */
-	BytesLeft = ByteCount - PartialBytes;
-
-	/* Write to the hold and advance its index */
-	mHold_Advance(F, PartialBytes);
-
-	while (PartialBytes--) {
-		mHold_CopyIn(F, i, *SrcPtr);
-		SrcPtr++;
-		i++;
-	}
-
-	/* Push to fifo if needed */
-	if (mHoldS_IsFull(F)) {
-		mPush64(F);
-		mHoldS_SetEmpty(F);
-	}
-
-	/* No more data to process */
-	if (!BytesLeft) {
-		return;
-	}
-
-	/* Stage 2: The hold is empty now, if any more bytes are left to process, then
-	 * it will begin with nothing in the hold. Use the hold as a temporary storage
-	 * area to contain the data.
-	 *
-	 * The hold is filled then pushed out to the FIFOs a number of times based on
-	 * how many bytes are left to process.
-	 */
-
-	/* Calculate the number of times a push will need to occur */
-	FifoTransfersLeft = BytesLeft / PFIFO_64BIT_WIDTH_BYTES;
-
-	/* Calculate the number of partial bytes left after this stage */
-	PartialBytes =
-		BytesLeft - (FifoTransfersLeft * PFIFO_64BIT_WIDTH_BYTES);
-
-	/* Write to the hold and push data to the FIFO */
-	while (FifoTransfersLeft--) {
-		for (i = 0; i < PFIFO_64BIT_WIDTH_BYTES; i++) {
-			mHold_CopyIn(F, i, *SrcPtr);
-			SrcPtr++;
-		}
-		mPush64(F);
-	}
-
-	/* No more data to process
-	 * HoldIndex was left at 0 by stage 1, at this point, that is
-	 * still the correct value.
-	 */
-	if (!PartialBytes) {
-		return;
-	}
-
-	/* Stage 3: All that is left is to fill the hold with the remaining data
-	 * to be processed. There will be no push to the FIFO because there is not
-	 * enough data left to cause one.
-	 */
-
-	/* Write to the hold and push data to the FIFO */
-	for (i = 0; i < PartialBytes; i++) {
-		mHold_CopyIn(F, i, *SrcPtr);
-		SrcPtr++;
-	}
-
-	/* Set the hold's index to its final correct value */
-	mHold_SetIndex(F, PartialBytes);
-}
-
-
-/*******************************************************************************
-* Write directly to the 64 bit wide transmit FIFO from an aligned source
-* buffer. Leftover bytes are written to the holding buffer.
-*
-* @param F is a pointer to the packet FIFO instance to be worked on.
-* @param BufPtr is the source buffer address on 32-bit alignment
-* @param ByteCount is the number of bytes to transfer
-*
-*******************************************************************************/
-static void Write64_Aligned(XTemac_PacketFifo *F, u32 *BufPtr, u32 ByteCount)
-{
-	unsigned FifoTransfersLeft = ByteCount / PFIFO_64BIT_WIDTH_BYTES;
-	unsigned PartialBytes = ByteCount & (PFIFO_64BIT_WIDTH_BYTES - 1);
-
-	/* Direct transfer */
-	while (FifoTransfersLeft--) {
-		mWriteFifo64(F, BufPtr);
-		BufPtr += 2;
-	}
-
-	/* Leftover bytes are left in the holding area */
-	if (PartialBytes) {
-		Write64_Unaligned(F, BufPtr, PartialBytes);
-	}
-}
-
-
-/*******************************************************************************
-* Read into the 64 bit holding buffer from the receive packet FIFO.
-* Each time the holding buffer becomes full, then it is flushed to the
-* provided buffer.
-*
-* @param F is a pointer to the packet FIFO instance to be worked on.
-* @param BufPtr is the destination buffer address on any alignment
-* @param ByteCount is the number of bytes to transfer
-*
-*******************************************************************************/
-static void Read64_Unaligned(XTemac_PacketFifo *F, void *BufPtr, u32 ByteCount)
-{
-	u8 *DestPtr = (u8 *) BufPtr;
-	unsigned FifoTransfersLeft;
-	unsigned PartialBytes;
-	unsigned BytesLeft;
-	unsigned i;
-
-	/* Stage 1: The hold may have some residual bytes that must be flushed
-	 * to the buffer before anything is read from the FIFO
-	 */
-
-	/* Calculate the number of bytes to flush to the buffer from the hold.
-	 * If the number of bytes to flush is greater than the "Bytes" requested,
-	 * then adjust accordingly.
-	 */
-	i = mHold_GetIndex(F);
-	PartialBytes = PFIFO_64BIT_WIDTH_BYTES - i;
-
-	if (PartialBytes > ByteCount) {
-		PartialBytes = ByteCount;
-	}
-
-	/* Calculate the number of bytes remaining after flushing to the buffer */
-	BytesLeft = ByteCount - PartialBytes;
-
-	/* Move the hold's index forward */
-	mHold_Advance(F, PartialBytes);
-
-	/* Copy bytes */
-	while (PartialBytes--) {
-		mHold_CopyOut(F, i, *DestPtr);
-		i++;
-		DestPtr++;
-	}
-
-	/* No more data to process */
-	if (!BytesLeft) {
-		return;
-	}
-
-	/* Stage 2: The hold is empty now, if any more bytes are left to process, then
-	 * it will begin with nothing in the hold. Use the hold as a temporary storage
-	 * area to contain the data.
-	 *
-	 * The hold is filled with FIFO data, then that data is written to the buffer.
-	 * Do this FifoTransfersLeft times
-	 */
-
-	/* Calculate the number of times a push will need to occur */
-	FifoTransfersLeft = BytesLeft / PFIFO_64BIT_WIDTH_BYTES;
-
-	/* Calculate the number of partial bytes left after this stage */
-	PartialBytes =
-		BytesLeft - (FifoTransfersLeft * PFIFO_64BIT_WIDTH_BYTES);
-
-	/* Write to the hold and push data to the FIFO */
-	while (FifoTransfersLeft--) {
-		/* Load the hold with the next data set from the FIFO */
-		mPop64(F);
-
-		/* Write hold to buffer */
-		for (i = 0; i < PFIFO_64BIT_WIDTH_BYTES; i++) {
-			mHold_CopyOut(F, i, *DestPtr);
-			DestPtr++;
-		}
-	}
-
-	/* No more data to process
-	 * After processing full FIFO chunks of data, the hold is empty at this
-	 * point
-	 */
-	if (!PartialBytes) {
-		return;
-	}
-
-	/* Stage 3: All that is left is to fill the hold one more time with FIFO
-	 * data, then write the remaining requested bytes to the buffer
-	 */
-
-	/* Get FIFO data */
-	mPop64(F);
-
-	/* Copy bytes from the hold to the buffer */
-	for (i = 0; i < PartialBytes; i++) {
-		mHold_CopyOut(F, i, *DestPtr);
-		DestPtr++;
-	}
-
-	/* Set the hold's index to its final correct value */
-	mHold_SetIndex(F, PartialBytes);
-}
-
-
-/*******************************************************************************
-* Read directly from the 64 bit wide receive FIFO into an aligned destination
-* buffer. Leftover bytes are written to the holding buffer.
-*
-* @param F is a pointer to the packet FIFO instance to be worked on.
-* @param BufPtr is the destination buffer address on 32-bit alignment
-* @param ByteCount is the number of bytes to transfer
-*
-*******************************************************************************/
-static void Read64_Aligned(XTemac_PacketFifo *F, u32 *BufPtr, u32 ByteCount)
-{
-	unsigned FifoTransfersLeft = ByteCount / PFIFO_64BIT_WIDTH_BYTES;
-	unsigned PartialBytes = ByteCount & (PFIFO_64BIT_WIDTH_BYTES - 1);
-
-	/* Direct transfer */
-	while (FifoTransfersLeft--) {
-		mReadFifo64(F, BufPtr);
-		BufPtr += 2;
-	}
-
-	/* Leftover bytes are left in the holding area */
-	if (PartialBytes) {
-		Read64_Unaligned(F, BufPtr, PartialBytes);
-	}
-}
diff --git a/drivers/net/ethernet/xilinx/xilinx_temac/xtemac_i.h b/drivers/net/ethernet/xilinx/xilinx_temac/xtemac_i.h
deleted file mode 100644
index 17ff87b..0000000
--- a/drivers/net/ethernet/xilinx/xilinx_temac/xtemac_i.h
+++ /dev/null
@@ -1,118 +0,0 @@
-/* $Id: */
-/******************************************************************************
-*
-*       XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS"
-*       AS A COURTESY TO YOU, SOLELY FOR USE IN DEVELOPING PROGRAMS AND
-*       SOLUTIONS FOR XILINX DEVICES.  BY PROVIDING THIS DESIGN, CODE,
-*       OR INFORMATION AS ONE POSSIBLE IMPLEMENTATION OF THIS FEATURE,
-*       APPLICATION OR STANDARD, XILINX IS MAKING NO REPRESENTATION
-*       THAT THIS IMPLEMENTATION IS FREE FROM ANY CLAIMS OF INFRINGEMENT,
-*       AND YOU ARE RESPONSIBLE FOR OBTAINING ANY RIGHTS YOU MAY REQUIRE
-*       FOR YOUR IMPLEMENTATION.  XILINX EXPRESSLY DISCLAIMS ANY
-*       WARRANTY WHATSOEVER WITH RESPECT TO THE ADEQUACY OF THE
-*       IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OR
-*       REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE FROM CLAIMS OF
-*       INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
-*       FOR A PARTICULAR PURPOSE.
-*
-*       (c) Copyright 2005-2006 Xilinx Inc.
-*       All rights reserved.
-* This program is free software; you can redistribute it and/or modify it
-* under the terms of the GNU General Public License as published by the
-* Free Software Foundation; either version 2 of the License, or (at your
-* option) any later version.
-*
-* You should have received a copy of the GNU General Public License
-* along with this program; if not, write to the Free Software
-* Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-*
-******************************************************************************/
-/*****************************************************************************/
-/**
-*
-* @file xtemac_i.h
-*
-* This header file contains internal identifiers, which are those shared
-* between XTemac components. The identifiers in this file are not intended for
-* use external to the driver.
-*
-* <pre>
-* MODIFICATION HISTORY:
-*
-* Ver   Who  Date     Changes
-* ----- ---- -------- -------------------------------------------------------
-* 1.00a rmm  06/01/05 First release
-* 2.00a rmm  11/21/05 Removed simple dma
-* </pre>
-*
-******************************************************************************/
-
-#ifndef XTEMAC_I_H		/* prevent circular inclusions */
-#define XTEMAC_I_H		/* by using protection macros */
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-/***************************** Include Files *********************************/
-
-#include "xtemac.h"
-
-/************************** Constant Definitions *****************************/
-
-
-/* Internal flags kept in Instance's Flags attribute */
-#define XTE_FLAGS_RECV_SGDMA_INT_ENABLE   0x0020
-#define XTE_FLAGS_SEND_SGDMA_INT_ENABLE   0x0010
-#define XTE_FLAGS_RECV_FIFO_INT_ENABLE    0x0002
-#define XTE_FLAGS_SEND_FIFO_INT_ENABLE    0x0001
-
-/**************************** Type Definitions *******************************/
-
-
-/***************** Macros (Inline Functions) Definitions *********************/
-
-/*****************************************************************************
-* Statistics increment macros
-* The referenced InstancePtr is an implicitly assumed parameter.
-******************************************************************************/
-#define XTemac_mBumpStats(Counter, Value) \
-    InstancePtr->Stats.Counter += (Value);
-
-
-/*****************************************************************************
-* Register accessors.
-*
-* The goal of these four functions is to make the code look cleaner. These
-* simply wrap to the level 0 macros defined in xtemac_l.h.
-*
-* The referenced InstancePtr is an implicitly assumed parameter.
-*
-******************************************************************************/
-#define XTemac_mGetHostReg(RegOffset) \
-    XTemac_mReadHostReg(InstancePtr->BaseAddress, RegOffset)
-
-#define XTemac_mSetHostReg(RegOffset, Data) \
-    XTemac_mWriteHostReg(InstancePtr->BaseAddress, RegOffset, Data)
-
-#define XTemac_mGetIpifReg(RegOffset) \
-    XTemac_mReadReg(InstancePtr->BaseAddress, RegOffset)
-
-#define XTemac_mSetIpifReg(RegOffset, Data) \
-    XTemac_mWriteReg(InstancePtr->BaseAddress, RegOffset, Data)
-
-
-
-/************************** Function Prototypes ******************************/
-
-int XTemac_ConfigureFifoAccess(XTemac *InstancePtr);
-
-/************************** Variable Definitions *****************************/
-
-
-#ifdef __cplusplus
-}
-#endif
-
-
-#endif /* end of protection macro */
diff --git a/drivers/net/ethernet/xilinx/xilinx_temac/xtemac_intr.c b/drivers/net/ethernet/xilinx/xilinx_temac/xtemac_intr.c
deleted file mode 100644
index 516628c..0000000
--- a/drivers/net/ethernet/xilinx/xilinx_temac/xtemac_intr.c
+++ /dev/null
@@ -1,158 +0,0 @@
-/* $Id: */
-/******************************************************************************
-*
-*       XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS"
-*       AS A COURTESY TO YOU, SOLELY FOR USE IN DEVELOPING PROGRAMS AND
-*       SOLUTIONS FOR XILINX DEVICES.  BY PROVIDING THIS DESIGN, CODE,
-*       OR INFORMATION AS ONE POSSIBLE IMPLEMENTATION OF THIS FEATURE,
-*       APPLICATION OR STANDARD, XILINX IS MAKING NO REPRESENTATION
-*       THAT THIS IMPLEMENTATION IS FREE FROM ANY CLAIMS OF INFRINGEMENT,
-*       AND YOU ARE RESPONSIBLE FOR OBTAINING ANY RIGHTS YOU MAY REQUIRE
-*       FOR YOUR IMPLEMENTATION.  XILINX EXPRESSLY DISCLAIMS ANY
-*       WARRANTY WHATSOEVER WITH RESPECT TO THE ADEQUACY OF THE
-*       IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OR
-*       REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE FROM CLAIMS OF
-*       INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
-*       FOR A PARTICULAR PURPOSE.
-*
-*       (c) Copyright 2005-2006 Xilinx Inc.
-*       All rights reserved.
-* This program is free software; you can redistribute it and/or modify it
-* under the terms of the GNU General Public License as published by the
-* Free Software Foundation; either version 2 of the License, or (at your
-* option) any later version.
-*
-* You should have received a copy of the GNU General Public License
-* along with this program; if not, write to the Free Software
-* Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-*
-******************************************************************************/
-/*****************************************************************************/
-/**
-*
-* @file xtemac_intr.c
-*
-* Functions in this file implement general purpose interrupt processing related
-* functionality. See xtemac.h for a detailed description of the driver.
-*
-* <pre>
-* MODIFICATION HISTORY:
-*
-* Ver   Who  Date     Changes
-* ----- ---- -------- -------------------------------------------------------
-* 1.00a rmm  06/01/05 First release
-* 2.00a rmm  11/21/05 Added auto-negotiation callback, removed simple DMA
-*                     callback
-* </pre>
-******************************************************************************/
-
-/***************************** Include Files *********************************/
-
-#include "xtemac.h"
-
-/************************** Constant Definitions *****************************/
-
-
-/**************************** Type Definitions *******************************/
-
-
-/***************** Macros (Inline Functions) Definitions *********************/
-
-
-/************************** Function Prototypes ******************************/
-
-
-/************************** Variable Definitions *****************************/
-
-
-/*****************************************************************************/
-/**
- * Install an asynchronious handler function for the given HandlerType:
- *
- * <pre>
- * HandlerType               Function Type
- * ------------------------  ---------------------------
- * XTE_HANDLER_FIFOSEND      XTemac_FifoSendHandler
- * XTE_HANDLER_FIFORECV      XTemac_FifoRecvHandler
- * XTE_HANDLER_ANEG          XTemac_AnegHandler
- * XTE_HANDLER_SGSEND        XTemac_SgHandler
- * XTE_HANDLER_SGRECV        XTemac_SgHandler
- * XTE_HANDLER_ERROR         XTemac_ErrorHandler
- *
- * HandlerType               Invoked by this driver when:
- * ------------------------  --------------------------------------------------
- * XTE_HANDLER_FIFOSEND      A packet transmitted by a call to
- *                           XTemac_FifoSend() has been sent successfully.
- * XTE_HANDLER_FIFORECV      When a packet has been received and is sitting in
- *                           the packet FIFO.
- * XTE_HANDLER_ANEG          Auto negotiation interrupt is asserted by HW and
- *                           XTE_ANEG_OPTION is set.
- * XTE_HANDLER_SGSEND        SG DMA has completed an operation on the transmit
- *                           side. Transmitted buffer descriptors require post
- *                           processing.
- * XTE_HANDLER_SGRECV        SG DMA has completed an operation on the receive
- *                           side. Buffer descriptors contain received packets.
- * XTE_HANDLER_ERROR         Any type of error has been detected.
- * </pre>
- *
- * @param InstancePtr is a pointer to the instance to be worked on.
- * @param HandlerType specifies which handler is to be attached.
- * @param CallbackFunc is the address of the callback function
- * @param CallbackRef is a user data item that will be passed to the callback
- *        when it is invoked.
- *
- * @return
- * - XST_SUCCESS when handler is installed.
- * - XST_INVALID_PARAM when HandlerType is invalid
- *
- * @note
- * Invoking this function for a handler that already has been installed replaces
- * it with the new handler.
- *
- ******************************************************************************/
-int XTemac_SetHandler(XTemac *InstancePtr, u32 HandlerType,
-		      void *CallbackFunc, void *CallbackRef)
-{
-	XASSERT_NONVOID(InstancePtr != NULL);
-	XASSERT_NONVOID(InstancePtr->IsReady == XCOMPONENT_IS_READY);
-	XASSERT_NONVOID(CallbackFunc != NULL);
-
-	switch (HandlerType) {
-	case XTE_HANDLER_FIFOSEND:
-		InstancePtr->FifoSendHandler =
-			(XTemac_FifoSendHandler) CallbackFunc;
-		InstancePtr->FifoSendRef = CallbackRef;
-		break;
-
-	case XTE_HANDLER_FIFORECV:
-		InstancePtr->FifoRecvHandler =
-			(XTemac_FifoRecvHandler) CallbackFunc;
-		InstancePtr->FifoRecvRef = CallbackRef;
-		break;
-
-	case XTE_HANDLER_ANEG:
-		InstancePtr->AnegHandler = (XTemac_AnegHandler) CallbackFunc;
-		InstancePtr->AnegRef = CallbackRef;
-		break;
-
-	case XTE_HANDLER_SGSEND:
-		InstancePtr->SgSendHandler = (XTemac_SgHandler) CallbackFunc;
-		InstancePtr->SgSendRef = CallbackRef;
-		break;
-
-	case XTE_HANDLER_SGRECV:
-		InstancePtr->SgRecvHandler = (XTemac_SgHandler) CallbackFunc;
-		InstancePtr->SgRecvRef = CallbackRef;
-		break;
-
-	case XTE_HANDLER_ERROR:
-		InstancePtr->ErrorHandler = (XTemac_ErrorHandler) CallbackFunc;
-		InstancePtr->ErrorRef = CallbackRef;
-		break;
-
-	default:
-		return (XST_INVALID_PARAM);
-
-	}
-	return (XST_SUCCESS);
-}
diff --git a/drivers/net/ethernet/xilinx/xilinx_temac/xtemac_intr_fifo.c b/drivers/net/ethernet/xilinx/xilinx_temac/xtemac_intr_fifo.c
deleted file mode 100644
index 4a7ec83..0000000
--- a/drivers/net/ethernet/xilinx/xilinx_temac/xtemac_intr_fifo.c
+++ /dev/null
@@ -1,354 +0,0 @@
-/* $Id: */
-/******************************************************************************
-*
-*       XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS"
-*       AS A COURTESY TO YOU, SOLELY FOR USE IN DEVELOPING PROGRAMS AND
-*       SOLUTIONS FOR XILINX DEVICES.  BY PROVIDING THIS DESIGN, CODE,
-*       OR INFORMATION AS ONE POSSIBLE IMPLEMENTATION OF THIS FEATURE,
-*       APPLICATION OR STANDARD, XILINX IS MAKING NO REPRESENTATION
-*       THAT THIS IMPLEMENTATION IS FREE FROM ANY CLAIMS OF INFRINGEMENT,
-*       AND YOU ARE RESPONSIBLE FOR OBTAINING ANY RIGHTS YOU MAY REQUIRE
-*       FOR YOUR IMPLEMENTATION.  XILINX EXPRESSLY DISCLAIMS ANY
-*       WARRANTY WHATSOEVER WITH RESPECT TO THE ADEQUACY OF THE
-*       IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OR
-*       REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE FROM CLAIMS OF
-*       INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
-*       FOR A PARTICULAR PURPOSE.
-*
-*       (c) Copyright 2005-2006 Xilinx Inc.
-*       All rights reserved.
-* This program is free software; you can redistribute it and/or modify it
-* under the terms of the GNU General Public License as published by the
-* Free Software Foundation; either version 2 of the License, or (at your
-* option) any later version.
-*
-* You should have received a copy of the GNU General Public License
-* along with this program; if not, write to the Free Software
-* Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-*
-******************************************************************************/
-/*****************************************************************************/
-/**
-*
-* @file xtemac_intr_fifo.c
-*
-* Functions in this file implement interrupt related operations for
-* FIFO direct frame transfer mode. See xtemac.h for a detailed description of
-* the driver.
-*
-* <pre>
-* MODIFICATION HISTORY:
-*
-* Ver   Who  Date     Changes
-* ----- ---- -------- -------------------------------------------------------
-* 1.00a rmm  06/01/05 First release
-* 2.00a rmm  11/21/05 Removed simple DMA, added auto-negotiate handling,
-*                     removed XST_SEND_ERROR reporting
-* </pre>
-******************************************************************************/
-
-/***************************** Include Files *********************************/
-
-#include "xtemac.h"
-#include "xtemac_i.h"
-#include "xio.h"
-
-/************************** Constant Definitions *****************************/
-
-
-/**************************** Type Definitions *******************************/
-
-
-/***************** Macros (Inline Functions) Definitions *********************/
-
-/* shortcut macros */
-#define ERR_HANDLER(Class, Word1, Word2)  \
-    InstancePtr->ErrorHandler(InstancePtr->ErrorRef, Class, Word1, Word2)
-
-#define FIFOSEND_HANDLER(Cnt)  \
-    InstancePtr->FifoSendHandler(InstancePtr->FifoSendRef, Cnt)
-
-#define FIFORECV_HANDLER()  \
-    InstancePtr->FifoRecvHandler(InstancePtr->FifoRecvRef)
-
-#define ANEG_HANDLER()  \
-    InstancePtr->AnegHandler(InstancePtr->AnegRef)
-
-
-/************************** Function Prototypes ******************************/
-
-
-/************************** Variable Definitions *****************************/
-
-
-/*****************************************************************************/
-/**
- *
- * Enable FIFO related interrupts for FIFO direct frame transfer mode. Dma
- * interrupts are not affected.
- *
- * Do not use this function when using SG DMA frame transfer mode.
- *
- * @param InstancePtr is a pointer to the instance to be worked on.
- * @param Direction specifies whether the transmit related (XTE_SEND) or
- *        receive related (XTE_RECV) interrupts should be affected, or
- *        both (XTE_SEND | XTE_RECV).
- *
- * @return None
- *
- * @note The state of the transmitter and receiver are not modified by this
- *       function.
- *
- * @note If the device is configured for SGDMA, then this function has no
- *       effect. Use XTemac_IntrSgDmaDisable() instead.
- *
- ******************************************************************************/
-void XTemac_IntrFifoEnable(XTemac *InstancePtr, u32 Direction)
-{
-	u32 RegIPIER;
-
-	XASSERT_VOID(InstancePtr != NULL);
-	XASSERT_VOID(InstancePtr->IsReady == XCOMPONENT_IS_READY);
-	XASSERT_VOID(!(Direction & ~(XTE_SEND | XTE_RECV)));
-
-	/* Don't allow if device is configured for SGDMA */
-	if (XTemac_mIsSgDma(InstancePtr)) {
-		return;
-	}
-
-	/* Get contents of IPIER register */
-	RegIPIER = XTemac_mGetIpifReg(XTE_IPIER_OFFSET);
-
-	/* Handle send direction */
-	if (Direction & XTE_SEND) {
-		RegIPIER |=
-			(XTE_IPXR_XMIT_ERROR_MASK | XTE_IPXR_XMIT_DONE_MASK);
-		InstancePtr->Flags |= XTE_FLAGS_SEND_FIFO_INT_ENABLE;
-
-		/* Don't allow Tx status overrun interrupt if option is cleared */
-		if (!
-		    (InstancePtr->
-		     Options & XTE_REPORT_TXSTATUS_OVERRUN_OPTION)) {
-			RegIPIER &= ~XTE_IPXR_XMIT_SFIFO_OVER_MASK;;
-		}
-	}
-
-	/* Handle receive direction */
-	if (Direction & XTE_RECV) {
-		RegIPIER |=
-			(XTE_IPXR_RECV_ERROR_MASK | XTE_IPXR_RECV_DONE_MASK);
-		InstancePtr->Flags |= XTE_FLAGS_RECV_FIFO_INT_ENABLE;
-
-		/* Don't enable recv reject errors if option is cleared */
-		if (!(InstancePtr->Options & XTE_REPORT_RXERR_OPTION)) {
-			RegIPIER &= ~XTE_IPXR_RECV_DROPPED_MASK;
-		}
-	}
-
-	/* Update IPIER with new setting */
-	XTemac_mSetIpifReg(XTE_IPIER_OFFSET, RegIPIER);
-}
-
-
-/*****************************************************************************/
-/**
- *
- * Disable FIFO related interrupts for FIFO direct frame transfer mode. Dma
- * interrupts are not affected.
- *
- * Do not use this function when using SG DMA frame transfer mode.
- *
- * @param InstancePtr is a pointer to the instance to be worked on.
- * @param Direction specifies whether the transmit related (XTE_SEND) or
- *        receive related (XTE_RECV) interrupts should be affected, or
- *        both (XTE_SEND | XTE_RECV).
- *
- * @return None
- *
- * @note The state of the transmitter and receiver are not modified by this
- *       function.
- *
- * @note If the device is configured for SGDMA, then this function has no
- *       effect. Use XTemac_IntrSgDmaDisable() instead.
- *
- ******************************************************************************/
-void XTemac_IntrFifoDisable(XTemac *InstancePtr, u32 Direction)
-{
-	u32 RegIPIER;
-
-	XASSERT_VOID(InstancePtr != NULL);
-	XASSERT_VOID(InstancePtr->IsReady == XCOMPONENT_IS_READY);
-	XASSERT_VOID(!(Direction & ~(XTE_SEND | XTE_RECV)));
-
-	/* Don't allow if device is configured for SGDMA */
-	if (XTemac_mIsSgDma(InstancePtr)) {
-		return;
-	}
-
-	/* Get contents of IPIER register */
-	RegIPIER = XTemac_mGetIpifReg(XTE_IPIER_OFFSET);
-
-	/* Handle send direction */
-	if (Direction & XTE_SEND) {
-		RegIPIER &=
-			~(XTE_IPXR_XMIT_ERROR_MASK | XTE_IPXR_XMIT_DONE_MASK);
-		InstancePtr->Flags &= ~XTE_FLAGS_SEND_FIFO_INT_ENABLE;
-	}
-
-	/* Handle receive direction */
-	if (Direction & XTE_RECV) {
-		RegIPIER &=
-			~(XTE_IPXR_RECV_ERROR_MASK | XTE_IPXR_RECV_DONE_MASK);
-		InstancePtr->Flags &= ~XTE_FLAGS_RECV_FIFO_INT_ENABLE;
-	}
-
-	/* Update IPIER with new setting */
-	XTemac_mSetIpifReg(XTE_IPIER_OFFSET, RegIPIER);
-}
-
-
-
-/*****************************************************************************/
-/**
- *
- * Master interrupt handler for FIFO direct frame transfer mode. This routine
- * will query the status of the device, bump statistics, and invoke user
- * callbacks in the following priority:
- *
- * This routine must be connected to an interrupt controller using OS/BSP
- * specific methods.
- *
- * @param InstancePtr is a pointer to the TEMAC instance that has caused the
- *        interrupt.
- *
- * @return None
- *
- ******************************************************************************/
-void XTemac_IntrFifoHandler(void *TemacPtr)
-{
-	u32 RegDISR;
-	u32 CorePending;
-	u32 RegMisc;
-	unsigned Cnt;
-	XTemac *InstancePtr = (XTemac *) TemacPtr;
-
-	XASSERT_VOID(InstancePtr != NULL);
-
-	/* This ISR will try to handle as many interrupts as it can in a single
-	 * call. However, in most of the places where the user's error handler is
-	 * called, this ISR exits because it is expected that the user will reset
-	 * the device most of the time.
-	 */
-
-	/* Log interrupt */
-	XTemac_mBumpStats(Interrupts, 1);
-
-	/* Get top level interrupt status. The status is self clearing when the
-	 * interrupt source is cleared
-	 */
-	RegDISR = XTemac_mGetIpifReg(XTE_DISR_OFFSET);
-
-	/* Handle IPIF and packet FIFO errors */
-	if (RegDISR & (XTE_DXR_DPTO_MASK | XTE_DXR_TERR_MASK |
-		       XTE_DXR_RECV_FIFO_MASK | XTE_DXR_SEND_FIFO_MASK)) {
-		/* IPIF transaction or data phase error */
-		if (RegDISR & (XTE_DXR_DPTO_MASK | XTE_DXR_TERR_MASK)) {
-			XTemac_mBumpStats(IpifErrors, 1);
-			ERR_HANDLER(XST_IPIF_ERROR, RegDISR, 0);
-			return;
-		}
-
-		/* Receive packet FIFO is deadlocked */
-		if (RegDISR & XTE_DXR_RECV_FIFO_MASK) {
-			XTemac_mBumpStats(RxPktFifoErrors, 1);
-			ERR_HANDLER(XST_PFIFO_DEADLOCK, XTE_RECV, 0);
-			return;
-		}
-
-		/* Transmit packet FIFO is deadlocked */
-		if (RegDISR & XTE_DXR_SEND_FIFO_MASK) {
-			XTemac_mBumpStats(TxPktFifoErrors, 1);
-			ERR_HANDLER(XST_PFIFO_DEADLOCK, XTE_SEND, 0);
-			return;
-		}
-	}
-
-	/* Handle core interrupts */
-	if (RegDISR & XTE_DXR_CORE_MASK) {
-		/* Calculate which enabled interrupts have been asserted */
-		CorePending = XTemac_mGetIpifReg(XTE_IPIER_OFFSET) &
-			XTemac_mGetIpifReg(XTE_IPISR_OFFSET);
-
-		/* Check for fatal status/length FIFO errors. These errors can't be
-		 * cleared
-		 */
-		if (CorePending & XTE_IPXR_FIFO_FATAL_ERROR_MASK) {
-			XTemac_mBumpStats(FifoErrors, 1);
-			ERR_HANDLER(XST_FIFO_ERROR, CorePending &
-				    XTE_IPXR_FIFO_FATAL_ERROR_MASK, 0);
-			return;
-		}
-
-		/* A receive packet has arrived. Call the receive handler.
-		 *
-		 * Acking this interrupt is not done here. The handler has a choice:
-		 * 1) Call XTemac_FifoRecv() which will ack this interrupt source, or
-		 * 2) Call XTemac_IntrFifoDisable() and defer XTEmac_FifoRecv() to a
-		 * later time. Failure to do one of these actions will leave this
-		 * interupt still pending resulting in an exception loop.
-		 */
-		if (CorePending & XTE_IPXR_RECV_DONE_MASK) {
-			FIFORECV_HANDLER();
-		}
-
-		/* A transmit has completed. Pull off all statuses that are available.
-		 * For each status that contains a non-fatal error, the error handler
-		 * is invoked. For fatal errors, the error handler is invoked once and
-		 * assumes the callback will reset the device.
-		 *
-		 * Unless there was a fatal error, then call the send handler since
-		 * resources in the packet FIFO, transmit length FIFO, and transmit
-		 * status FIFO have been freed up. This gives the handler a chance
-		 * to enqueue new frame(s).
-		 */
-		if (CorePending & XTE_IPXR_XMIT_DONE_MASK) {
-			Cnt = 0;
-
-			/* While XMIT_DONE persists */
-			do {
-				/* Get TSR, try to clear XMIT_DONE */
-				RegMisc = XTemac_mGetIpifReg(XTE_TSR_OFFSET);
-				XTemac_mSetIpifReg(XTE_IPISR_OFFSET,
-						   XTE_IPXR_XMIT_DONE_MASK);
-
-				Cnt++;
-
-				/* Read IPISR and test XMIT_DONE again */
-				RegMisc = XTemac_mGetIpifReg(XTE_IPISR_OFFSET);
-			} while (RegMisc & XTE_IPXR_XMIT_DONE_MASK);
-
-			FIFOSEND_HANDLER(Cnt);
-		}
-
-		/* Auto negotiation interrupt */
-		if (CorePending & XTE_IPXR_AUTO_NEG_MASK) {
-			ANEG_HANDLER();
-		}
-
-		/* Check for dropped receive frame. Ack the interupt then call the
-		 * error handler
-		 */
-		if (CorePending & XTE_IPXR_RECV_DROPPED_MASK) {
-			XTemac_mSetIpifReg(XTE_IPISR_OFFSET,
-					   CorePending &
-					   XTE_IPXR_RECV_DROPPED_MASK);
-
-			XTemac_mBumpStats(RxRejectErrors, 1);
-			ERR_HANDLER(XST_RECV_ERROR,
-				    CorePending & XTE_IPXR_RECV_DROPPED_MASK,
-				    0);
-
-			/* no return here, nonfatal error */
-		}
-	}
-}
diff --git a/drivers/net/ethernet/xilinx/xilinx_temac/xtemac_intr_sgdma.c b/drivers/net/ethernet/xilinx/xilinx_temac/xtemac_intr_sgdma.c
deleted file mode 100644
index 99b2cbd..0000000
--- a/drivers/net/ethernet/xilinx/xilinx_temac/xtemac_intr_sgdma.c
+++ /dev/null
@@ -1,437 +0,0 @@
-/* $Id: */
-/******************************************************************************
-*
-*       XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS"
-*       AS A COURTESY TO YOU, SOLELY FOR USE IN DEVELOPING PROGRAMS AND
-*       SOLUTIONS FOR XILINX DEVICES.  BY PROVIDING THIS DESIGN, CODE,
-*       OR INFORMATION AS ONE POSSIBLE IMPLEMENTATION OF THIS FEATURE,
-*       APPLICATION OR STANDARD, XILINX IS MAKING NO REPRESENTATION
-*       THAT THIS IMPLEMENTATION IS FREE FROM ANY CLAIMS OF INFRINGEMENT,
-*       AND YOU ARE RESPONSIBLE FOR OBTAINING ANY RIGHTS YOU MAY REQUIRE
-*       FOR YOUR IMPLEMENTATION.  XILINX EXPRESSLY DISCLAIMS ANY
-*       WARRANTY WHATSOEVER WITH RESPECT TO THE ADEQUACY OF THE
-*       IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OR
-*       REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE FROM CLAIMS OF
-*       INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
-*       FOR A PARTICULAR PURPOSE.
-*
-*       (c) Copyright 2005-2006 Xilinx Inc.
-*       All rights reserved.
-* This program is free software; you can redistribute it and/or modify it
-* under the terms of the GNU General Public License as published by the
-* Free Software Foundation; either version 2 of the License, or (at your
-* option) any later version.
-*
-* You should have received a copy of the GNU General Public License
-* along with this program; if not, write to the Free Software
-* Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-*
-******************************************************************************/
-/*****************************************************************************/
-/**
-*
-* @file xtemac_intr_sgdma.c
-*
-* Functions in this file implement interrupt related operations for
-* scatter gather DMA packet transfer mode. See xtemac.h for a detailed
-* description of the driver.
-*
-* <pre>
-* MODIFICATION HISTORY:
-*
-* Ver   Who  Date     Changes
-* ----- ---- -------- -------------------------------------------------------
-* 1.00a rmm  06/01/05 First release
-* 2.00a rmm  11/21/05 Switched to local link DMA driver
-* </pre>
-******************************************************************************/
-
-/***************************** Include Files *********************************/
-
-#include "xtemac.h"
-#include "xtemac_i.h"
-
-/************************** Constant Definitions *****************************/
-
-
-/**************************** Type Definitions *******************************/
-
-
-/***************** Macros (Inline Functions) Definitions *********************/
-
-/* shortcut macros */
-#define ERR_HANDLER(Class, Word1, Word2)  \
-    InstancePtr->ErrorHandler(InstancePtr->ErrorRef, Class, Word1, Word2)
-
-#define SGSEND_HANDLER() \
-    InstancePtr->SgSendHandler(InstancePtr->SgSendRef)
-
-#define SGRECV_HANDLER() \
-    InstancePtr->SgRecvHandler(InstancePtr->SgRecvRef)
-
-#define ANEG_HANDLER() \
-    InstancePtr->AnegHandler(InstancePtr->AnegRef)
-
-/************************** Function Prototypes ******************************/
-
-
-/************************** Variable Definitions *****************************/
-
-
-/*****************************************************************************/
-/**
-*
-* Enable DMA related interrupts for SG DMA frame transfer mode.
-*
-* @param InstancePtr is a pointer to the instance to be worked on.
-* @param Direction specifies whether the transmit related (XTE_SEND) or
-*        receive related (XTE_RECV) interrupts should be affected, or
-*        both (XTE_SEND | XTE_RECV).
-*
-* @note
-* The state of the transmitter and receiver are not modified by this function.
-*
-******************************************************************************/
-void XTemac_IntrSgEnable(XTemac *InstancePtr, u32 Direction)
-{
-	u32 RegIPIER;
-
-	XASSERT_VOID(InstancePtr != NULL);
-	XASSERT_VOID(InstancePtr->IsReady == XCOMPONENT_IS_READY);
-	XASSERT_VOID(!(Direction & ~(XTE_SEND | XTE_RECV)));
-
-	/* Get current contents of core's IER. Depending on direction(s)
-	 * specified, status/length FIFO error interrupt enables will be enabled
-	 */
-	RegIPIER = XTemac_mGetIpifReg(XTE_IPIER_OFFSET);
-
-	/* Set interrupts for transmit DMA channel */
-	if (Direction & XTE_SEND) {
-		/* DMA interrupt enable */
-		InstancePtr->Flags |= XTE_FLAGS_SEND_SGDMA_INT_ENABLE;
-
-		/* Mask in core's transmit interrupt enables */
-		RegIPIER |= (XTE_IPXR_XMIT_DMA_MASK | XTE_IPXR_XMIT_ERROR_MASK);
-	}
-
-	/* Set interrupts for receive DMA channel */
-	if (Direction & XTE_RECV) {
-		/* DMA interrupt enable */
-		InstancePtr->Flags |= XTE_FLAGS_RECV_SGDMA_INT_ENABLE;
-
-		/* Mask in core's receive interrupt enables */
-		RegIPIER |= (XTE_IPXR_RECV_DMA_MASK | XTE_IPXR_RECV_ERROR_MASK);
-
-		/* Don't enable recv reject errors if option is cleared */
-		if (!(InstancePtr->Options & XTE_REPORT_RXERR_OPTION)) {
-			RegIPIER &= ~XTE_IPXR_RECV_DROPPED_MASK;
-		}
-	}
-
-	/* Update core interrupt enables */
-	XTemac_mSetIpifReg(XTE_IPIER_OFFSET, RegIPIER);
-}
-
-
-/*****************************************************************************/
-/**
-*
-* Disable DMA related interrupts for SG DMA frame transfer mode.
-*
-* @param InstancePtr is a pointer to the instance to be worked on.
-* @param Direction specifies whether the transmit related (XTE_SEND) or
-*        receive related (XTE_RECV) interrupts should be affected, or
-*        both (XTE_SEND | XTE_RECV).
-*
-* @note
-* The state of the transmitter and receiver are not modified by this function.
-*
-******************************************************************************/
-void XTemac_IntrSgDisable(XTemac *InstancePtr, u32 Direction)
-{
-	u32 RegIPIER;
-
-	XASSERT_VOID(InstancePtr != NULL);
-	XASSERT_VOID(InstancePtr->IsReady == XCOMPONENT_IS_READY);
-	XASSERT_VOID(!(Direction & ~(XTE_SEND | XTE_RECV)));
-
-	/* Get contents of IPIER register */
-	RegIPIER = XTemac_mGetIpifReg(XTE_IPIER_OFFSET);
-
-	if (Direction & XTE_SEND) {
-		/* Disable DMA channel interrupt */
-		InstancePtr->Flags &= ~XTE_FLAGS_SEND_SGDMA_INT_ENABLE;
-
-		/* Mask out core's transmit interrupt enables */
-		RegIPIER &=
-			~(XTE_IPXR_XMIT_DMA_MASK | XTE_IPXR_XMIT_ERROR_MASK);
-	}
-
-	if (Direction & XTE_RECV) {
-		/* Disable DMA channel interrupt */
-		InstancePtr->Flags &= ~XTE_FLAGS_RECV_SGDMA_INT_ENABLE;
-
-		/* Mask out core's receive interrupt enables */
-		RegIPIER &=
-			~(XTE_IPXR_RECV_DMA_MASK | XTE_IPXR_RECV_ERROR_MASK);
-	}
-
-	/* Update IPIER with new setting */
-	XTemac_mSetIpifReg(XTE_IPIER_OFFSET, RegIPIER);
-}
-
-
-/*****************************************************************************/
-/**
-*
-* Set the SGDMA interrupt coalescing parameters. The device must be stopped
-* before setting these parameters. See xtemac.h for a complete discussion of
-* the interrupt coalescing features of this device.
-*
-* @param InstancePtr is a pointer to the instance to be worked on.
-* @param Direction indicates the channel, XTE_SEND or XTE_RECV, to set.
-* @param Threshold is the value of the packet threshold count used during
-*        interrupt coalescing. Valid range is 0 - 1023. A value of 0 disables
-*        the use of packet threshold by the hardware.
-* @param Timer is the waitbound timer value in units of approximately
-*        milliseconds. Valid range is 0 - 1023. A value of 0 disables the use
-*        of the waitbound timer by the hardware.
-*
-* @return
-* - XST_SUCCESS if the threshold was successfully set
-* - XST_NO_FEATURE if the MAC is not configured for scatter-gather DMA
-* - XST_DEVICE_IS_STARTED if the device has not been stopped
-* - XST_INVALID_PARAM if Direction does not indicate a valid channel
-*
-******************************************************************************/
-int XTemac_IntrSgCoalSet(XTemac *InstancePtr, u32 Direction,
-			 u16 Threshold, u16 Timer)
-{
-	XASSERT_NONVOID(InstancePtr != NULL);
-	XASSERT_NONVOID(InstancePtr->IsReady == XCOMPONENT_IS_READY);
-
-	/* Must be SGDMA */
-	if (!XTemac_mIsSgDma(InstancePtr)) {
-		return (XST_NO_FEATURE);
-	}
-
-	/* Device must be stopped before changing these settings */
-	if (InstancePtr->IsStarted == XCOMPONENT_IS_STARTED) {
-		return (XST_DEVICE_IS_STARTED);
-	}
-
-	/* Set HW */
-	if (Direction == XTE_SEND) {
-		(void) XDmaV3_SgSetPktThreshold(&InstancePtr->SendDma,
-						Threshold);
-		XDmaV3_SgSetPktWaitbound(&InstancePtr->SendDma, Timer);
-	}
-	else if (Direction == XTE_RECV) {
-		(void) XDmaV3_SgSetPktThreshold(&InstancePtr->RecvDma,
-						Threshold);
-		XDmaV3_SgSetPktWaitbound(&InstancePtr->RecvDma, Timer);
-	}
-	else {
-		return (XST_INVALID_PARAM);
-	}
-
-	return (XST_SUCCESS);
-}
-
-
-/*****************************************************************************/
-/**
-*
-* Get the current interrupt coalescing settings. See xtemac.h for more
-* discussion of interrupt coalescing features.
-*
-* @param InstancePtr is a pointer to the instance to be worked on.
-* @param Direction indicates the channel, XTE_SEND or XTE_RECV, to get.
-* @param ThresholdPtr is a pointer to the word into which the current value of
-*        the packet threshold will be copied.
-* @param TimerPtr is a pointer to the word into which the current value of the
-*        waitbound timer will be copied.
-*
-* @return
-* - XST_SUCCESS if the packet threshold was retrieved successfully
-* - XST_NO_FEATURE if the MAC is not configured for scatter-gather DMA
-* - XST_INVALID_PARAM if Direction does not indicate a valid channel
-*
-******************************************************************************/
-int XTemac_IntrSgCoalGet(XTemac *InstancePtr, u32 Direction,
-			 u16 *ThresholdPtr, u16 *TimerPtr)
-{
-	XASSERT_NONVOID(InstancePtr != NULL);
-	XASSERT_NONVOID(ThresholdPtr != NULL);
-	XASSERT_NONVOID(InstancePtr->IsReady == XCOMPONENT_IS_READY);
-
-	/* Must be SGDMA */
-	if (!XTemac_mIsSgDma(InstancePtr)) {
-		return (XST_NO_FEATURE);
-	}
-
-	/* Get data from HW */
-	if (Direction == XTE_SEND) {
-		*ThresholdPtr = XDmaV3_SgGetPktThreshold(&InstancePtr->SendDma);
-		*TimerPtr = XDmaV3_SgGetPktWaitbound(&InstancePtr->SendDma);
-	}
-	else if (Direction == XTE_RECV) {
-		*ThresholdPtr = XDmaV3_SgGetPktThreshold(&InstancePtr->RecvDma);
-		*TimerPtr = XDmaV3_SgGetPktWaitbound(&InstancePtr->RecvDma);
-	}
-	else {
-		return (XST_INVALID_PARAM);
-	}
-
-	return (XST_SUCCESS);
-}
-
-
-/*****************************************************************************/
-/**
-* Master interrupt handler for SGDMA frame transfer mode. This routine will
-* query the status of the device, bump statistics, and invoke user callbacks
-* in the following priority:
-*
-* This routine must be connected to an interrupt controller using OS/BSP
-* specific methods.
-*
-* @param InstancePtr is a pointer to the TEMAC instance that has caused the
-*        interrupt.
-*
-******************************************************************************/
-void XTemac_IntrSgHandler(void *TemacPtr)
-{
-	u32 RegDISR;
-	u32 CorePending = 0;
-	u32 RegDmaPending;
-	XTemac *InstancePtr = (XTemac *) TemacPtr;
-
-	XASSERT_VOID(InstancePtr != NULL);
-
-	/* This ISR will try to handle as many interrupts as it can in a single
-	 * call. However, in most of the places where the user's error handler is
-	 * called, this ISR exits because it is expected that the user will reset
-	 * the device in nearly all instances.
-	 */
-
-	/* Log interrupt */
-	XTemac_mBumpStats(Interrupts, 1);
-
-	/* Get top level interrupt status */
-	RegDISR = XTemac_mGetIpifReg(XTE_DISR_OFFSET);
-
-	/* IPIF transaction or data phase error */
-	if (RegDISR & (XTE_DXR_DPTO_MASK | XTE_DXR_TERR_MASK)) {
-		XTemac_mBumpStats(IpifErrors, 1);
-		ERR_HANDLER(XST_IPIF_ERROR, RegDISR, 0);
-		return;
-	}
-
-	/* Handle core interupts */
-	if (RegDISR & XTE_DXR_CORE_MASK) {
-		/* Get currently pending core interrupts */
-		CorePending = XTemac_mGetIpifReg(XTE_IPIER_OFFSET) &
-			XTemac_mGetIpifReg(XTE_IPISR_OFFSET);
-
-		/* Check for fatal status/length FIFO errors. These errors can't be
-		 * cleared
-		 */
-		if (CorePending & XTE_IPXR_FIFO_FATAL_ERROR_MASK) {
-			XTemac_mBumpStats(FifoErrors, 1);
-			ERR_HANDLER(XST_FIFO_ERROR,
-				    CorePending &
-				    XTE_IPXR_FIFO_FATAL_ERROR_MASK, 0);
-			return;
-		}
-
-		/* Check for SGDMA receive interrupts */
-		if (CorePending & XTE_IPXR_RECV_DMA_MASK) {
-			RegDmaPending =
-				XDmaV3_GetInterruptStatus(&InstancePtr->
-							  RecvDma) &
-				XDmaV3_GetInterruptEnable(&InstancePtr->
-							  RecvDma);
-
-			XDmaV3_SetInterruptStatus(&InstancePtr->RecvDma,
-						  RegDmaPending);
-
-			/* Check for errors */
-			if (RegDmaPending & XDMAV3_IPXR_DE_MASK) {
-				XDmaV3_SetInterruptStatus(&InstancePtr->RecvDma,
-							  XDMAV3_IPXR_DE_MASK);
-
-				XTemac_mBumpStats(RxDmaErrors, 1);
-				ERR_HANDLER(XST_DMA_ERROR, XTE_RECV,
-					    XDmaV3_mGetStatus(&InstancePtr->
-							      RecvDma));
-				return;
-			}
-
-			/* Check for packets processed */
-			if (RegDmaPending & (XDMAV3_IPXR_PCTR_MASK |
-					     XDMAV3_IPXR_PWBR_MASK |
-					     XDMAV3_IPXR_SGEND_MASK)) {
-				/* Invoke the user's receive handler. The handler may remove the
-				 * ready BDs from the list right away or defer until later
-				 */
-				SGRECV_HANDLER();
-			}
-		}
-
-		/* Check for SGDMA transmit interrupts */
-		if (CorePending & XTE_IPXR_XMIT_DMA_MASK) {
-			RegDmaPending =
-				XDmaV3_GetInterruptStatus(&InstancePtr->
-							  SendDma) &
-				XDmaV3_GetInterruptEnable(&InstancePtr->
-							  SendDma);
-
-			XDmaV3_SetInterruptStatus(&InstancePtr->SendDma,
-						  RegDmaPending);
-
-			/* Check for errors */
-			if (RegDmaPending & XDMAV3_IPXR_DE_MASK) {
-				XDmaV3_SetInterruptStatus(&InstancePtr->SendDma,
-							  XDMAV3_IPXR_DE_MASK);
-
-				XTemac_mBumpStats(TxDmaErrors, 1);
-				ERR_HANDLER(XST_DMA_ERROR, XTE_SEND,
-					    XDmaV3_mGetStatus(&InstancePtr->
-							      SendDma));
-				return;
-			}
-
-			/* Check for packets processed */
-			if (RegDmaPending & (XDMAV3_IPXR_PCTR_MASK |
-					     XDMAV3_IPXR_PWBR_MASK |
-					     XDMAV3_IPXR_SGEND_MASK)) {
-				/* Invoke the user's send handler. The handler may remove the
-				 * ready BDs from the list right away or defer until later
-				 */
-				SGSEND_HANDLER();
-			}
-		}
-
-		/* Auto negotiation interrupt */
-		if (CorePending & XTE_IPXR_AUTO_NEG_MASK) {
-			ANEG_HANDLER();
-		}
-
-		/* Check for dropped receive frame. Ack the interupt then call the
-		 * error handler
-		 */
-		if (CorePending & XTE_IPXR_RECV_DROPPED_MASK) {
-			XTemac_mBumpStats(RxRejectErrors, 1);
-			ERR_HANDLER(XST_RECV_ERROR,
-				    CorePending & XTE_IPXR_RECV_DROPPED_MASK,
-				    0);
-
-			/* no return here, nonfatal error */
-		}
-	}
-
-	/* Ack core top level interrupt status */
-	XTemac_mSetIpifReg(XTE_IPISR_OFFSET, CorePending);
-	XTemac_mSetIpifReg(XTE_DISR_OFFSET, RegDISR);
-}
diff --git a/drivers/net/ethernet/xilinx/xilinx_temac/xtemac_l.c b/drivers/net/ethernet/xilinx/xilinx_temac/xtemac_l.c
deleted file mode 100644
index d77077c..0000000
--- a/drivers/net/ethernet/xilinx/xilinx_temac/xtemac_l.c
+++ /dev/null
@@ -1,255 +0,0 @@
-/* $Id: */
-/******************************************************************************
-*
-*       XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS"
-*       AS A COURTESY TO YOU, SOLELY FOR USE IN DEVELOPING PROGRAMS AND
-*       SOLUTIONS FOR XILINX DEVICES.  BY PROVIDING THIS DESIGN, CODE,
-*       OR INFORMATION AS ONE POSSIBLE IMPLEMENTATION OF THIS FEATURE,
-*       APPLICATION OR STANDARD, XILINX IS MAKING NO REPRESENTATION
-*       THAT THIS IMPLEMENTATION IS FREE FROM ANY CLAIMS OF INFRINGEMENT,
-*       AND YOU ARE RESPONSIBLE FOR OBTAINING ANY RIGHTS YOU MAY REQUIRE
-*       FOR YOUR IMPLEMENTATION.  XILINX EXPRESSLY DISCLAIMS ANY
-*       WARRANTY WHATSOEVER WITH RESPECT TO THE ADEQUACY OF THE
-*       IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OR
-*       REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE FROM CLAIMS OF
-*       INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
-*       FOR A PARTICULAR PURPOSE.
-*
-*       (c) Copyright 2005-2006 Xilinx Inc.
-*       All rights reserved.
-* This program is free software; you can redistribute it and/or modify it
-* under the terms of the GNU General Public License as published by the
-* Free Software Foundation; either version 2 of the License, or (at your
-* option) any later version.
-*
-* You should have received a copy of the GNU General Public License
-* along with this program; if not, write to the Free Software
-* Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-*
-******************************************************************************/
-/*****************************************************************************/
-/**
-*
-* @file xtemac_l.c
-*
-* This file contains low-level functions to send and receive Ethernet frames.
-*
-* @note
-*
-* This API cannot be used when device is configured in SGDMA mode.
-*
-* <pre>
-* MODIFICATION HISTORY:
-*
-* Ver   Who  Date     Changes
-* ----- ---- -------- ------------------------------------------------------
-* 1.00a rmm  06/01/05 First release
-* 2.00a rmm  11/21/05 Modified to match HW 3.00a
-* </pre>
-*
-******************************************************************************/
-
-/***************************** Include Files *********************************/
-
-#include "xtemac_l.h"
-#include "xpacket_fifo_l_v2_00_a.h"
-
-/************************** Constant Definitions *****************************/
-
-/**************************** Type Definitions *******************************/
-
-/***************** Macros (Inline Functions) Definitions *********************/
-
-/************************** Function Prototypes ******************************/
-
-/************************** Variable Definitions *****************************/
-
-/*****************************************************************************/
-/**
-*
-* Reset and enable the transmitter and receiver. The contents of the Rx and Tx
-* control registers are preserved.
-*
-* @param BaseAddress is the base address of the device
-*
-* @return
-*
-* None.
-*
-* @note
-*
-* If hardware is not behaving properly, then this function may never return.
-*
-******************************************************************************/
-void XTemac_Enable(u32 BaseAddress)
-{
-	u32 CR_save0;
-	u32 CR_save1;
-	volatile u32 CR;
-
-	/* Save contents of the Rx control registers, then reset the receiver */
-	CR_save0 = XTemac_mReadHostReg(BaseAddress, XTE_RXC0_OFFSET);
-	CR_save1 = XTemac_mReadHostReg(BaseAddress, XTE_RXC1_OFFSET);
-	XTemac_mWriteHostReg(BaseAddress, XTE_RXC1_OFFSET, XTE_RXC1_RXRST_MASK);
-
-	/* Wait for the receiver to finish reset */
-	do {
-		CR = XTemac_mReadHostReg(BaseAddress, XTE_RXC1_OFFSET);
-	} while (CR & XTE_RXC1_RXRST_MASK);
-
-	/* Restore contents of Rx control registers, enable receiver */
-	XTemac_mWriteHostReg(BaseAddress, XTE_RXC0_OFFSET, CR_save0);
-	XTemac_mWriteHostReg(BaseAddress, XTE_RXC1_OFFSET,
-			     CR_save1 | XTE_RXC1_RXEN_MASK);
-
-	/* Save contents of the Tx control register, then reset the transmitter */
-	CR_save0 = XTemac_mReadHostReg(BaseAddress, XTE_TXC_OFFSET);
-	XTemac_mWriteHostReg(BaseAddress, XTE_TXC_OFFSET, XTE_TXC_TXRST_MASK);
-
-	/* Wait for the transmitter to finish reset */
-	do {
-		CR = XTemac_mReadHostReg(BaseAddress, XTE_TXC_OFFSET);
-	} while (CR & XTE_TXC_TXRST_MASK);
-
-	/* Restore contents of Tx control register, enable transmitter */
-	XTemac_mWriteHostReg(BaseAddress, XTE_TXC_OFFSET,
-			     CR_save0 | XTE_TXC_TXEN_MASK);
-}
-
-
-/*****************************************************************************/
-/**
-*
-* Disable the transmitter and receiver.
-*
-* @param BaseAddress is the base address of the device
-*
-* @return
-*
-* None.
-*
-* @note
-*
-******************************************************************************/
-void XTemac_Disable(u32 BaseAddress)
-{
-	u32 CR;
-
-	/* Disable the receiver */
-	CR = XTemac_mReadHostReg(BaseAddress, XTE_RXC1_OFFSET);
-	XTemac_mWriteHostReg(BaseAddress, XTE_RXC1_OFFSET,
-			     CR & ~XTE_RXC1_RXEN_MASK);
-
-	/* Disable the transmitter */
-	CR = XTemac_mReadHostReg(BaseAddress, XTE_TXC_OFFSET);
-	XTemac_mWriteHostReg(BaseAddress, XTE_TXC_OFFSET,
-			     CR & ~XTE_TXC_TXEN_MASK);
-}
-
-
-/*****************************************************************************/
-/**
-*
-* Send an Ethernet frame. This size is the total frame size, including header.
-* This function will return immediately upon dispatching of the frame to the
-* transmit FIFO. Upon return, the provided frame buffer can be reused. To
-* monitor the transmit status, use XTemac_mIsTxDone(). If desired, the
-* transmit status register (XTE_TSR_OFFSET) can be read to obtain the outcome
-* of the transaction. This function can be used only when the device is
-* configured for FIFO direct mode.
-*
-* @param BaseAddress is the base address of the device
-* @param FramePtr is a pointer to a 32-bit aligned frame
-* @param Size is the size, in bytes, of the frame
-*
-* @return
-*
-* - Size of the frame sent (Size parameter)
-* - 0 if the frame will not fit in the data FIFO.
-*
-* @note
-*
-* A transmit length FIFO overrun (XTE_IPXR_XMIT_LFIFO_OVER_MASK) condition may
-* occur if too many frames are pending transmit. This situation can happen when
-* many small frames are being sent. To prevent this condition, pause sending
-* when transmit length FIFO full (XTE_IPXR_XMIT_LFIFO_FULL_MASK) is indicated in
-* the XTE_XTE_IPISR_OFFSET register.
-*
-******************************************************************************/
-int XTemac_SendFrame(u32 BaseAddress, void *FramePtr, int Size)
-{
-	int Result;
-
-	/* Clear the status so it can be checked by the caller
-	 * Must handle toggle-on-write for status bits...unfortunately
-	 */
-	if (XTemac_mReadReg(BaseAddress, XTE_IPISR_OFFSET) &
-	    XTE_IPXR_XMIT_DONE_MASK) {
-		XTemac_mWriteReg(BaseAddress, XTE_IPISR_OFFSET,
-				 XTE_IPXR_XMIT_DONE_MASK);
-	}
-
-	/* Use the packet fifo driver write the FIFO */
-	Result = XPacketFifoV200a_L0Write(BaseAddress + XTE_PFIFO_TXREG_OFFSET,
-					  BaseAddress + XTE_PFIFO_TXDATA_OFFSET,
-					  (u8 *) FramePtr, Size);
-
-	/* No room in the FIFO */
-	if (Result != XST_SUCCESS) {
-		return (0);
-	}
-
-	/* The frame is in the Fifo, now send it */
-	XIo_Out32(BaseAddress + XTE_TPLR_OFFSET, Size);
-
-	return (Size);
-}
-
-
-/*****************************************************************************/
-/**
-*
-* Receive a frame. This function can be used only when the device is
-* configured for FIFO direct mode.
-*
-* @param BaseAddress is the base address of the device
-* @param FramePtr is a pointer to a 32-bit aligned buffer where the frame will
-*        be stored
-*
-* @return
-*
-* The size, in bytes, of the frame received.
-* 0 if no frame has been received.
-*
-* @note
-*
-* None.
-*
-******************************************************************************/
-int XTemac_RecvFrame(u32 BaseAddress, void *FramePtr)
-{
-	int Length;
-
-	/* Is there a received frame present */
-	if (XTemac_mIsRxEmpty(BaseAddress)) {
-		return (0);
-	}
-
-	/* Get the length of the frame that arrived */
-	Length = XTemac_mReadReg(BaseAddress, XTE_RPLR_OFFSET);
-
-	/* Clear the status now that the length is read so we're ready again
-	 * next time
-	 */
-	XTemac_mWriteReg(BaseAddress, XTE_IPISR_OFFSET,
-			 XTE_IPXR_RECV_DONE_MASK);
-
-	/* Use the packet fifo driver to read the FIFO. We assume the Length is
-	 * valid and there is enough data in the FIFO - so we ignore the return
-	 * code.
-	 */
-	(void) XPacketFifoV200a_L0Read(BaseAddress + XTE_PFIFO_RXREG_OFFSET,
-				       BaseAddress + XTE_PFIFO_RXDATA_OFFSET,
-				       (u8 *) FramePtr, Length);
-	return (Length);
-}
diff --git a/drivers/net/ethernet/xilinx/xilinx_temac/xtemac_l.h b/drivers/net/ethernet/xilinx/xilinx_temac/xtemac_l.h
deleted file mode 100644
index aea3e64..0000000
--- a/drivers/net/ethernet/xilinx/xilinx_temac/xtemac_l.h
+++ /dev/null
@@ -1,705 +0,0 @@
-/* $Id: */
-/******************************************************************************
-*
-*       XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS"
-*       AS A COURTESY TO YOU, SOLELY FOR USE IN DEVELOPING PROGRAMS AND
-*       SOLUTIONS FOR XILINX DEVICES.  BY PROVIDING THIS DESIGN, CODE,
-*       OR INFORMATION AS ONE POSSIBLE IMPLEMENTATION OF THIS FEATURE,
-*       APPLICATION OR STANDARD, XILINX IS MAKING NO REPRESENTATION
-*       THAT THIS IMPLEMENTATION IS FREE FROM ANY CLAIMS OF INFRINGEMENT,
-*       AND YOU ARE RESPONSIBLE FOR OBTAINING ANY RIGHTS YOU MAY REQUIRE
-*       FOR YOUR IMPLEMENTATION.  XILINX EXPRESSLY DISCLAIMS ANY
-*       WARRANTY WHATSOEVER WITH RESPECT TO THE ADEQUACY OF THE
-*       IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OR
-*       REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE FROM CLAIMS OF
-*       INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
-*       FOR A PARTICULAR PURPOSE.
-*
-*       (c) Copyright 2004-2006 Xilinx Inc.
-*       All rights reserved.
-* This program is free software; you can redistribute it and/or modify it
-* under the terms of the GNU General Public License as published by the
-* Free Software Foundation; either version 2 of the License, or (at your
-* option) any later version.
-*
-* You should have received a copy of the GNU General Public License
-* along with this program; if not, write to the Free Software
-* Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-*
-******************************************************************************/
-
-/*****************************************************************************/
-/**
-*
-* @file xtemac_l.h
-*
-* This header file contains identifiers and low-level driver functions (or
-* macros) that can be used to access the Tri-Mode MAC Ethernet (TEMAC) device.
-* High-level driver functions are defined in xtemac.h.
-*
-* @note
-*
-* Some registers are not accessible when a HW instance is configured for SGDMA.
-*
-* <pre>
-* MODIFICATION HISTORY:
-*
-* Ver   Who  Date     Changes
-* ----- ---- -------- -------------------------------------------------------
-* 1.00a rmm  05/24/04 First release for early access.
-* 1.00a rmm  06/01/05 General release
-* 1.00b rmm  09/23/05 Added MII interrupt bit definitions, removed IFGP register
-*                     and associated bit masks, added MGT register and
-*                     associated bit masks, removed DIID register, renamed host
-*                     register names to match those in the latest HW spec.
-* 2.00a rmm  11/21/05 Modified to match HW 3.00a
-* </pre>
-*
-******************************************************************************/
-
-#ifndef XTEMAC_L_H		/* prevent circular inclusions */
-#define XTEMAC_L_H		/* by using protection macros */
-
-/***************************** Include Files *********************************/
-
-#include "xbasic_types.h"
-#include "xio.h"
-#include "xdmav3_l.h"
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-/************************** Constant Definitions *****************************/
-
-#define XTE_PLB_BD_ALIGNMENT  4	     /**< Minimum buffer descriptor alignment
-                                          on the PLB bus */
-#define XTE_PLB_BUF_ALIGNMENT 8	     /**< Minimum buffer alignment when using
-                                          HW options that impose alignment
-                                          restrictions on the buffer data on
-                                          the PLB bus */
-
-#define XTE_RESET_IPIF_DELAY_US 1    /**< Number of Us to delay after IPIF
-                                          reset */
-#define XTE_RESET_HARD_DELAY_US 4    /**< Number of Us to delay after hard core
-                                          reset */
-
-/* Register offset definitions. Unless otherwise noted, register access is
- * 32 bit.
- */
-
-/** @name IPIF interrupt and reset registers
- *  @{
- */
-#define XTE_DISR_OFFSET  0x00000000  /**< Device interrupt status */
-#define XTE_DIPR_OFFSET  0x00000004  /**< Device interrupt pending */
-#define XTE_DIER_OFFSET  0x00000008  /**< Device interrupt enable */
-#define XTE_DGIE_OFFSET  0x0000001C  /**< Device global interrupt enable */
-#define XTE_IPISR_OFFSET 0x00000020  /**< IP interrupt status */
-#define XTE_IPIER_OFFSET 0x00000028  /**< IP interrupt enable */
-#define XTE_DSR_OFFSET   0x00000040  /**< Device software reset (write) */
-#define XTE_MIR_OFFSET   0x00000040  /**< Device software reset (read) */
-/*@}*/
-
-
-/** @name IPIF transmit and receive packet fifo base offsets
- *        Individual registers and bit definitions are defined in
- *        xpacket_fifo_l_v2_00_a.h. This register group is not accessible if
- *        the device instance is configured for SGDMA.
- *  @{
- */
-#define XTE_PFIFO_TXREG_OFFSET   0x00002000  /**< Packet FIFO Tx channel */
-#define XTE_PFIFO_RXREG_OFFSET   0x00002010  /**< Packet FIFO Rx channel */
-/*@}*/
-
-
-/** @name IPIF transmit and receive packet fifo data offsets. This register
- *        group is not accessible if the device instance is configured for
- *        SGDMA.
- *  @{
- */
-#define XTE_PFIFO_TXDATA_OFFSET  0x00002100  /**< IPIF Tx packet fifo port */
-#define XTE_PFIFO_RXDATA_OFFSET  0x00002200  /**< IPIF Rx packet fifo port */
-/*@}*/
-
-
-/** @name IPIF transmit and recieve DMA offsets
- *        Individual registers and bit definitions are defined in xdmav3.h.
- *        This register group is not accessible if the device instance is
- *        configured for FIFO direct.
- *  @{
- */
-#define XTE_DMA_SEND_OFFSET      0x00002300  /**< DMA Tx channel */
-#define XTE_DMA_RECV_OFFSET      0x00002340  /**< DMA Rx channel */
-/*@}*/
-
-
-/** @name PLB_TEMAC registers. The TPLR, TSR, RPLR, and RSR are not accessible
- *        when a device instance is configured for SGDMA. LLPS is not accessible
- *        when a device instance is configured for FIFO direct.
- *  @{
- */
-#define XTE_CR_OFFSET           0x00001000  /**< Control */
-#define XTE_TPLR_OFFSET         0x00001004  /**< Tx packet length (FIFO) */
-#define XTE_TSR_OFFSET          0x00001008  /**< Tx status (FIFO) */
-#define XTE_RPLR_OFFSET         0x0000100C  /**< Rx packet length (FIFO) */
-#define XTE_RSR_OFFSET          0x00001010  /**< Receive status */
-#define XTE_TPPR_OFFSET         0x00001014  /**< Tx pause packet */
-#define XTE_LLPS_OFFSET         0x00001018  /**< LLINK PFIFO status */
-#define XTE_MGTDR_OFFSET        0x000033B0  /**< MII data */
-#define XTE_MGTCR_OFFSET        0x000033B4  /**< MII control */
-/*@}*/
-
-
-/** @name HARD_TEMAC Core Registers
- * These are registers defined within the device's hard core located in the
- * processor block. They are accessed with the host interface. These registers
- * are addressed offset by XTE_HOST_IPIF_OFFSET or by the DCR base address
- * if so configured.
- *
- * Access to these registers should go through macros XTemac_mReadHostReg()
- * and XTemac_mWriteHostReg() to guarantee proper access.
- * @{
- */
-#define XTE_HOST_IPIF_OFFSET    0x00003000  /**< Offset of host registers when
-                                                 memory mapped into IPIF */
-#define XTE_RXC0_OFFSET         0x00000200  /**< Rx configuration word 0 */
-#define XTE_RXC1_OFFSET         0x00000240  /**< Rx configuration word 1 */
-#define XTE_TXC_OFFSET          0x00000280  /**< Tx configuration */
-#define XTE_FCC_OFFSET          0x000002C0  /**< Flow control configuration */
-#define XTE_EMCFG_OFFSET        0x00000300  /**< EMAC configuration */
-#define XTE_GMIC_OFFSET         0x00000320  /**< RGMII/SGMII configuration */
-#define XTE_MC_OFFSET           0x00000340  /**< Management configuration */
-#define XTE_UAW0_OFFSET         0x00000380  /**< Unicast address word 0 */
-#define XTE_UAW1_OFFSET         0x00000384  /**< Unicast address word 1 */
-#define XTE_MAW0_OFFSET         0x00000388  /**< Multicast address word 0 */
-#define XTE_MAW1_OFFSET         0x0000038C  /**< Multicast address word 1 */
-#define XTE_AFM_OFFSET          0x00000390  /**< Promisciuous mode */
-/*@}*/
-
-
-/* Register masks. The following constants define bit locations of various
- * control bits in the registers. Constants are not defined for those registers
- * that have a single bit field representing all 32 bits. For further
- * information on the meaning of the various bit masks, refer to the HW spec.
- */
-
-/** @name Interrupt status bits for top level interrupts
- *  These bits are associated with the XTE_DISR_OFFSET, XTE_DIPR_OFFSET,
- *  and XTE_DIER_OFFSET registers.
- * @{
- */
-#define XTE_DXR_SEND_FIFO_MASK          0x00000040 /**< Send FIFO channel */
-#define XTE_DXR_RECV_FIFO_MASK          0x00000020 /**< Receive FIFO channel */
-#define XTE_DXR_CORE_MASK               0x00000004 /**< Core */
-#define XTE_DXR_DPTO_MASK               0x00000002 /**< Data phase timeout */
-#define XTE_DXR_TERR_MASK               0x00000001 /**< Transaction error */
-/*@}*/
-
-/** @name Interrupt status bits for MAC interrupts
- *  These bits are associated with XTE_IPISR_OFFSET and XTE_IPIER_OFFSET
- *  registers.
- *
- *  @{
- */
-#define XTE_IPXR_XMIT_DONE_MASK         0x00000001 /**< Tx complete */
-#define XTE_IPXR_RECV_DONE_MASK         0x00000002 /**< Rx complete */
-#define XTE_IPXR_AUTO_NEG_MASK          0x00000004 /**< Auto negotiation complete */
-#define XTE_IPXR_RECV_REJECT_MASK       0x00000008 /**< Rx packet rejected */
-#define XTE_IPXR_XMIT_SFIFO_EMPTY_MASK  0x00000010 /**< Tx status fifo empty */
-#define XTE_IPXR_RECV_LFIFO_EMPTY_MASK  0x00000020 /**< Rx length fifo empty */
-#define XTE_IPXR_XMIT_LFIFO_FULL_MASK   0x00000040 /**< Tx length fifo full */
-#define XTE_IPXR_RECV_LFIFO_OVER_MASK   0x00000080 /**< Rx length fifo overrun
-                                                        Note that this signal is
-                                                        no longer asserted by HW
-                                                        */
-#define XTE_IPXR_RECV_LFIFO_UNDER_MASK  0x00000100 /**< Rx length fifo underrun */
-#define XTE_IPXR_XMIT_SFIFO_OVER_MASK   0x00000200 /**< Tx status fifo overrun */
-#define XTE_IPXR_XMIT_SFIFO_UNDER_MASK  0x00000400 /**< Tx status fifo underrun */
-#define XTE_IPXR_XMIT_LFIFO_OVER_MASK   0x00000800 /**< Tx length fifo overrun */
-#define XTE_IPXR_XMIT_LFIFO_UNDER_MASK  0x00001000 /**< Tx length fifo underrun */
-#define XTE_IPXR_RECV_PFIFO_ABORT_MASK  0x00002000 /**< Rx packet rejected due to
-                                                        full packet FIFO */
-#define XTE_IPXR_RECV_LFIFO_ABORT_MASK  0x00004000 /**< Rx packet rejected due to
-                                                        full length FIFO */
-#define XTE_IPXR_MII_PEND_MASK          0x00008000 /**< Mii operation now
-                                                        pending */
-#define XTE_IPXR_MII_DONE_MASK          0x00010000 /**< Mii operation has
-                                                        completed */
-#define XTE_IPXR_XMIT_PFIFO_UNDER_MASK  0x00020000 /**< Tx packet FIFO
-                                                        underrun */
-#define XTE_IPXR_XMIT_DMA_MASK          0x00080000 /**< Rx dma channel */
-#define XTE_IPXR_RECV_DMA_MASK          0x00100000 /**< Tx dma channel */
-#define XTE_IPXR_RECV_FIFO_LOCK_MASK    0x00200000 /**< Rx FIFO deadlock */
-#define XTE_IPXR_XMIT_FIFO_LOCK_MASK    0x00400000 /**< Tx FIFO deadlock */
-
-
-#define XTE_IPXR_RECV_DROPPED_MASK                                      \
-    (XTE_IPXR_RECV_REJECT_MASK |                                        \
-     XTE_IPXR_RECV_PFIFO_ABORT_MASK |                                   \
-     XTE_IPXR_RECV_LFIFO_ABORT_MASK)	/**< IPXR bits that indicate a dropped
-                                             receive frame */
-
-#define XTE_IPXR_XMIT_ERROR_MASK                                        \
-    (XTE_IPXR_XMIT_SFIFO_OVER_MASK |                                    \
-     XTE_IPXR_XMIT_SFIFO_UNDER_MASK |                                   \
-     XTE_IPXR_XMIT_LFIFO_OVER_MASK |                                    \
-     XTE_IPXR_XMIT_LFIFO_UNDER_MASK |                                   \
-     XTE_IPXR_XMIT_PFIFO_UNDER_MASK)	/**< IPXR bits that indicate transmit
-                                             errors */
-
-#define XTE_IPXR_RECV_ERROR_MASK                                        \
-    (XTE_IPXR_RECV_DROPPED_MASK |                                       \
-     XTE_IPXR_RECV_LFIFO_UNDER_MASK)	/**< IPXR bits that indicate receive
-                                             errors */
-
-#define XTE_IPXR_FIFO_FATAL_ERROR_MASK                                  \
-    (XTE_IPXR_RECV_FIFO_LOCK_MASK |                                     \
-     XTE_IPXR_XMIT_FIFO_LOCK_MASK |                                     \
-     XTE_IPXR_XMIT_SFIFO_OVER_MASK |                                    \
-     XTE_IPXR_XMIT_SFIFO_UNDER_MASK |                                   \
-     XTE_IPXR_XMIT_LFIFO_OVER_MASK |                                    \
-     XTE_IPXR_XMIT_LFIFO_UNDER_MASK |                                   \
-     XTE_IPXR_XMIT_PFIFO_UNDER_MASK |                                   \
-     XTE_IPXR_RECV_LFIFO_UNDER_MASK)	/**< IPXR bits that indicate fatal FIFO
-                                             errors. These bits can only be
-                                             cleared by a device reset */
-/*@}*/
-
-
-/** @name Software reset register (DSR)
- *  @{
- */
-#define XTE_DSR_RESET_MASK      0x0000000A  /**< Write this value to DSR to
-                                                 reset entire core */
-/*@}*/
-
-
-/** @name Global interrupt enable register (DGIE)
- *  @{
- */
-#define XTE_DGIE_ENABLE_MASK    0x80000000  /**< Write this value to DGIE to
-                                                 enable interrupts from this
-                                                 device */
-/*@}*/
-
-/** @name Control Register (CR)
- *  @{
- */
-#define XTE_CR_BCREJ_MASK       0x00000004   /**< Disable broadcast address
-                                                  filtering */
-#define XTE_CR_MCREJ_MASK       0x00000002   /**< Disable multicast address
-                                                  filtering */
-#define XTE_CR_HRST_MASK        0x00000001   /**< Reset the hard TEMAC core */
-/*@}*/
-
-
-/** @name Transmit Packet Length Register (TPLR)
- *  @{
- */
-#define XTE_TPLR_TXPL_MASK      0x00003FFF   /**< Tx packet length in bytes */
-/*@}*/
-
-
-/** @name Transmit Status Register (TSR)
- *  @{
- */
-#define XTE_TSR_TPCF_MASK       0x00000001   /**< Transmit packet complete
-                                                  flag */
-
-/*@}*/
-
-
-/** @name Receive Packet Length Register (RPLR)
- *  @{
- */
-#define XTE_RPLR_RXPL_MASK      0x00003FFF   /**< Rx packet length in bytes */
-/*@}*/
-
-
-/** @name Receive Status Register (RSR)
- * @{
- */
-#define XTE_RSR_RPCF_MASK       0x00000001   /**< Receive packet complete
-                                                  flag */
-/*@}*/
-
-
-/** @name MII Mamagement Data register (MGTDR)
- *  @{
- */
-#define XTE_MGTDR_MIID_MASK     0x0000FFFF   /**< MII data */
-/*@}*/
-
-
-/** @name MII Mamagement Control register (MGTCR)
- *  @{
- */
-#define XTE_MGTCR_RWN_MASK      0x00000400  /**< Read-not-write,0=read
-                                                 1=write */
-#define XTE_MGTCR_PHYAD_MASK    0x000003E0  /**< PHY address */
-#define XTE_MGTCR_REGAD_MASK    0x0000001F  /**< PHY register address */
-
-#define XTE_MGTCR_PHYAD_SHIFT_MASK       5  /**< Shift bits for PHYAD */
-/*@}*/
-
-
-/** @name Transmit Pause Packet Register (TPPR)
- *  @{
- */
-#define XTE_TPPR_TPPD_MASK      0x0000FFFF   /**< Tx pause packet data */
-/*@}*/
-
-
-/** @name Receiver Configuration Word 1 (RXC1)
- *  @{
- */
-#define XTE_RXC1_RXRST_MASK     0x80000000   /**< Receiver reset */
-#define XTE_RXC1_RXJMBO_MASK    0x40000000   /**< Jumbo frame enable */
-#define XTE_RXC1_RXFCS_MASK     0x20000000   /**< FCS not stripped */
-#define XTE_RXC1_RXEN_MASK      0x10000000   /**< Receiver enable */
-#define XTE_RXC1_RXVLAN_MASK    0x08000000   /**< VLAN enable */
-#define XTE_RXC1_RXHD_MASK      0x04000000   /**< Half duplex */
-#define XTE_RXC1_RXLT_MASK      0x02000000   /**< Length/type check disable */
-#define XTE_RXC1_ERXC1_MASK     0x0000FFFF   /**< Pause frame source address
-                                                  bits [47:32]. Bits [31:0]
-                                                  are stored in register
-                                                  ERXC0 */
-/*@}*/
-
-
-/** @name Transmitter Configuration (TXC)
- *  @{
- */
-#define XTE_TXC_TXRST_MASK      0x80000000   /**< Transmitter reset */
-#define XTE_TXC_TXJMBO_MASK     0x40000000   /**< Jumbo frame enable */
-#define XTE_TXC_TXFCS_MASK      0x20000000   /**< Generate FCS */
-#define XTE_TXC_TXEN_MASK       0x10000000   /**< Transmitter enable */
-#define XTE_TXC_TXVLAN_MASK     0x08000000   /**< VLAN enable */
-#define XTE_TXC_TXHD_MASK       0x04000000   /**< Half duplex */
-#define XTE_TXC_TXIFG_MASK      0x02000000   /**< IFG adjust enable */
-/*@}*/
-
-
-/** @name Flow Control Configuration (FCC)
- *  @{
- */
-#define XTE_FCC_RXFLO_MASK      0x20000000   /**< Rx flow control enable */
-#define XTE_FCC_TXFLO_MASK      0x40000000   /**< Tx flow control enable */
-/*@}*/
-
-
-/** @name EMAC Configuration (EMCFG)
- * @{
- */
-#define XTE_EMCFG_LINKSPD_MASK   0xC0000000  /**< Link speed */
-#define XTE_EMCFG_RGMII_MASK     0x20000000  /**< RGMII mode enable */
-#define XTE_EMCFG_SGMII_MASK     0x10000000  /**< SGMII mode enable */
-#define XTE_EMCFG_1000BASEX_MASK 0x08000000  /**< 1000BaseX mode enable */
-#define XTE_EMCFG_HOSTEN_MASK    0x04000000  /**< Host interface enable */
-#define XTE_EMCFG_TX16BIT        0x02000000  /**< 16 bit Tx client enable */
-#define XTE_EMCFG_RX16BIT        0x01000000  /**< 16 bit Rx client enable */
-
-#define XTE_EMCFG_LINKSPD_10     0x00000000   /**< XTE_EMCFG_LINKSPD_MASK for
-                                                   10 Mbit */
-#define XTE_EMCFG_LINKSPD_100    0x40000000   /**< XTE_EMCFG_LINKSPD_MASK for
-                                                   100 Mbit */
-#define XTE_EMCFG_LINKSPD_1000   0x80000000   /**< XTE_EMCFG_LINKSPD_MASK for
-                                                   1000 Mbit */
-/*@}*/
-
-
-/** @name EMAC RGMII/SGMII Configuration (GMIC)
- * @{
- */
-#define XTE_GMIC_RGLINKSPD_MASK    0xC0000000	/**< RGMII link speed */
-#define XTE_GMIC_SGLINKSPD_MASK    0x0000000C	/**< SGMII link speed */
-#define XTE_GMIC_RGSTATUS_MASK     0x00000002	/**< RGMII link status */
-#define XTE_GMIC_RGHALFDUPLEX_MASK 0x00000001	/**< RGMII half duplex */
-
-#define XTE_GMIC_RGLINKSPD_10      0x00000000	/**< XTE_GMIC_RGLINKSPD_MASK
-                                                     for 10 Mbit */
-#define XTE_GMIC_RGLINKSPD_100     0x40000000	/**< XTE_GMIC_RGLINKSPD_MASK
-                                                     for 100 Mbit */
-#define XTE_GMIC_RGLINKSPD_1000    0x80000000	/**< XTE_GMIC_RGLINKSPD_MASK
-                                                     for 1000 Mbit */
-#define XTE_GMIC_SGLINKSPD_10      0x00000000	/**< XTE_SGMIC_RGLINKSPD_MASK
-                                                     for 10 Mbit */
-#define XTE_GMIC_SGLINKSPD_100     0x00000004	/**< XTE_SGMIC_RGLINKSPD_MASK
-                                                     for 100 Mbit */
-#define XTE_GMIC_SGLINKSPD_1000    0x00000008	/**< XTE_SGMIC_RGLINKSPD_MASK
-                                                     for 1000 Mbit */
-/*@}*/
-
-
-/** @name EMAC Management Configuration (MC)
- * @{
- */
-#define XTE_MC_MDIO_MASK       0x00000040   /**< MII management enable */
-#define XTE_MC_CLK_DVD_MAX     0x3F	    /**< Maximum MDIO divisor */
-/*@}*/
-
-
-/** @name EMAC Unicast Address Register Word 1 (UAW1)
- * @{
- */
-#define XTE_UAW1_MASK          0x0000FFFF   /**< Station address bits [47:32]
-                                                 Station address bits [31:0]
-                                                 are stored in register
-                                                 UAW0 */
-/*@}*/
-
-
-/** @name EMAC Multicast Address Register Word 1 (MAW1)
- * @{
- */
-#define XTE_MAW1_CAMRNW_MASK   0x00800000   /**< CAM read/write control */
-#define XTE_MAW1_CAMADDR_MASK  0x00030000   /**< CAM address mask */
-#define XTE_MAW1_MASK          0x0000FFFF   /**< Multicast address bits [47:32]
-                                                 Multicast address bits [31:0]
-                                                 are stored in register
-                                                 MAW0 */
-#define XTE_MAW1_CAMMADDR_SHIFT_MASK 16	    /**< Number of bits to shift right
-                                                 to align with
-                                                 XTE_MAW1_CAMADDR_MASK */
-/*@}*/
-
-
-/** @name EMAC Address Filter Mode (AFM)
- * @{
- */
-#define XTE_AFM_EPPRM_MASK     0x80000000   /**< Promiscuous mode enable */
-/*@}*/
-
-
-/** @name Checksum offload buffer descriptor extensions
- * @{
- */
-/** Byte offset where checksum should begin (16 bit word) */
-#define XTE_BD_TX_CSBEGIN_OFFSET  XDMAV3_BD_USR0_OFFSET
-
-/** Offset where checksum should be inserted (16 bit word) */
-#define XTE_BD_TX_CSINSERT_OFFSET (XDMAV3_BD_USR0_OFFSET + 2)
-
-/** Checksum offload control for transmit (16 bit word) */
-#define XTE_BD_TX_CSCNTRL_OFFSET  XDMAV3_BD_USR1_OFFSET
-
-/** Seed value for checksum calculation (16 bit word) */
-#define XTE_BD_TX_CSINIT_OFFSET   (XDMAV3_BD_USR1_OFFSET + 2)
-
-/** Receive frame checksum calculation (16 bit word) */
-#define XTE_BD_RX_CSRAW_OFFSET    (XDMAV3_BD_USR5_OFFSET + 2)
-
-/*@}*/
-
-/** @name TX_CSCNTRL bit mask
- * @{
- */
-#define XTE_BD_TX_CSCNTRL_CALC_MASK  0x0001  /**< Enable/disable Tx
-                                                  checksum */
-/*@}*/
-
-/**************************** Type Definitions *******************************/
-
-/***************** Macros (Inline Functions) Definitions *********************/
-
-
-/****************************************************************************/
-/**
-*
-* Read the given IPIF register.
-*
-* @param    BaseAddress is the IPIF base address of the device
-* @param    RegOffset is the register offset to be read
-*
-* @return   The 32-bit value of the register
-*
-* @note
-* C-style signature:
-*    u32 XTemac_mReadReg(u32 BaseAddress, u32 RegOffset)
-*
-*****************************************************************************/
-#define XTemac_mReadReg(BaseAddress, RegOffset) \
-    XIo_In32((BaseAddress) + (RegOffset))
-
-
-/****************************************************************************/
-/**
-*
-* Write the given IPIF register.
-*
-* @param    BaseAddress is the IPIF base address of the device
-* @param    RegOffset is the register offset to be written
-* @param    Data is the 32-bit value to write to the register
-*
-* @return   None.
-*
-* @note
-* C-style signature:
-*    void XTemac_mWriteReg(u32 BaseAddress, u32 RegOffset, u32 Data)
-*
-*****************************************************************************/
-#define XTemac_mWriteReg(BaseAddress, RegOffset, Data) \
-    XIo_Out32((BaseAddress) + (RegOffset), (Data))
-
-/****************************************************************************/
-/**
-*
-* Convert host register offset to a proper DCR or memory mapped offset (DCR
-* not currently supported).
-*
-* @param    HostRegOffset is the relative regster offset to be converted
-*
-* @return   The correct offset of the register
-*
-* @note
-* C-style signature:
-*    u32 XTemac_mHostOffset(u32 RegOffset)
-*
-*****************************************************************************/
-#define XTemac_mHostOffset(HostRegOffset) \
-    ((u32)(HostRegOffset) + XTE_HOST_IPIF_OFFSET)
-
-/****************************************************************************/
-/**
-*
-* Read the given host register.
-*
-* @param    BaseAddress is the base address of the device
-* @param    HostRegOffset is the register offset to be read
-*
-* @return   The 32-bit value of the register
-*
-* @note
-* C-style signature:
-*    u32 XTemac_mReadHostReg(u32 BaseAddress, u32 HostRegOffset)
-*
-*****************************************************************************/
-#define XTemac_mReadHostReg(BaseAddress, HostRegOffset) \
-    XIo_In32((BaseAddress) + XTemac_mHostOffset(HostRegOffset))
-
-
-/****************************************************************************/
-/**
-*
-* Write the given host register.
-*
-* @param    BaseAddress is the base address of the device
-* @param    HostRegOffset is the register offset to be written
-* @param    Data is the 32-bit value to write to the register
-*
-* @return   None.
-*
-* C-style signature:
-*    void XTemac_mWriteHostReg(u32 BaseAddress, u32 RegOffset,
-*                              u32 Data)
-*
-*****************************************************************************/
-#define XTemac_mWriteHostReg(BaseAddress, HostRegOffset, Data) \
-    XIo_Out32((BaseAddress) + XTemac_mHostOffset(HostRegOffset), (Data))
-
-
-/****************************************************************************/
-/**
-*
-* Set the station address.
-*
-* @param    BaseAddress is the base address of the device
-* @param    AddressPtr is a pointer to a 6-byte MAC address
-*
-* @return   None.
-*
-* @note
-* C-style signature:
-*    u32 XTemac_mSetMacAddress(u32 BaseAddress, u8 *AddressPtr)
-*
-*****************************************************************************/
-#define XTemac_mSetMacAddress(BaseAddress, AddressPtr)              \
-{                                                                   \
-    u32 Reg;                                                    \
-    u8* Aptr = (u8*)(AddressPtr);                           \
-                                                                    \
-    Reg =  Aptr[0] & 0x000000FF;                                    \
-    Reg |= Aptr[1] << 8;                                            \
-    Reg |= Aptr[2] << 16;                                           \
-    Reg |= Aptr[3] << 24;                                           \
-    XTemac_mWriteHostReg((BaseAddress), XTE_UAW0_OFFSET, Reg);      \
-                                                                    \
-    Reg = XTemac_mReadHostReg((BaseAddress), XTE_UAW1_OFFSET);      \
-    Reg &= ~XTE_UAW1_MASK;                                          \
-    Reg |= Aptr[4] & 0x000000FF;                                    \
-    Reg |= Aptr[5] << 8;                                            \
-    XTemac_mWriteHostReg((BaseAddress), XTE_UAW1_OFFSET, Reg);      \
-}
-
-
-/****************************************************************************/
-/**
-*
-* Check to see if the transmission is complete.
-*
-* @param    BaseAddress is the base address of the device
-*
-* @return   TRUE if it is done, or FALSE if it is not.
-*
-* @note
-* C-style signature:
-*    XBoolean XTemac_mIsTxDone(u32 BaseAddress)
-*
-*****************************************************************************/
-#define XTemac_mIsTxDone(BaseAddress)                                   \
-    (((XIo_In32((BaseAddress) + XTE_IPISR_OFFSET) & XTE_IPXR_XMIT_DONE_MASK) == \
-      XTE_IPXR_XMIT_DONE_MASK) ? TRUE : FALSE)
-
-
-/****************************************************************************/
-/**
-*
-* Check to see if the receive FIFO is empty.
-*
-* @param    BaseAddress is the base address of the device
-*
-* @return   TRUE if it is empty, or FALSE if it is not.
-*
-* @note
-* C-style signature:
-*    XBoolean XTemac_mIsRxEmpty(u32 BaseAddress)
-*
-*****************************************************************************/
-#define XTemac_mIsRxEmpty(BaseAddress)                                  \
-    ((XIo_In32((BaseAddress) + XTE_IPISR_OFFSET) & XTE_IPXR_RECV_DONE_MASK) \
-     ? FALSE : TRUE)
-
-
-/****************************************************************************/
-/**
-*
-* Reset the entire core including any attached PHY. Note that there may be a
-* settling time required after initiating a reset. See the core spec and the
-* PHY datasheet.
-*
-* @param    BaseAddress is the base address of the device
-*
-* @return   Nothing
-*
-* @note
-* C-style signature:
-*    void XTemac_mReset(u32 BaseAddress)
-*
-*****************************************************************************/
-#define XTemac_mReset(BaseAddress)                                      \
-    XIo_Out32((BaseAddress) + XTE_DSR_OFFSET, XTE_DSR_RESET_MASK)
-
-
-/************************** Function Prototypes ******************************/
-
-void XTemac_Enable(u32 BaseAddress);
-void XTemac_Disable(u32 BaseAddress);
-int XTemac_SendFrame(u32 BaseAddress, void *FramePtr, int Size);
-int XTemac_RecvFrame(u32 BaseAddress, void *FramePtr);
-
-#ifdef __cplusplus
-  }
-#endif
-
-#endif /* end of protection macro */
diff --git a/drivers/net/ethernet/xilinx/xilinx_temac/xtemac_linux.c b/drivers/net/ethernet/xilinx/xilinx_temac/xtemac_linux.c
deleted file mode 100644
index 9463624..0000000
--- a/drivers/net/ethernet/xilinx/xilinx_temac/xtemac_linux.c
+++ /dev/null
@@ -1,3242 +0,0 @@
-/*
- * Xilinx Ethernet Linux component to interface XTemac component to Linux
- *
- * Author: MontaVista Software, Inc.
- *         source@mvista.com
- *
- * 2002-2004 (c) MontaVista, Software, Inc.  This file is licensed under the terms
- * of the GNU General Public License version 2.1.  This program is licensed
- * "as is" without any warranty of any kind, whether express or implied.
- *
- * <pre>
- * MODIFICATION HISTORY:
- *
- * Ver   Who  Date     Changes
- * ----- ---- -------- -------------------------------------------------------
- * 1.00a xd   12/12/05 First release
- * 2.00a jvb  12/21/05 Added support for checksum offload, and receive side DRE
- * 2.00b wgr  08/17/06 Port to kernel 2.6.10_mvl401.
- * 2.00c rpm  12/12/06 Updated PHY address detection code, as well as PHY
- *			autonegotiation support (still not great - but better). Changed
- *			XILINX_PLB_TEMAC_3_00A_ML403_PHY_SUPPORT to MARVELL_88E1111.
- * </pre>
- *
- */
-
-/*
- * This driver is a bit unusual in that it is composed of two logical
- * parts where one part is the OS independent code and the other part is
- * the OS dependent code.  Xilinx provides their drivers split in this
- * fashion.  This file represents the Linux OS dependent part known as
- * the Linux adapter.  The other files in this directory are the OS
- * independent files as provided by Xilinx with no changes made to them.
- * The names exported by those files begin with XTemac_.  All functions
- * in this file that are called by Linux have names that begin with
- * xenet_.  The functions in this file that have Handler in their name
- * are registered as callbacks with the underlying Xilinx OS independent
- * layer.  Any other functions are static helper functions.
- */
-
-/*
- * With the way the hardened PLB Temac works, the driver needs to communicate
- * with the PHY controller. Since each board will have a different
- * type of PHY, the code that communicates with the MII type controller
- * is inside #ifdef MARVELL_88E1111_PHY conditional
- * compilation. For your specific board, you will want to replace this code with
- * code of your own for your specific board.
- */
-
-#include <linux/module.h>
-#include <linux/kernel.h>
-#include <linux/init.h>
-#include <linux/mm.h>
-#include <linux/netdevice.h>
-#include <linux/etherdevice.h>
-#include <linux/mii.h>
-#include <linux/delay.h>
-#include <linux/dma-mapping.h>
-#include <linux/xilinx_devices.h>
-#include <asm/io.h>
-#include <linux/ethtool.h>
-#include <linux/vmalloc.h>
-
-#include "xbasic_types.h"
-#include "xtemac.h"
-#include "xipif_v1_23_b.h"
-#include "xpacket_fifo_v2_00_a.h"
-#include "xdmav3.h"
-#include "xdmabdv3.h"
-
-
-#define LOCAL_FEATURE_RX_CSUM   0x01
-#define LOCAL_FEATURE_RX_DRE    0x02
-
-/*
- * Default SEND and RECV buffer descriptors (BD) numbers.
- * BD Space needed is (XTE_SEND_BD_CNT+XTE_RECV_BD_CNT)*Sizeof(XDmaBdV3).
- * Each XDmaBdV3 instance currently takes 40 bytes.
- */
-#define XTE_SEND_BD_CNT 256
-#define XTE_RECV_BD_CNT 256
-
-/* Must be shorter than length of ethtool_drvinfo.driver field to fit */
-#define DRIVER_NAME         "xilinx_temac"
-#define DRIVER_DESCRIPTION  "Xilinx Tri-Mode Ethernet MAC driver"
-#define DRIVER_VERSION      "2.00b"
-
-#define TX_TIMEOUT   (3*HZ)	/* Transmission timeout is 3 seconds. */
-
-/*
- * When Xilinx TEMAC is configured to use the TX Data Realignment Engine (DRE),
- * alignment restrictions are as follows:
- *   - SGDMA transmit buffers can be aligned on any boundary, but receive buffers
- *     must be aligned on a 8-byte boundary.
- *
- * Without TX DRE, buffer alignment restrictions are as follows:
- *   - SGDMA transmit and receive buffers must be aligned on a 8-byte boundary
- *
- * There are no alignment restrictions when using XTemac_FifoRead() and
- * XTemac_FifoWrite().
- *
- */
-/*
- * ALIGNMENT_RECV = the alignement required to receive (8 required by plb bus w/no DRE)
- * ALIGNMENT_SEND = the alignement required to send (8 required by plb bus w/no DRE)
- * ALIGNMENT_SEND_PERF = tx alignment for better performance
- *
- * ALIGNMENT_SEND is used to see if we *need* to copy the data to re-align.
- * ALIGNMENT_SEND_PERF is used if we've decided we need to copy anyway, we just
- * copy to this alignment for better performance.
- */
-
-#define ALIGNMENT_RECV          32
-#define ALIGNMENT_SEND          8
-#define ALIGNMENT_SEND_PERF     32
-
-
-/* SGDMA buffer descriptors must be aligned on a 8-byte boundary. */
-#define ALIGNMENT_BD            4
-
-/* BUFFER_ALIGN(adr) calculates the number of bytes to the next alignment. */
-#define BUFFER_ALIGNSEND(adr) ((ALIGNMENT_SEND - ((u32) adr)) % ALIGNMENT_SEND)
-#define BUFFER_ALIGNSEND_PERF(adr) ((ALIGNMENT_SEND_PERF - ((u32) adr)) % ALIGNMENT_SEND_PERF)
-#define BUFFER_ALIGNRECV(adr) ((ALIGNMENT_RECV - ((u32) adr)) % ALIGNMENT_RECV)
-
-/* Default TX/RX Threshold and waitbound values for SGDMA mode */
-#define DFT_TX_THRESHOLD  16
-#define DFT_TX_WAITBOUND  1
-#define DFT_RX_THRESHOLD  2
-#define DFT_RX_WAITBOUND  1
-
-#define XTE_AUTOSTRIPPING 1
-
-/* Put Buffer Descriptors in BRAM?
- * NOTE:
- *   Putting BDs in BRAM only works if there is only ONE instance of the TEMAC
- *   in hardware.  The code does not handle multiple instances, e.g. it does
- *   not manage the memory in BRAM.
- */
-#define BD_IN_BRAM        0
-#define BRAM_BASEADDR     0xffff8000
-
-/*
- * Our private per device data.  When a net_device is allocated we will
- * ask for enough extra space for this.
- */
-struct net_local {
-	struct list_head rcv;
-	struct list_head xmit;
-
-	struct net_device *ndev;	/* this device */
-	struct net_device *next_dev;	/* The next device in dev_list */
-	struct net_device_stats stats;	/* Statistics for this device */
-	struct timer_list phy_timer;	/* PHY monitoring timer */
-
-	u32 index;		/* Which interface is this */
-	XInterruptHandler Isr;	/* Pointer to the XTemac ISR routine */
-	u8 gmii_addr;		/* The GMII address of the PHY */
-
-	/* The underlying OS independent code needs space as well.  A
-	 * pointer to the following XTemac structure will be passed to
-	 * any XTemac_ function that requires it.  However, we treat the
-	 * data as an opaque object in this file (meaning that we never
-	 * reference any of the fields inside of the structure). */
-	XTemac Emac;
-
-	unsigned int max_frame_size;
-
-	int cur_speed;
-
-	/* Buffer Descriptor space for both TX and RX BD ring */
-	void *desc_space;	/* virtual address of BD space */
-	dma_addr_t desc_space_handle;	/* physical address of BD space */
-	int desc_space_size;	/* size of BD space */
-
-	/* buffer for one skb in case no room is available for transmission */
-	struct sk_buff *deferred_skb;
-
-	/* send buffers for non tx-dre hw */
-	void **tx_orig_buffers;	/* Buffer addresses as returned by
-				   dma_alloc_coherent() */
-	void **tx_buffers;	/* Buffers addresses aligned for DMA */
-	dma_addr_t *tx_phys_buffers;	/* Buffer addresses in physical memory */
-	size_t tx_buffers_cur;	/* Index of current buffer used */
-
-	/* stats */
-	int max_frags_in_a_packet;
-	unsigned long realignments;
-	unsigned long tx_hw_csums;
-	unsigned long rx_hw_csums;
-	unsigned long local_features;
-#if ! XTE_AUTOSTRIPPING
-	unsigned long stripping;
-#endif
-};
-
-/* for exclusion of all program flows (processes, ISRs and BHs) */
-spinlock_t XTE_spinlock;
-spinlock_t XTE_tx_spinlock;
-spinlock_t XTE_rx_spinlock;
-
-/*
- * ethtool has a status reporting feature where we can report any sort of
- * status information we'd like. This is the list of strings used for that
- * status reporting. ETH_GSTRING_LEN is defined in ethtool.h
- */
-static char xenet_ethtool_gstrings_stats[][ETH_GSTRING_LEN] = {
-	"txdmaerr", "txpfifoerr", "txstatuserr", "rxrejerr", "rxdmaerr",
-	"rxpfifoerror", "fifoerr", "ipiferr", "intr",
-	"max_frags", "tx_hw_csums", "rx_hw_csums",
-};
-
-#define XENET_STATS_LEN sizeof(xenet_ethtool_gstrings_stats) / ETH_GSTRING_LEN
-
-/* Helper function to determine if a given XTemac error warrants a reset. */
-extern inline int status_requires_reset(int s)
-{
-	return (s == XST_FIFO_ERROR ||
-		s == XST_PFIFO_DEADLOCK ||
-		s == XST_DMA_ERROR || s == XST_IPIF_ERROR);
-}
-
-/* BH statics */
-static LIST_HEAD(receivedQueue);
-static spinlock_t receivedQueueSpin = __SPIN_LOCK_UNLOCKED(receivedQueueSpin);
-
-static LIST_HEAD(sentQueue);
-static spinlock_t sentQueueSpin = __SPIN_LOCK_UNLOCKED(sentQueueSpin);
-
-/* from mii.h
- *
- * Items in mii.h but not in gmii.h
- */
-#define ADVERTISE_100FULL       0x0100
-#define ADVERTISE_100HALF       0x0080
-#define ADVERTISE_10FULL        0x0040
-#define ADVERTISE_10HALF        0x0020
-#define ADVERTISE_CSMA          0x0001
-
-#define EX_ADVERTISE_1000FULL   0x0200
-#define EX_ADVERTISE_1000HALF   0x0100
-
-/*
- * items not in mii.h nor gmii.h but should be
- */
-#define MII_EXADVERTISE 0x09
-
-typedef enum DUPLEX { UNKNOWN_DUPLEX, HALF_DUPLEX, FULL_DUPLEX } DUPLEX;
-
-int renegotiate_speed(struct net_device *dev, int speed, DUPLEX duplex)
-{
-	struct net_local *lp = (struct net_local *) dev->priv;
-	int status;
-	int retries = 2;
-	int wait_count;
-	u16 phy_reg0 = BMCR_ANENABLE | BMCR_ANRESTART;
-	u16 phy_reg1;
-	u16 phy_reg4;
-	u16 phy_reg9 = 0;
-
-
-	/*
-	 * It appears that the 10baset full and half duplex settings
-	 * are overloaded for gigabit ethernet
-	 */
-	if ((duplex == FULL_DUPLEX) && (speed == 10)) {
-		phy_reg4 = ADVERTISE_10FULL | ADVERTISE_CSMA;
-	}
-	else if ((duplex == FULL_DUPLEX) && (speed == 100)) {
-		phy_reg4 = ADVERTISE_100FULL | ADVERTISE_CSMA;
-	}
-	else if ((duplex == FULL_DUPLEX) && (speed == 1000)) {
-		phy_reg4 = ADVERTISE_CSMA;
-		phy_reg9 = EX_ADVERTISE_1000FULL;
-	}
-	else if (speed == 10) {
-		phy_reg4 = ADVERTISE_10HALF | ADVERTISE_CSMA;
-	}
-	else if (speed == 100) {
-		phy_reg4 = ADVERTISE_100HALF | ADVERTISE_CSMA;
-	}
-	else if (speed == 1000) {
-		phy_reg4 = ADVERTISE_CSMA;
-		phy_reg9 = EX_ADVERTISE_1000HALF;
-	}
-	else {
-		printk(KERN_ERR
-		       "%s: XTemac: unsupported speed requested: %d\n",
-		       dev->name, speed);
-		return -1;
-	}
-
-	/*
-	 * link status in register 1:
-	 * first read / second read:
-	 * 0               0           link is down
-	 * 0               1           link is up (but it was down earlier)
-	 * 1               0           link is down (but it was just up)
-	 * 1               1           link is up
-	 *
-	 */
-	status = XTemac_PhyRead(&lp->Emac, lp->gmii_addr, MII_BMSR, &phy_reg1);
-	status |= XTemac_PhyRead(&lp->Emac, lp->gmii_addr, MII_BMSR, &phy_reg1);
-	status |=
-		XTemac_PhyWrite(&lp->Emac, lp->gmii_addr, MII_ADVERTISE,
-				phy_reg4);
-	status |=
-		XTemac_PhyWrite(&lp->Emac, lp->gmii_addr, MII_EXADVERTISE,
-				phy_reg9);
-	if (status != XST_SUCCESS) {
-		printk(KERN_ERR
-		       "%s: XTemac: error accessing PHY: %d\n", dev->name,
-		       status);
-		return -1;
-	}
-
-	while (retries--) {
-		/* initiate an autonegotiation of the speed */
-		status = XTemac_PhyWrite(&lp->Emac, lp->gmii_addr, MII_BMCR,
-					 phy_reg0);
-		if (status != XST_SUCCESS) {
-			printk(KERN_ERR
-			       "%s: XTemac: error starting autonegotiateion: %d\n",
-			       dev->name, status);
-			return -1;
-		}
-
-		wait_count = 20;	/* so we don't loop forever */
-		while (wait_count--) {
-			/* wait a bit for the negotiation to complete */
-			mdelay(500);
-			status = XTemac_PhyRead(&lp->Emac, lp->gmii_addr,
-						MII_BMSR, &phy_reg1);
-			status |=
-				XTemac_PhyRead(&lp->Emac, lp->gmii_addr,
-					       MII_BMSR, &phy_reg1);
-			if (status != XST_SUCCESS) {
-				printk(KERN_ERR
-				       "%s: XTemac: error reading MII status %d\n",
-				       dev->name, status);
-				return -1;
-			}
-			if ((phy_reg1 & BMSR_LSTATUS) &&
-			    (phy_reg1 & BMSR_ANEGCAPABLE))
-				break;
-
-		}
-
-		if (phy_reg1 & BMSR_LSTATUS) {
-			printk(KERN_INFO
-			       "%s: XTemac: We renegotiated the speed to: %d\n",
-			       dev->name, speed);
-			return 0;
-		}
-		else {
-			printk(KERN_ERR
-			       "%s: XTemac: Not able to set the speed to %d (status: 0x%0x)\n",
-			       dev->name, speed, phy_reg1);
-			return -1;
-		}
-	}
-
-	printk(KERN_ERR
-	       "%s: XTemac: Not able to set the speed to %d\n", dev->name,
-	       speed);
-	return -1;
-}
-
-/* The following code tries to detect the MAC speed so that the silicon-
- * based TEMAC speed can be set to match. There is some PHY-specific code
- * that works with Marvel PHY (Xilinx ML4xx boards), or some more general
- * code that tries to start autonegotiation and detect the result. If you
- * don't like this or it doesn't work for you, change it or hardcode the speed.
- *
- * Note also a silicon issue with Xilinx V4FX with regards to MDIO access:
- * 	pre-CES4 chips (ML403, pre-production ML405/ML410)
- *		use hard_temac_v3_00_a
- *	CES4 or later chips (production ML405, ML410 boards)
- *		use hard_temac_v3_00_b
- */
-#define MARVELL_88E1111_PHY
-
-/*
- * This function sets up MAC's speed according to link speed of PHY
- * This function is specific to MARVELL 88E1111 PHY chip and assumes GMII
- * interface is being used by the TEMAC
- */
-void set_mac_speed(struct net_local *lp)
-{
-	u16 phylinkspeed;
-	struct net_device *dev = lp->ndev;
-	int ret;
-
-#ifndef MARVELL_88E1111_PHY
-	int retry_count = 1;
-#endif
-
-	/* See comments at top for an explanation of MARVELL_88E1111_PHY */
-#ifdef MARVELL_88E1111_PHY
-#define MARVELL_88E1111_PHY_SPECIFIC_STATUS_REG_OFFSET  17
-#define MARVELL_88E1111_LINKSPEED_MARK                  0xC000
-#define MARVELL_88E1111_LINKSPEED_SHIFT                 14
-#define MARVELL_88E1111_LINKSPEED_1000M                 0x0002
-#define MARVELL_88E1111_LINKSPEED_100M                  0x0001
-#define MARVELL_88E1111_LINKSPEED_10M                   0x0000
-	u16 RegValue;
-
-	/* Loop until read of PHY specific status register is successful. */
-	do {
-		ret = XTemac_PhyRead(&lp->Emac, lp->gmii_addr,
-				     MARVELL_88E1111_PHY_SPECIFIC_STATUS_REG_OFFSET,
-				     &RegValue);
-	} while (ret != XST_SUCCESS);
-
-
-	/* Get current link speed */
-	phylinkspeed = (RegValue & MARVELL_88E1111_LINKSPEED_MARK)
-		>> MARVELL_88E1111_LINKSPEED_SHIFT;
-
-	/* Update TEMAC speed accordingly */
-	switch (phylinkspeed) {
-	case (MARVELL_88E1111_LINKSPEED_1000M):
-		XTemac_SetOperatingSpeed(&lp->Emac, 1000);
-		printk(KERN_INFO "%s: XTemac: speed set to 1000Mb/s\n",
-		       dev->name);
-		lp->cur_speed = 1000;
-		break;
-	case (MARVELL_88E1111_LINKSPEED_100M):
-		XTemac_SetOperatingSpeed(&lp->Emac, 100);
-		printk(KERN_INFO "%s: XTemac: speed set to 100Mb/s\n",
-		       dev->name);
-		lp->cur_speed = 100;
-		break;
-	case (MARVELL_88E1111_LINKSPEED_10M):
-		XTemac_SetOperatingSpeed(&lp->Emac, 10);
-		printk(KERN_INFO "%s: XTemac: speed set to 10Mb/s\n",
-		       dev->name);
-		lp->cur_speed = 10;
-		break;
-	default:
-		XTemac_SetOperatingSpeed(&lp->Emac, 1000);
-		printk(KERN_INFO "%s: XTemac: speed set to 1000Mb/s\n",
-		       dev->name);
-		lp->cur_speed = 1000;
-		break;
-	}
-
-#else /* generic PHY */
-	if (XTemac_mGetPhysicalInterface(&lp->Emac) == XTE_PHY_TYPE_MII) {
-		phylinkspeed = 100;
-	}
-	else {
-		phylinkspeed = 1000;
-	}
-
-	/*
-	 * Try to renegotiate the speed until something sticks
-	 */
-	while (phylinkspeed > 1) {
-		ret = renegotiate_speed(dev, phylinkspeed, FULL_DUPLEX);
-		/*
-		 * ret == 1 - try it again
-		 * ret == 0 - it worked
-		 * ret <  0 - there was some failure negotiating the speed
-		 */
-		if (ret == 0) {
-			/* it worked, get out of the loop */
-			break;
-		}
-
-		/* it didn't work this time, but it may work if we try again */
-		if ((ret == 1) && (retry_count)) {
-			retry_count--;
-			printk("trying again...\n");
-			continue;
-		}
-		/* reset the retry_count, becuase we're about to try a lower speed */
-		retry_count = 1;
-		phylinkspeed /= 10;
-	}
-	if (phylinkspeed == 1) {
-		printk(KERN_INFO "%s: XTemac: could not negotiate speed\n",
-		       dev->name);
-		lp->cur_speed = 0;
-		return;
-	}
-
-	XTemac_SetOperatingSpeed(&lp->Emac, phylinkspeed);
-	printk(KERN_INFO "%s: XTemac: speed set to %dMb/s\n", dev->name,
-	       phylinkspeed);
-	lp->cur_speed = phylinkspeed;
-#endif
-}
-
-/*
- * Helper function to reset the underlying hardware.  This is called
- * when we get into such deep trouble that we don't know how to handle
- * otherwise.
- */
-
-/*
- * This reset function should handle five different reset request types
- * from other functions. The reset request types include
- *      1. FIFO error: FifoWrite()/FifoSend()/FifoRecv()/FifoRead() fails
- *      2. DMA error: SgAlloc()/SgCommit()/SgFree() fails
- *      3. DUPLEX error: MAC DUPLEX is not full duplex or does not match
- *                       PHY setting
- *      4. TX Timeout: Timeout occurs for a TX frame given to this adapter
- *      5. Error Status: Temac Error interrupt occurs and asks for a reset
- *
- */
-
-static void reset(struct net_device *dev, u32 line_num)
-{
-	struct net_local *lp = (struct net_local *) dev->priv;
-	u16 TxThreshold, TxWaitBound, RxThreshold, RxWaitBound;
-	u32 Options;
-	static u32 reset_cnt = 0;
-
-	printk(KERN_INFO "%s: XTemac: resets (#%u) from code line %d\n",
-	       dev->name, ++reset_cnt, line_num);
-
-	/* Shouldn't really be necessary, but shouldn't hurt. */
-	netif_stop_queue(dev);
-
-	/* Stop device */
-	XTemac_Stop(&lp->Emac);
-
-	/*
-	 * XTemac_Reset puts the device back to the default state.  We need
-	 * to save all the settings we don't already know, reset, restore
-	 * the settings, and then restart the temac.
-	 */
-	Options = XTemac_GetOptions(&lp->Emac);
-	if (XTemac_mIsSgDma(&lp->Emac)) {
-		/*
-		 * The following two functions will return an error if we are
-		 * not doing scatter-gather DMA.  We just checked that so we
-		 * can safely ignore the return values.
-		 */
-		(int) XTemac_IntrSgCoalGet(&lp->Emac, XTE_RECV, &RxThreshold,
-					   &RxWaitBound);
-		(int) XTemac_IntrSgCoalGet(&lp->Emac, XTE_SEND, &TxThreshold,
-					   &TxWaitBound);
-
-	}
-
-	/* now we can reset the device */
-	XTemac_Reset(&lp->Emac, 0);
-
-	/* Reset on TEMAC also resets PHY. Give it some time to finish negotiation
-	 * before we move on */
-	mdelay(2000);
-
-	/*
-	 * The following four functions will return an error if the
-	 * EMAC is already started.  We just stopped it by calling
-	 * XTemac_Reset() so we can safely ignore the return values.
-	 */
-	(int) XTemac_SetMacAddress(&lp->Emac, dev->dev_addr);
-	(int) XTemac_SetOptions(&lp->Emac, Options);
-	(int) XTemac_ClearOptions(&lp->Emac, ~Options);
-	Options = XTemac_GetOptions(&lp->Emac);
-	printk(KERN_INFO "%s: XTemac: Options: 0x%x\n", dev->name, Options);
-
-	set_mac_speed(lp);
-
-	if (XTemac_mIsSgDma(&lp->Emac)) {	/* SG DMA mode */
-		/*
-		 * The following 2 functions will return an error if
-		 * we are not doing scatter-gather DMA or if the EMAC is
-		 * already started.  We just checked that we are indeed
-		 * doing scatter-gather and we just stopped the EMAC so
-		 * we can safely ignore the return values.
-		 */
-		(int) XTemac_IntrSgCoalSet(&lp->Emac, XTE_RECV, RxThreshold,
-					   RxWaitBound);
-		(int) XTemac_IntrSgCoalSet(&lp->Emac, XTE_SEND, TxThreshold,
-					   TxWaitBound);
-
-		/* Enable both SEND and RECV interrupts */
-		XTemac_IntrSgEnable(&lp->Emac, XTE_SEND | XTE_RECV);
-	}
-	else {			/* FIFO interrupt mode */
-		XTemac_IntrFifoEnable(&lp->Emac, XTE_RECV | XTE_SEND);
-	}
-
-	if (lp->deferred_skb) {
-		dev_kfree_skb_any(lp->deferred_skb);
-		lp->deferred_skb = NULL;
-		lp->stats.tx_errors++;
-	}
-
-	/*
-	 * XTemac_Start returns an error when: if configured for
-	 * scatter-gather DMA and a descriptor list has not yet been created
-	 * for the send or receive channel, or if no receive buffer descriptors
-	 * have been initialized. Those are not happening. so ignore the returned
-	 * result checking.
-	 */
-	(int) XTemac_Start(&lp->Emac);
-
-	/* We're all ready to go.  Start the queue in case it was stopped. */
-	netif_wake_queue(dev);
-}
-
-/*
- * The PHY registers read here should be standard registers in all PHY chips
- */
-static int get_phy_status(struct net_device *dev, DUPLEX * duplex, int *linkup)
-{
-	struct net_local *lp = (struct net_local *) dev->priv;
-	u16 reg;
-	int xs;
-
-	xs = XTemac_PhyRead(&lp->Emac, lp->gmii_addr, MII_BMCR, &reg);
-	if (xs != XST_SUCCESS) {
-		printk(KERN_ERR
-		       "%s: XTemac: could not read PHY control register; error %d\n",
-		       dev->name, xs);
-		return -1;
-	}
-	*duplex = FULL_DUPLEX;
-
-	xs = XTemac_PhyRead(&lp->Emac, lp->gmii_addr, MII_BMSR, &reg);
-	if (xs != XST_SUCCESS) {
-		printk(KERN_ERR
-		       "%s: XTemac: could not read PHY status register; error %d\n",
-		       dev->name, xs);
-		return -1;
-	}
-	*linkup = (reg & BMSR_LSTATUS) != 0;
-
-	return 0;
-}
-
-/*
- * This routine is used for two purposes.  The first is to keep the
- * EMAC's duplex setting in sync with the PHY's.  The second is to keep
- * the system apprised of the state of the link.  Note that this driver
- * does not configure the PHY.  Either the PHY should be configured for
- * auto-negotiation or it should be handled by something like mii-tool.
- */
-static void poll_gmii(unsigned long data)
-{
-	struct net_device *dev;
-	struct net_local *lp;
-	DUPLEX phy_duplex;
-	int phy_carrier;
-	int netif_carrier;
-	unsigned long flags;
-
-	spin_lock_irqsave(&XTE_spinlock, flags);
-	dev = (struct net_device *) data;
-	lp = (struct net_local *) dev->priv;
-
-	/* First, find out what's going on with the PHY. */
-	if (get_phy_status(dev, &phy_duplex, &phy_carrier)) {
-		printk(KERN_ERR "%s: XTemac: terminating link monitoring.\n",
-		       dev->name);
-		spin_unlock_irqrestore(&XTE_spinlock, flags);
-		return;
-	}
-
-	netif_carrier = netif_carrier_ok(dev) != 0;
-
-	if (phy_carrier != netif_carrier) {
-		if (phy_carrier) {
-			printk(KERN_INFO
-			       "%s: XTemac: PHY Link carrier restored.\n",
-			       dev->name);
-			netif_carrier_on(dev);
-		}
-		else {
-			printk(KERN_INFO "%s: XTemac: PHY Link carrier lost.\n",
-			       dev->name);
-			netif_carrier_off(dev);
-		}
-	}
-
-	/* Set up the timer so we'll get called again in 2 seconds. */
-	lp->phy_timer.expires = jiffies + 2 * HZ;
-	add_timer(&lp->phy_timer);
-	spin_unlock_irqrestore(&XTE_spinlock, flags);
-}
-
-/*
- * This routine is registered with the OS as the function to call when
- * the TEMAC interrupts.  It in turn, calls the Xilinx OS independent
- * interrupt function.  There are different interrupt functions for FIFO
- * and scatter-gather so we just set a pointer (Isr) into our private
- * data so we don't have to figure it out here.  The Xilinx OS
- * independent interrupt function will in turn call any callbacks that
- * we have registered for various conditions.
- */
-static irqreturn_t xenet_interrupt(int irq, void *dev_id)
-{
-	struct net_device *dev = dev_id;
-	struct net_local *lp = (struct net_local *) dev->priv;
-
-	/* Call it. */
-	(*(lp->Isr)) (&lp->Emac);
-
-	/* Right now, our IRQ handlers do not return a status. Let's always return
-	 * IRQ_HANDLED here for now.
-	 */
-	return IRQ_HANDLED;
-}
-
-static int xenet_open(struct net_device *dev)
-{
-	struct net_local *lp;
-	u32 Options;
-	unsigned long flags;
-
-	/*
-	 * Just to be safe, stop TX queue and the device first.  If the device is
-	 * already stopped, an error will be returned.  In this case, we don't
-	 * really care.
-	 */
-	netif_stop_queue(dev);
-	spin_lock_irqsave(&XTE_spinlock, flags);
-	lp = (struct net_local *) dev->priv;
-	XTemac_Stop(&lp->Emac);
-
-	/* Set the MAC address each time opened. */
-	if (XTemac_SetMacAddress(&lp->Emac, dev->dev_addr) != XST_SUCCESS) {
-		printk(KERN_ERR "%s: XTemac: could not set MAC address.\n",
-		       dev->name);
-		spin_unlock_irqrestore(&XTE_spinlock, flags);
-		return -EIO;
-	}
-
-	/*
-	 * If the device is not configured for polled mode, connect to the
-	 * interrupt controller and enable interrupts.  Currently, there
-	 * isn't any code to set polled mode, so this check is probably
-	 * superfluous.
-	 */
-	Options = XTemac_GetOptions(&lp->Emac);
-	Options &= ~XTE_SGEND_INT_OPTION;
-	Options &= ~XTE_REPORT_RXERR_OPTION;
-	Options |= XTE_FLOW_CONTROL_OPTION;
-	Options |= XTE_JUMBO_OPTION;
-#if XTE_AUTOSTRIPPING
-	Options |= XTE_FCS_STRIP_OPTION;
-#endif
-
-	(int) XTemac_SetOptions(&lp->Emac, Options);
-	(int) XTemac_ClearOptions(&lp->Emac, ~Options);
-	Options = XTemac_GetOptions(&lp->Emac);
-	printk(KERN_INFO "%s: XTemac: Options: 0x%x\n", dev->name, Options);
-
-	/* Register interrupt handler */
-	if ((Options & XTE_POLLED_OPTION) == 0) {
-		int retval;
-
-		/* Grab the IRQ */
-		retval = request_irq(dev->irq, &xenet_interrupt, 0, dev->name,
-				     dev);
-		if (retval) {
-			printk(KERN_ERR
-			       "%s: XTemac: could not allocate interrupt %d.\n",
-			       dev->name, dev->irq);
-			spin_unlock_irqrestore(&XTE_spinlock, flags);
-			return retval;
-		}
-	}
-
-	/* give the system enough time to establish a link */
-	mdelay(2000);
-
-	set_mac_speed(lp);
-
-	INIT_LIST_HEAD(&(lp->rcv));
-	INIT_LIST_HEAD(&(lp->xmit));
-
-	/* Enable interrupts if not in polled mode */
-	if ((Options & XTE_POLLED_OPTION) == 0) {
-		if (!XTemac_mIsSgDma(&lp->Emac)) {	/*fifo direct interrupt driver mode */
-			XTemac_IntrFifoEnable(&lp->Emac, XTE_RECV | XTE_SEND);
-		}
-		else {		/* SG DMA mode */
-			XTemac_IntrSgEnable(&lp->Emac, XTE_SEND | XTE_RECV);
-		}
-	}
-
-	/* Start TEMAC device */
-	if (XTemac_Start(&lp->Emac) != XST_SUCCESS) {
-		printk(KERN_ERR "%s: XTemac: could not start device.\n",
-		       dev->name);
-		free_irq(dev->irq, dev);
-		spin_unlock_irqrestore(&XTE_spinlock, flags);
-		return -EBUSY;
-	}
-	spin_unlock_irqrestore(&XTE_spinlock, flags);
-
-	if (XTemac_mIsSgDma(&lp->Emac)) {
-		u16 threshold_s, timer_s, threshold_r, timer_r;
-
-		(int) XTemac_IntrSgCoalGet(&lp->Emac, XTE_SEND, &threshold_s,
-					   &timer_s);
-		(int) XTemac_IntrSgCoalGet(&lp->Emac, XTE_RECV, &threshold_r,
-					   &timer_r);
-		printk(KERN_INFO
-		       "%s: XTemac: Send Threshold = %d, Receive Threshold = %d\n",
-		       dev->name, threshold_s, threshold_r);
-		printk(KERN_INFO
-		       "%s: XTemac: Send Wait bound = %d, Receive Wait bound = %d\n",
-		       dev->name, timer_s, timer_r);
-	}
-
-	/* We're ready to go. */
-	netif_start_queue(dev);
-
-	/* Set up the PHY monitoring timer. */
-	lp->phy_timer.expires = jiffies + 2 * HZ;
-	lp->phy_timer.data = (unsigned long) dev;
-	lp->phy_timer.function = &poll_gmii;
-	init_timer(&lp->phy_timer);
-	add_timer(&lp->phy_timer);
-	return 0;
-}
-
-static int xenet_close(struct net_device *dev)
-{
-	struct net_local *lp;
-	unsigned long flags, flags_reset;
-
-	spin_lock_irqsave(&XTE_spinlock, flags_reset);
-	lp = (struct net_local *) dev->priv;
-
-	/* Shut down the PHY monitoring timer. */
-	del_timer_sync(&lp->phy_timer);
-
-	/* Stop Send queue */
-	netif_stop_queue(dev);
-
-	/* Now we could stop the device */
-	XTemac_Stop(&lp->Emac);
-
-	/*
-	 * If not in polled mode, free the interrupt.  Currently, there
-	 * isn't any code to set polled mode, so this check is probably
-	 * superfluous.
-	 */
-	if ((XTemac_GetOptions(&lp->Emac) & XTE_POLLED_OPTION) == 0)
-		free_irq(dev->irq, dev);
-
-	spin_unlock_irqrestore(&XTE_spinlock, flags_reset);
-
-	spin_lock_irqsave(&receivedQueueSpin, flags);
-	list_del(&(lp->rcv));
-	spin_unlock_irqrestore(&receivedQueueSpin, flags);
-
-	spin_lock_irqsave(&sentQueueSpin, flags);
-	list_del(&(lp->xmit));
-	spin_unlock_irqrestore(&sentQueueSpin, flags);
-
-	return 0;
-}
-
-static struct net_device_stats *xenet_get_stats(struct net_device *dev)
-{
-	struct net_local *lp = (struct net_local *) dev->priv;
-
-	return &lp->stats;
-}
-
-static int xenet_change_mtu(struct net_device *dev, int new_mtu)
-{
-#ifdef CONFIG_XILINX_GIGE_VLAN
-	int head_size = XTE_HDR_VLAN_SIZE;
-#else
-	int head_size = XTE_HDR_SIZE;
-#endif
-	struct net_local *lp = (struct net_local *) dev->priv;
-	int max_frame = new_mtu + head_size + XTE_TRL_SIZE;
-	int min_frame = 1 + head_size + XTE_TRL_SIZE;
-
-	if ((max_frame < min_frame) || (max_frame > lp->max_frame_size))
-		return -EINVAL;
-
-	dev->mtu = new_mtu;	/* change mtu in net_device structure */
-	return 0;
-}
-
-static int xenet_FifoSend(struct sk_buff *skb, struct net_device *dev)
-{
-	struct net_local *lp;
-	unsigned int len;
-	int result;
-	unsigned long flags, fifo_free_bytes;
-
-	/* The following lock is used to protect GetFreeBytes, FifoWrite
-	 * and FifoSend sequence which could happen from FifoSendHandler
-	 * or other processor in SMP case.
-	 */
-	spin_lock_irqsave(&XTE_tx_spinlock, flags);
-	lp = (struct net_local *) dev->priv;
-	len = skb->len;
-
-	fifo_free_bytes = XTemac_FifoGetFreeBytes(&lp->Emac, XTE_SEND);
-	if (fifo_free_bytes < len) {
-		netif_stop_queue(dev);	/* stop send queue */
-		lp->deferred_skb = skb;	/* buffer the sk_buffer and will send
-					   it in interrupt context */
-		spin_unlock_irqrestore(&XTE_tx_spinlock, flags);
-		return 0;
-	}
-
-	/* Write frame data to FIFO */
-	result = XTemac_FifoWrite(&lp->Emac, (void *) skb->data, len,
-				  XTE_END_OF_PACKET);
-	if (result != XST_SUCCESS) {
-		reset(dev, __LINE__);
-		lp->stats.tx_errors++;
-		spin_unlock_irqrestore(&XTE_tx_spinlock, flags);
-		return -EIO;
-	}
-
-	/* Initiate transmit */
-	if ((result = XTemac_FifoSend(&lp->Emac, len)) != XST_SUCCESS) {
-		reset(dev, __LINE__);
-		lp->stats.tx_errors++;
-		spin_unlock_irqrestore(&XTE_tx_spinlock, flags);
-		return -EIO;
-	}
-	lp->stats.tx_bytes += len;
-	spin_unlock_irqrestore(&XTE_tx_spinlock, flags);
-
-	dev_kfree_skb(skb);	/* free skb */
-	dev->trans_start = jiffies;
-	return 0;
-}
-
-/* Callback function for completed frames sent in FIFO interrupt driven mode */
-static void FifoSendHandler(void *CallbackRef)
-{
-	struct net_device *dev;
-	struct net_local *lp;
-	int result;
-	struct sk_buff *skb;
-
-	spin_lock(&XTE_tx_spinlock);
-	dev = (struct net_device *) CallbackRef;
-	lp = (struct net_local *) dev->priv;
-	lp->stats.tx_packets++;
-
-	/*Send out the deferred skb and wake up send queue if a deferred skb exists */
-	if (lp->deferred_skb) {
-
-		skb = lp->deferred_skb;
-		/* If no room for the deferred packet, return */
-		if (XTemac_FifoGetFreeBytes(&lp->Emac, XTE_SEND) < skb->len) {
-			spin_unlock(&XTE_tx_spinlock);
-			return;
-		}
-
-		/* Write frame data to FIFO */
-		result = XTemac_FifoWrite(&lp->Emac, (void *) skb->data,
-					  skb->len, XTE_END_OF_PACKET);
-		if (result != XST_SUCCESS) {
-			reset(dev, __LINE__);
-			lp->stats.tx_errors++;
-			spin_unlock(&XTE_tx_spinlock);
-			return;
-		}
-
-		/* Initiate transmit */
-		if ((result =
-		     XTemac_FifoSend(&lp->Emac, skb->len)) != XST_SUCCESS) {
-			reset(dev, __LINE__);
-			lp->stats.tx_errors++;
-			spin_unlock(&XTE_tx_spinlock);
-			return;
-		}
-
-		dev_kfree_skb_irq(skb);
-		lp->deferred_skb = NULL;
-		lp->stats.tx_packets++;
-		lp->stats.tx_bytes += skb->len;
-		dev->trans_start = jiffies;
-		netif_wake_queue(dev);	/* wake up send queue */
-	}
-	spin_unlock(&XTE_tx_spinlock);
-}
-
-#if 0
-/*
- * These are used for debugging purposes, left here in case they are useful
- * for further debugging
- */
-static unsigned int _xenet_tx_csum(struct sk_buff *skb)
-{
-	unsigned int csum = 0;
-	long csstart = skb->h.raw - skb->data;
-
-	if (csstart != skb->len) {
-		csum = skb_checksum(skb, csstart, skb->len - csstart, 0);
-	}
-
-	return csum;
-}
-
-static inline unsigned int _xenet_rx_csum(struct sk_buff *skb)
-{
-	return skb_checksum(skb, 0, skb->len, 0);
-}
-#endif
-
-/*
- * xenet_SgSend_internal is an internal use, send routine.
- * Any locks that need to be acquired, should be acquired
- * prior to calling this routine.
- */
-static int xenet_SgSend_internal(struct sk_buff *skb, struct net_device *dev)
-{
-	struct net_local *lp;
-	XDmaBdV3 *bd_ptr;
-	int result;
-	int total_frags;
-	int i;
-	void *virt_addr;
-	size_t len;
-	dma_addr_t phy_addr;
-	XDmaBdV3 *first_bd_ptr;
-	skb_frag_t *frag;
-
-	lp = (struct net_local *) dev->priv;
-
-	/* get skb_shinfo(skb)->nr_frags + 1 buffer descriptors */
-	total_frags = skb_shinfo(skb)->nr_frags + 1;
-
-	/* stats */
-	if (lp->max_frags_in_a_packet < total_frags) {
-		lp->max_frags_in_a_packet = total_frags;
-	}
-
-	if (total_frags < XTE_SEND_BD_CNT) {
-		result = XTemac_SgAlloc(&lp->Emac, XTE_SEND, total_frags,
-					&bd_ptr);
-
-		if (result != XST_SUCCESS) {
-			netif_stop_queue(dev);	/* stop send queue */
-			lp->deferred_skb = skb;	/* buffer the sk_buffer and will send
-						   it in interrupt context */
-			return result;
-		}
-	}
-	else {
-		dev_kfree_skb(skb);
-		lp->stats.tx_dropped++;
-		printk(KERN_ERR
-		       "%s: XTemac: could not send TX socket buffers (too many fragments).\n",
-		       dev->name);
-		return XST_FAILURE;
-	}
-
-	len = skb_headlen(skb);
-
-	/* get the physical address of the header */
-	phy_addr = (u32) dma_map_single(NULL, skb->data, len, DMA_TO_DEVICE);
-
-	/* get the header fragment, it's in the skb differently */
-	XDmaBdV3_mSetBufAddrLow(bd_ptr, phy_addr);
-	XDmaBdV3_mSetLength(bd_ptr, len);
-	XDmaBdV3_mSetId(bd_ptr, skb);
-	XDmaBdV3_mClearLast(bd_ptr);
-
-	/*
-	 * if tx checksum offloading is enabled, when the ethernet stack
-	 * wants us to perform the checksum in hardware,
-	 * skb->ip_summed is CHECKSUM_PARTIAL. Otherwise skb->ip_summed is
-	 * CHECKSUM_NONE, meaning the checksum is already done, or
-	 * CHECKSUM_UNNECESSARY, meaning checksumming is turned off (e.g.
-	 * loopback interface)
-	 *
-	 * skb->csum is an overloaded value. On send, skb->csum is the offset
-	 * into the buffer (skb->h.raw) to place the csum value. On receive
-	 * this feild gets set to the actual csum value, before it's passed up
-	 * the stack.
-	 *
-	 * When we get here, the ethernet stack above will have already
-	 * computed the pseudoheader csum value and have placed it in the
-	 * TCP/UDP header.
-	 *
-	 * The IP header csum has also already been computed and inserted.
-	 *
-	 * Since the IP header with it's own csum should compute to a null
-	 * csum, it should be ok to include it in the hw csum. If it is decided
-	 * to change this scheme, skb should be examined before dma_map_single()
-	 * is called, which flushes the page from the cpu's cache.
-	 *
-	 * skb->data points to the beginning of the whole packet
-	 * skb->h.raw points to the beginning of the ip header
-	 *
-	 */
-	if (skb->ip_summed == CHECKSUM_PARTIAL) {
-#if 0
-		{
-			unsigned int csum = _xenet_tx_csum(skb);
-
-			*((unsigned short *) (skb->h.raw + skb->csum)) =
-				csum_fold(csum);
-			XTemac_mSgSendBdCsumDisable(bd_ptr);
-		}
-#else
-		XTemac_mSgSendBdCsumEnable(bd_ptr);
-		XTemac_mSgSendBdCsumSetup(bd_ptr,
-					  skb->transport_header - skb->data,
-					  (skb->transport_header - skb->data) +
-					  skb->csum);
-#endif
-		lp->tx_hw_csums++;
-	}
-	else {
-		/*
-		 * This routine will do no harm even if hardware checksum capability is
-		 * off.
-		 */
-		XTemac_mSgSendBdCsumDisable(bd_ptr);
-	}
-
-	first_bd_ptr = bd_ptr;
-
-	frag = &skb_shinfo(skb)->frags[0];
-
-	for (i = 1; i < total_frags; i++, frag++) {
-		bd_ptr = XTemac_mSgSendBdNext(&lp->Emac, bd_ptr);
-
-		virt_addr =
-			(void *) page_address(frag->page) + frag->page_offset;
-		phy_addr =
-			(u32) dma_map_single(NULL, virt_addr, frag->size,
-					     DMA_TO_DEVICE);
-
-		XDmaBdV3_mSetBufAddrLow(bd_ptr, phy_addr);
-		XDmaBdV3_mSetLength(bd_ptr, frag->size);
-		XDmaBdV3_mSetId(bd_ptr, NULL);
-
-		if (i < (total_frags - 1)) {
-			XDmaBdV3_mClearLast(bd_ptr);
-		}
-	}
-
-	XDmaBdV3_mSetLast(bd_ptr);
-
-	/* Enqueue to HW */
-	result = XTemac_SgCommit(&lp->Emac, XTE_SEND, total_frags,
-				 first_bd_ptr);
-	if (result != XST_SUCCESS) {
-		netif_stop_queue(dev);	/* stop send queue */
-		dev_kfree_skb(skb);
-		XDmaBdV3_mSetId(first_bd_ptr, NULL);
-		lp->stats.tx_dropped++;
-		printk(KERN_ERR
-		       "%s: XTemac: could not send commit TX buffer descriptor (%d).\n",
-		       dev->name, result);
-		reset(dev, __LINE__);
-
-		return XST_FAILURE;
-	}
-
-	dev->trans_start = jiffies;
-
-	return XST_SUCCESS;
-}
-
-/* The send function for frames sent in SGDMA mode and TEMAC has TX DRE. */
-static int xenet_SgSend(struct sk_buff *skb, struct net_device *dev)
-{
-	/* The following spin_lock protects
-	 * SgAlloc, SgCommit sequence, which also exists in SgSendHandlerBH Bottom
-	 * Half, or triggered by other processor in SMP case.
-	 */
-	spin_lock_bh(&XTE_tx_spinlock);
-
-	xenet_SgSend_internal(skb, dev);
-
-	spin_unlock_bh(&XTE_tx_spinlock);
-
-	return 0;
-}
-
-
-/* The send function for frames sent in SGDMA mode (and no TX DRE is in TEMAC). */
-static int xenet_SgSend_NoDRE(struct sk_buff *skb, struct net_device *dev)
-{
-	int result;
-
-	void *tx_addr;
-	void *cur_addr;
-	dma_addr_t phy_addr;
-	size_t len;
-
-	XDmaBdV3 *bd_ptr;
-	skb_frag_t *frag;
-	int nr_frags;
-	int total_frags;
-	int i;
-
-	struct net_local *lp = (struct net_local *) dev->priv;
-
-	/* Without the DRE hardware engine, DMA transfers must be double word
-	 * aligned (8 bytes), front and back. If there are no fragments, and the
-	 * main chunk is aligned at the front, let the regular, SgSend handle it.
-	 * Otherwise, just go ahead and copy the whole darn thing to the tx ring
-	 * buffer before sending it out.
-	 *
-	 * For better performance the tx rign buffer alignment set in
-	 * ALIGNMENT_SEND can be set to 32 which is cache line aligned, on the
-	 * PPC405 and PPC440.
-	 */
-	if (!skb_is_nonlinear(skb) && (0 == BUFFER_ALIGNSEND(skb->data))) {
-		/* buffer is linear and already aligned nicely. We can send it using
-		 * xenet_SgSend(). Done.
-		 */
-		return xenet_SgSend(skb, dev);
-	}
-
-	/* The buffer is either nonlinear or not aligned. We have to copy it.
-	 */
-	nr_frags = skb_shinfo(skb)->nr_frags;
-	total_frags = nr_frags + 1;
-
-	/* stats */
-	lp->realignments++;
-	if (lp->max_frags_in_a_packet < total_frags) {
-		lp->max_frags_in_a_packet = total_frags;
-	}
-
-	/* Copy the skb. Get the address of the next buffer in the ring. Also,
-	 * remember the physical address of that buffer for the DMA setup.
-	 */
-	cur_addr = lp->tx_buffers[lp->tx_buffers_cur];
-	phy_addr = lp->tx_phys_buffers[lp->tx_buffers_cur];
-
-	/* set up tx_buffers_cur for the next use */
-	lp->tx_buffers_cur++;
-	if (lp->tx_buffers_cur >= XTE_SEND_BD_CNT) {
-		lp->tx_buffers_cur = 0;
-	}
-
-	tx_addr = cur_addr;
-
-	len = skb_headlen(skb);
-
-	cacheable_memcpy(cur_addr, skb->data, len);
-	cur_addr += len;
-
-	frag = &skb_shinfo(skb)->frags[0];
-	for (i = 1; i < nr_frags; i++, frag++) {
-		void *p = (void *) page_address(frag->page) + frag->page_offset;
-
-		len = frag->size;
-		cacheable_memcpy(cur_addr, p, len);
-		cur_addr += len;
-	}
-
-	/*
-	 * set up the transfer
-	 */
-	result = XTemac_SgAlloc(&lp->Emac, XTE_SEND, 1, &bd_ptr);
-
-	if (result != XST_SUCCESS) {
-		netif_stop_queue(dev);	/* stop send queue */
-		lp->deferred_skb = skb;	/* buffer the sk_buffer and will send
-					   it in interrupt context */
-		return result;
-	}
-
-	/* get the header fragment, it's in the skb differently */
-	XDmaBdV3_mSetBufAddrLow(bd_ptr, phy_addr);
-	XDmaBdV3_mSetLength(bd_ptr, len);
-	XDmaBdV3_mSetId(bd_ptr, skb);
-	XDmaBdV3_mClearLast(bd_ptr);
-
-	if (skb->ip_summed == CHECKSUM_PARTIAL) {
-		/*
-		 * skb->data points to the beginning of the whole packet
-		 * skb->h.raw points to the beginning of the ip header
-		 * skb->csum, on send, is the offset into the buffer (skb->h.raw)
-		 * to place the csum value.
-		 * tx_addr is the address where the data is really copied (for
-		 * alignment)
-		 */
-		XTemac_mSgSendBdCsumEnable(bd_ptr);
-
-		XTemac_mSgSendBdCsumSetup(bd_ptr,
-					  (u32) (tx_addr +
-						 (skb->transport_header -
-						  skb->data)),
-					  (u32) (tx_addr +
-						 (skb->transport_header -
-						  skb->data) + skb->csum));
-		lp->tx_hw_csums++;
-	}
-	else {
-		/*
-		 * This routine will do no harm even if hardware checksum capability is
-		 * off.
-		 */
-		XTemac_mSgSendBdCsumDisable(bd_ptr);
-	}
-	XDmaBdV3_mSetLast(bd_ptr);
-
-	/* Enqueue to HW */
-	result = XTemac_SgCommit(&lp->Emac, XTE_SEND, total_frags, bd_ptr);
-	if (result != XST_SUCCESS) {
-		netif_stop_queue(dev);	/* stop send queue */
-		dev_kfree_skb(skb);
-		XDmaBdV3_mSetId(bd_ptr, NULL);
-		lp->stats.tx_dropped++;
-		printk(KERN_ERR
-		       "%s: XTemac: could not send commit TX buffer descriptor (%d).\n",
-		       dev->name, result);
-		reset(dev, __LINE__);
-
-		return XST_FAILURE;
-	}
-
-	dev->trans_start = jiffies;
-
-	return XST_SUCCESS;
-}
-
-/* The callback function for completed frames sent in SGDMA mode. */
-static void SgSendHandlerBH(unsigned long p);
-static void SgRecvHandlerBH(unsigned long p);
-
-static DECLARE_TASKLET(SgSendBH, SgSendHandlerBH, 0);
-static DECLARE_TASKLET(SgRecvBH, SgRecvHandlerBH, 0);
-
-static void SgSendHandlerBH(unsigned long p)
-{
-	struct net_device *dev;
-	struct net_local *lp;
-	XDmaBdV3 *BdPtr, *BdCurPtr;
-	unsigned long len;
-	unsigned long flags;
-	struct sk_buff *skb;
-	dma_addr_t skb_dma_addr;
-	int result = XST_SUCCESS;
-	unsigned int bd_processed, bd_processed_save;
-
-	while (1) {
-		spin_lock_irqsave(&sentQueueSpin, flags);
-		if (list_empty(&sentQueue)) {
-			spin_unlock_irqrestore(&sentQueueSpin, flags);
-			break;
-		}
-
-		lp = list_entry(sentQueue.next, struct net_local, xmit);
-
-		list_del_init(&(lp->xmit));
-		spin_unlock_irqrestore(&sentQueueSpin, flags);
-
-		spin_lock(&XTE_tx_spinlock);
-		dev = lp->ndev;
-		bd_processed_save = 0;
-		while ((bd_processed =
-			XTemac_SgGetProcessed(&lp->Emac, XTE_SEND,
-					      XTE_SEND_BD_CNT, &BdPtr)) > 0) {
-
-			bd_processed_save = bd_processed;
-			BdCurPtr = BdPtr;
-			do {
-				len = XDmaBdV3_mGetLength(BdCurPtr);
-				skb_dma_addr =
-					(dma_addr_t)
-					XDmaBdV3_mGetBufAddrLow(BdCurPtr);
-				dma_unmap_single(NULL, skb_dma_addr, len,
-						 DMA_TO_DEVICE);
-
-				/* get ptr to skb */
-				skb = (struct sk_buff *)
-					XDmaBdV3_mGetId(BdCurPtr);
-				if (skb)
-					dev_kfree_skb(skb);
-
-				/* reset BD id */
-				XDmaBdV3_mSetId(BdCurPtr, NULL);
-
-				lp->stats.tx_bytes += len;
-				if (XDmaBdV3_mSetLast(&BdCurPtr)) {
-					lp->stats.tx_packets++;
-				}
-
-				BdCurPtr =
-					XTemac_mSgSendBdNext(&lp->Emac,
-							     BdCurPtr);
-				bd_processed--;
-			} while (bd_processed > 0);
-
-			result = XTemac_SgFree(&lp->Emac, XTE_SEND,
-					       bd_processed_save, BdPtr);
-			if (result != XST_SUCCESS) {
-				printk(KERN_ERR
-				       "%s: XTemac: SgFree() error %d.\n",
-				       dev->name, result);
-				reset(dev, __LINE__);
-				spin_unlock(&XTE_tx_spinlock);
-				return;
-			}
-		}
-		XTemac_IntrSgEnable(&lp->Emac, XTE_SEND);
-
-		/* Send out the deferred skb if it exists */
-		if ((lp->deferred_skb) && bd_processed_save) {
-			skb = lp->deferred_skb;
-			lp->deferred_skb = NULL;
-
-			result = xenet_SgSend_internal(skb, dev);
-		}
-
-		if (result == XST_SUCCESS) {
-			netif_wake_queue(dev);	/* wake up send queue */
-		}
-		spin_unlock(&XTE_tx_spinlock);
-	}
-}
-
-static void SgSendHandler(void *CallBackRef)
-{
-	struct net_local *lp;
-	struct list_head *cur_lp;
-
-	spin_lock(&sentQueueSpin);
-
-	lp = (struct net_local *) CallBackRef;
-	list_for_each(cur_lp, &sentQueue) {
-		if (cur_lp == &(lp->xmit)) {
-			break;
-		}
-	}
-	if (cur_lp != &(lp->xmit)) {
-		list_add_tail(&lp->xmit, &sentQueue);
-		XTemac_IntrSgDisable(&lp->Emac, XTE_SEND);
-		tasklet_schedule(&SgSendBH);
-	}
-	spin_unlock(&sentQueueSpin);
-}
-
-static void xenet_tx_timeout(struct net_device *dev)
-{
-	struct net_local *lp;
-	unsigned long flags;
-
-	/*
-	 * Make sure that no interrupts come in that could cause reentrancy
-	 * problems in reset.
-	 */
-	spin_lock_irqsave(&XTE_tx_spinlock, flags);
-
-	lp = (struct net_local *) dev->priv;
-	printk(KERN_ERR
-	       "%s: XTemac: exceeded transmit timeout of %lu ms.  Resetting emac.\n",
-	       dev->name, TX_TIMEOUT * 1000UL / HZ);
-	lp->stats.tx_errors++;
-
-	reset(dev, __LINE__);
-
-	spin_unlock_irqrestore(&XTE_tx_spinlock, flags);
-}
-
-/* The callback function for frames received when in FIFO mode. */
-static void FifoRecvHandler(void *CallbackRef)
-{
-	struct net_device *dev;
-	struct net_local *lp;
-	struct sk_buff *skb;
-	u32 len;
-	int Result;
-
-#define XTE_RX_SINK_BUFFER_SIZE 1024
-	static u32 rx_buffer_sink[XTE_RX_SINK_BUFFER_SIZE / sizeof(u32)];
-
-	spin_lock(&XTE_rx_spinlock);
-	dev = (struct net_device *) CallbackRef;
-	lp = (struct net_local *) dev->priv;
-
-	Result = XTemac_FifoRecv(&lp->Emac, &len);
-	if (Result != XST_SUCCESS) {
-		printk(KERN_ERR
-		       "%s: XTemac: could not read received packet length, error=%d.\n",
-		       dev->name, Result);
-		lp->stats.rx_errors++;
-		reset(dev, __LINE__);
-		spin_unlock(&XTE_rx_spinlock);
-		return;
-	}
-
-	if (!(skb = /*dev_ */ alloc_skb(len + ALIGNMENT_RECV, GFP_ATOMIC))) {
-		/* Couldn't get memory. */
-		lp->stats.rx_dropped++;
-		printk(KERN_ERR
-		       "%s: XTemac: could not allocate receive buffer.\n",
-		       dev->name);
-
-		/* consume data in Xilinx TEMAC RX data fifo so it is sync with RX length fifo */
-		for (; len > XTE_RX_SINK_BUFFER_SIZE;
-		     len -= XTE_RX_SINK_BUFFER_SIZE) {
-			XTemac_FifoRead(&lp->Emac, rx_buffer_sink,
-					XTE_RX_SINK_BUFFER_SIZE,
-					XTE_PARTIAL_PACKET);
-		}
-		XTemac_FifoRead(&lp->Emac, rx_buffer_sink, len,
-				XTE_END_OF_PACKET);
-
-		spin_unlock(&XTE_rx_spinlock);
-		return;
-	}
-
-	/* Read the packet data */
-	Result = XTemac_FifoRead(&lp->Emac, skb->data, len, XTE_END_OF_PACKET);
-	if (Result != XST_SUCCESS) {
-		lp->stats.rx_errors++;
-		dev_kfree_skb_irq(skb);
-		printk(KERN_ERR
-		       "%s: XTemac: could not receive buffer, error=%d.\n",
-		       dev->name, Result);
-		reset(dev, __LINE__);
-		spin_unlock(&XTE_rx_spinlock);
-		return;
-	}
-	lp->stats.rx_packets++;
-	lp->stats.rx_bytes += len;
-	spin_unlock(&XTE_rx_spinlock);
-
-	skb_put(skb, len);	/* Tell the skb how much data we got. */
-	skb->dev = dev;		/* Fill out required meta-data. */
-	skb->protocol = eth_type_trans(skb, dev);
-	skb->ip_summed = CHECKSUM_NONE;
-	netif_rx(skb);		/* Send the packet upstream. */
-}
-
-
-/*
- * _xenet_SgSetupRecvBuffers allocates as many socket buffers (sk_buff's) as it
- * can up to the number of free RX buffer descriptors. Then it sets up the RX
- * buffer descriptors to DMA into the socket_buffers.
- *
- * The net_device, dev, indcates on which device to operate for buffer
- * descriptor allocation.
- */
-static void _xenet_SgSetupRecvBuffers(struct net_device *dev)
-{
-	struct net_local *lp = (struct net_local *) dev->priv;
-	int free_bd_count = XDmaV3_mSgGetFreeCnt(&(lp->Emac.RecvDma));
-	int num_sk_buffs;
-	struct sk_buff_head sk_buff_list;
-	struct sk_buff *new_skb;
-	u32 new_skb_baddr;
-	XDmaBdV3 *BdPtr, *BdCurPtr;
-	u32 align;
-	int result;
-	int align_max = ALIGNMENT_RECV;
-
-	if (lp->local_features & LOCAL_FEATURE_RX_DRE) {
-		align_max = 0;
-	}
-
-	skb_queue_head_init(&sk_buff_list);
-	for (num_sk_buffs = 0; num_sk_buffs < free_bd_count; num_sk_buffs++) {
-		new_skb = alloc_skb(lp->max_frame_size + align_max, GFP_ATOMIC);
-		if (new_skb == NULL) {
-			break;
-		}
-		/*
-		 * I think the XTE_spinlock, and Recv DMA int disabled will protect this
-		 * list as well, so we can use the __ version just fine
-		 */
-		__skb_queue_tail(&sk_buff_list, new_skb);
-	}
-	if (!num_sk_buffs) {
-		printk(KERN_ERR "%s: XTemac: alloc_skb unsuccessful\n",
-		       dev->name);
-		return;
-	}
-
-	/* now we got a bunch o' sk_buffs */
-	result = XTemac_SgAlloc(&lp->Emac, XTE_RECV, num_sk_buffs, &BdPtr);
-	if (result != XST_SUCCESS) {
-		/* we really shouldn't get this */
-		skb_queue_purge(&sk_buff_list);
-		printk(KERN_ERR "%s: XTemac: SgAlloc unsuccessful (%d)\n",
-		       dev->name, result);
-		reset(dev, __LINE__);
-		return;
-	}
-
-	BdCurPtr = BdPtr;
-
-	new_skb = skb_dequeue(&sk_buff_list);
-	while (new_skb) {
-		/* make sure we're long-word aligned */
-		if (lp->local_features & LOCAL_FEATURE_RX_DRE) {
-			align = BUFFER_ALIGNRECV(new_skb->data);
-			if (align) {
-				skb_reserve(new_skb, align);
-			}
-		}
-
-		/* Get dma handle of skb->data */
-		new_skb_baddr = (u32) dma_map_single(NULL, new_skb->data,
-						     lp->max_frame_size,
-						     DMA_FROM_DEVICE);
-
-		XDmaBdV3_mSetBufAddrLow(BdCurPtr, new_skb_baddr);
-		XDmaBdV3_mSetLength(BdCurPtr, lp->max_frame_size);
-		XDmaBdV3_mSetId(BdCurPtr, new_skb);
-
-		BdCurPtr = XTemac_mSgRecvBdNext(&lp->Emac, BdCurPtr);
-
-		new_skb = skb_dequeue(&sk_buff_list);
-	}
-
-	/* enqueue RxBD with the attached skb buffers such that it is
-	 * ready for frame reception */
-	result = XTemac_SgCommit(&lp->Emac, XTE_RECV, num_sk_buffs, BdPtr);
-	if (result != XST_SUCCESS) {
-		printk(KERN_ERR
-		       "%s: XTemac: (SgSetupRecvBuffers) XTemac_SgCommit unsuccessful (%d)\n",
-		       dev->name, result);
-		skb_queue_purge(&sk_buff_list);
-		BdCurPtr = BdPtr;
-		while (num_sk_buffs > 0) {
-			XDmaBdV3_mSetId(BdCurPtr, NULL);
-			BdCurPtr = XTemac_mSgRecvBdNext(&lp->Emac, BdCurPtr);
-			num_sk_buffs--;
-		}
-		reset(dev, __LINE__);
-		return;
-	}
-}
-
-static void SgRecvHandlerBH(unsigned long p)
-{
-	struct net_device *dev;
-	struct net_local *lp;
-	struct sk_buff *skb;
-	u32 len, skb_baddr;
-	int result;
-	unsigned long flags;
-	XDmaBdV3 *BdPtr, *BdCurPtr;
-	unsigned int bd_processed, bd_processed_saved;
-
-	while (1) {
-		spin_lock_irqsave(&receivedQueueSpin, flags);
-		if (list_empty(&receivedQueue)) {
-			spin_unlock_irqrestore(&receivedQueueSpin, flags);
-			break;
-		}
-		lp = list_entry(receivedQueue.next, struct net_local, rcv);
-
-		list_del_init(&(lp->rcv));
-		dev = lp->ndev;
-		spin_unlock_irqrestore(&receivedQueueSpin, flags);
-
-		spin_lock(&XTE_rx_spinlock);
-		if ((bd_processed =
-		     XTemac_SgGetProcessed(&lp->Emac, XTE_RECV, XTE_RECV_BD_CNT,
-					   &BdPtr)) > 0) {
-
-			bd_processed_saved = bd_processed;
-			BdCurPtr = BdPtr;
-			do {
-				len = XDmaBdV3_mGetLength(BdCurPtr);
-
-				/* get ptr to skb */
-				skb = (struct sk_buff *)
-					XDmaBdV3_mGetId(BdCurPtr);
-
-				/* get and free up dma handle used by skb->data */
-				skb_baddr =
-					(dma_addr_t)
-					XDmaBdV3_mGetBufAddrLow(BdCurPtr);
-				dma_unmap_single(NULL, skb_baddr,
-						 lp->max_frame_size,
-						 DMA_FROM_DEVICE);
-
-				/* reset ID */
-				XDmaBdV3_mSetId(BdCurPtr, NULL);
-
-				/* setup received skb and send it upstream */
-				skb_put(skb, len);	/* Tell the skb how much data we got. */
-				skb->dev = dev;
-
-				/* this routine adjusts skb->data to skip the header */
-				skb->protocol = eth_type_trans(skb, dev);
-
-				/* default the ip_summed value */
-				skb->ip_summed = CHECKSUM_NONE;
-
-				/* if we're doing rx csum offload, set it up */
-				if (((lp->
-				      local_features & LOCAL_FEATURE_RX_CSUM) !=
-				     0) &&
-				    (skb->protocol ==
-				     __constant_htons(ETH_P_IP)) &&
-				    (skb->len > 64)) {
-					unsigned int csum;
-
-					/*
-					 * This hardware only supports proper checksum calculations
-					 * on TCP/UDP packets.
-					 *
-					 * skb->csum is an overloaded value. On send, skb->csum is
-					 * the offset into the buffer (skb->h.raw) to place the
-					 * csum value. On receive this feild gets set to the actual
-					 * csum value, before it's passed up the stack.
-					 *
-					 * If we set skb->ip_summed to CHECKSUM_PARTIAL, the ethernet
-					 * stack above will compute the pseudoheader csum value and
-					 * add it to the partial checksum already computed (to be
-					 * placed in skb->csum) and verify it.
-					 *
-					 * Setting skb->ip_summed to CHECKSUM_NONE means that the
-					 * cheksum didn't verify and the stack will (re)check it.
-					 *
-					 * Setting skb->ip_summed to CHECKSUM_UNNECESSARY means
-					 * that the cheksum was verified/assumed to be good and the
-					 * stack does not need to (re)check it.
-					 *
-					 * The ethernet stack above will (re)compute the checksum
-					 * under the following conditions:
-					 * 1) skb->ip_summed was set to CHECKSUM_NONE
-					 * 2) skb->len does not match the length of the ethernet
-					 *    packet determined by parsing the packet. In this case
-					 *    the ethernet stack will assume any prior checksum
-					 *    value was miscomputed and throw it away.
-					 * 3) skb->ip_summed was set to CHECKSUM_PARTIAL, skb->csum was
-					 *    set, but the result does not check out ok by the
-					 *    ethernet stack.
-					 *
-					 * If the TEMAC hardware stripping feature is off, each
-					 * packet will contain an FCS feild which will have been
-					 * computed by the hardware checksum operation. This 4 byte
-					 * FCS value needs to be subtracted back out of the checksum
-					 * value computed by hardware as it's not included in a
-					 * normal ethernet packet checksum.
-					 *
-					 * The minimum transfer packet size over the wire is 64
-					 * bytes. If the packet is sent as exactly 64 bytes, then
-					 * it probably contains some random padding bytes. It's
-					 * somewhat difficult to determine the actual length of the
-					 * real packet data, so we just let the stack recheck the
-					 * checksum for us.
-					 *
-					 * After the call to eth_type_trans(), the following holds
-					 * true:
-					 *    skb->data points to the beginning of the ip header
-					 */
-					csum = XTemac_mSgRecvBdCsumGet
-						(BdCurPtr);
-
-#if ! XTE_AUTOSTRIPPING
-					if (!lp->stripping) {
-						/* take off the FCS */
-						u16 *data;
-
-						/* FCS is 4 bytes */
-						skb_put(skb, -4);
-
-						data = (u16 *) (&skb->
-								data[skb->len]);
-
-						/* subtract out the FCS from the csum value */
-						csum = csum_sub(csum,
-								*data
-								/* & 0xffff */
-								);
-						data++;
-						csum = csum_sub(csum,
-								*data
-								/* & 0xffff */
-								);
-					}
-#endif
-					skb->csum = csum;
-					skb->ip_summed = CHECKSUM_PARTIAL;
-
-					lp->rx_hw_csums++;
-				}
-
-				lp->stats.rx_packets++;
-				lp->stats.rx_bytes += len;
-				netif_rx(skb);	/* Send the packet upstream. */
-
-				BdCurPtr =
-					XTemac_mSgRecvBdNext(&lp->Emac,
-							     BdCurPtr);
-				bd_processed--;
-			} while (bd_processed > 0);
-
-
-			/* give the descriptor back to the driver */
-			result = XTemac_SgFree(&lp->Emac, XTE_RECV,
-					       bd_processed_saved, BdPtr);
-			if (result != XST_SUCCESS) {
-				printk(KERN_ERR
-				       "%s: XTemac: SgFree unsuccessful (%d)\n",
-				       dev->name, result);
-				reset(dev, __LINE__);
-				spin_unlock(&XTE_rx_spinlock);
-				return;
-			}
-
-			_xenet_SgSetupRecvBuffers(dev);
-		}
-		XTemac_IntrSgEnable(&lp->Emac, XTE_RECV);
-		spin_unlock(&XTE_rx_spinlock);
-	}
-}
-
-static void SgRecvHandler(void *CallBackRef)
-{
-	struct net_local *lp;
-	struct list_head *cur_lp;
-
-	spin_lock(&receivedQueueSpin);
-	lp = (struct net_local *) CallBackRef;
-	list_for_each(cur_lp, &receivedQueue) {
-		if (cur_lp == &(lp->rcv)) {
-			break;
-		}
-	}
-	if (cur_lp != &(lp->rcv)) {
-		list_add_tail(&lp->rcv, &receivedQueue);
-		XTemac_IntrSgDisable(&lp->Emac, XTE_RECV);
-		tasklet_schedule(&SgRecvBH);
-	}
-	spin_unlock(&receivedQueueSpin);
-}
-
-/* The callback function for errors. */
-static void ErrorHandler(void *CallbackRef, int ErrClass, u32 Word1, u32 Word2)
-{
-	struct net_device *dev;
-	struct net_local *lp;
-	int need_reset;
-
-	spin_lock(&XTE_spinlock);
-	dev = (struct net_device *) CallbackRef;
-	lp = (struct net_local *) dev->priv;
-
-	need_reset = status_requires_reset(ErrClass);
-	printk(KERN_ERR "%s: XTemac device error %d (%d, %d) %s\n",
-	       dev->name, ErrClass, Word1, Word2,
-	       need_reset ? ", resetting device." : "");
-
-	if (need_reset)
-		reset(dev, __LINE__);
-
-	spin_unlock(&XTE_spinlock);
-}
-
-static int descriptor_init(struct net_device *dev)
-{
-	struct net_local *lp = (struct net_local *) dev->priv;
-	int recvsize, sendsize;
-	int dftsize;
-	u32 *recvpoolptr, *sendpoolptr;
-	void *recvpoolphy, *sendpoolphy;
-	int result;
-	XDmaBdV3 bd_tx_template;
-	XDmaBdV3 bd_rx_template;
-	int XferType = XDMAV3_DMACR_TYPE_BFBURST_MASK;
-	int XferWidth = XDMAV3_DMACR_DSIZE_64_MASK;
-
-	/* calc size of descriptor space pool; alloc from non-cached memory */
-	dftsize =
-		XDmaV3_mSgListMemCalc(ALIGNMENT_BD,
-				      XTE_RECV_BD_CNT + XTE_SEND_BD_CNT);
-	printk(KERN_INFO "XTemac: buffer descriptor size: %d (0x%0x)\n",
-	       dftsize, dftsize);
-
-#if BD_IN_BRAM == 0
-	lp->desc_space = dma_alloc_coherent(NULL, dftsize,
-					    &lp->desc_space_handle, GFP_KERNEL);
-#else
-	lp->desc_space_handle = BRAM_BASEADDR;
-	lp->desc_space = ioremap(lp->desc_space_handle, dftsize);
-#endif
-	if (lp->desc_space == 0) {
-		return -1;
-	}
-
-	lp->desc_space_size = dftsize;
-
-	printk(KERN_INFO
-	       "XTemac: (buffer_descriptor_init) phy: 0x%x, virt: 0x%x, size: 0x%x\n",
-	       lp->desc_space_handle, (unsigned int) lp->desc_space,
-	       lp->desc_space_size);
-
-	/* calc size of send and recv descriptor space */
-	recvsize = XDmaV3_mSgListMemCalc(ALIGNMENT_BD, XTE_RECV_BD_CNT);
-	sendsize = XDmaV3_mSgListMemCalc(ALIGNMENT_BD, XTE_SEND_BD_CNT);
-
-	recvpoolptr = lp->desc_space;
-	sendpoolptr = (void *) ((u32) lp->desc_space + recvsize);
-
-	recvpoolphy = (void *) lp->desc_space_handle;
-	sendpoolphy = (void *) ((u32) lp->desc_space_handle + recvsize);
-
-	/* set up descriptor spaces using a template */
-
-	/* rx template */
-	/*
-	 * Create the ring for Rx descriptors.
-	 * The following attributes will be in effect for all RxBDs
-	 */
-	XDmaBdV3_mClear(&bd_rx_template);
-	XDmaBdV3_mSetLast(&bd_rx_template);	/* 1:1 mapping of BDs to buffers */
-	XDmaBdV3_mSetBufIncrement(&bd_rx_template);	/* Buffers exist along incrementing
-							   addresses */
-	XDmaBdV3_mSetBdPage(&bd_rx_template, 0);	/* Default to 32 bit addressing */
-	XDmaBdV3_mSetBufAddrHigh(&bd_rx_template, 0);	/* Default to 32 bit addressing */
-	XDmaBdV3_mSetDevSel(&bd_rx_template, 0);	/* Always 0 */
-	XDmaBdV3_mSetTransferType(&bd_rx_template, XferType, XferWidth);	/* Data bus
-										   attributes */
-
-
-	/* tx template */
-	/*
-	 * Create the ring for Tx descriptors. If no Tx DRE then buffers must occupy
-	 * a single descriptor, so set the "last" field for all descriptors.
-	 */
-	XDmaBdV3_mClear(&bd_tx_template);
-	XDmaBdV3_mUseDre(&bd_tx_template);	/* Always use DRE if available */
-	XDmaBdV3_mSetBufIncrement(&bd_tx_template);	/* Buffers exist along incrementing
-							   addresses */
-	XDmaBdV3_mSetBdPage(&bd_tx_template, 0);	/* Default to 32 bit addressing */
-	XDmaBdV3_mSetBufAddrHigh(&bd_tx_template, 0);	/* Default to 32 bit addressing */
-	XDmaBdV3_mSetDevSel(&bd_tx_template, 0);	/* Always 0 */
-	XDmaBdV3_mSetTransferType(&bd_tx_template, XferType, XferWidth);	/* Data bus
-										   attributes */
-	XTemac_mSgSendBdCsumDisable(&bd_tx_template);	/* Disable csum offload by default */
-	XTemac_mSgSendBdCsumSeed(&bd_tx_template, 0);	/* Don't need csum seed feature */
-
-	if (XTemac_mIsTxDre(&lp->Emac) == FALSE) {
-		XDmaBdV3_mSetLast(&bd_tx_template);
-	}
-
-	if ((result = XTemac_SgSetSpace(&lp->Emac, XTE_RECV, (u32) recvpoolphy,
-					(u32) recvpoolptr, ALIGNMENT_BD,
-					XTE_RECV_BD_CNT,
-					&bd_rx_template)) != XST_SUCCESS) {
-		printk(KERN_ERR "%s: XTemac: SgSetSpace RECV ERROR %d\n",
-		       dev->name, result);
-		return -EIO;
-	}
-
-	if ((result = XTemac_SgSetSpace(&lp->Emac, XTE_SEND, (u32) sendpoolphy,
-					(u32) sendpoolptr, ALIGNMENT_BD,
-					XTE_SEND_BD_CNT,
-					&bd_tx_template)) != XST_SUCCESS) {
-		printk(KERN_ERR "%s: XTemac: SgSetSpace SEND ERROR %d\n",
-		       dev->name, result);
-		return -EIO;
-	}
-
-	_xenet_SgSetupRecvBuffers(dev);
-	return 0;
-}
-
-/*
- * If DRE is not enabled, allocate a ring buffer to use to aid in transferring
- * aligned packets for DMA.
- */
-static int tx_ring_buffer_init(struct net_device *dev, unsigned max_frame_size)
-{
-	struct net_local *lp = (struct net_local *) dev->priv;
-	int idx;
-
-	lp->tx_buffers_cur = -1;
-
-	/* pre-initialize values. The error handling code relies on those. */
-	lp->tx_buffers = NULL;
-	lp->tx_orig_buffers = NULL;
-	lp->tx_phys_buffers = NULL;
-	idx = -1;
-
-	if (XTemac_mIsTxDre(&lp->Emac) == FALSE) {
-		/* Allocate the space for the buffer pointer array.
-		 */
-		lp->tx_orig_buffers = vmalloc(sizeof(void *) * XTE_SEND_BD_CNT);
-		lp->tx_phys_buffers =
-			vmalloc(sizeof(dma_addr_t) * XTE_SEND_BD_CNT);
-		lp->tx_buffers = vmalloc(sizeof(void *) * XTE_SEND_BD_CNT);
-
-		/* Handle allocation error
-		 */
-		if ((!lp->tx_orig_buffers) || (!lp->tx_buffers) ||
-		    (!lp->tx_phys_buffers)) {
-			printk(KERN_ERR
-			       "XTemac: Could not vmalloc descriptor pointer arrays.\n");
-			goto error;
-		}
-
-		/* Now, allocate the actual buffers.
-		 */
-		for (idx = 0; idx < XTE_SEND_BD_CNT; idx++) {
-			lp->tx_orig_buffers[idx] = dma_alloc_coherent(NULL,
-								      max_frame_size
-								      +
-								      ALIGNMENT_SEND_PERF,
-								      &lp->
-								      tx_phys_buffers
-								      [idx],
-								      GFP_KERNEL);
-			/* Handle allocation error.
-			 */
-			if (!lp->tx_orig_buffers[idx]) {
-				printk(KERN_ERR
-				       "XTemac: Could not alloc TX buffer %d (%d bytes). "
-				       "Cleaning up.\n", idx,
-				       max_frame_size + ALIGNMENT_SEND_PERF);
-				goto error;
-			}
-
-			lp->tx_buffers[idx] = lp->tx_orig_buffers[idx] +
-				BUFFER_ALIGNSEND_PERF(lp->tx_orig_buffers[idx]);
-		}
-		lp->tx_buffers_cur = 0;
-	}
-	return 0;
-
-      error:
-	/* Check, if buffers have already been allocated.
-	 */
-	if (-1 != idx) {
-		/* Yes, free them... Note, idx points to the failed allocation.
-		 * Therefore the pre-decrement.
-		 */
-		while (--idx >= 0) {
-			dma_free_coherent(NULL,
-					  max_frame_size + ALIGNMENT_SEND_PERF,
-					  lp->tx_orig_buffers[idx],
-					  lp->tx_phys_buffers[idx]);
-		}
-	}
-
-	/* Free allocated buffer pointer arrays if allocated.
-	 */
-	if (lp->tx_orig_buffers) {
-		vfree(lp->tx_orig_buffers);
-	}
-	if (lp->tx_phys_buffers) {
-		vfree(lp->tx_phys_buffers);
-	}
-	if (lp->tx_buffers) {
-		vfree(lp->tx_buffers);
-	}
-
-	lp->tx_orig_buffers = NULL;
-	lp->tx_phys_buffers = NULL;
-	lp->tx_buffers = NULL;
-
-	return 1;		/* 1 == general error */
-}
-
-static void free_descriptor_skb(struct net_device *dev)
-{
-	struct net_local *lp = (struct net_local *) dev->priv;
-	XDmaBdV3 *BdPtr;
-	struct sk_buff *skb;
-	dma_addr_t skb_dma_addr;
-	u32 len, i;
-
-	/* Unmap and free skb's allocated and mapped in descriptor_init() */
-
-	/* Get the virtual address of the 1st BD in the DMA RX BD ring */
-	BdPtr = (XDmaBdV3 *) lp->Emac.RecvDma.BdRing.BaseAddr;
-
-	for (i = 0; i < XTE_RECV_BD_CNT; i++) {
-		skb = (struct sk_buff *) XDmaBdV3_mGetId(BdPtr);
-		if (skb) {
-			skb_dma_addr =
-				(dma_addr_t) XDmaBdV3_mGetBufAddrLow(BdPtr);
-			dma_unmap_single(NULL, skb_dma_addr, lp->max_frame_size,
-					 DMA_FROM_DEVICE);
-			dev_kfree_skb(skb);
-		}
-		/* find the next BD in the DMA RX BD ring */
-		BdPtr = XTemac_mSgRecvBdNext(&lp->Emac, BdPtr);
-	}
-
-	/* Unmap and free TX skb's that have not had a chance to be freed
-	 * in SgSendHandlerBH(). This could happen when TX Threshold is larger
-	 * than 1 and TX waitbound is 0
-	 */
-
-	/* Get the virtual address of the 1st BD in the DMA TX BD ring */
-	BdPtr = (XDmaBdV3 *) lp->Emac.SendDma.BdRing.BaseAddr;
-
-	for (i = 0; i < XTE_SEND_BD_CNT; i++) {
-		skb = (struct sk_buff *) XDmaBdV3_mGetId(BdPtr);
-		if (skb) {
-			skb_dma_addr =
-				(dma_addr_t) XDmaBdV3_mGetBufAddrLow(BdPtr);
-			len = XDmaBdV3_mGetLength(BdPtr);
-			dma_unmap_single(NULL, skb_dma_addr, len,
-					 DMA_TO_DEVICE);
-			dev_kfree_skb(skb);
-		}
-		/* find the next BD in the DMA TX BD ring */
-		BdPtr = XTemac_mSgSendBdNext(&lp->Emac, BdPtr);
-	}
-
-#if BD_IN_BRAM == 0
-	dma_free_coherent(NULL,
-			  lp->desc_space_size,
-			  lp->desc_space, lp->desc_space_handle);
-#else
-	iounmap(lp->desc_space);
-#endif
-}
-
-static int
-xenet_ethtool_get_settings(struct net_device *dev, struct ethtool_cmd *ecmd)
-{
-	int ret;
-	struct net_local *lp = (struct net_local *) dev->priv;
-	u32 mac_options;
-	u16 threshold, timer;
-	u16 gmii_cmd, gmii_status, gmii_advControl;
-	int xs;
-
-	memset(ecmd, 0, sizeof(struct ethtool_cmd));
-
-	mac_options = XTemac_GetOptions(&(lp->Emac));
-	xs = XTemac_PhyRead(&lp->Emac, lp->gmii_addr, MII_BMCR, &gmii_cmd);
-	if (xs != XST_SUCCESS) {
-		printk(KERN_ERR
-		       "%s: XTemac: could not read gmii command register; error %d\n",
-		       dev->name, xs);
-		return -1;
-	}
-	xs = XTemac_PhyRead(&lp->Emac, lp->gmii_addr, MII_BMSR, &gmii_status);
-	if (xs != XST_SUCCESS) {
-		printk(KERN_ERR
-		       "%s: XTemac: could not read gmii status register; error %d\n",
-		       dev->name, xs);
-		return -1;
-	}
-
-	xs = XTemac_PhyRead(&lp->Emac, lp->gmii_addr, MII_ADVERTISE,
-			    &gmii_advControl);
-	if (xs != XST_SUCCESS) {
-		printk(KERN_ERR
-		       "%s: XTemac: could not read gmii advertisement control register; error %d\n",
-		       dev->name, xs);
-		return -1;
-	}
-
-	ecmd->duplex = DUPLEX_FULL;
-
-	ecmd->supported |= SUPPORTED_MII;
-
-	ecmd->port = PORT_MII;
-
-	ecmd->speed = lp->cur_speed;
-
-	if (gmii_status & BMSR_ANEGCAPABLE) {
-		ecmd->supported |= SUPPORTED_Autoneg;
-	}
-	if (gmii_status & BMSR_ANEGCOMPLETE) {
-		ecmd->autoneg = AUTONEG_ENABLE;
-		ecmd->advertising |= ADVERTISED_Autoneg;
-	}
-	else {
-		ecmd->autoneg = AUTONEG_DISABLE;
-	}
-	ecmd->phy_address = lp->Emac.BaseAddress;
-	ecmd->transceiver = XCVR_INTERNAL;
-	if (XTemac_mIsSgDma(&lp->Emac)) {
-		/* get TX threshold */
-		if ((ret =
-		     XTemac_IntrSgCoalGet(&lp->Emac, XTE_SEND, &threshold,
-					  &timer))
-		    == XST_SUCCESS) {
-			ecmd->maxtxpkt = threshold;
-		}
-		else {
-			return -EIO;
-		}
-
-		/* get RX threshold */
-		if ((ret =
-		     XTemac_IntrSgCoalGet(&lp->Emac, XTE_RECV, &threshold,
-					  &timer))
-		    == XST_SUCCESS) {
-			ecmd->maxrxpkt = threshold;
-		}
-		else {
-			return -EIO;
-		}
-	}
-
-	ecmd->supported |= SUPPORTED_10baseT_Full | SUPPORTED_100baseT_Full |
-		SUPPORTED_1000baseT_Full | SUPPORTED_Autoneg;
-
-	return 0;
-}
-
-static int
-xenet_ethtool_set_settings(struct net_device *dev, struct ethtool_cmd *ecmd)
-{
-	struct net_local *lp = (struct net_local *) dev->priv;
-
-	if ((ecmd->duplex != DUPLEX_FULL) ||
-	    (ecmd->transceiver != XCVR_INTERNAL) ||
-	    (ecmd->phy_address &&
-	     (ecmd->phy_address != lp->Emac.BaseAddress))) {
-		return -EOPNOTSUPP;
-	}
-
-	if ((ecmd->speed != 1000) && (ecmd->speed != 100) &&
-	    (ecmd->speed != 10)) {
-		printk(KERN_ERR
-		       "%s: XTemac: xenet_ethtool_set_settings speed not supported: %d\n",
-		       dev->name, ecmd->speed);
-		return -EOPNOTSUPP;
-	}
-
-	if (ecmd->speed != lp->cur_speed) {
-		renegotiate_speed(dev, ecmd->speed, FULL_DUPLEX);
-		XTemac_SetOperatingSpeed(&lp->Emac, ecmd->speed);
-		lp->cur_speed = ecmd->speed;
-	}
-	return 0;
-}
-
-static int
-xenet_ethtool_get_coalesce(struct net_device *dev, struct ethtool_coalesce *ec)
-{
-	int ret;
-	struct net_local *lp = (struct net_local *) dev->priv;
-	u16 threshold, waitbound;
-
-	memset(ec, 0, sizeof(struct ethtool_coalesce));
-
-	if ((ret =
-	     XTemac_IntrSgCoalGet(&lp->Emac, XTE_RECV, &threshold, &waitbound))
-	    != XST_SUCCESS) {
-		printk(KERN_ERR "%s: XTemac: IntrSgCoalGet error %d\n",
-		       dev->name, ret);
-		return -EIO;
-	}
-	ec->rx_max_coalesced_frames = threshold;
-	ec->rx_coalesce_usecs = waitbound;
-
-	if ((ret =
-	     XTemac_IntrSgCoalGet(&lp->Emac, XTE_SEND, &threshold, &waitbound))
-	    != XST_SUCCESS) {
-		printk(KERN_ERR "%s: XTemac: IntrSgCoalGet error %d\n",
-		       dev->name, ret);
-		return -EIO;
-	}
-	ec->tx_max_coalesced_frames = threshold;
-	ec->tx_coalesce_usecs = waitbound;
-
-	return 0;
-}
-
-#if 0
-void disp_bd_ring(XDmaV3_BdRing bd_ring)
-{
-	int num_bds = bd_ring.AllCnt;
-	u32 *cur_bd_ptr = bd_ring.BaseAddr;
-	int idx;
-
-	printk("PhysBaseAddr: %p\n", (void *) bd_ring.PhysBaseAddr);
-	printk("BaseAddr: %p\n", (void *) bd_ring.BaseAddr);
-	printk("HighAddr: %p\n", (void *) bd_ring.HighAddr);
-	printk("Length: %d (0x%0x)\n", bd_ring.Length, bd_ring.Length);
-	printk("RunState: %d (0x%0x)\n", bd_ring.RunState, bd_ring.RunState);
-	printk("Separation: %d (0x%0x)\n", bd_ring.Separation,
-	       bd_ring.Separation);
-	printk("BD Count: %d\n", bd_ring.AllCnt);
-
-	printk("\n");
-
-	printk("FreeHead: %p\n", (void *) bd_ring.FreeHead);
-	printk("PreHead: %p\n", (void *) bd_ring.PreHead);
-	printk("HwHead: %p\n", (void *) bd_ring.HwHead);
-	printk("HwTail: %p\n", (void *) bd_ring.HwTail);
-	printk("PostHead: %p\n", (void *) bd_ring.PostHead);
-	printk("BdaRestart: %p\n", (void *) bd_ring.BdaRestart);
-
-	printk("Ring Contents:\n");
-	printk("Idx     Addr    DMASR     LSBA      BDA   Length     USR0     USR1     USR5       ID\n");
-	printk("--- -------- -------- -------- -------- -------- -------- -------- -------- --------\n");
-
-	for (idx = 0; idx < num_bds; idx++) {
-		printk("%3d %08x %08x %08x %08x %08x %08x %08x %08x %08x\n",
-		       idx, cur_bd_ptr,
-		       cur_bd_ptr[XDMAV3_BD_DMASR_OFFSET / sizeof(*cur_bd_ptr)],
-		       cur_bd_ptr[XDMAV3_BD_LSBA_OFFSET / sizeof(*cur_bd_ptr)],
-		       cur_bd_ptr[XDMAV3_BD_BDA_OFFSET / sizeof(*cur_bd_ptr)],
-		       cur_bd_ptr[XDMAV3_BD_LENGTH_OFFSET /
-				  sizeof(*cur_bd_ptr)],
-		       cur_bd_ptr[XDMAV3_BD_USR0_OFFSET / sizeof(*cur_bd_ptr)],
-		       cur_bd_ptr[XDMAV3_BD_USR1_OFFSET / sizeof(*cur_bd_ptr)],
-		       cur_bd_ptr[XDMAV3_BD_USR5_OFFSET / sizeof(*cur_bd_ptr)],
-		       cur_bd_ptr[XDMAV3_BD_ID_OFFSET / sizeof(*cur_bd_ptr)]);
-
-		cur_bd_ptr += bd_ring.Separation / sizeof(int);
-	}
-	printk("--------------------------------------- Done ---------------------------------------\n");
-}
-#endif
-
-static int
-xenet_ethtool_set_coalesce(struct net_device *dev, struct ethtool_coalesce *ec)
-{
-	int ret;
-	struct net_local *lp;
-	unsigned long flags;
-	int dev_started;
-
-	spin_lock_irqsave(&XTE_spinlock, flags);
-	lp = (struct net_local *) dev->priv;
-
-	if ((dev_started = XTemac_mIsStarted(&lp->Emac)) == TRUE)
-		XTemac_Stop(&lp->Emac);
-
-	if ((ret = XTemac_IntrSgCoalSet(&lp->Emac, XTE_RECV,
-					(u16) (ec->rx_max_coalesced_frames),
-					(u16) (ec->rx_coalesce_usecs))) !=
-	    XST_SUCCESS) {
-		printk(KERN_ERR "%s: XTemac: IntrSgCoalSet error %d\n",
-		       dev->name, ret);
-		spin_unlock_irqrestore(&XTE_spinlock, flags);
-		return -EIO;
-	}
-
-	if ((ret = XTemac_IntrSgCoalSet(&lp->Emac, XTE_SEND,
-					(u16) (ec->tx_max_coalesced_frames),
-					(u16) (ec->tx_coalesce_usecs))) !=
-	    XST_SUCCESS) {
-		printk(KERN_ERR "%s: XTemac: IntrSgCoalSet error %d\n",
-		       dev->name, ret);
-		spin_unlock_irqrestore(&XTE_spinlock, flags);
-		return -EIO;
-	}
-
-	if (dev_started == TRUE) {
-		if ((ret = XTemac_Start(&lp->Emac)) != XST_SUCCESS) {
-			spin_unlock_irqrestore(&XTE_spinlock, flags);
-			return -EIO;
-		}
-	}
-
-	spin_unlock_irqrestore(&XTE_spinlock, flags);
-	return 0;
-}
-
-static int
-xenet_ethtool_get_ringparam(struct net_device *dev,
-			    struct ethtool_ringparam *erp)
-{
-	memset(erp, 0, sizeof(struct ethtool_ringparam));
-
-	erp->rx_max_pending = XTE_RECV_BD_CNT;
-	erp->tx_max_pending = XTE_SEND_BD_CNT;
-	erp->rx_pending = XTE_RECV_BD_CNT;
-	erp->tx_pending = XTE_SEND_BD_CNT;
-	return 0;
-}
-
-#define EMAC_REGS_N 32
-struct mac_regsDump {
-	struct ethtool_regs hd;
-	u16 data[EMAC_REGS_N];
-};
-
-static void
-xenet_ethtool_get_regs(struct net_device *dev, struct ethtool_regs *regs,
-		       void *ret)
-{
-	struct net_local *lp = (struct net_local *) dev->priv;
-	struct mac_regsDump *dump = (struct mac_regsDump *) regs;
-	int i;
-	int r;
-
-	dump->hd.version = 0;
-	dump->hd.len = sizeof(dump->data);
-	memset(dump->data, 0, sizeof(dump->data));
-
-	for (i = 0; i < EMAC_REGS_N; i++) {
-		if ((r =
-		     XTemac_PhyRead(&(lp->Emac), lp->gmii_addr, i,
-				    &(dump->data[i])))
-		    != XST_SUCCESS) {
-			printk(KERN_INFO "%s: XTemac: PhyRead ERROR %d\n",
-			       dev->name, r);
-			*(int *) ret = -EIO;
-			return;
-		}
-	}
-
-	*(int *) ret = 0;
-}
-
-static int
-xenet_ethtool_get_drvinfo(struct net_device *dev, struct ethtool_drvinfo *ed)
-{
-	memset(ed, 0, sizeof(struct ethtool_drvinfo));
-	strncpy(ed->driver, DRIVER_NAME, sizeof(ed->driver) - 1);
-	strncpy(ed->version, DRIVER_VERSION, sizeof(ed->version) - 1);
-	/* Also tell how much memory is needed for dumping register values */
-	ed->regdump_len = sizeof(u16) * EMAC_REGS_N;
-	return 0;
-}
-
-static int xenet_do_ethtool_ioctl(struct net_device *dev, struct ifreq *rq)
-{
-	struct net_local *lp = (struct net_local *) dev->priv;
-	struct ethtool_cmd ecmd;
-	struct ethtool_coalesce eco;
-	struct ethtool_drvinfo edrv;
-	struct ethtool_ringparam erp;
-	struct ethtool_pauseparam epp;
-	struct mac_regsDump regs;
-	unsigned long flags;
-	int ret = -EOPNOTSUPP;
-	u32 Options;
-	XTemac_SoftStats stat;
-
-	if (copy_from_user(&ecmd, rq->ifr_data, sizeof(ecmd)))
-		return -EFAULT;
-	switch (ecmd.cmd) {
-	case ETHTOOL_GSET:	/* Get setting. No command option needed w/ ethtool */
-		ret = xenet_ethtool_get_settings(dev, &ecmd);
-		if (ret < 0)
-			return -EIO;
-		if (copy_to_user(rq->ifr_data, &ecmd, sizeof(ecmd)))
-			return -EFAULT;
-		ret = 0;
-		break;
-	case ETHTOOL_SSET:	/* Change setting. Use "-s" command option w/ ethtool */
-		ret = xenet_ethtool_set_settings(dev, &ecmd);
-		break;
-	case ETHTOOL_GPAUSEPARAM:	/* Get pause parameter information. Use "-a" w/ ethtool */
-		ret = xenet_ethtool_get_settings(dev, &ecmd);
-		if (ret < 0)
-			return ret;
-		epp.cmd = ecmd.cmd;
-		epp.autoneg = ecmd.autoneg;
-		Options = XTemac_GetOptions(&lp->Emac);
-		if (Options & XTE_FCS_INSERT_OPTION) {
-			epp.rx_pause = 1;
-			epp.tx_pause = 1;
-		}
-		else {
-			epp.rx_pause = 0;
-			epp.tx_pause = 0;
-		}
-		if (copy_to_user
-		    (rq->ifr_data, &epp, sizeof(struct ethtool_pauseparam)))
-			return -EFAULT;
-		ret = 0;
-		break;
-	case ETHTOOL_SPAUSEPARAM:	/* Set pause parameter. Use "-A" w/ ethtool */
-		return -EOPNOTSUPP;	/* TODO: To support in next version */
-	case ETHTOOL_GRXCSUM:{	/* Get rx csum offload info. Use "-k" w/ ethtool */
-			struct ethtool_value edata = { ETHTOOL_GRXCSUM };
-
-			edata.data =
-				(lp->local_features & LOCAL_FEATURE_RX_CSUM) !=
-				0;
-			if (copy_to_user(rq->ifr_data, &edata, sizeof(edata)))
-				return -EFAULT;
-			ret = 0;
-			break;
-		}
-	case ETHTOOL_SRXCSUM:{	/* Set rx csum offload info. Use "-K" w/ ethtool */
-			struct ethtool_value edata;
-
-			if (copy_from_user(&edata, rq->ifr_data, sizeof(edata)))
-				return -EFAULT;
-
-			spin_lock_irqsave(&XTE_spinlock, flags);
-			if (edata.data) {
-				if (XTemac_mIsRxCsum(&lp->Emac) == TRUE) {
-					lp->local_features |=
-						LOCAL_FEATURE_RX_CSUM;
-				}
-			}
-			else {
-				lp->local_features &= ~LOCAL_FEATURE_RX_CSUM;
-			}
-			spin_unlock_irqrestore(&XTE_spinlock, flags);
-
-			ret = 0;
-			break;
-		}
-	case ETHTOOL_GTXCSUM:{	/* Get tx csum offload info. Use "-k" w/ ethtool */
-			struct ethtool_value edata = { ETHTOOL_GTXCSUM };
-
-			edata.data = (dev->features & NETIF_F_IP_CSUM) != 0;
-			if (copy_to_user(rq->ifr_data, &edata, sizeof(edata)))
-				return -EFAULT;
-			ret = 0;
-			break;
-		}
-	case ETHTOOL_STXCSUM:{	/* Set tx csum offload info. Use "-K" w/ ethtool */
-			struct ethtool_value edata;
-
-			if (copy_from_user(&edata, rq->ifr_data, sizeof(edata)))
-				return -EFAULT;
-
-			if (edata.data) {
-				if (XTemac_mIsTxCsum(&lp->Emac) == TRUE) {
-					dev->features |= NETIF_F_IP_CSUM;
-				}
-			}
-			else {
-				dev->features &= ~NETIF_F_IP_CSUM;
-			}
-
-			ret = 0;
-			break;
-		}
-	case ETHTOOL_GSG:{	/* Get ScatterGather info. Use "-k" w/ ethtool */
-			struct ethtool_value edata = { ETHTOOL_GSG };
-
-			edata.data = (dev->features & NETIF_F_SG) != 0;
-			if (copy_to_user(rq->ifr_data, &edata, sizeof(edata)))
-				return -EFAULT;
-			ret = 0;
-			break;
-		}
-	case ETHTOOL_SSG:{	/* Set ScatterGather info. Use "-K" w/ ethtool */
-			struct ethtool_value edata;
-
-			if (copy_from_user(&edata, rq->ifr_data, sizeof(edata)))
-				return -EFAULT;
-
-			if (edata.data) {
-				if ((XTemac_mIsTxDre(&lp->Emac) == TRUE) &&
-				    (XTemac_mIsSgDma(&lp->Emac) == TRUE)) {
-					dev->features |=
-						NETIF_F_SG | NETIF_F_FRAGLIST;
-				}
-			}
-			else {
-				dev->features &=
-					~(NETIF_F_SG | NETIF_F_FRAGLIST);
-			}
-
-			ret = 0;
-			break;
-		}
-	case ETHTOOL_GCOALESCE:	/* Get coalescing info. Use "-c" w/ ethtool */
-		if (!(XTemac_mIsSgDma(&lp->Emac)))
-			break;
-		eco.cmd = ecmd.cmd;
-		ret = xenet_ethtool_get_coalesce(dev, &eco);
-		if (ret < 0) {
-			return -EIO;
-		}
-		if (copy_to_user
-		    (rq->ifr_data, &eco, sizeof(struct ethtool_coalesce))) {
-			return -EFAULT;
-		}
-		ret = 0;
-		break;
-	case ETHTOOL_SCOALESCE:	/* Set coalescing info. Use "-C" w/ ethtool */
-		if (!(XTemac_mIsSgDma(&lp->Emac)))
-			break;
-		if (copy_from_user
-		    (&eco, rq->ifr_data, sizeof(struct ethtool_coalesce)))
-			return -EFAULT;
-		ret = xenet_ethtool_set_coalesce(dev, &eco);
-		break;
-	case ETHTOOL_GDRVINFO:	/* Get driver information. Use "-i" w/ ethtool */
-		edrv.cmd = edrv.cmd;
-		ret = xenet_ethtool_get_drvinfo(dev, &edrv);
-		if (ret < 0) {
-			return -EIO;
-		}
-		edrv.n_stats = XENET_STATS_LEN;
-		if (copy_to_user
-		    (rq->ifr_data, &edrv, sizeof(struct ethtool_drvinfo))) {
-			return -EFAULT;
-		}
-		ret = 0;
-		break;
-	case ETHTOOL_GREGS:	/* Get register values. Use "-d" with ethtool */
-		regs.hd.cmd = edrv.cmd;
-		xenet_ethtool_get_regs(dev, &(regs.hd), &ret);
-		if (ret < 0) {
-			return ret;
-		}
-		if (copy_to_user
-		    (rq->ifr_data, &regs, sizeof(struct mac_regsDump))) {
-			return -EFAULT;
-		}
-		ret = 0;
-		break;
-	case ETHTOOL_GRINGPARAM:	/* Get RX/TX ring parameters. Use "-g" w/ ethtool */
-		erp.cmd = edrv.cmd;
-		ret = xenet_ethtool_get_ringparam(dev, &(erp));
-		if (ret < 0) {
-			return ret;
-		}
-		if (copy_to_user
-		    (rq->ifr_data, &erp, sizeof(struct ethtool_ringparam))) {
-			return -EFAULT;
-		}
-		ret = 0;
-		break;
-	case ETHTOOL_NWAY_RST:	/* Restart auto negotiation if enabled. Use "-r" w/ ethtool */
-		return -EOPNOTSUPP;	/* TODO: To support in next version */
-	case ETHTOOL_GSTRINGS:{
-			struct ethtool_gstrings gstrings = { ETHTOOL_GSTRINGS };
-			void *addr = rq->ifr_data;
-			char *strings = NULL;
-
-			if (copy_from_user(&gstrings, addr, sizeof(gstrings))) {
-				return -EFAULT;
-			}
-			switch (gstrings.string_set) {
-			case ETH_SS_STATS:
-				gstrings.len = XENET_STATS_LEN;
-				strings = *xenet_ethtool_gstrings_stats;
-				break;
-			default:
-				return -EOPNOTSUPP;
-			}
-			if (copy_to_user(addr, &gstrings, sizeof(gstrings))) {
-				return -EFAULT;
-			}
-			addr += offsetof(struct ethtool_gstrings, data);
-			if (copy_to_user
-			    (addr, strings, gstrings.len * ETH_GSTRING_LEN)) {
-				return -EFAULT;
-			}
-			ret = 0;
-			break;
-		}
-	case ETHTOOL_GSTATS:{
-			struct {
-				struct ethtool_stats cmd;
-				uint64_t data[XENET_STATS_LEN];
-			} stats = { {
-			ETHTOOL_GSTATS, XENET_STATS_LEN}};
-
-			XTemac_GetSoftStats(&lp->Emac, &stat);
-			stats.data[0] = stat.TxDmaErrors;
-			stats.data[1] = stat.TxPktFifoErrors;
-			stats.data[2] = stat.TxStatusErrors;
-			stats.data[3] = stat.RxRejectErrors;
-			stats.data[4] = stat.RxDmaErrors;
-			stats.data[5] = stat.RxPktFifoErrors;
-			stats.data[6] = stat.FifoErrors;
-			stats.data[7] = stat.IpifErrors;
-			stats.data[8] = stat.Interrupts;
-			stats.data[9] = lp->max_frags_in_a_packet;
-			stats.data[10] = lp->tx_hw_csums;
-			stats.data[11] = lp->rx_hw_csums;
-
-			if (copy_to_user(rq->ifr_data, &stats, sizeof(stats))) {
-				return -EFAULT;
-			}
-			ret = 0;
-			break;
-		}
-	default:
-		return -EOPNOTSUPP;	/* All other operations not supported */
-	}
-	return ret;
-}
-
-static int xenet_ioctl(struct net_device *dev, struct ifreq *rq, int cmd)
-{
-	struct net_local *lp = (struct net_local *) dev->priv;
-
-	/* gmii_ioctl_data has 4 u16 fields: phy_id, reg_num, val_in & val_out */
-	struct mii_ioctl_data *data = (struct mii_ioctl_data *) &rq->ifr_data;
-	struct {
-		__u16 threshold;
-		__u32 direction;
-	} thr_arg;
-	struct {
-		__u16 waitbound;
-		__u32 direction;
-	} wbnd_arg;
-
-	int ret;
-	unsigned long flags;
-	u16 threshold, timer;
-	int dev_started;
-
-	switch (cmd) {
-	case SIOCETHTOOL:
-		return xenet_do_ethtool_ioctl(dev, rq);
-	case SIOCGMIIPHY:	/* Get address of GMII PHY in use. */
-	case SIOCDEVPRIVATE:	/* for binary compat, remove in 2.5 */
-		data->phy_id = lp->gmii_addr;
-		/* Fall Through */
-
-	case SIOCGMIIREG:	/* Read GMII PHY register. */
-	case SIOCDEVPRIVATE + 1:	/* for binary compat, remove in 2.5 */
-		if (data->phy_id > 31 || data->reg_num > 31)
-			return -ENXIO;
-
-		/* Stop the PHY timer to prevent reentrancy. */
-		spin_lock_irqsave(&XTE_spinlock, flags);
-		del_timer_sync(&lp->phy_timer);
-
-		ret = XTemac_PhyRead(&lp->Emac, data->phy_id,
-				     data->reg_num, &data->val_out);
-
-		/* Start the PHY timer up again. */
-		lp->phy_timer.expires = jiffies + 2 * HZ;
-		add_timer(&lp->phy_timer);
-		spin_unlock_irqrestore(&XTE_spinlock, flags);
-		if (ret != XST_SUCCESS) {
-			printk(KERN_ERR
-			       "%s: XTemac: could not read from PHY, error=%d.\n",
-			       dev->name, ret);
-			return -EBUSY;
-		}
-		return 0;
-
-	case SIOCSMIIREG:	/* Write GMII PHY register. */
-	case SIOCDEVPRIVATE + 2:	/* for binary compat, remove in 2.5 */
-		if (!capable(CAP_NET_ADMIN))
-			return -EPERM;
-
-		if (data->phy_id > 31 || data->reg_num > 31)
-			return -ENXIO;
-
-		spin_lock_irqsave(&XTE_spinlock, flags);
-		/* Stop the PHY timer to prevent reentrancy. */
-		del_timer_sync(&lp->phy_timer);
-
-		ret = XTemac_PhyWrite(&lp->Emac, data->phy_id,
-				      data->reg_num, data->val_in);
-
-		/* Start the PHY timer up again. */
-		lp->phy_timer.expires = jiffies + 2 * HZ;
-		add_timer(&lp->phy_timer);
-		spin_unlock_irqrestore(&XTE_spinlock, flags);
-
-		if (ret != XST_SUCCESS) {
-			printk(KERN_ERR
-			       "%s: XTemac: could not write to PHY, error=%d.\n",
-			       dev->name, ret);
-			return -EBUSY;
-		}
-		return 0;
-
-	case SIOCDEVPRIVATE + 3:	/* set THRESHOLD */
-		if (!(XTemac_mIsSgDma(&lp->Emac)))
-			return -EFAULT;
-
-		if (copy_from_user(&thr_arg, rq->ifr_data, sizeof(thr_arg)))
-			return -EFAULT;
-
-		spin_lock_irqsave(&XTE_spinlock, flags);
-		if ((dev_started = XTemac_mIsStarted(&lp->Emac)) == TRUE)
-			XTemac_Stop(&lp->Emac);
-
-		if ((ret = XTemac_IntrSgCoalGet(&lp->Emac, thr_arg.direction,
-						&threshold,
-						&timer)) != XST_SUCCESS) {
-			spin_unlock_irqrestore(&XTE_spinlock, flags);
-			return -EIO;
-		}
-		if ((ret = XTemac_IntrSgCoalSet(&lp->Emac, thr_arg.direction,
-						thr_arg.threshold,
-						timer)) != XST_SUCCESS) {
-			spin_unlock_irqrestore(&XTE_spinlock, flags);
-			return -EIO;
-		}
-		if (dev_started == TRUE) {
-			if ((ret = XTemac_Start(&lp->Emac)) != XST_SUCCESS) {
-				spin_unlock_irqrestore(&XTE_spinlock, flags);
-				return -EIO;
-			}
-		}
-		spin_unlock_irqrestore(&XTE_spinlock, flags);
-		return 0;
-
-	case SIOCDEVPRIVATE + 4:	/* set WAITBOUND */
-		if (!(XTemac_mIsSgDma(&lp->Emac)))
-			return -EFAULT;
-
-		if (copy_from_user(&wbnd_arg, rq->ifr_data, sizeof(wbnd_arg)))
-			return -EFAULT;
-
-		spin_lock_irqsave(&XTE_spinlock, flags);
-		if ((dev_started = XTemac_mIsStarted(&lp->Emac)) == TRUE)
-			XTemac_Stop(&lp->Emac);
-
-		if ((ret = XTemac_IntrSgCoalGet(&lp->Emac, wbnd_arg.direction,
-						&threshold,
-						&timer)) != XST_SUCCESS) {
-			spin_unlock_irqrestore(&XTE_spinlock, flags);
-			return -EIO;
-		}
-		if ((ret =
-		     XTemac_IntrSgCoalSet(&lp->Emac, wbnd_arg.direction,
-					  threshold,
-					  wbnd_arg.waitbound)) != XST_SUCCESS) {
-			spin_unlock_irqrestore(&XTE_spinlock, flags);
-			return -EIO;
-		}
-		if (dev_started == TRUE) {
-			if ((ret = XTemac_Start(&lp->Emac)) != XST_SUCCESS) {
-				spin_unlock_irqrestore(&XTE_spinlock, flags);
-				return -EIO;
-			}
-		}
-		spin_unlock_irqrestore(&XTE_spinlock, flags);
-		return 0;
-
-	case SIOCDEVPRIVATE + 5:	/* get THRESHOLD */
-		if (!(XTemac_mIsSgDma(&lp->Emac)))
-			return -EFAULT;
-
-		if (copy_from_user(&thr_arg, rq->ifr_data, sizeof(thr_arg)))
-			return -EFAULT;
-
-		if ((ret = XTemac_IntrSgCoalGet(&lp->Emac, thr_arg.direction,
-						(u16 *) &(thr_arg.threshold),
-						&timer)) != XST_SUCCESS) {
-			return -EIO;
-		}
-		if (copy_to_user(rq->ifr_data, &thr_arg, sizeof(thr_arg))) {
-			return -EFAULT;
-		}
-		return 0;
-
-	case SIOCDEVPRIVATE + 6:	/* get WAITBOUND */
-		if (!(XTemac_mIsSgDma(&lp->Emac)))
-			return -EFAULT;
-
-		if (copy_from_user(&wbnd_arg, rq->ifr_data, sizeof(wbnd_arg))) {
-			return -EFAULT;
-		}
-		if ((ret = XTemac_IntrSgCoalGet(&lp->Emac, wbnd_arg.direction,
-						&threshold,
-						(u16 *) &(wbnd_arg.
-							  waitbound))) !=
-		    XST_SUCCESS) {
-			return -EIO;
-		}
-		if (copy_to_user(rq->ifr_data, &wbnd_arg, sizeof(wbnd_arg))) {
-			return -EFAULT;
-		}
-		return 0;
-
-	default:
-		return -EOPNOTSUPP;
-	}
-}
-
-
-/******************************************************************************
- *
- * NEW FUNCTIONS FROM LINUX 2.6
- *
- ******************************************************************************/
-
-static void xtenet_remove_ndev(struct net_device *ndev)
-{
-	if (ndev) {
-		struct net_local *lp = netdev_priv(ndev);
-
-		if (XTemac_mIsSgDma(&lp->Emac) && (lp->desc_space))
-			free_descriptor_skb(ndev);
-
-		iounmap((void *) (lp->Emac.BaseAddress));
-		free_netdev(ndev);
-	}
-}
-
-static int xtenet_remove(struct device *dev)
-{
-	struct net_device *ndev = dev_get_drvdata(dev);
-
-	unregister_netdev(ndev);
-	xtenet_remove_ndev(ndev);
-
-	return 0;		/* success */
-}
-
-/* Detect the PHY address by scanning addresses 0 to 31 and
- * looking at the MII status register (register 1) and assuming
- * the PHY supports 10Mbps full/half duplex. Feel free to change
- * this code to match your PHY, or hardcode the address if needed.
- */
-/* Use MII register 1 (MII status register) to detect PHY */
-#define PHY_DETECT_REG  1
-
-/* Mask used to verify certain PHY features (or register contents)
- * in the register above:
- *  0x1000: 10Mbps full duplex support
- *  0x0800: 10Mbps half duplex support
- *  0x0008: Auto-negotiation support
- */
-#define PHY_DETECT_MASK 0x1808
-
-static int detect_phy(struct net_local *lp, char *dev_name)
-{
-	int status;
-	u16 phy_reg;
-	u32 phy_addr;
-	int i;
-
-	for (phy_addr = 0; phy_addr <= 31; phy_addr++) {
-		status = XTemac_PhyRead(&lp->Emac, phy_addr, PHY_DETECT_REG,
-					&phy_reg);
-
-		if ((status == XST_SUCCESS) && (phy_reg != 0xFFFF) &&
-		    ((phy_reg & PHY_DETECT_MASK) == PHY_DETECT_MASK)) {
-			/* Found a valid PHY address */
-			printk(KERN_INFO
-			       "%s: XTemac: PHY detected at address %d.\n",
-			       dev_name, phy_addr);
-
-			for (i = 0; i < 32; i++) {
-				if ((i % 8) == 0) {
-					if (i != 0)
-						printk("\n");
-					printk(KERN_INFO "%.2x: ", i);
-				}
-				XTemac_PhyRead(&lp->Emac, phy_addr, i,
-					       &phy_reg);
-				printk(" %.4x", phy_reg);
-			}
-			printk("\n");
-			return phy_addr;
-		}
-	}
-
-	printk(KERN_WARNING
-	       "%s: XTemac: No PHY detected.  Assuming a PHY at address 0\n",
-	       dev_name);
-	return 0;		/* default to zero */
-}
-
-static int xtenet_probe(struct device *dev)
-{
-	int xs;
-	u32 hwid;
-	u32 virt_baddr;		/* virtual base address of temac */
-
-	XTemac_Config Config;
-
-	struct resource *r_irq = NULL;	/* Interrupt resources */
-	struct resource *r_mem = NULL;	/* IO mem resources */
-
-	struct xtemac_platform_data *pdata;
-
-	struct platform_device *pdev = to_platform_device(dev);
-	struct net_device *ndev = NULL;
-	struct net_local *lp = NULL;
-
-	int rc = 0;
-
-
-	/* param check */
-	if (!pdev) {
-		printk(KERN_ERR
-		       "XTemac: Internal error. Probe called with NULL param.\n");
-		rc = -ENODEV;
-		goto error;
-	}
-
-	pdata = (struct xtemac_platform_data *) pdev->dev.platform_data;
-	if (!pdata) {
-		printk(KERN_ERR "xtemac %d: Couldn't find platform data.\n",
-		       pdev->id);
-
-		rc = -ENODEV;
-		goto error;
-	}
-
-	/* Create an ethernet device instance */
-	ndev = alloc_etherdev(sizeof(struct net_local));
-	if (!ndev) {
-		printk(KERN_ERR "xtemac %d: Could not allocate net device.\n",
-		       pdev->id);
-		rc = -ENOMEM;
-		goto error;
-	}
-	dev_set_drvdata(dev, ndev);
-
-	/* Get iospace and an irq for the device */
-	r_irq = platform_get_resource(pdev, IORESOURCE_IRQ, 0);
-	r_mem = platform_get_resource(pdev, IORESOURCE_MEM, 0);
-	if (!r_irq || !r_mem) {
-		printk(KERN_ERR "xtemac %d: IO resource(s) not found.\n",
-		       pdev->id);
-		rc = -ENODEV;
-		goto error;
-	}
-	ndev->irq = r_irq->start;
-
-
-	/* Initialize the private data used by XEmac_LookupConfig().
-	 * The private data are zeroed out by alloc_etherdev() already.
-	 */
-	lp = netdev_priv(ndev);
-	lp->ndev = ndev;
-	lp->index = pdev->id;
-
-	/* Setup the Config structure for the XTemac_CfgInitialize() call. */
-	Config.DeviceId = pdev->id;
-	Config.BaseAddress = r_mem->start;
-	Config.RxPktFifoDepth = pdata->rx_pkt_fifo_depth;
-	Config.TxPktFifoDepth = pdata->tx_pkt_fifo_depth;
-	Config.MacFifoDepth = pdata->mac_fifo_depth;
-	Config.IpIfDmaConfig = pdata->dma_mode;
-#ifdef XPAR_TEMAC_0_INCLUDE_RX_CSUM
-	Config.TxDre = pdata->tx_dre;
-	Config.RxDre = pdata->rx_dre;
-	Config.TxCsum = pdata->tx_csum;
-	Config.RxCsum = pdata->rx_csum;
-	Config.PhyType = pdata->phy_type;
-#endif
-//    Config.DcrHost         = pdata->dcr_host;
-//    Config.Dre             = pdata->dre;
-
-	/* Get the virtual base address for the device */
-	virt_baddr = (u32) ioremap(r_mem->start, r_mem->end - r_mem->start + 1);
-	if (0 == virt_baddr) {
-		printk(KERN_ERR "XTemac: Could not allocate iomem.\n");
-		rc = -EIO;
-		goto error;
-	}
-
-
-	if (XTemac_CfgInitialize(&lp->Emac, &Config, virt_baddr) != XST_SUCCESS) {
-		printk(KERN_ERR "XTemac: Could not initialize device.\n");
-		rc = -ENODEV;
-		goto error;
-	}
-
-	/* Set the MAC address */
-	/* wgr TODO: Get the MAC address right! */
-	ndev->dev_addr[0] = 0x01;
-	ndev->dev_addr[1] = 0x02;
-	ndev->dev_addr[2] = 0x03;
-	ndev->dev_addr[3] = 0x04;
-	ndev->dev_addr[4] = 0x05;
-	ndev->dev_addr[5] = 0x06;
-// -wgr-     memcpy(ndev->dev_addr, ((bd_t *) &__res)->bi_enetaddr, 6);
-	if (XTemac_SetMacAddress(&lp->Emac, ndev->dev_addr) != XST_SUCCESS) {
-		/* should not fail right after an initialize */
-		printk(KERN_ERR "XTemac: could not set MAC address.\n");
-		rc = -EIO;
-		goto error;
-	}
-
-
-	lp->max_frame_size = XTE_MAX_JUMBO_FRAME_SIZE;
-	if (ndev->mtu > XTE_JUMBO_MTU)
-		ndev->mtu = XTE_JUMBO_MTU;
-
-
-	if (XTemac_mIsSgDma(&lp->Emac)) {
-		int result;
-
-		printk(KERN_ERR "XTemac: using sgDMA mode.\n");
-		XTemac_SetHandler(&lp->Emac, XTE_HANDLER_SGSEND, SgSendHandler,
-				  lp);
-		XTemac_SetHandler(&lp->Emac, XTE_HANDLER_SGRECV, SgRecvHandler,
-				  lp);
-		lp->Isr = XTemac_IntrSgHandler;
-
-		if (XTemac_mIsTxDre(&lp->Emac) == TRUE) {
-			printk(KERN_INFO "XTemac: using TxDRE mode\n");
-			ndev->hard_start_xmit = xenet_SgSend;
-		}
-		else {
-			printk(KERN_INFO "XTemac: not using TxDRE mode\n");
-			ndev->hard_start_xmit = xenet_SgSend_NoDRE;
-		}
-		if (XTemac_mIsRxDre(&lp->Emac) == TRUE) {
-			printk(KERN_INFO "XTemac: using RxDRE mode\n");
-			lp->local_features |= LOCAL_FEATURE_RX_DRE;
-		}
-		else {
-			printk(KERN_INFO "XTemac: not using RxDRE mode\n");
-			lp->local_features &= ~LOCAL_FEATURE_RX_DRE;
-		}
-
-		result = descriptor_init(ndev);
-		if (result) {
-			rc = -EIO;
-			goto error;
-		}
-
-		if (XTemac_mIsTxDre(&lp->Emac) == FALSE) {
-			result = tx_ring_buffer_init(ndev, lp->max_frame_size);
-			if (result) {
-				printk(KERN_ERR
-				       "XTemac: Could not allocate TX buffers.\n");
-				rc = -EIO;
-				goto error;
-			}
-		}
-
-		/* set the packet threshold and wait bound for both TX/RX directions */
-		if ((xs =
-		     XTemac_IntrSgCoalSet(&lp->Emac, XTE_SEND, DFT_TX_THRESHOLD,
-					  DFT_TX_WAITBOUND)) != XST_SUCCESS) {
-			printk(KERN_ERR
-			       "XTemac: could not set SEND pkt threshold/waitbound, ERROR %d",
-			       xs);
-		}
-		if ((xs =
-		     XTemac_IntrSgCoalSet(&lp->Emac, XTE_RECV, DFT_RX_THRESHOLD,
-					  DFT_RX_WAITBOUND)) != XST_SUCCESS) {
-			printk(KERN_ERR
-			       "XTemac: Could not set RECV pkt threshold/waitbound ERROR %d",
-			       xs);
-		}
-	}
-	else {
-		printk(KERN_INFO
-		       "XTemac: using FIFO direct interrupt driven mode.\n");
-		XTemac_SetHandler(&lp->Emac, XTE_HANDLER_FIFORECV,
-				  FifoRecvHandler, ndev);
-		XTemac_SetHandler(&lp->Emac, XTE_HANDLER_FIFOSEND,
-				  FifoSendHandler, ndev);
-		ndev->hard_start_xmit = xenet_FifoSend;
-		lp->Isr = XTemac_IntrFifoHandler;
-	}
-	XTemac_SetHandler(&lp->Emac, XTE_HANDLER_ERROR, ErrorHandler, ndev);
-
-	/* Scan to find the PHY */
-	lp->gmii_addr = detect_phy(lp, ndev->name);
-
-
-	/* initialize the netdev structure */
-	ndev->open = xenet_open;
-	ndev->stop = xenet_close;
-	ndev->change_mtu = xenet_change_mtu;
-	ndev->get_stats = xenet_get_stats;
-	ndev->flags &= ~IFF_MULTICAST;
-
-	/* TX DRE and SGDMA need to go together for this to work right */
-	if ((XTemac_mIsTxDre(&lp->Emac) == TRUE) &&
-	    (XTemac_mIsSgDma(&lp->Emac) == TRUE)) {
-		ndev->features = NETIF_F_SG | NETIF_F_FRAGLIST;
-	}
-
-	if (XTemac_mIsTxCsum(&lp->Emac) == TRUE) {
-		/*
-		 * This hardware only supports proper checksum calculations
-		 * on TCP/UDP packets.
-		 */
-		ndev->features |= NETIF_F_IP_CSUM;
-	}
-	if (XTemac_mIsRxCsum(&lp->Emac) == TRUE) {
-		lp->local_features |= LOCAL_FEATURE_RX_CSUM;
-	}
-
-	ndev->do_ioctl = xenet_ioctl;
-	ndev->tx_timeout = xenet_tx_timeout;
-	ndev->watchdog_timeo = TX_TIMEOUT;
-
-	/* init the stats */
-	lp->max_frags_in_a_packet = 0;
-	lp->tx_hw_csums = 0;
-	lp->rx_hw_csums = 0;
-
-#if ! XTE_AUTOSTRIPPING
-	lp->stripping =
-		(XTemac_GetOptions(&(lp->Emac)) & XTE_FCS_STRIP_OPTION) != 0;
-#endif
-
-	rc = register_netdev(ndev);
-	if (rc) {
-		printk(KERN_ERR
-		       "%s: Cannot register net device, aborting.\n",
-		       ndev->name);
-		goto error;	/* rc is already set here... */
-	}
-
-	printk(KERN_INFO
-	       "%s: Xilinx TEMAC #%d at 0x%08X mapped to 0x%08X, irq=%d\n",
-	       ndev->name, lp->Emac.Config.DeviceId,
-	       lp->Emac.Config.BaseAddress, lp->Emac.BaseAddress, ndev->irq);
-
-	/* print h/w id  */
-	hwid = XIo_In32((lp->Emac).BaseAddress + XIIF_V123B_RESETR_OFFSET);
-
-	printk(KERN_INFO
-	       "%s: XTemac id %d.%d%c, block id %d, type %d\n",
-	       ndev->name, (hwid >> 28) & 0xf, (hwid >> 21) & 0x7f,
-	       ((hwid >> 16) & 0x1f) + 'a', (hwid >> 16) & 0xff,
-	       (hwid >> 0) & 0xff);
-
-	return 0;
-
-      error:
-	if (ndev) {
-		xtenet_remove_ndev(ndev);
-	}
-	return rc;
-}
-
-
-
-static struct device_driver xtenet_driver = {
-	.name = DRIVER_NAME,
-	.bus = &platform_bus_type,
-
-	.probe = xtenet_probe,
-	.remove = xtenet_remove
-};
-
-static int __init xtenet_init(void)
-{
-	/*
-	 * No kernel boot options used,
-	 * so we just need to register the driver
-	 */
-	return driver_register(&xtenet_driver);
-}
-
-static void __exit xtenet_cleanup(void)
-{
-	driver_unregister(&xtenet_driver);
-}
-
-module_init(xtenet_init);
-module_exit(xtenet_cleanup);
-
-MODULE_AUTHOR("MontaVista Software, Inc. <source@mvista.com>");
-MODULE_DESCRIPTION(DRIVER_DESCRIPTION);
-MODULE_LICENSE("GPL");
diff --git a/drivers/net/ethernet/xilinx/xilinx_temac/xtemac_selftest.c b/drivers/net/ethernet/xilinx/xilinx_temac/xtemac_selftest.c
deleted file mode 100644
index d242943..0000000
--- a/drivers/net/ethernet/xilinx/xilinx_temac/xtemac_selftest.c
+++ /dev/null
@@ -1,139 +0,0 @@
-/* $Id: */
-/******************************************************************************
-*
-*       XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS"
-*       AS A COURTESY TO YOU, SOLELY FOR USE IN DEVELOPING PROGRAMS AND
-*       SOLUTIONS FOR XILINX DEVICES.  BY PROVIDING THIS DESIGN, CODE,
-*       OR INFORMATION AS ONE POSSIBLE IMPLEMENTATION OF THIS FEATURE,
-*       APPLICATION OR STANDARD, XILINX IS MAKING NO REPRESENTATION
-*       THAT THIS IMPLEMENTATION IS FREE FROM ANY CLAIMS OF INFRINGEMENT,
-*       AND YOU ARE RESPONSIBLE FOR OBTAINING ANY RIGHTS YOU MAY REQUIRE
-*       FOR YOUR IMPLEMENTATION.  XILINX EXPRESSLY DISCLAIMS ANY
-*       WARRANTY WHATSOEVER WITH RESPECT TO THE ADEQUACY OF THE
-*       IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OR
-*       REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE FROM CLAIMS OF
-*       INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
-*       FOR A PARTICULAR PURPOSE.
-*
-*       (c) Copyright 2005-2006 Xilinx Inc.
-*       All rights reserved.
-* This program is free software; you can redistribute it and/or modify it
-* under the terms of the GNU General Public License as published by the
-* Free Software Foundation; either version 2 of the License, or (at your
-* option) any later version.
-*
-* You should have received a copy of the GNU General Public License
-* along with this program; if not, write to the Free Software
-* Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-*
-******************************************************************************/
-/*****************************************************************************/
-/**
-*
-* @file xtemac_selftest.c
-*
-* Self-test and diagnostic functions of the XTemac driver.
-*
-* <pre>
-* MODIFICATION HISTORY:
-*
-* Ver   Who  Date     Changes
-* ----- ---- -------- -------------------------------------------------------
-* 1.00a rmm  06/01/05 First release
-* 2.00a rmm  11/21/05 Switched to local link DMA driver
-* </pre>
-*
-******************************************************************************/
-
-/***************************** Include Files *********************************/
-
-#include "xtemac.h"
-#include "xtemac_i.h"
-
-/************************** Constant Definitions *****************************/
-#define XTE_IPIF_IP_INTR_COUNT 13
-
-/**************************** Type Definitions *******************************/
-
-
-/***************** Macros (Inline Functions) Definitions *********************/
-
-
-/************************** Function Prototypes ******************************/
-
-
-/************************** Variable Definitions *****************************/
-
-
-/*****************************************************************************/
-/**
-* Performs a self-test on the Ethernet device.  The test includes:
-*   - Run self-test on DMA channel, FIFO, and IPIF components
-*
-* This self-test is destructive. On successful completion, the device is reset
-* and returned to its default configuration. The caller is responsible for
-* re-configuring the device after the self-test is run, and starting it when
-* ready to send and receive frames.
-*
-* @param InstancePtr is a pointer to the instance to be worked on.
-*
-* @return
-*
-*  - XST_SUCCESS  Self-test was successful
-*  - XST_FAILURE  Self-test failed
-*
-* @note
-* There is the possibility that this function will not return if the hardware is
-* broken (i.e., it never sets the status bit indicating that transmission is
-* done). If this is of concern to the user, the user should provide protection
-* from this problem - perhaps by using a different timer thread to monitor the
-* self-test thread.
-*
-******************************************************************************/
-int XTemac_SelfTest(XTemac *InstancePtr)
-{
-	int Result;
-
-	XASSERT_NONVOID(InstancePtr != NULL);
-	XASSERT_NONVOID(InstancePtr->IsReady == XCOMPONENT_IS_READY);
-
-	/* Run self-test on the DMA (if configured) */
-	if (XTemac_mIsSgDma(InstancePtr)) {
-		Result = XDmaV3_SelfTest(&InstancePtr->RecvDma);
-		if (Result != XST_SUCCESS) {
-			return (XST_FAILURE);
-		}
-
-		Result = XDmaV3_SelfTest(&InstancePtr->SendDma);
-		if (Result != XST_SUCCESS) {
-			return (XST_FAILURE);
-		}
-	}
-
-	/* Run self-test on packet fifos */
-	if (XTemac_mIsFifo(InstancePtr)) {
-		Result = XPacketFifoV200a_SelfTest(&InstancePtr->RecvFifo.Fifo,
-						   XPF_V200A_READ_FIFO_TYPE);
-		if (Result != XST_SUCCESS) {
-			return (XST_FAILURE);
-		}
-
-		Result = XPacketFifoV200a_SelfTest(&InstancePtr->SendFifo.Fifo,
-						   XPF_V200A_WRITE_FIFO_TYPE);
-		if (Result != XST_SUCCESS) {
-			return (XST_FAILURE);
-		}
-	}
-
-	/* Run the IPIF self-test */
-	Result = XIpIfV123b_SelfTest(InstancePtr->BaseAddress,
-				     XTE_IPIF_IP_INTR_COUNT);
-	if (Result != XST_SUCCESS) {
-		return (XST_FAILURE);
-	}
-
-	/* Reset the Ethernet MAC to leave it in a known good state */
-	XTemac_Reset(InstancePtr, XTE_NORESET_HARD);
-
-	return (XST_SUCCESS);
-}
diff --git a/drivers/net/ethernet/xilinx/xilinx_temac/xtemac_sgdma.c b/drivers/net/ethernet/xilinx/xilinx_temac/xtemac_sgdma.c
deleted file mode 100644
index 5e45a9c..0000000
--- a/drivers/net/ethernet/xilinx/xilinx_temac/xtemac_sgdma.c
+++ /dev/null
@@ -1,654 +0,0 @@
-/* $Id: */
-/******************************************************************************
-*
-*       XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS"
-*       AS A COURTESY TO YOU, SOLELY FOR USE IN DEVELOPING PROGRAMS AND
-*       SOLUTIONS FOR XILINX DEVICES.  BY PROVIDING THIS DESIGN, CODE,
-*       OR INFORMATION AS ONE POSSIBLE IMPLEMENTATION OF THIS FEATURE,
-*       APPLICATION OR STANDARD, XILINX IS MAKING NO REPRESENTATION
-*       THAT THIS IMPLEMENTATION IS FREE FROM ANY CLAIMS OF INFRINGEMENT,
-*       AND YOU ARE RESPONSIBLE FOR OBTAINING ANY RIGHTS YOU MAY REQUIRE
-*       FOR YOUR IMPLEMENTATION.  XILINX EXPRESSLY DISCLAIMS ANY
-*       WARRANTY WHATSOEVER WITH RESPECT TO THE ADEQUACY OF THE
-*       IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OR
-*       REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE FROM CLAIMS OF
-*       INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
-*       FOR A PARTICULAR PURPOSE.
-*
-*       (c) Copyright 2005-2006 Xilinx Inc.
-*       All rights reserved.
-* This program is free software; you can redistribute it and/or modify it
-* under the terms of the GNU General Public License as published by the
-* Free Software Foundation; either version 2 of the License, or (at your
-* option) any later version.
-*
-* You should have received a copy of the GNU General Public License
-* along with this program; if not, write to the Free Software
-* Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-*
-******************************************************************************/
-/*****************************************************************************/
-/**
- *
- * @file xtemac_sgdma.c
- *
- * Functions in this file implement scatter-gather DMA frame transfer mode.
- * See xtemac.h for a detailed description of the driver.
- *
- * <pre>
- * MODIFICATION HISTORY:
- *
- * Ver   Who  Date     Changes
- * ----- ---- -------- -------------------------------------------------------
- * 1.00a rmm  06/01/05 First release
- * 2.00a rmm  11/21/05 Switched to local link DMA driver
- *       rmm  06/22/06 Fixed C++ compiler warnings
- *
- * </pre>
- *
- ******************************************************************************/
-
-/***************************** Include Files *********************************/
-
-#include "xtemac.h"
-#include "xtemac_i.h"
-#include "xdmav3_l.h"
-
-/************************** Constant Definitions *****************************/
-
-
-/**************************** Type Definitions *******************************/
-
-
-/***************** Macros (Inline Functions) Definitions *********************/
-
-
-/************************** Variable Definitions *****************************/
-
-
-/************************** Function Prototypes ******************************/
-
-
-/*****************************************************************************/
-/**
- * Allocate a set of BDs from the given SGDMA channel. It is expected the user
- * will attach buffers and set other DMA transaction parameters to the returned
- * BDs in preparation to calling XTemac_SgCommit(). The set of BDs returned is
- * a list starting with the BdPtr and extending for NumBd BDs. The list can be
- * navigated with macros XTemac_mSgRecvBdNext() for the XTE_RECV channel, and
- * XTemac_mSgSendBdNext() for the XTE_SEND channel.
- *
- * The BDs returned by this function are a segment of the BD ring maintained
- * by the SGDMA driver. Do not modify BDs past the end of the returned list.
- * Doing so will cause data corruption and may lead to system instability.
- *
- * This function and XTemac_SgCommit() must be called in the correct order. See
- * xtemac.h for more information on the SGDMA use model.
- *
- * @param InstancePtr is a pointer to the instance to be worked on.
- * @param Direction is the channel to address (XTE_SEND or XTE_RECV).
- * @param NumBd is the number of BDs to allocate.
- * @param BdPtr is an output parameter, it points to the first BD in the
- *        returned list.
- *
- * @return
- * - XST_SUCCESS if the requested number of BDs was returned.
- * - XST_INVALID_PARAM if Direction did not specify a valid channel.
- * - XST_FAILURE if there were not enough free BDs to satisfy the request.
- *
- * @note
- * This function is not thread-safe. The user must provide mutually exclusive
- * access to this function if there are to be multiple threads that can call it.
- *
- ******************************************************************************/
-int XTemac_SgAlloc(XTemac *InstancePtr, u32 Direction,
-		   unsigned NumBd, XDmaBdV3 ** BdPtr)
-{
-	int Status;
-	XDmaV3 *DmaPtr;
-	u32 DgieReg;
-
-	XASSERT_NONVOID(InstancePtr != NULL);
-	XASSERT_NONVOID(BdPtr != NULL);
-	XASSERT_NONVOID(InstancePtr->IsReady == XCOMPONENT_IS_READY);
-
-	/* Which channel to address */
-	if (Direction == XTE_RECV) {
-		DmaPtr = &InstancePtr->RecvDma;
-	}
-	else if (Direction == XTE_SEND) {
-		DmaPtr = &InstancePtr->SendDma;
-	}
-	else {
-		return (XST_INVALID_PARAM);
-	}
-
-	/* XDmaV3_SgBdAlloc() will return either XST_SUCCESS or XST_FAILURE
-	 * This is a critical section, prevent interrupts from the device while
-	 * the BD ring is being modified.
-	 */
-	DgieReg = XTemac_mGetIpifReg(XTE_DGIE_OFFSET);
-	XTemac_mSetIpifReg(XTE_DGIE_OFFSET, 0);
-	Status = XDmaV3_SgBdAlloc(DmaPtr, NumBd, BdPtr);
-	XTemac_mSetIpifReg(XTE_DGIE_OFFSET, DgieReg);
-	return (Status);
-}
-
-/*****************************************************************************/
-/**
- * Fully or partially undo a XTemac_SgAlloc() operation. Use this function to
- * free BDs prior to being given to HW with XTemac_SgCommit().
- *
- * An UnAlloc operation may be required if for some reason there is an error
- * (OS out of resources for example) prior to committing them. The last BD
- * in the list provided by XTemac_SgAlloc() must be the last BD in the list
- * provided to XTemac_SgUnAlloc().
- *
- * @param InstancePtr is a pointer to the instance to be worked on.
- * @param Direction is the channel to address (XTE_SEND or XTE_RECV).
- * @param NumBd is the number of BDs to allocate.
- * @param BdPtr is an output parameter, it points to the first BD in the
- *        returned list.
- *
- * @return
- * - XST_SUCCESS if the requested number of BDs was returned.
- * - XST_INVALID_PARAM if Direction did not specify a valid channel.
- * - XST_FAILURE if there were not enough free BDs to satisfy the request.
- *
- * @note
- * This function is not thread-safe. The user must provide mutually exclusive
- * access to this function if there are to be multiple threads that can call it.
- *
- ******************************************************************************/
-int XTemac_SgUnAlloc(XTemac *InstancePtr, u32 Direction,
-		     unsigned NumBd, XDmaBdV3 * BdPtr)
-{
-	int Status;
-	XDmaV3 *DmaPtr;
-	u32 DgieReg;
-
-	XASSERT_NONVOID(InstancePtr != NULL);
-	XASSERT_NONVOID(BdPtr != NULL);
-	XASSERT_NONVOID(InstancePtr->IsReady == XCOMPONENT_IS_READY);
-
-	/* Which channel to address */
-	if (Direction == XTE_RECV) {
-		DmaPtr = &InstancePtr->RecvDma;
-	}
-	else if (Direction == XTE_SEND) {
-		DmaPtr = &InstancePtr->SendDma;
-	}
-	else {
-		return (XST_INVALID_PARAM);
-	}
-
-	/* XDmaV3_SgBdAlloc() will return either XST_SUCCESS or XST_FAILURE
-	 * This is a critical section, prevent interrupts from the device while
-	 * the BD ring is being modified.
-	 */
-	DgieReg = XTemac_mGetIpifReg(XTE_DGIE_OFFSET);
-	XTemac_mSetIpifReg(XTE_DGIE_OFFSET, 0);
-	Status = XDmaV3_SgBdUnAlloc(DmaPtr, NumBd, BdPtr);
-	XTemac_mSetIpifReg(XTE_DGIE_OFFSET, DgieReg);
-	return (Status);
-}
-
-/*****************************************************************************/
-/**
- * Commit a set of BDs to the SGDMA engine that had been allocated by
- * XTemac_SgAlloc() and prepared by the user to describe SGDMA transaction(s).
- *
- * This function and XTemac_SgAlloc() must be called in the correct order. See
- * xtemac.h for more information on the SGDMA use model.
- *
- * Upon return, the committed BDs go under hardware control. Do not modify BDs
- * after they have been committed. Doing so may cause data corruption and system
- * instability.
- *
- * This function may be called if the TEMAC device is started or stopped. If
- * started (see XTemac_Start()), then the BDs may be processed by HW at any
- * time.
- *
- * This function is non-blocking.  Notification of error or successful
- * transmission/reception is done asynchronously through callback functions.
- *
- * For transmit (XTE_SEND):
- *
- * It is assumed that the upper layer software supplies a correctly formatted
- * Ethernet frame, including the destination and source addresses, the
- * type/length field, and the data field.
- *
- * For receive (XTE_RECV):
- *
- * It is assumed that BDs have an appropriately sized frame buffer attached
- * that corresponds to the network MTU.
- *
- * @param InstancePtr is a pointer to the instance to be worked on.
- * @param Direction is the channel to address (XTE_SEND or XTE_RECV).
- * @param NumBd is the number of BDs to commit. This is typically the same
- *        value used when the BDs were allocated with XTemac_SgAlloc().
- * @param BdPtr is the first BD in the set to commit and is typically the
- *        same value returned by XTemac_SgAlloc().
- *
- * @return
- * - XST_SUCCESS if the requested number of BDs was returned.
- * - XST_INVALID_PARAM if Direction did not specify a valid channel.
- * - XST_FAILURE if the last BD in the set does not have its "last" bit
- *   set (see XDmaBdV3_mSetLast()).
- * - XST_DMA_SG_LIST_ERROR if BdPtr parameter does not reflect the correct
- *   insertion point within the internally maintained BD ring. This error occurs
- *   when this function and XTemac_SgAlloc() are called out of order.
- *
- * @note
- * This function is not thread-safe. The user must provide mutually exclusive
- * access to this function if there are to be multiple threads that can call it.
- *
- ******************************************************************************/
-int XTemac_SgCommit(XTemac *InstancePtr, u32 Direction,
-		    unsigned NumBd, XDmaBdV3 * BdPtr)
-{
-	int Status;
-	XDmaV3 *DmaPtr;
-	u32 DgieReg;
-
-	XASSERT_NONVOID(InstancePtr != NULL);
-	XASSERT_NONVOID(InstancePtr->IsReady == XCOMPONENT_IS_READY);
-
-	/* Which channel to address */
-	if (Direction == XTE_RECV) {
-		DmaPtr = &InstancePtr->RecvDma;
-	}
-	else if (Direction == XTE_SEND) {
-		DmaPtr = &InstancePtr->SendDma;
-	}
-	else {
-		return (XST_INVALID_PARAM);
-	}
-
-	/* XDmaV3_SgToHw() will return either XST_SUCCESS, XST_FAILURE, or
-	 * XST_DMA_SG_LIST_ERROR
-	 *
-	 * This is a critical section, prevent interrupts from the device while
-	 * the BD ring is being modified.
-	 */
-	DgieReg = XTemac_mGetIpifReg(XTE_DGIE_OFFSET);
-	XTemac_mSetIpifReg(XTE_DGIE_OFFSET, 0);
-	Status = XDmaV3_SgBdToHw(DmaPtr, NumBd, BdPtr);
-	XTemac_mSetIpifReg(XTE_DGIE_OFFSET, DgieReg);
-	return (Status);
-}
-
-
-/*****************************************************************************/
-/**
- * Retrieve BDs that have been processed by the SGDMA channel. This function is
- * called typically after the XTE_HANDLER_SGRECV handler has been invoked for
- * the receive channel or XTE_HANDLER_SGSEND for the transmit channel.
- *
- * The set of BDs returned is a list starting with the BdPtr and extending
- * for 1 or more BDs (the exact number is the return value of this function).
- * The list can be navigated with macros XTemac_mSgRecvBdNext() for the
- * XTE_RECV channel, and XTemac_mSgSendBdNext() for the XTE_SEND channel.
- * Treat the returned BDs as read-only.
- *
- * This function and XTemac_SgFree() must be called in the correct order. See
- * xtemac.h for more information on the SGDMA use model.
- *
- * The last BD in the returned list is guaranteed to have the "Last" bit set
- * (i.e. XDmaBdV3_IsLast evaluates to true).
- *
- * The returned BDs can be examined for the outcome of the SGDMA transaction.
- *
- * @param InstancePtr is a pointer to the instance to be worked on.
- * @param Direction is the channel to address (XTE_SEND or XTE_RECV).
- * @param BdPtr is an output parameter that points to the 1st BD in the returned
- *        list. If no BDs were ready, then this parameter is unchanged.
- * @param NumBd is an upper limit to the number of BDs to retrieve.
- *
- * @return
- * Number of BDs that are ready for post processing. If the direction parameter
- * is invalid, then 0 is returned.
- *
- * @note
- * This function is not thread-safe. The user must provide mutually exclusive
- * access to this function if there are to be multiple threads that can call it.
- *
- ******************************************************************************/
-unsigned XTemac_SgGetProcessed(XTemac *InstancePtr, u32 Direction,
-			       unsigned NumBd, XDmaBdV3 ** BdPtr)
-{
-	u32 DgieReg;
-	XDmaV3 *DmaPtr;
-	unsigned Rc;
-
-	XASSERT_NONVOID(InstancePtr != NULL);
-	XASSERT_NONVOID(BdPtr != NULL);
-	XASSERT_NONVOID(InstancePtr->IsReady == XCOMPONENT_IS_READY);
-
-	/* Which channel to address */
-	if (Direction == XTE_RECV) {
-		DmaPtr = &InstancePtr->RecvDma;
-	}
-	else if (Direction == XTE_SEND) {
-		DmaPtr = &InstancePtr->SendDma;
-	}
-	else {
-		return (0);
-	}
-
-	/* This is a critical section. Prevent interrupts from the device while
-	 * the BD ring is being modified.
-	 */
-	DgieReg = XTemac_mGetIpifReg(XTE_DGIE_OFFSET);
-	XTemac_mSetIpifReg(XTE_DGIE_OFFSET, 0);
-
-	/* Extract ready BDs */
-	Rc = XDmaV3_SgBdFromHw(DmaPtr, NumBd, BdPtr);
-
-	/* End critical section */
-	XTemac_mSetIpifReg(XTE_DGIE_OFFSET, DgieReg);
-
-	return (Rc);
-}
-
-
-/*****************************************************************************/
-/**
- * Free a set of BDs that had been retrieved by XTemac_SgGetProcessed(). If BDs
- * are not freed, then eventually the channel will run out of BDs to
- * XTemac_SgAlloc().
- *
- * This function and XTemac_SgGetProcessed() must be called in the correct
- * order. See xtemac.h for more information on the SGDMA use model.
- *
- * @param InstancePtr is a pointer to the instance to be worked on.
- * @param Direction is the channel to address (XTE_SEND or XTE_RECV).
- * @param BdPtr is the first BD in the set to free. This is typically the same
- *        value returned by XTemac_SgGetProcessed().
- * @param NumBd is the number of BDs to free. This is typically the same value
- *        returned by XTemac_SgGetProcessed().
- *
- * @return
- * - XST_SUCCESS if the requested number of BDs was returned.
- * - XST_INVALID_PARAM if Direction did not specify a valid channel.
- * - XST_DMA_SG_LIST_ERROR if BdPtr parameter does not reflect the correct
- *   insertion point within the internally maintained BD ring. This error occurs
- *   when this function and XTemac_SgGetProcessed() are called out of order.
- *
- * @note
- * This function is not thread-safe. The user must provide mutually exclusive
- * access to this function if there are to be multiple threads that can call it.
- *
- ******************************************************************************/
-int XTemac_SgFree(XTemac *InstancePtr, u32 Direction,
-		  unsigned NumBd, XDmaBdV3 * BdPtr)
-{
-	u32 DgieReg;
-	XDmaV3 *DmaPtr;
-	int Status;
-
-	XASSERT_NONVOID(InstancePtr != NULL);
-	XASSERT_NONVOID(InstancePtr->IsReady == XCOMPONENT_IS_READY);
-
-	/* Which channel to address */
-	if (Direction == XTE_RECV) {
-		DmaPtr = &InstancePtr->RecvDma;
-	}
-	else if (Direction == XTE_SEND) {
-		DmaPtr = &InstancePtr->SendDma;
-	}
-	else {
-		return (XST_INVALID_PARAM);
-	}
-
-	/* This is a critical section. Prevent interrupts from the device while
-	 * the BD ring is being modified.
-	 */
-	DgieReg = XTemac_mGetIpifReg(XTE_DGIE_OFFSET);
-	XTemac_mSetIpifReg(XTE_DGIE_OFFSET, 0);
-	Status = XDmaV3_SgBdFree(DmaPtr, NumBd, BdPtr);
-	XTemac_mSetIpifReg(XTE_DGIE_OFFSET, DgieReg);
-
-	return (Status);
-}
-
-
-/*****************************************************************************/
-/**
- * Give the driver memory space to be used for the scatter-gather DMA
- * descriptor list. This function should only be called once for each channel
- * during initialization. If a list had already been created, then it is
- * destroyed and replaced with a new one.
- *
- * To increase performance, a BdTemplate parameter is provided to allow the
- * user to permanently set BD fields in all BDs for this SGDMA channel. For
- * example, if every BD describes a buffer that will contain a full packet (as
- * it typically does with receive channels), then XDmaBdV3_mSetLast(BdTemplate)
- * can be performed prior to calling this function and when it returns every BD
- * will have the "last" bit set in it's DMACR word. The user will never have to
- * explicitly set the "last" bit again.
- *
- * The following operations can be replicated for the BdTemplate:
- *   - XDmaBdV3_mSetId()
- *   - XDmaBdV3_mSetLast()
- *   - XDmaBdV3_mClearLast()
- *   - XDmaBdV3_mSetBufIncrement()
- *   - XDmaBdV3_mSetBufNoIncrement()
- *   - XDmaBdV3_mSetDevSel()
- *   - XDmaBdV3_mSetBdPage()
- *   - XDmaBdV3_mSetTransferType()
- *   - XDmaBdV3_mSetBufAddrHigh()
- *   - XDmaBdV3_mSetBufAddrLow()
- *   - XTemac_mSgSendBdCsumEnable()  -- transmit channel only
- *   - XTemac_mSgSendBdCsumDisable() -- transmit channel only
- *   - XTemac_mSgSendBdCsumSetup()   -- transmit channel only
- *   - XTemac_mSgSendBdCsumSeed()    -- transmit channel only
- *
- * The base address of the memory space must be aligned according to buffer
- * descriptor requirements (see xtemac.h).
- *
- * The size of the memory space is assumed to be big enough to contain BdCount
- * buffers at the given alignment. If the region is too small, then adjacent
- * data may be overwritten causing system instability. There are tools in the
- * DMA driver that help calculate the sizing requirments. See macros
- * XDmaV3_mSgListCntCalc() and XDmaV3_mSgListMemCalc().
- *
- * @param InstancePtr is a pointer to the instance to be worked on.
- * @param Direction is the channel to address.
- * @param PhysicalAddr is the physical base address of user memory region.
- * @param VirtualAddr is the virtual base address of the user memory region. If
- *        address translation is not being utilized, then VirtAddr should be
- *        equivalent to PhysAddr.
- * @param Alignment governs the byte alignment of individual BDs. This function
- *        will enforce a minimum alignment of 8 bytes with no maximum as long as
- *        it is specified as a power of 2.
- * @param BdCount is the number of BDs to allocate in the memory region. It is
- *        assumed the region is large enough to contain all the BDs.
- * @param BdTemplate is copied to each BD after the list is created. If the user
- *        does not have a need to replicate any BD fields then this parameter
- *        should be zeroed (XDmaBdV3_mClear()). This parameter will be modified
- *        by this function.
- *
- * @return
- * - XST_SUCCESS if the space was initialized successfully
- * - XST_DEVICE_IS_STARTED if the device has not been stopped.
- * - XST_NOT_SGDMA if the MAC is not configured for scatter-gather DMA per
- *   the configuration information contained in XTemac_Config.
- * - XST_INVALID_PARAM if: 1) Direction is not either XTE_SEND or XTE_RECV;
- *   2) PhysicalAddr and/or VirtualAddr are not aligned to the given
- *   alignment parameter; 3) Alignment parameter does not meet minimum
- *   requirements of this device; 3) BdCount is 0.
- * - XST_DMA_SG_LIST_ERROR if the memory segment containing the list spans
- *   over address 0x00000000 in virtual address space.
- * - XST_NO_FEATURE if the DMA sub-driver discovers that the HW is not SGDMA
- *   capable.
- * - XST_FAILURE for other failures that shouldn't occur. If this is returned,
- *   then the driver is experiencing a problem that should be reported to
- *   Xilinx.
- *
- * @note
- * If the device is configured for scatter-gather DMA, this function must be
- * called AFTER the XTemac_Initialize() function because the DMA channel
- * components must be initialized before the memory space is set.
- *
- ******************************************************************************/
-int XTemac_SgSetSpace(XTemac *InstancePtr, u32 Direction,
-		      u32 PhysicalAddr, u32 VirtualAddr,
-		      u32 Alignment, unsigned BdCount, XDmaBdV3 * BdTemplate)
-{
-	int Status;
-
-	XASSERT_NONVOID(InstancePtr != NULL);
-	XASSERT_NONVOID(BdTemplate != NULL);
-	XASSERT_NONVOID(InstancePtr->IsReady == XCOMPONENT_IS_READY);
-
-	/* Make sure device is ready for this operation */
-	if (InstancePtr->IsStarted == XCOMPONENT_IS_STARTED) {
-		return (XST_DEVICE_IS_STARTED);
-	}
-
-	/* Must have sgdma */
-	if (!XTemac_mIsSgDma(InstancePtr)) {
-		return (XST_NOT_SGDMA);
-	}
-
-	/* Check alignment */
-	if (Alignment < XTE_PLB_BD_ALIGNMENT) {
-		return (XST_INVALID_PARAM);
-	}
-
-	if (Direction == XTE_SEND) {
-		/* Create the list. This function will return one of XST_SUCCESS,
-		 * XST_INVALID_PARAM (for alignment violations), or
-		 * XST_DMA_SG_LIST_ERROR (if memory segment spans address 0)
-		 */
-		Status = XDmaV3_SgListCreate(&InstancePtr->SendDma,
-					     PhysicalAddr, VirtualAddr,
-					     Alignment, BdCount);
-		if (Status != XST_SUCCESS) {
-			return (Status);
-		}
-
-		/* Clone the template BD. This should always work. If it does not
-		 * then something is seriously wrong
-		 */
-		Status = XDmaV3_SgListClone(&InstancePtr->SendDma, BdTemplate);
-		if (Status != XST_SUCCESS) {
-			return (XST_FAILURE);
-		}
-		else {
-			return (XST_SUCCESS);
-		}
-	}
-	else if (Direction == XTE_RECV) {
-		/* Create the list. This function will return one of XST_SUCCESS,
-		 * XST_INVALID_PARAM (for alignment violations), or
-		 * XST_DMA_SG_LIST_ERROR (if memory segment spans address 0)
-		 */
-		Status = XDmaV3_SgListCreate(&InstancePtr->RecvDma,
-					     PhysicalAddr, VirtualAddr,
-					     Alignment, BdCount);
-		if (Status != XST_SUCCESS) {
-			return (Status);
-		}
-
-		/* Clone the template BD */
-		Status = XDmaV3_SgListClone(&InstancePtr->RecvDma, BdTemplate);
-		if (Status != XST_SUCCESS) {
-			return (XST_FAILURE);
-		}
-		else {
-			return (XST_SUCCESS);
-		}
-	}
-
-	/* Direction is incorrect */
-	return (XST_INVALID_PARAM);
-}
-
-
-/*****************************************************************************/
-/**
- * Verify the consistency of the SGDMA BD ring. While the check occurs, the
- * device is stopped. If any problems are found the device is left stopped.
- *
- * Use this function to troubleshoot SGDMA problems.
- *
- * @param InstancePtr is a pointer to the instance to be worked on.
- * @param Direction is the channel to check (XTE_SEND or XTE_RECV)
- *
- * @return
- * - XST_SUCCESS if no problems are found.
- * - XST_INVALID_PARAM if Direction is not XTE_SEND or XTE_RECV.
- * - XST_DMA_SG_NO_LIST if the SG list has not yet been setup.
- * - XST_DMA_BD_ERROR if a BD has been corrupted.
- * - XST_DMA_SG_LIST_ERROR if the internal data structures of the BD ring are
- *   inconsistent.
- *
- * @note
- * This function is not thread-safe. The user must provide mutually exclusive
- * access to this function if there are to be multiple threads that can call it.
- *
- ******************************************************************************/
-int XTemac_SgCheck(XTemac *InstancePtr, u32 Direction)
-{
-	XDmaV3 *DmaPtr;
-	XDmaBdV3 *BdPtr;
-	unsigned i;
-	int Restart = 0;
-	int Rc;
-
-	XASSERT_NONVOID(InstancePtr != NULL);
-
-	/* Select channel to check */
-	if (Direction == XTE_SEND) {
-		DmaPtr = &InstancePtr->SendDma;
-	}
-	else if (Direction == XTE_RECV) {
-		DmaPtr = &InstancePtr->RecvDma;
-	}
-	else {
-		return (XST_INVALID_PARAM);
-	}
-
-	/* Stop the device if it is running */
-	if (InstancePtr->IsStarted == XST_DEVICE_IS_STARTED) {
-		XTemac_Stop(InstancePtr);
-		Restart = 1;
-	}
-
-	/* Perform check of ring structure using DMA driver routine */
-	Rc = XDmaV3_SgCheck(DmaPtr);
-
-	/* Check BDs for consistency as used by TEMAC */
-	if (Rc == XST_SUCCESS) {
-		/* Verify DMACR is setup for Tx direction */
-		if (Direction == XTE_SEND) {
-			BdPtr = (XDmaBdV3 *) DmaPtr->BdRing.BaseAddr;
-			for (i = 0; i < DmaPtr->BdRing.AllCnt; i++) {
-				if (XDmaV3_mReadBd(BdPtr, XDMAV3_DMACR_OFFSET) &
-				    XDMAV3_DMACR_DIR_RX_MASK) {
-					return (XST_DMA_BD_ERROR);
-				}
-			}
-		}
-		else {		/* XTE_RECV */
-
-			BdPtr = (XDmaBdV3 *) DmaPtr->BdRing.BaseAddr;
-			for (i = 0; i < DmaPtr->BdRing.AllCnt; i++) {
-				if (!
-				    (XDmaV3_mReadBd(BdPtr, XDMAV3_DMACR_OFFSET)
-				     & XDMAV3_DMACR_DIR_RX_MASK)) {
-					return (XST_DMA_BD_ERROR);
-				}
-			}
-		}
-	}
-
-	/* Restart the device if it was stopped by this function */
-	if ((Rc == XST_SUCCESS) && Restart) {
-		XTemac_Start(InstancePtr);
-	}
-
-	return (Rc);
-}
diff --git a/drivers/net/ethernet/xilinx/xilinx_temac/xtemac_stats.c b/drivers/net/ethernet/xilinx/xilinx_temac/xtemac_stats.c
deleted file mode 100644
index 840ea3d..0000000
--- a/drivers/net/ethernet/xilinx/xilinx_temac/xtemac_stats.c
+++ /dev/null
@@ -1,100 +0,0 @@
-/* $Id: */
-/******************************************************************************
-*
-*       XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS"
-*       AS A COURTESY TO YOU, SOLELY FOR USE IN DEVELOPING PROGRAMS AND
-*       SOLUTIONS FOR XILINX DEVICES.  BY PROVIDING THIS DESIGN, CODE,
-*       OR INFORMATION AS ONE POSSIBLE IMPLEMENTATION OF THIS FEATURE,
-*       APPLICATION OR STANDARD, XILINX IS MAKING NO REPRESENTATION
-*       THAT THIS IMPLEMENTATION IS FREE FROM ANY CLAIMS OF INFRINGEMENT,
-*       AND YOU ARE RESPONSIBLE FOR OBTAINING ANY RIGHTS YOU MAY REQUIRE
-*       FOR YOUR IMPLEMENTATION.  XILINX EXPRESSLY DISCLAIMS ANY
-*       WARRANTY WHATSOEVER WITH RESPECT TO THE ADEQUACY OF THE
-*       IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OR
-*       REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE FROM CLAIMS OF
-*       INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
-*       FOR A PARTICULAR PURPOSE.
-*
-*       (c) Copyright 2005-2006 Xilinx Inc.
-*       All rights reserved.
-* This program is free software; you can redistribute it and/or modify it
-* under the terms of the GNU General Public License as published by the
-* Free Software Foundation; either version 2 of the License, or (at your
-* option) any later version.
-*
-* You should have received a copy of the GNU General Public License
-* along with this program; if not, write to the Free Software
-* Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-*
-******************************************************************************/
-/*****************************************************************************/
-/**
-*
-* @file xtemac_stats.c
-*
-* Functions in this file implement statistics related functionality.
-* See xtemac.h for a detailed description of the driver.
-*
-* <pre>
-* MODIFICATION HISTORY:
-*
-* Ver   Who  Date     Changes
-* ----- ---- -------- -------------------------------------------------------
-* 1.00a rmm  06/01/05 First release
-* 2.00a rmm  11/21/05 Changed copyright
-* </pre>
-******************************************************************************/
-
-/***************************** Include Files *********************************/
-
-#include <linux/string.h>
-
-#include "xtemac.h"
-
-/************************** Constant Definitions *****************************/
-
-
-/**************************** Type Definitions *******************************/
-
-
-/***************** Macros (Inline Functions) Definitions *********************/
-
-
-/************************** Function Prototypes ******************************/
-
-
-/************************** Variable Definitions *****************************/
-
-
-/*****************************************************************************/
-/**
-* Get a current copy of the software maintained statistics. See
-* XTemac_SoftStats structure for information on what counters are maintained.
-*
-* @param InstancePtr is a pointer to the instance to be worked on.
-* @param StatsPtr is an output parameter, and is a pointer to a stats buffer
-*        into which the current statistics will be copied.
-*
-******************************************************************************/
-void XTemac_GetSoftStats(XTemac *InstancePtr, XTemac_SoftStats *StatsPtr)
-{
-	XASSERT_VOID(InstancePtr != NULL);
-	XASSERT_VOID(StatsPtr != NULL);
-
-	memcpy(StatsPtr, &InstancePtr->Stats, sizeof(XTemac_SoftStats));
-}
-
-
-/*****************************************************************************/
-/**
-* Zero out the software maintained statistics counters.
-*
-* @param InstancePtr is a pointer to the instance to be worked on.
-*
-******************************************************************************/
-void XTemac_ClearSoftStats(XTemac *InstancePtr)
-{
-	XASSERT_VOID(InstancePtr != NULL);
-
-	memset(&InstancePtr->Stats, 0, sizeof(XTemac_SoftStats));
-}
-- 
1.7.1

