From 41ed08a064ee78d7e0b006dc8da3fd76ef203ef5 Mon Sep 17 00:00:00 2001
From: Michal Simek <monstr@monstr.eu>
Date: Mon, 8 Oct 2012 12:52:55 +0200
Subject: [PATCH] block: Remove ancient sysace driver

Use only mainline version.

Signed-off-by: Michal Simek <monstr@monstr.eu>
---
 drivers/block/Makefile                             |    1 -
 drivers/block/xilinx_sysace/Makefile               |   14 -
 drivers/block/xilinx_sysace/xsysace.c              |  354 ---------
 drivers/block/xilinx_sysace/xsysace.h              |  371 ---------
 drivers/block/xilinx_sysace/xsysace_compactflash.c |  808 --------------------
 drivers/block/xilinx_sysace/xsysace_g.c            |   75 --
 drivers/block/xilinx_sysace/xsysace_intr.c         |  424 ----------
 drivers/block/xilinx_sysace/xsysace_jtagcfg.c      |  456 -----------
 drivers/block/xilinx_sysace/xsysace_l.c            |  582 --------------
 drivers/block/xilinx_sysace/xsysace_l.h            |  523 -------------
 drivers/block/xilinx_sysace/xsysace_linux.c        |  617 ---------------
 drivers/block/xilinx_sysace/xsysace_selftest.c     |  155 ----
 drivers/block/xilinx_sysace/xsysace_sinit.c        |  146 ----
 13 files changed, 0 insertions(+), 4526 deletions(-)
 delete mode 100644 drivers/block/xilinx_sysace/Makefile
 delete mode 100644 drivers/block/xilinx_sysace/xsysace.c
 delete mode 100644 drivers/block/xilinx_sysace/xsysace.h
 delete mode 100644 drivers/block/xilinx_sysace/xsysace_compactflash.c
 delete mode 100644 drivers/block/xilinx_sysace/xsysace_g.c
 delete mode 100644 drivers/block/xilinx_sysace/xsysace_intr.c
 delete mode 100644 drivers/block/xilinx_sysace/xsysace_jtagcfg.c
 delete mode 100644 drivers/block/xilinx_sysace/xsysace_l.c
 delete mode 100644 drivers/block/xilinx_sysace/xsysace_l.h
 delete mode 100644 drivers/block/xilinx_sysace/xsysace_linux.c
 delete mode 100644 drivers/block/xilinx_sysace/xsysace_selftest.c
 delete mode 100644 drivers/block/xilinx_sysace/xsysace_sinit.c

diff --git a/drivers/block/Makefile b/drivers/block/Makefile
index b20c87f..5b79505 100644
--- a/drivers/block/Makefile
+++ b/drivers/block/Makefile
@@ -34,7 +34,6 @@ obj-$(CONFIG_VIRTIO_BLK)	+= virtio_blk.o
 obj-$(CONFIG_VIODASD)		+= viodasd.o
 obj-$(CONFIG_BLK_DEV_SX8)	+= sx8.o
 obj-$(CONFIG_BLK_DEV_UB)	+= ub.o
-obj-$(CONFIG_XILINX_SYSACE_OLD)	+= xilinx_sysace/
 obj-$(CONFIG_BLK_DEV_HD)	+= hd.o
 
 obj-$(CONFIG_XEN_BLKDEV_FRONTEND)	+= xen-blkfront.o
diff --git a/drivers/block/xilinx_sysace/Makefile b/drivers/block/xilinx_sysace/Makefile
deleted file mode 100644
index 8b8e78a..0000000
--- a/drivers/block/xilinx_sysace/Makefile
+++ /dev/null
@@ -1,14 +0,0 @@
-#
-# Makefile for the Xilinx System ACE driver
-#
-
-EXTRA_CFLAGS		+= -Idrivers/xilinx_common -Iarch/ppc/platforms/4xx/xparameters
-
-# The Linux Version for the Xilinx driver code.
-xilinx_sysace-objs	+= xsysace_linux.o
-
-# The Xilinx OS independent code.
-xilinx_sysace-objs	+= xsysace.o xsysace_intr.o xsysace_l.o
-xilinx_sysace-objs	+= xsysace_compactflash.o xsysace_jtagcfg.o
-
-obj-$(CONFIG_XILINX_SYSACE_OLD) += xilinx_sysace.o
diff --git a/drivers/block/xilinx_sysace/xsysace.c b/drivers/block/xilinx_sysace/xsysace.c
deleted file mode 100644
index 4842887..0000000
--- a/drivers/block/xilinx_sysace/xsysace.c
+++ /dev/null
@@ -1,354 +0,0 @@
-/* $Id: xsysace.c,v 1.1 2006/02/17 21:52:36 moleres Exp $ */
-/******************************************************************************
-*
-*       XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS"
-*       AS A COURTESY TO YOU, SOLELY FOR USE IN DEVELOPING PROGRAMS AND
-*       SOLUTIONS FOR XILINX DEVICES.  BY PROVIDING THIS DESIGN, CODE,
-*       OR INFORMATION AS ONE POSSIBLE IMPLEMENTATION OF THIS FEATURE,
-*       APPLICATION OR STANDARD, XILINX IS MAKING NO REPRESENTATION
-*       THAT THIS IMPLEMENTATION IS FREE FROM ANY CLAIMS OF INFRINGEMENT,
-*       AND YOU ARE RESPONSIBLE FOR OBTAINING ANY RIGHTS YOU MAY REQUIRE
-*       FOR YOUR IMPLEMENTATION.  XILINX EXPRESSLY DISCLAIMS ANY
-*       WARRANTY WHATSOEVER WITH RESPECT TO THE ADEQUACY OF THE
-*       IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OR
-*       REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE FROM CLAIMS OF
-*       INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
-*       FOR A PARTICULAR PURPOSE.
-*
-*       (c) Copyright 2002-2005 Xilinx Inc.
-*       All rights reserved.
-* This program is free software; you can redistribute it and/or modify it
-* under the terms of the GNU General Public License as published by the
-* Free Software Foundation; either version 2 of the License, or (at your
-* option) any later version.
-*
-* You should have received a copy of the GNU General Public License
-* along with this program; if not, write to the Free Software
-* Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-*
-******************************************************************************/
-/*****************************************************************************/
-/**
-*
-* @file xsysace.c
-*
-* The Xilinx System ACE driver component. This driver supports the Xilinx
-* System Advanced Configuration Environment (ACE) controller. It currently
-* supports only the CompactFlash solution. See xsysace.h for a detailed
-* description of the driver.
-*
-* <pre>
-* MODIFICATION HISTORY:
-*
-* Ver   Who  Date     Changes
-* ----- ---- -------- -----------------------------------------------
-* 1.00a rpm  06/17/02 work in progress
-* 1.00a rmm  05/14/03 Fixed diab compiler warnings relating to asserts
-* 1.01a jvb  12/13/05 I changed Initialize() into CfgInitialize(), and made
-*                     CfgInitialize() take a pointer to a config structure
-*                     instead of a device id. I moved Initialize() into
-*                     xgpio_sinit.c, and had Initialize() call CfgInitialize()
-*                     after it retrieved the config structure using the device
-*                     id. I removed include of xparameters.h along with any
-*                     dependencies on xparameters.h and the _g.c config table.
-*                     The dependency on XPAR_XSYSACE_MEM_WIDTH still remains.
-*
-* </pre>
-*
-******************************************************************************/
-
-/***************************** Include Files *********************************/
-
-#include "xsysace.h"
-#include "xsysace_l.h"
-
-/************************** Constant Definitions *****************************/
-
-
-/**************************** Type Definitions *******************************/
-
-
-/***************** Macros (Inline Functions) Definitions *********************/
-
-
-/************************** Function Prototypes ******************************/
-
-static void StubEventHandler(void *CallBackRef, int Event);
-
-/************************** Variable Definitions *****************************/
-
-
-/*****************************************************************************/
-/**
-*
-* Initialize a specific XSysAce instance. The configuration information is
-* passed in as an argument and the driver instance data is initialized
-* appropriately.
-*
-* @param InstancePtr is a pointer to the XSysAce instance to be worked on.
-* @param Config is a reference to a structure containing information about a
-*        specific SysAce device. This function initializes an InstancePtr object
-*        for a specific device specified by the contents of Config. This function
-*        can initialize multiple instance objects with the use of multiple calls
-*        giving different Config information on each call.
-* @param EffectiveAddr is the device base address in the virtual memory address
-*        space. The caller is responsible for keeping the address mapping
-*        from EffectiveAddr to the device physical base address unchanged
-*        once this function is invoked. Unexpected errors may occur if the
-*        address mapping changes after this function is called. If address
-*        translation is not used, use Config->BaseAddress for this parameters,
-*        passing the physical address instead.
-*
-* @return
-*
-* XST_SUCCESS if successful.
-*
-* @note
-*
-* We do not want to reset the configuration controller here since this could
-* cause a reconfiguration of the JTAG target chain, depending on how the
-* CFGMODEPIN of the device is wired.
-* <br><br>
-* The Config pointer argument is not used by this function, but is provided
-* to keep the function signature consistent with other drivers.
-*
-******************************************************************************/
-int XSysAce_CfgInitialize(XSysAce * InstancePtr, XSysAce_Config * Config,
-			  u32 EffectiveAddr)
-{
-	XASSERT_NONVOID(InstancePtr != NULL);
-
-	InstancePtr->IsReady = 0;
-
-	/*
-	 * Set some default values for the instance data
-	 */
-	InstancePtr->BaseAddress = EffectiveAddr;
-	InstancePtr->EventHandler = StubEventHandler;
-	InstancePtr->NumRequested = 0;
-	InstancePtr->NumRemaining = 0;
-	InstancePtr->BufferPtr = NULL;
-
-	/*
-	 * Put the device into 16-bit mode or 8-bit mode depending on compile-time
-	 * parameter
-	 */
-#if (XPAR_XSYSACE_MEM_WIDTH == 16)
-	XSysAce_RegWrite16(InstancePtr->BaseAddress + XSA_BMR_OFFSET,
-			   XSA_BMR_16BIT_MASK);
-#else
-	XSysAce_RegWrite16(InstancePtr->BaseAddress + XSA_BMR_OFFSET, 0);
-#endif
-
-	/*
-	 * Disable interrupts. Interrupts must be enabled by the user using
-	 * XSysAce_EnableInterrupt(). Put the interrupt request line in reset and
-	 * clear the interrupt enable bits.
-	 */
-	XSysAce_mOrControlReg(InstancePtr->BaseAddress, XSA_CR_RESETIRQ_MASK);
-	XSysAce_mAndControlReg(InstancePtr->BaseAddress,
-			       ~(XSA_CR_DATARDYIRQ_MASK | XSA_CR_ERRORIRQ_MASK |
-				 XSA_CR_CFGDONEIRQ_MASK));
-
-	/*
-	 * Indicate the instance is now ready to use, initialized without error
-	 */
-	InstancePtr->IsReady = XCOMPONENT_IS_READY;
-
-	return XST_SUCCESS;
-}
-
-/*****************************************************************************/
-/**
-*
-* Attempt to lock access to the CompactFlash. The CompactFlash may be accessed
-* by the MPU port as well as the JTAG configuration port within the System ACE
-* device. This function requests exclusive access to the CompactFlash for the
-* MPU port. This is a non-blocking request. If access cannot be locked
-* (because the configuration controller has the lock), an appropriate status is
-* returned. In this case, the user should call this function again until
-* successful.
-*
-* If the user requests a forced lock, the JTAG configuration controller will
-* be put into a reset state in case it currently has a lock on the CompactFlash.
-* This effectively aborts any operation the configuration controller had in
-* progress and makes the configuration controller restart its process the
-* next time it is able to get a lock.
-*
-* A lock must be granted to the user before attempting to read or write the
-* CompactFlash device.
-*
-* @param InstancePtr is a pointer to the XSysAce instance to be worked on.
-* @param Force is a boolean value that, when set to TRUE, will force the MPU
-*        lock to occur in the System ACE.  When set to FALSE, the lock is
-*        requested and the device arbitrates between the MPU request and
-*        JTAG requests. Forcing the MPU lock resets the configuration
-*        controller, thus aborting any configuration operations in progress.
-*
-* @return
-*
-* XST_SUCCESS if the lock was granted, or XST_DEVICE_BUSY if the lock was
-* not granted because the configuration controller currently has access to
-* the CompactFlash.
-*
-* @note
-*
-* If the lock is not granted to the MPU immediately, this function removes its
-* request for a lock so that a lock is not later granted at a time when the
-* application is (a) not ready for the lock, or (b) cannot be informed
-* asynchronously about the granted lock since there is no such interrupt event.
-*
-******************************************************************************/
-int XSysAce_Lock(XSysAce * InstancePtr, u32 Force)
-{
-	u32 IsLocked;
-
-	XASSERT_NONVOID(InstancePtr != NULL);
-	XASSERT_NONVOID(InstancePtr->IsReady == XCOMPONENT_IS_READY);
-
-	/*
-	 * Check to see if the configuration controller currently has the lock
-	 */
-	IsLocked = (XSysAce_mGetStatusReg(InstancePtr->BaseAddress) &
-		    XSA_SR_CFGLOCK_MASK);
-
-	if (Force) {
-		/*
-		 * Reset the configuration controller if it has the lock. Per ASIC
-		 * designer, this eliminates a potential deadlock if the FORCELOCK and
-		 * LOCKREQ bits are both set and the RDYFORCFCMD is not set.
-		 */
-		if (IsLocked) {
-			/* Reset the configuration controller */
-			XSysAce_mOrControlReg(InstancePtr->BaseAddress,
-					      XSA_CR_CFGRESET_MASK);
-		}
-
-		/* Force the MPU lock. The lock will occur immediately. */
-		XSysAce_mOrControlReg(InstancePtr->BaseAddress,
-				      XSA_CR_LOCKREQ_MASK |
-				      XSA_CR_FORCELOCK_MASK);
-	}
-	else {
-		/*
-		 * Check to see if the configuration controller has the lock. If so,
-		 * return a busy status.
-		 */
-		if (IsLocked) {
-			return XST_DEVICE_BUSY;
-		}
-
-		/* Request the lock, but do not force it */
-		XSysAce_mOrControlReg(InstancePtr->BaseAddress,
-				      XSA_CR_LOCKREQ_MASK);
-	}
-
-	/*
-	 * See if the lock was granted. Note that it is guaranteed to occur if
-	 * the user forced it.
-	 */
-	if (!XSysAce_mIsMpuLocked(InstancePtr->BaseAddress)) {
-		/* Lock was not granted, so remove request and return a busy */
-		XSysAce_mAndControlReg(InstancePtr->BaseAddress,
-				       ~(XSA_CR_LOCKREQ_MASK |
-					 XSA_CR_FORCELOCK_MASK));
-
-		return XST_DEVICE_BUSY;
-	}
-
-	/*
-	 * Lock has been granted.
-	 *
-	 * If the configuration controller had the lock and has been reset,
-	 * go ahead and release it from reset as it will not be able to get
-	 * the lock again until the MPU lock is released.
-	 */
-	if (IsLocked && Force) {
-		/* Release the reset of the configuration controller */
-		XSysAce_mAndControlReg(InstancePtr->BaseAddress,
-				       ~XSA_CR_CFGRESET_MASK);
-	}
-
-	return XST_SUCCESS;
-}
-
-
-/*****************************************************************************/
-/**
-*
-* Release the MPU lock to the CompactFlash. If a lock is not currently granted
-* to the MPU port, this function has no effect.
-*
-* @param InstancePtr is a pointer to the XSysAce instance to be worked on.
-*
-* @return
-*
-* None.
-*
-* @note
-*
-* None.
-*
-******************************************************************************/
-void XSysAce_Unlock(XSysAce * InstancePtr)
-{
-	XASSERT_VOID(InstancePtr != NULL);
-	XASSERT_VOID(InstancePtr->IsReady == XCOMPONENT_IS_READY);
-
-	/*
-	 * Blindly clear the lock and force-lock request bits of the control
-	 * register
-	 */
-	XSysAce_mAndControlReg(InstancePtr->BaseAddress,
-			       ~(XSA_CR_LOCKREQ_MASK | XSA_CR_FORCELOCK_MASK));
-}
-
-/*****************************************************************************/
-/**
-*
-* Get all outstanding errors. Errors include the inability to read or write
-* CompactFlash and the inability to successfully configure FPGA devices along
-* the target FPGA chain.
-*
-* @param InstancePtr is a pointer to the XSysAce instance to be worked on.
-*
-* @return
-*
-* A 32-bit mask of error values. See xsysace_l.h for a description of possible
-* values. The error identifiers are prefixed with XSA_ER_*.
-*
-* @note
-*
-* None.
-*
-******************************************************************************/
-u32 XSysAce_GetErrors(XSysAce * InstancePtr)
-{
-	XASSERT_NONVOID(InstancePtr != NULL);
-	XASSERT_NONVOID(InstancePtr->IsReady == XCOMPONENT_IS_READY);
-
-	return XSysAce_mGetErrorReg(InstancePtr->BaseAddress);
-}
-
-/*****************************************************************************/
-/**
-*
-* Stub for the asynchronous event callback. The stub is here in case the upper
-* layers forget to set the handler.
-*
-* @param    CallBackRef is a pointer to the upper layer callback reference
-* @param    Event is the event that occurs
-*
-* @return
-*
-* None.
-*
-* @note
-*
-* None.
-*
-******************************************************************************/
-static void StubEventHandler(void *CallBackRef, int Event)
-{
-	XASSERT_VOID_ALWAYS();
-}
diff --git a/drivers/block/xilinx_sysace/xsysace.h b/drivers/block/xilinx_sysace/xsysace.h
deleted file mode 100644
index 7c27963..0000000
--- a/drivers/block/xilinx_sysace/xsysace.h
+++ /dev/null
@@ -1,371 +0,0 @@
-/* $Id: xsysace.h,v 1.1 2006/02/17 21:52:36 moleres Exp $ */
-/******************************************************************************
-*
-*       XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS"
-*       AS A COURTESY TO YOU, SOLELY FOR USE IN DEVELOPING PROGRAMS AND
-*       SOLUTIONS FOR XILINX DEVICES.  BY PROVIDING THIS DESIGN, CODE,
-*       OR INFORMATION AS ONE POSSIBLE IMPLEMENTATION OF THIS FEATURE,
-*       APPLICATION OR STANDARD, XILINX IS MAKING NO REPRESENTATION
-*       THAT THIS IMPLEMENTATION IS FREE FROM ANY CLAIMS OF INFRINGEMENT,
-*       AND YOU ARE RESPONSIBLE FOR OBTAINING ANY RIGHTS YOU MAY REQUIRE
-*       FOR YOUR IMPLEMENTATION.  XILINX EXPRESSLY DISCLAIMS ANY
-*       WARRANTY WHATSOEVER WITH RESPECT TO THE ADEQUACY OF THE
-*       IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OR
-*       REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE FROM CLAIMS OF
-*       INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
-*       FOR A PARTICULAR PURPOSE.
-*
-*       (c) Copyright 2002-2005 Xilinx Inc.
-*       All rights reserved.
-* This program is free software; you can redistribute it and/or modify it
-* under the terms of the GNU General Public License as published by the
-* Free Software Foundation; either version 2 of the License, or (at your
-* option) any later version.
-*
-* You should have received a copy of the GNU General Public License
-* along with this program; if not, write to the Free Software
-* Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-*
-******************************************************************************/
-/*****************************************************************************/
-/**
-*
-* @file xsysace.h
-*
-* The Xilinx System ACE driver. This driver supports the Xilinx System Advanced
-* Configuration Environment (ACE) controller. It currently supports only the
-* CompactFlash solution. The driver makes use of the Microprocessor (MPU)
-* interface to communicate with the device.
-*
-* The driver provides a user the ability to access the CompactFlash through
-* the System ACE device.  The user can read and write CompactFlash sectors,
-* identify the flash device, and reset the flash device.  Also, the driver
-* provides a user the ability to configure FPGA devices by selecting a
-* configuration file (.ace file) resident on the CompactFlash, or directly
-* configuring the FPGA devices via the MPU port and the configuration JTAG
-* port of the controller.
-*
-* <b>Initialization & Configuration</b>
-*
-* The XSysAce_Config structure is used by the driver to configure itself. This
-* configuration structure is typically created by the tool-chain based on HW
-* build properties.
-*
-* To support multiple runtime loading and initialization strategies employed
-* by various operating systems, the driver instance can be initialized in one
-* of the following ways:
-*
-*   - XSysAce_Initialize(InstancePtr, DeviceId) - The driver looks up its own
-*     configuration structure created by the tool-chain based on an ID provided
-*     by the tool-chain.
-*
-*   - XSysAce_CfgInitialize(InstancePtr, CfgPtr, EffectiveAddr) - Uses a
-*     configuration structure provided by the caller. If running in a system
-*     with address translation, the provided virtual memory base address
-*     replaces the physical address present in the configuration structure.
-*
-* <b>Bus Mode</b>
-*
-* The System ACE device supports both 8-bit and 16-bit access to its registers.
-* The driver defaults to 8-bit access, but can be changed to use 16-bit access
-* at compile-time.  The compile-time constant XPAR_XSYSACE_MEM_WIDTH must be
-* defined equal to 16 to make the driver use 16-bit access. This constant is
-* typically defined in xparameters.h.
-*
-* <b>Endianness</b>
-*
-* The System ACE device is little-endian. If being accessed by a big-endian
-* processor, the endian conversion will be done by the device driver. The
-* endian conversion is encapsulated inside the XSysAce_RegRead/Write functions
-* so that it can be removed if the endian conversion is moved to hardware.
-*
-* <b>Hardware Access</b>
-*
-* The device driver expects the System ACE controller to be a memory-mapped
-* device. Access to the System ACE controller is typically achieved through
-* the External Memory Controller (EMC) IP core. The EMC is simply a pass-through
-* device that allows access to the off-chip System ACE device. There is no
-* software-based setup or configuration necessary for the EMC.
-*
-* The System ACE registers are expected to be byte-addressable. If for some
-* reason this is not possible, the register offsets defined in xsysace_l.h must
-* be changed accordingly.
-*
-* <b>Reading or Writing CompactFlash</b>
-*
-* The smallest unit that can be read from or written to CompactFlash is one
-* sector. A sector is 512 bytes.  The functions provided by this driver allow
-* the user to specify a starting sector ID and the number of sectors to be read
-* or written. At most 256 sectors can be read or written in one operation. The
-* user must ensure that the buffer passed to the functions is big enough to
-* hold (512 * NumSectors), where NumSectors is the number of sectors specified.
-*
-* <b>Interrupt Mode</b>
-*
-* By default, the device and driver are in polled mode. The user is required to
-* enable interrupts using XSysAce_EnableInterrupt(). In order to use interrupts,
-* it is necessary for the user to connect the driver's interrupt handler,
-* XSysAce_InterruptHandler(), to the interrupt system of the application. This
-* function does not save and restore the processor context. An event handler
-* must also be set by the user, using XSysAce_SetEventHandler(), for the driver
-* such that the handler is called when interrupt events occur. The handler is
-* called from interrupt context and allows application-specific processing to
-* be performed.
-*
-* In interrupt mode, the only available interrupt is data buffer ready, so
-* the size of a data transfer between interrupts is 32 bytes (the size of the
-* data buffer).
-*
-* <b>Polled Mode</b>
-*
-* The sector read and write functions are blocking when in polled mode. This
-* choice was made over non-blocking since sector transfer rates are high
-* (>20Mbps) and the user can limit the number of sectors transferred in a single
-* operation to 1 when in polled mode, plus the API for non-blocking polled
-* functions was a bit awkward. Below is some more information on the sector
-* transfer rates given the current state of technology (year 2002). Although
-* the seek times for CompactFlash cards is high, this average hit needs to be
-* taken every time a new read/write operation is invoked by the user. So the
-* additional few microseconds to transfer an entire sector along with seeking
-* is miniscule.
-*
-* - Microdrives are slower than CompactFlash cards by a significant factor,
-*   especially if the MD is asleep.
-*     - Microdrive:
-*           - Power-up/wake-up time is approx. 150 to 1000 ms.
-*           - Average seek time is approx. 15 to 20 ms.
-*     - CompactFlash:
-*           - Power-up/reset time is approx. 50 to 400 ms and wake-up time is
-*             approx. 3 ms.
-*           - "Seek time" here means how long it takes the internal controller
-*             to process the command until the sector data is ready for transfer
-*             by the ACE controller.  This time is approx. 2 ms per sector.
-*
-*  - Once the sector data is ready in the CF device buffer (i.e., "seek time" is
-*    over) the ACE controller can read 2 bytes from the MD/CF device every 11
-*    clock cycles, assuming no wait cycles happen.  For instance, if the clock
-*    is 33 MHz, then then the max. rate that the ACE controller can transfer is
-*    6 MB/sec.  However, due to other overhead (e.g., time for data buffer
-*    transfers over MPU port, etc.), a better estimate is 3-5 MB/sec.
-*
-* <b>Mutual Exclusion</b>
-*
-* This driver is not thread-safe. The System ACE device has a single data
-* buffer and therefore only one operation can be active at a time. The device
-* driver does not prevent the user from starting an operation while a previous
-* operation is still in progress. It is up to the user to provide this mutual
-* exclusion.
-*
-* <b>Errors</b>
-*
-* Error causes are defined in xsysace_l.h using the prefix XSA_ER_*. The
-* user can use XSysAce_GetErrors() to retrieve all outstanding errors.
-*
-* <pre>
-* MODIFICATION HISTORY:
-*
-* Ver   Who  Date     Changes
-* ----- ---- -------- -----------------------------------------------
-* 1.00a rpm  06/17/02 work in progress
-* 1.01a jvb  12/14/05 I separated dependency on the static config table and
-*                     xparameters.h from the driver initialization by moving
-*                     _Initialize and _LookupConfig to _sinit.c. I also added
-*                     the new _CfgInitialize routine. (The dependency on
-*                     XPAR_XSYSACE_MEM_WIDTH still remains.)
-* </pre>
-*
-******************************************************************************/
-
-#ifndef XSYSACE_H		/* prevent circular inclusions */
-#define XSYSACE_H		/* by using protection macros */
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-
-/***************************** Include Files *********************************/
-
-#include "xbasic_types.h"
-#include "xstatus.h"
-#include "xsysace_l.h"
-
-/************************** Constant Definitions *****************************/
-
-/** @name Asynchronous Events
- *
- * Asynchronous events passed to the event handler when in interrupt mode.
- *
- * Note that when an error event occurs, the only way to clear this condition
- * is to reset the CompactFlash or the System ACE configuration controller,
- * depending on where the error occurred. The driver does not reset either
- * and leaves this task to the user.
- * @{
- */
-#define XSA_EVENT_CFG_DONE  1  /**< Configuration of JTAG chain is done */
-#define XSA_EVENT_DATA_DONE 2  /**< Data transfer to/from CompactFlash is done */
-#define XSA_EVENT_ERROR     3  /**< An error occurred. Use XSysAce_GetErrors()
-                                *   to determine the cause of the error(s).
-                                */
-/*@}*/
-
-
-/**************************** Type Definitions *******************************/
-
-/**
- * Typedef for CompactFlash identify drive parameters. Use XSysAce_IdentifyCF()
- * to retrieve this information from the CompactFlash storage device.
- */
-typedef struct {
-	u16 Signature;	    /**< CompactFlash signature is 0x848a */
-	u16 NumCylinders;   /**< Default number of cylinders */
-	u16 Reserved;
-	u16 NumHeads;	    /**< Default number of heads */
-	u16 NumBytesPerTrack;
-			    /**< Number of unformatted bytes per track */
-	u16 NumBytesPerSector;
-			    /**< Number of unformatted bytes per sector */
-	u16 NumSectorsPerTrack;
-			    /**< Default number of sectors per track */
-	u32 NumSectorsPerCard;
-			    /**< Default number of sectors per card */
-	u16 VendorUnique;   /**< Vendor unique */
-	u8 SerialNo[20];    /**< ASCII serial number */
-	u16 BufferType;	    /**< Buffer type */
-	u16 BufferSize;	    /**< Buffer size in 512-byte increments */
-	u16 NumEccBytes;    /**< Number of ECC bytes on R/W Long cmds */
-	u8 FwVersion[8];    /**< ASCII firmware version */
-	u8 ModelNo[40];	    /**< ASCII model number */
-	u16 MaxSectors;	    /**< Max sectors on R/W Multiple cmds */
-	u16 DblWord;	    /**< Double Word not supported */
-	u16 Capabilities;   /**< Device capabilities */
-	u16 Reserved2;
-	u16 PioMode;	    /**< PIO data transfer cycle timing mode */
-	u16 DmaMode;	    /**< DMA data transfer cycle timing mode */
-	u16 TranslationValid;
-			    /**< Translation parameters are valid */
-	u16 CurNumCylinders;/**< Current number of cylinders */
-	u16 CurNumHeads;    /**< Current number of heads */
-	u16 CurSectorsPerTrack;
-			    /**< Current number of sectors per track */
-	u32 CurSectorsPerCard;
-			    /**< Current capacity in sectors */
-	u16 MultipleSectors;/**< Multiple sector setting */
-	u32 LbaSectors;	    /**< Number of addressable sectors in LBA mode */
-	u8 Reserved3[132];
-	u16 SecurityStatus; /**< Security status */
-	u8 VendorUniqueBytes[62];
-			      /**< Vendor unique bytes */
-	u16 PowerDesc;	    /**< Power requirement description */
-	u8 Reserved4[190];
-
-} XSysAce_CFParameters;
-
-
-/**
- * Callback when an asynchronous event occurs during interrupt mode.
- *
- * @param CallBackRef is a callback reference passed in by the upper layer
- *        when setting the callback functions, and passed back to the upper
- *        layer when the callback is invoked.
- * @param Event is the event that occurred.  See xsysace.h and the event
- *        identifiers prefixed with XSA_EVENT_* for a description of possible
- *        events.
- */
-typedef void (*XSysAce_EventHandler) (void *CallBackRef, int Event);
-
-/**
- * This typedef contains configuration information for the device.
- */
-typedef struct {
-	u16 DeviceId;	/**< Unique ID  of device */
-	u32 BaseAddress;/**< Register base address */
-
-} XSysAce_Config;
-
-/**
- * The XSysAce driver instance data. The user is required to allocate a
- * variable of this type for every System ACE device in the system. A
- * pointer to a variable of this type is then passed to the driver API
- * functions.
- */
-typedef struct {
-	u32 BaseAddress;	/* Base address of ACE device */
-	u32 IsReady;		/* Device is initialized and ready */
-
-	/* interrupt-related data */
-	int NumRequested;	/* Number of bytes to read/write */
-	int NumRemaining;	/* Number of bytes left to read/write */
-	u8 *BufferPtr;		/* Buffer being read/written */
-	XSysAce_EventHandler EventHandler;	/* Callback for asynchronous events */
-	void *EventRef;		/* Callback reference */
-
-} XSysAce;
-
-
-/***************** Macros (Inline Functions) Definitions *********************/
-
-
-/************************** Function Prototypes ******************************/
-
-/*
- * Initialization functions in xsysace_sinit.c
- */
-int XSysAce_Initialize(XSysAce * InstancePtr, u16 DeviceId);
-XSysAce_Config *XSysAce_LookupConfig(u16 DeviceId);
-
-/*
- * Required functions in xsysace.c
- */
-int XSysAce_CfgInitialize(XSysAce * InstancePtr, XSysAce_Config * Config,
-			  u32 EffectiveAddr);
-int XSysAce_Lock(XSysAce * InstancePtr, u32 Force);
-void XSysAce_Unlock(XSysAce * InstancePtr);
-u32 XSysAce_GetErrors(XSysAce * InstancePtr);
-
-/*
- * CompactFlash access functions in xsysace_compactflash.c
- */
-int XSysAce_ResetCF(XSysAce * InstancePtr);
-int XSysAce_AbortCF(XSysAce * InstancePtr);
-int XSysAce_IdentifyCF(XSysAce * InstancePtr, XSysAce_CFParameters * ParamPtr);
-u32 XSysAce_IsCFReady(XSysAce * InstancePtr);
-int XSysAce_SectorRead(XSysAce * InstancePtr, u32 StartSector,
-		       int NumSectors, u8 *BufferPtr);
-int XSysAce_SectorWrite(XSysAce * InstancePtr, u32 StartSector,
-			int NumSectors, u8 *BufferPtr);
-u16 XSysAce_GetFatStatus(XSysAce * InstancePtr);
-
-/*
- * JTAG configuration interface functions in xsysace_jtagcfg.c
- */
-void XSysAce_ResetCfg(XSysAce * InstancePtr);
-void XSysAce_SetCfgAddr(XSysAce * InstancePtr, unsigned int Address);
-void XSysAce_SetStartMode(XSysAce * InstancePtr, u32 ImmedOnReset,
-			  u32 SetStart);
-u32 XSysAce_IsCfgDone(XSysAce * InstancePtr);
-u32 XSysAce_GetCfgSector(XSysAce * InstancePtr);
-int XSysAce_ProgramChain(XSysAce * InstancePtr, u8 *BufferPtr, int NumBytes);
-
-/*
- * General interrupt-related functions in xsysace_intr.c
- */
-void XSysAce_EnableInterrupt(XSysAce * InstancePtr);
-void XSysAce_DisableInterrupt(XSysAce * InstancePtr);
-void XSysAce_SetEventHandler(XSysAce * InstancePtr,
-			     XSysAce_EventHandler FuncPtr, void *CallBackRef);
-void XSysAce_InterruptHandler(void *InstancePtr);	/* interrupt handler */
-
-/*
- * Diagnostic functions in xsysace_selftest.c
- */
-int XSysAce_SelfTest(XSysAce * InstancePtr);
-u16 XSysAce_GetVersion(XSysAce * InstancePtr);
-
-
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif /* end of protection macro */
diff --git a/drivers/block/xilinx_sysace/xsysace_compactflash.c b/drivers/block/xilinx_sysace/xsysace_compactflash.c
deleted file mode 100644
index 8af258e..0000000
--- a/drivers/block/xilinx_sysace/xsysace_compactflash.c
+++ /dev/null
@@ -1,808 +0,0 @@
-/* $Id: xsysace_compactflash.c,v 1.1 2006/02/17 21:52:36 moleres Exp $ */
-/******************************************************************************
-*
-*       XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS"
-*       AS A COURTESY TO YOU, SOLELY FOR USE IN DEVELOPING PROGRAMS AND
-*       SOLUTIONS FOR XILINX DEVICES.  BY PROVIDING THIS DESIGN, CODE,
-*       OR INFORMATION AS ONE POSSIBLE IMPLEMENTATION OF THIS FEATURE,
-*       APPLICATION OR STANDARD, XILINX IS MAKING NO REPRESENTATION
-*       THAT THIS IMPLEMENTATION IS FREE FROM ANY CLAIMS OF INFRINGEMENT,
-*       AND YOU ARE RESPONSIBLE FOR OBTAINING ANY RIGHTS YOU MAY REQUIRE
-*       FOR YOUR IMPLEMENTATION.  XILINX EXPRESSLY DISCLAIMS ANY
-*       WARRANTY WHATSOEVER WITH RESPECT TO THE ADEQUACY OF THE
-*       IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OR
-*       REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE FROM CLAIMS OF
-*       INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
-*       FOR A PARTICULAR PURPOSE.
-*
-*       (c) Copyright 2002 Xilinx Inc.
-*       All rights reserved.
-* This program is free software; you can redistribute it and/or modify it
-* under the terms of the GNU General Public License as published by the
-* Free Software Foundation; either version 2 of the License, or (at your
-* option) any later version.
-*
-* You should have received a copy of the GNU General Public License
-* along with this program; if not, write to the Free Software
-* Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-*
-******************************************************************************/
-/*****************************************************************************/
-/**
-*
-* @file xsysace_compactflash.c
-*
-* Contains functions to reset, read, and write the CompactFlash device via
-* the System ACE controller.
-*
-* <pre>
-* MODIFICATION HISTORY:
-*
-* Ver   Who  Date     Changes
-* ----- ---- -------- -----------------------------------------------
-* 1.00a rpm  06/17/02 work in progress
-* 1.00a ecm  09/17/04 Fixed the endianism issue with the string copies.
-*                     Replaced the ByteCopy with WordCopySwap which
-*                     copies the bytes and swaps to correct the endianism.
-*                     CR 194182
-*
-* 1.00a ecm  09/27/04 Fixed the lack of reset during read and write in
-*                     L1 functions.
-*                     CR 194423
-*
-* 1.00a ecm  12/09/04 Removed the above fix, breaks MVL.
-*                     CR 200015
-*
-* </pre>
-*
-******************************************************************************/
-
-/***************************** Include Files *********************************/
-
-#include "xsysace.h"
-#include "xsysace_l.h"
-
-/************************** Constant Definitions *****************************/
-
-/*
- * Indices into the parameter information from the CompactFlash.  When the
- * user calls XSysAce_IdentifyCF(), the parameter information is read into a
- * byte buffer.  The byte buffer is then mapped to a XSysAce_CFParameters
- * structure using these indices into the byte buffer.
- */
-#define XSA_CFPARM_SIGNATURE    0
-#define XSA_CFPARM_NUMCYLS      2
-#define XSA_CFPARM_RESERVED1    4
-#define XSA_CFPARM_NUMHEADS     6
-#define XSA_CFPARM_BYTES_TRACK  8
-#define XSA_CFPARM_BYTES_SECT   10
-#define XSA_CFPARM_SECTS_TRK    12
-#define XSA_CFPARM_SECTS_HI     14
-#define XSA_CFPARM_SECTS_LO     16
-#define XSA_CFPARM_VENDOR1      18
-#define XSA_CFPARM_SERIAL_NO    20
-#define XSA_CFPARM_BUFFER_TYPE  40
-#define XSA_CFPARM_BUFFER_SIZE  42
-#define XSA_CFPARM_ECC_BYTES    44
-#define XSA_CFPARM_FW_VERSION   46
-#define XSA_CFPARM_MODEL_NO     54
-#define XSA_CFPARM_MAX_SECTORS  94
-#define XSA_CFPARM_DBL_WORD     96
-#define XSA_CFPARM_CAPS         98
-#define XSA_CFPARM_RESERVED2    100
-#define XSA_CFPARM_PIO_MODE     102
-#define XSA_CFPARM_DMA_MODE     104
-#define XSA_CFPARM_TRANSLATE    106
-#define XSA_CFPARM_CURCYLS      108
-#define XSA_CFPARM_CURHEADS     110
-#define XSA_CFPARM_CURSECTS_TRK 112
-#define XSA_CFPARM_CURSECTS     114
-#define XSA_CFPARM_MULTIPLE     118
-#define XSA_CFPARM_LBA_SECTS    120
-#define XSA_CFPARM_RESERVED3    124
-#define XSA_CFPARM_SECURITY     256
-#define XSA_CFPARM_VENDOR2      258
-#define XSA_CFPARM_POWER        320
-#define XSA_CFPARM_RESERVED4    322
-
-/**************************** Type Definitions *******************************/
-
-
-/***************** Macros (Inline Functions) Definitions *********************/
-
-
-/************************** Function Prototypes ******************************/
-
-static void WordCopySwap(u8 *SourcePtr, u8 *DestPtr, int NumBytes);
-static void FillParam(XSysAce_CFParameters * ParamPtr, u8 *BufPtr);
-
-/************************** Variable Definitions *****************************/
-
-
-/*****************************************************************************/
-/**
-*
-* Reset the CompactFlash device. This function does not reset the System ACE
-* controller.  An ATA soft-reset of the CompactFlash is performed.
-*
-* An MPU lock, obtained using XSysAce_Lock(), must be granted before calling
-* this function. If a lock has not been granted, no action is taken and an
-* error is returned.
-*
-* @param InstancePtr is a pointer to the XSysAce instance to be worked on.
-*
-* @return
-*
-* - XST_SUCCESS if the reset was done successfully
-* - XST_SYSACE_NO_LOCK if no MPU lock has yet been granted
-* - XST_DEVICE_BUSY if the CompactFlash is not ready for a command
-*
-* @note
-*
-* None.
-*
-******************************************************************************/
-int XSysAce_ResetCF(XSysAce * InstancePtr)
-{
-	XASSERT_NONVOID(InstancePtr != NULL);
-	XASSERT_NONVOID(InstancePtr->IsReady == XCOMPONENT_IS_READY);
-
-	/* If a lock has not been granted, return an error */
-	if (!XSysAce_mIsMpuLocked(InstancePtr->BaseAddress)) {
-		return XST_SYSACE_NO_LOCK;
-	}
-
-	/* See if the CF is ready for a command */
-	if (!XSysAce_mIsReadyForCmd(InstancePtr->BaseAddress)) {
-		return XST_DEVICE_BUSY;
-	}
-
-	/*
-	 * If interrupts are enabled, enable the error interrupt. A reset clears
-	 * the error status, so we're going to re-enable the interrupt here so any
-	 * new errors will be caught.
-	 */
-	if (XSysAce_mIsIntrEnabled(InstancePtr->BaseAddress)) {
-		XSysAce_mOrControlReg(InstancePtr->BaseAddress,
-				      XSA_CR_ERRORIRQ_MASK);
-	}
-
-	/*
-	 * Send the reset command
-	 */
-	XSysAce_RegWrite16(InstancePtr->BaseAddress + XSA_SCCR_OFFSET,
-			   XSA_SCCR_RESET_MASK);
-
-	return XST_SUCCESS;
-}
-
-/*****************************************************************************/
-/**
-*
-* Abort the CompactFlash operation currently in progress.
-*
-* An MPU lock, obtained using XSysAce_Lock(), must be granted before calling
-* this function. If a lock has not been granted, no action is taken and an
-* error is returned.
-*
-* @param InstancePtr is a pointer to the XSysAce instance to be worked on.
-*
-* @return
-*
-* - XST_SUCCESS if the abort was done successfully
-* - XST_SYSACE_NO_LOCK if no MPU lock has yet been granted
-* - XST_DEVICE_BUSY if the CompactFlash is not ready for a command
-*
-* @note
-*
-* According to the ASIC designer, the abort command has not been well tested.
-*
-******************************************************************************/
-int XSysAce_AbortCF(XSysAce * InstancePtr)
-{
-	XASSERT_NONVOID(InstancePtr != NULL);
-	XASSERT_NONVOID(InstancePtr->IsReady == XCOMPONENT_IS_READY);
-
-	/* If a lock has not been granted, return an error */
-	if (!XSysAce_mIsMpuLocked(InstancePtr->BaseAddress)) {
-		return XST_SYSACE_NO_LOCK;
-	}
-
-	/*
-	 * See if the CF is ready for a command
-	 *
-	 * TODO: make sure this check works, or possibly the abort can be done
-	 * if it is not ready for a command (e.g., that's what we're aborting)?
-	 */
-	if (!XSysAce_mIsReadyForCmd(InstancePtr->BaseAddress)) {
-		return XST_DEVICE_BUSY;
-	}
-
-	/*
-	 * Send the abort command
-	 */
-	XSysAce_RegWrite16(InstancePtr->BaseAddress + XSA_SCCR_OFFSET,
-			   XSA_SCCR_ABORT_MASK);
-
-	return XST_SUCCESS;
-}
-
-/*****************************************************************************/
-/**
-*
-* Identify the CompactFlash device. Retrieves the parameters for the
-* CompactFlash storage device. Note that this is a polled read of one sector
-* of data. The data is read from the CompactFlash into a byte buffer, which
-* is then copied into the XSysAce_CFParameters structure passed in by the
-* user.  The copy is necessary since we don't know how the compiler packs
-* the XSysAce_CFParameters structure.
-*
-* An MPU lock, obtained using XSysAce_Lock(), must be granted before calling
-* this function. If a lock has not been granted, no action is taken and an
-* error is returned.
-*
-* @param InstancePtr is a pointer to the XSysAce instance to be worked on.
-* @param ParamPtr is a pointer to a XSysAce_CFParameters structure where the
-*        information for the CompactFlash device will be stored. See xsysace.h
-*        for details on the XSysAce_CFParameters structure.
-*
-* @return
-*
-* - XST_SUCCESS if the identify was done successfully
-* - XST_FAILURE if an error occurs. Use XSysAce_GetErrors() to determine cause.
-* - XST_SYSACE_NO_LOCK if no MPU lock has yet been granted
-* - XST_DEVICE_BUSY if the CompactFlash is not ready for a command
-*
-* @note
-*
-* None.
-*
-* @internal
-*
-* The identify command has the same protocol as the read sector command
-* according to the CompactFlash specification.  However, there is a discepency
-* in that same specification on the size of the parameter structure. The word
-* addresses defined in the spec indicate the parameter information is a full
-* 512 bytes, the same size as a sector. The total bytes defined in the spec,
-* however, indicate that the parameter information is only 500 bytes. We
-* defined the parameter structure in xsysace.h assuming the parameters are the
-* full 512 bytes since that makes sense, and therefore ignored the "Total
-* Bytes" column in the spec.
-*
-* The SectorData variable was made static to avoid putting 512 bytes on the
-* stack every time this function is called.
-*
-******************************************************************************/
-int XSysAce_IdentifyCF(XSysAce * InstancePtr, XSysAce_CFParameters * ParamPtr)
-{
-	int NumRead;
-	u32 InterruptsOn;
-	static u8 SectorData[XSA_CF_SECTOR_SIZE];
-
-	XASSERT_NONVOID(InstancePtr != NULL);
-	XASSERT_NONVOID(ParamPtr != NULL);
-	XASSERT_NONVOID(InstancePtr->IsReady == XCOMPONENT_IS_READY);
-
-	/* If a lock has not been granted, return an error */
-	if (!XSysAce_mIsMpuLocked(InstancePtr->BaseAddress)) {
-		return XST_SYSACE_NO_LOCK;
-	}
-
-	/* See if the CF is ready for a command */
-	if (!XSysAce_mIsReadyForCmd(InstancePtr->BaseAddress)) {
-		return XST_DEVICE_BUSY;
-	}
-
-	/*
-	 * If interrupts are enabled, we disable them because we want to do this
-	 * identify in polled mode - due to the buffer endian conversion and copy
-	 * that takes place.
-	 */
-	InterruptsOn = XSysAce_mIsIntrEnabled(InstancePtr->BaseAddress);
-	if (InterruptsOn) {
-		XSysAce_DisableInterrupt(InstancePtr);
-	}
-
-	/*
-	 * Send the identify command
-	 */
-	XSysAce_RegWrite16(InstancePtr->BaseAddress + XSA_SCCR_OFFSET,
-			   XSA_SCCR_IDENTIFY_MASK);
-
-	/* Reset configuration controller (be sure to keep the lock) */
-	/* This breaks mvl, beware! */
-	/* XSysAce_mOrControlReg(InstancePtr->BaseAddress, XSA_CR_CFGRESET_MASK); */
-
-	/*
-	 * Read a sector of data from the data buffer. The parameter info is
-	 * the same size as a sector.
-	 */
-	NumRead = XSysAce_ReadDataBuffer(InstancePtr->BaseAddress, SectorData,
-					 XSA_CF_SECTOR_SIZE);
-
-	/* Clear reset of configuration controller */
-	/* This breaks mvl, beware! */
-	/*XSysAce_mAndControlReg(InstancePtr->BaseAddress, ~(XSA_CR_CFGRESET_MASK)); */
-
-	/* If interrupts were on, re-enable interrupts (regardless of error) */
-	if (InterruptsOn) {
-		XSysAce_EnableInterrupt(InstancePtr);
-	}
-
-	if (NumRead == 0) {
-		/* an error occurred */
-		return XST_FAILURE;
-	}
-
-	/*
-	 * Copy the byte buffer to the parameter structure
-	 */
-	FillParam(ParamPtr, SectorData);
-
-	return XST_SUCCESS;
-}
-
-/*****************************************************************************/
-/**
-*
-* Check to see if the CompactFlash is ready for a command. The CompactFlash
-* may delay after one operation before it is ready for the next. This function
-* helps the user determine when it is ready before invoking a CompactFlash
-* operation such as XSysAce_SectorRead() or XSysAce_SectorWrite();
-*
-* @param InstancePtr is a pointer to the XSysAce instance to be worked on.
-*
-* @return
-*
-* TRUE if the CompactFlash is ready for a command, and FALSE otherwise.
-*
-* @note
-*
-* None.
-*
-******************************************************************************/
-u32 XSysAce_IsCFReady(XSysAce * InstancePtr)
-{
-	XASSERT_NONVOID(InstancePtr != NULL);
-	XASSERT_NONVOID(InstancePtr->IsReady == XCOMPONENT_IS_READY);
-
-	return XSysAce_mIsReadyForCmd(InstancePtr->BaseAddress);
-}
-
-/*****************************************************************************/
-/**
-*
-* Read at least one sector of data from the CompactFlash. The user specifies
-* the starting sector ID and the number of sectors to be read. The minimum unit
-* that can be read from the CompactFlash is a sector, which is 512 bytes.
-*
-* In polled mode, this read is blocking. If there are other tasks in the system
-* that must run, it is best to keep the number of sectors to be read to a
-* minimum (e.g., 1). In interrupt mode, this read is non-blocking and an event,
-* XSA_EVENT_DATA_DONE, is returned to the user in the asynchronous event
-* handler when the read is complete. The user must call
-* XSysAce_EnableInterrupt() to put the driver/device into interrupt mode.
-*
-* An MPU lock, obtained using XSysAce_Lock(), must be granted before calling
-* this function. If a lock has not been granted, no action is taken and an
-* error is returned.
-*
-* @param InstancePtr is a pointer to the XSysAce instance to be worked on.
-* @param StartSector is the starting sector ID from where data will be read.
-*        Sector IDs range from 0 (first sector) to 0x10000000.
-* @param NumSectors is the number of sectors to read. The range can be from
-*        1 to 256.
-* @param BufferPtr is a pointer to a buffer where the data will be stored.
-*        The user must ensure it is big enough to hold (512 * NumSectors) bytes.
-*
-* @return
-*
-* - XST_SUCCESS if the read was successful. In interrupt mode, this does not
-*   mean the read is complete, only that it has begun. An event is returned
-*   to the user when the read is complete.
-* - XST_SYSACE_NO_LOCK if no MPU lock has yet been granted
-* - XST_DEVICE_BUSY if the ACE controller is not ready for a command
-* - XST_FAILURE if an error occurred during the read. The user should call
-*   XSysAce_GetErrors() to determine the cause of the error.
-*
-* @note
-*
-* None.
-*
-* @internal
-*
-* Polled mode is blocking under the assumption that a single sector can be
-* transferred at a very fast rate (>20 Mbps).  So, the user can choose to
-* transfer only single sectors when in polled mode, thus allowing time for
-* other work to be done. The biggest issue is that although data transfer
-* rates are high, seek time for CompactFlash cards is slow (5-20 ms on
-* average, depending on the type of device). We could move to a non-blocking
-* solution that transfers 32 bytes at a time (the entire data buffer) and
-* then returns. The user would then need to increment its buffer pointer
-* appropriately and call the read/write again. The driver would need some way
-* to know not to issue a new command to the CompactFlash, but instead continue
-* with the previous command.  This can be done either with a NumSectors argument
-* of zero to indicate that there is already an operation in progress, or by
-* having the driver keep state to know there is an operation in progress. The
-* interface for either seems a bit awkward. Also, the hit for seek time needs
-* to be taken regardless of the blocking or non-blocking nature of the call, so
-* the additional few microseconds to transfer a sector of data seems acceptable.
-*
-******************************************************************************/
-int XSysAce_SectorRead(XSysAce * InstancePtr, u32 StartSector,
-		       int NumSectors, u8 *BufferPtr)
-{
-	u16 SectorCmd;
-	int BytesToRecv;
-
-	XASSERT_NONVOID(InstancePtr != NULL);
-	XASSERT_NONVOID(NumSectors > 0 &&
-			NumSectors <= (XSA_SCCR_COUNT_MASK + 1));
-	XASSERT_NONVOID(BufferPtr != NULL);
-	XASSERT_NONVOID(InstancePtr->IsReady == XCOMPONENT_IS_READY);
-
-	/* If a lock has not been granted, return an error */
-	if (!XSysAce_mIsMpuLocked(InstancePtr->BaseAddress)) {
-		return XST_SYSACE_NO_LOCK;
-	}
-
-	/* See if the CF is ready for a command */
-	if (!XSysAce_mIsReadyForCmd(InstancePtr->BaseAddress)) {
-		return XST_DEVICE_BUSY;
-	}
-
-	BytesToRecv = XSA_CF_SECTOR_SIZE * NumSectors;
-
-	/*
-	 * If in interrupt mode, set up the state variables and enable the
-	 * data-buffer-ready interrupt. This needs to be done before the command
-	 * is sent to the ACE, which will cause the interrupt to occur.
-	 */
-	if (XSysAce_mIsIntrEnabled(InstancePtr->BaseAddress)) {
-		InstancePtr->NumRequested = BytesToRecv;
-		InstancePtr->NumRemaining = BytesToRecv;
-		InstancePtr->BufferPtr = BufferPtr;
-
-		XSysAce_mOrControlReg(InstancePtr->BaseAddress,
-				      XSA_CR_DATARDYIRQ_MASK);
-	}
-
-	/* Write the sector ID (LBA) */
-	XSysAce_RegWrite32(InstancePtr->BaseAddress + XSA_MLR_OFFSET,
-			   StartSector);
-
-	/*
-	 * Send the read command for the number of sectors specified
-	 */
-	SectorCmd = (NumSectors & XSA_SCCR_COUNT_MASK) | XSA_SCCR_READDATA_MASK;
-	XSysAce_RegWrite16(InstancePtr->BaseAddress + XSA_SCCR_OFFSET,
-			   SectorCmd);
-
-	/*
-	 * If in polled mode, receive the entire amount requested
-	 */
-	if (!XSysAce_mIsIntrEnabled(InstancePtr->BaseAddress)) {
-		int NumRead;
-
-		/* Reset configuration controller (be sure to keep the lock) */
-		/* This breaks mvl, beware! */
-		/*XSysAce_mOrControlReg(InstancePtr->BaseAddress, XSA_CR_CFGRESET_MASK); */
-
-		NumRead =
-			XSysAce_ReadDataBuffer(InstancePtr->BaseAddress,
-					       BufferPtr, BytesToRecv);
-		/* Clear reset of configuration controller */
-		/* This breaks mvl, beware! */
-		/*XSysAce_mAndControlReg(InstancePtr->BaseAddress, ~(XSA_CR_CFGRESET_MASK)); */
-
-		if (NumRead != BytesToRecv) {
-			/* an error occurred, report this to the user */
-			return XST_FAILURE;
-		}
-	}
-
-	return XST_SUCCESS;
-}
-
-/*****************************************************************************/
-/**
-*
-* Write data to the CompactFlash. The user specifies the starting sector ID
-* and the number of sectors to be written. The minimum unit that can be written
-* to the CompactFlash is a sector, which is 512 bytes.
-*
-* In polled mode, this write is blocking. If there are other tasks in the
-* system that must run, it is best to keep the number of sectors to be written
-* to a minimum (e.g., 1). In interrupt mode, this write is non-blocking and an
-* event, XSA_EVENT_DATA_DONE, is returned to the user in the asynchronous
-* event handler when the write is complete. The user must call
-* XSysAce_EnableInterrupt() to put the driver/device into interrupt mode.
-*
-* An MPU lock, obtained using XSysAce_Lock(), must be granted before calling
-* this function. If a lock has not been granted, no action is taken and an
-* error is returned.
-*
-* @param InstancePtr is a pointer to the XSysAce instance to be worked on.
-* @param StartSector is the starting sector ID from where data will be written.
-*        Sector IDs range from 0 (first sector) to 0x10000000.
-* @param NumSectors is the number of sectors to write. The range can be from
-*        1 to 256.
-* @param BufferPtr is a pointer to the data buffer to be written. This buffer
-*        must have at least (512 * NumSectors) bytes.
-*
-* @return
-*
-* - XST_SUCCESS if the write was successful. In interrupt mode, this does not
-*   mean the write is complete, only that it has begun. An event is returned
-*   to the user when the write is complete.
-* - XST_SYSACE_NO_LOCK if no MPU lock has yet been granted
-* - XST_DEVICE_BUSY if the ACE controller is not ready for a command
-* - XST_FAILURE if an error occurred during the write. The user should call
-*   XSysAce_GetErrors() to determine the cause of the error.
-*
-* @note
-*
-* None.
-*
-* @internal
-*
-* Polled mode is blocking under the assumption that a single sector can be
-* transferred at a very fast rate (>20 Mbps).  So, the user can choose to
-* transfer only single sectors when in polled mode, thus allowing time for
-* other work to be done. The biggest issue is that although data transfer
-* rates are high, seek time for CompactFlash cards is slow (5-20 ms on
-* average, depending on the type of device). We could move to a non-blocking
-* solution that transfers 32 bytes at a time (the entire data buffer) and
-* then returns. The user would then need to increment its buffer pointer
-* appropriately and call the read/write again. The driver would need some way
-* to know not to issue a new command to the CompactFlash, but instead continue
-* with the previous command.  This can be done either with a NumSectors argument
-* of zero to indicate that there is already an operation in progress, or by
-* having the driver keep state to know there is an operation in progress. The
-* interface for either seems a bit awkward. Also, the hit for seek time needs
-* to be taken regardless of the blocking or non-blocking nature of the call, so
-* the additional few microseconds to transfer a sector of data seems acceptable.
-*
-******************************************************************************/
-int XSysAce_SectorWrite(XSysAce * InstancePtr, u32 StartSector,
-			int NumSectors, u8 *BufferPtr)
-{
-	u16 SectorCmd;
-	int NumSent;
-	int BytesToSend;
-
-	XASSERT_NONVOID(InstancePtr != NULL);
-	XASSERT_NONVOID(NumSectors > 0 &&
-			NumSectors <= (XSA_SCCR_COUNT_MASK + 1));
-	XASSERT_NONVOID(BufferPtr != NULL);
-	XASSERT_NONVOID(InstancePtr->IsReady == XCOMPONENT_IS_READY);
-
-	/* If a lock has not been granted, return an error */
-	if (!XSysAce_mIsMpuLocked(InstancePtr->BaseAddress)) {
-		return XST_SYSACE_NO_LOCK;
-	}
-
-	/* See if the CF is ready for a command */
-	if (!XSysAce_mIsReadyForCmd(InstancePtr->BaseAddress)) {
-		return XST_DEVICE_BUSY;
-	}
-
-	/* Write the sector ID (LBA) */
-	XSysAce_RegWrite32(InstancePtr->BaseAddress + XSA_MLR_OFFSET,
-			   StartSector);
-
-	/*
-	 * Send the write command for the number of sectors specified
-	 */
-	SectorCmd =
-		(NumSectors & XSA_SCCR_COUNT_MASK) | XSA_SCCR_WRITEDATA_MASK;
-	XSysAce_RegWrite16(InstancePtr->BaseAddress + XSA_SCCR_OFFSET,
-			   SectorCmd);
-
-	BytesToSend = XSA_CF_SECTOR_SIZE * NumSectors;
-
-	/*
-	 * If in interrupt mode, set up the state variables and enable the
-	 * data-buffer-ready interrupt. We do this after the write command above
-	 * is done in order to guarantee that the interrupt occurs only after the
-	 * first data buffer write is done below (an interrupt may or may not occur
-	 * after the write command is issued)
-	 */
-	if (XSysAce_mIsIntrEnabled(InstancePtr->BaseAddress)) {
-		/*
-		 * Set the state variables. We're going to send one data buffer here in
-		 * this routine, so adjust the buffer pointer and number remaining to
-		 * reflect this.
-		 */
-		InstancePtr->NumRequested = BytesToSend;
-		InstancePtr->NumRemaining = BytesToSend - XSA_DATA_BUFFER_SIZE;
-		InstancePtr->BufferPtr = BufferPtr + XSA_DATA_BUFFER_SIZE;
-
-		/* Send only one data buffer in interrupt mode */
-		BytesToSend = XSA_DATA_BUFFER_SIZE;
-
-		XSysAce_mOrControlReg(InstancePtr->BaseAddress,
-				      XSA_CR_DATARDYIRQ_MASK);
-	}
-
-	NumSent = XSysAce_WriteDataBuffer(InstancePtr->BaseAddress, BufferPtr,
-					  BytesToSend);
-	if (NumSent != BytesToSend) {
-		/* an error occurred, report this to the user */
-		return XST_FAILURE;
-	}
-
-	return XST_SUCCESS;
-}
-
-
-/*****************************************************************************/
-/**
-*
-* Get the status of the FAT filesystem on the first valid partition of the
-* CompactFlash device such as the boot record and FAT types found.
-*
-* @param InstancePtr is a pointer to the XSysAce instance to be worked on.
-*
-* @return
-*
-* A 16-bit mask of status values. These values are defined in xsysace_l.h
-* with the prefix XSA_FAT_*.
-*
-* @note
-*
-* None.
-*
-******************************************************************************/
-u16 XSysAce_GetFatStatus(XSysAce * InstancePtr)
-{
-	XASSERT_NONVOID(InstancePtr != NULL);
-	XASSERT_NONVOID(InstancePtr->IsReady == XCOMPONENT_IS_READY);
-
-	return XSysAce_RegRead16(InstancePtr->BaseAddress + XSA_FSR_OFFSET);
-}
-
-/*****************************************************************************/
-/**
-*
-* This bit of ugliness allows us to present a structure to the user. The
-* byte buffer which was read from the CompactFlash is converted into the
-* XSysAce_CFParameters structure. The byte buffer is accessed by the indices
-* of the fields as defined at the top of this file. We do not read from
-* CompactFlash directly into the CF Parameter structure because of structure
-* packing problems.
-*
-* Note that we also need to perform endian conversion here since the System
-* ACE device gives us little endian data and we're (possibly) on a big endian
-* processor.
-*
-* @param ParamPtr is the structure to fill
-* @param BufPtr is the byte buffer containing the CF parameter data
-*
-* @return
-*
-* None.
-*
-* @note
-*
-* None.
-*
-******************************************************************************/
-static void FillParam(XSysAce_CFParameters * ParamPtr, u8 *BufPtr)
-{
-	u16 HiWord;
-	u16 LoWord;
-
-	XIo_FromLittleEndian16(*((u16 *) &BufPtr[XSA_CFPARM_SIGNATURE]),
-			       &ParamPtr->Signature);
-	XIo_FromLittleEndian16(*((u16 *) &BufPtr[XSA_CFPARM_NUMCYLS]),
-			       &ParamPtr->NumCylinders);
-	XIo_FromLittleEndian16(*((u16 *) &BufPtr[XSA_CFPARM_RESERVED1]),
-			       &ParamPtr->Reserved);
-	XIo_FromLittleEndian16(*((u16 *) &BufPtr[XSA_CFPARM_NUMHEADS]),
-			       &ParamPtr->NumHeads);
-	XIo_FromLittleEndian16(*((u16 *) &BufPtr[XSA_CFPARM_BYTES_TRACK]),
-			       &ParamPtr->NumBytesPerTrack);
-	XIo_FromLittleEndian16(*((u16 *) &BufPtr[XSA_CFPARM_BYTES_SECT]),
-			       &ParamPtr->NumBytesPerSector);
-	XIo_FromLittleEndian16(*((u16 *) &BufPtr[XSA_CFPARM_SECTS_TRK]),
-			       &ParamPtr->NumSectorsPerTrack);
-
-	/* NumSectorsPerCard is stored as two half-words, MSW first */
-	XIo_FromLittleEndian16(*((u16 *) &BufPtr[XSA_CFPARM_SECTS_HI]),
-			       &HiWord);
-	XIo_FromLittleEndian16(*((u16 *) &BufPtr[XSA_CFPARM_SECTS_LO]),
-			       &LoWord);
-	ParamPtr->NumSectorsPerCard = ((u32) HiWord << 16) | (u32) LoWord;
-
-	XIo_FromLittleEndian16(*((u16 *) &BufPtr[XSA_CFPARM_VENDOR1]),
-			       &ParamPtr->VendorUnique);
-
-	WordCopySwap(&BufPtr[XSA_CFPARM_SERIAL_NO], ParamPtr->SerialNo, 20);
-
-	XIo_FromLittleEndian16(*((u16 *) &BufPtr[XSA_CFPARM_BUFFER_TYPE]),
-			       &ParamPtr->BufferType);
-	XIo_FromLittleEndian16(*((u16 *) &BufPtr[XSA_CFPARM_BUFFER_SIZE]),
-			       &ParamPtr->BufferSize);
-	XIo_FromLittleEndian16(*((u16 *) &BufPtr[XSA_CFPARM_ECC_BYTES]),
-			       &ParamPtr->NumEccBytes);
-
-	WordCopySwap(&BufPtr[XSA_CFPARM_FW_VERSION], ParamPtr->FwVersion, 8);
-	WordCopySwap(&BufPtr[XSA_CFPARM_MODEL_NO], ParamPtr->ModelNo, 40);
-
-	XIo_FromLittleEndian16(*((u16 *) &BufPtr[XSA_CFPARM_MAX_SECTORS]),
-			       &ParamPtr->MaxSectors);
-	XIo_FromLittleEndian16(*((u16 *) &BufPtr[XSA_CFPARM_DBL_WORD]),
-			       &ParamPtr->DblWord);
-	XIo_FromLittleEndian16(*((u16 *) &BufPtr[XSA_CFPARM_CAPS]),
-			       &ParamPtr->Capabilities);
-	XIo_FromLittleEndian16(*((u16 *) &BufPtr[XSA_CFPARM_RESERVED2]),
-			       &ParamPtr->Reserved2);
-	XIo_FromLittleEndian16(*((u16 *) &BufPtr[XSA_CFPARM_PIO_MODE]),
-			       &ParamPtr->PioMode);
-	XIo_FromLittleEndian16(*((u16 *) &BufPtr[XSA_CFPARM_DMA_MODE]),
-			       &ParamPtr->DmaMode);
-	XIo_FromLittleEndian16(*((u16 *) &BufPtr[XSA_CFPARM_TRANSLATE]),
-			       &ParamPtr->TranslationValid);
-	XIo_FromLittleEndian16(*((u16 *) &BufPtr[XSA_CFPARM_CURCYLS]),
-			       &ParamPtr->CurNumCylinders);
-	XIo_FromLittleEndian16(*((u16 *) &BufPtr[XSA_CFPARM_CURHEADS]),
-			       &ParamPtr->CurNumHeads);
-	XIo_FromLittleEndian16(*((u16 *) &BufPtr[XSA_CFPARM_CURSECTS_TRK]),
-			       &ParamPtr->CurSectorsPerTrack);
-	XIo_FromLittleEndian32(*((u32 *) &BufPtr[XSA_CFPARM_CURSECTS]),
-			       &ParamPtr->CurSectorsPerCard);
-	XIo_FromLittleEndian16(*((u16 *) &BufPtr[XSA_CFPARM_MULTIPLE]),
-			       &ParamPtr->MultipleSectors);
-	XIo_FromLittleEndian32(*((u32 *) &BufPtr[XSA_CFPARM_LBA_SECTS]),
-			       &ParamPtr->LbaSectors);
-
-	WordCopySwap(&BufPtr[XSA_CFPARM_RESERVED3], ParamPtr->Reserved3, 132);
-
-	XIo_FromLittleEndian16(*((u16 *) &BufPtr[XSA_CFPARM_SECURITY]),
-			       &ParamPtr->SecurityStatus);
-
-	WordCopySwap(&BufPtr[XSA_CFPARM_VENDOR2], ParamPtr->VendorUniqueBytes,
-		     62);
-
-	XIo_FromLittleEndian16(*((u16 *) &BufPtr[XSA_CFPARM_POWER]),
-			       &ParamPtr->PowerDesc);
-
-	WordCopySwap(&BufPtr[XSA_CFPARM_RESERVED4], ParamPtr->Reserved4, 190);
-
-}
-
-/*****************************************************************************/
-/**
-*
-* Utility to copy words and swap the endianism on the fly.
-*
-* @param SourcePtr is a pointer to the source byte buffer
-* @param DestPtr is a pointer to the destination byte buffer
-* @param NumBytes is the number of bytes to copy
-*
-* @return
-*
-* None.
-*
-* @note
-*
-* NumBytes should be even but if it isn't, the function increases by 1
-* to correct.
-*
-******************************************************************************/
-static void WordCopySwap(u8 *SourcePtr, u8 *DestPtr, int NumBytes)
-{
-	int i;
-
-	/* make sure the requested length is even, if not, increase by 1 */
-
-	if ((NumBytes & 0x00000001) != 0) {
-		NumBytes += 1;
-	}
-
-	for (i = 0; i < NumBytes; i += 2) {
-		DestPtr[i + 1] = SourcePtr[i];
-		DestPtr[i] = SourcePtr[i + 1];
-	}
-}
diff --git a/drivers/block/xilinx_sysace/xsysace_g.c b/drivers/block/xilinx_sysace/xsysace_g.c
deleted file mode 100644
index 3d580de..0000000
--- a/drivers/block/xilinx_sysace/xsysace_g.c
+++ /dev/null
@@ -1,75 +0,0 @@
-/* $Id: xsysace_g.c,v 1.1 2006/02/17 21:52:36 moleres Exp $ */
-/*****************************************************************************
-*
-*       XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS"
-*       AS A COURTESY TO YOU, SOLELY FOR USE IN DEVELOPING PROGRAMS AND
-*       SOLUTIONS FOR XILINX DEVICES.  BY PROVIDING THIS DESIGN, CODE,
-*       OR INFORMATION AS ONE POSSIBLE IMPLEMENTATION OF THIS FEATURE,
-*       APPLICATION OR STANDARD, XILINX IS MAKING NO REPRESENTATION
-*       THAT THIS IMPLEMENTATION IS FREE FROM ANY CLAIMS OF INFRINGEMENT,
-*       AND YOU ARE RESPONSIBLE FOR OBTAINING ANY RIGHTS YOU MAY REQUIRE
-*       FOR YOUR IMPLEMENTATION.  XILINX EXPRESSLY DISCLAIMS ANY
-*       WARRANTY WHATSOEVER WITH RESPECT TO THE ADEQUACY OF THE
-*       IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OR
-*       REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE FROM CLAIMS OF
-*       INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
-*       FOR A PARTICULAR PURPOSE.
-*
-*       (c) Copyright 2002 Xilinx Inc.
-*       All rights reserved.
-* This program is free software; you can redistribute it and/or modify it
-* under the terms of the GNU General Public License as published by the
-* Free Software Foundation; either version 2 of the License, or (at your
-* option) any later version.
-*
-* You should have received a copy of the GNU General Public License
-* along with this program; if not, write to the Free Software
-* Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-*
-*****************************************************************************/
-/****************************************************************************/
-/**
-*
-* @file xsysace_g.c
-*
-* This file contains a configuration table that specifies the configuration of
-* System ACE devices in the system.
-*
-* <pre>
-* MODIFICATION HISTORY:
-*
-* Ver   Who  Date     Changes
-* ----- ---- -------- -----------------------------------------------
-* 1.00a rpm  06/17/02 work in progress
-* </pre>
-*
-******************************************************************************/
-
-/***************************** Include Files *********************************/
-
-#include "xsysace.h"
-#include "xparameters.h"
-
-/************************** Constant Definitions *****************************/
-
-
-/**************************** Type Definitions *******************************/
-
-
-/***************** Macros (Inline Functions) Definitions *********************/
-
-
-/************************** Function Prototypes ******************************/
-
-
-/************************** Variable Prototypes ******************************/
-
-/**
- * The configuration table for System ACE devices in the system. Each
- * device should have an entry in this table.
- */
-XSysAce_Config XSysAce_ConfigTable[XPAR_XSYSACE_NUM_INSTANCES] = {
-	{
-	 XPAR_SYSACE_0_DEVICE_ID,
-	 XPAR_SYSACE_0_BASEADDR}
-};
diff --git a/drivers/block/xilinx_sysace/xsysace_intr.c b/drivers/block/xilinx_sysace/xsysace_intr.c
deleted file mode 100644
index ca91f38..0000000
--- a/drivers/block/xilinx_sysace/xsysace_intr.c
+++ /dev/null
@@ -1,424 +0,0 @@
-/* $Id: xsysace_intr.c,v 1.1 2006/02/17 21:52:36 moleres Exp $ */
-/******************************************************************************
-*
-*       XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS"
-*       AS A COURTESY TO YOU, SOLELY FOR USE IN DEVELOPING PROGRAMS AND
-*       SOLUTIONS FOR XILINX DEVICES.  BY PROVIDING THIS DESIGN, CODE,
-*       OR INFORMATION AS ONE POSSIBLE IMPLEMENTATION OF THIS FEATURE,
-*       APPLICATION OR STANDARD, XILINX IS MAKING NO REPRESENTATION
-*       THAT THIS IMPLEMENTATION IS FREE FROM ANY CLAIMS OF INFRINGEMENT,
-*       AND YOU ARE RESPONSIBLE FOR OBTAINING ANY RIGHTS YOU MAY REQUIRE
-*       FOR YOUR IMPLEMENTATION.  XILINX EXPRESSLY DISCLAIMS ANY
-*       WARRANTY WHATSOEVER WITH RESPECT TO THE ADEQUACY OF THE
-*       IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OR
-*       REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE FROM CLAIMS OF
-*       INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
-*       FOR A PARTICULAR PURPOSE.
-*
-*       (c) Copyright 2002 Xilinx Inc.
-*       All rights reserved.
-* This program is free software; you can redistribute it and/or modify it
-* under the terms of the GNU General Public License as published by the
-* Free Software Foundation; either version 2 of the License, or (at your
-* option) any later version.
-*
-* You should have received a copy of the GNU General Public License
-* along with this program; if not, write to the Free Software
-* Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-*
-******************************************************************************/
-/*****************************************************************************/
-/**
-*
-* @file xsysace_intr.c
-*
-* Contains functions related to System ACE interrupt mode. The driver's
-* interrupt handler, XSysAce_InterruptHandler(), must be connected by the
-* user to the interrupt controller.
-*
-* <pre>
-* MODIFICATION HISTORY:
-*
-* Ver   Who  Date     Changes
-* ----- ---- -------- -----------------------------------------------
-* 1.00a rpm  06/17/02 work in progress
-* </pre>
-*
-******************************************************************************/
-
-/***************************** Include Files *********************************/
-
-#include "xsysace.h"
-#include "xsysace_l.h"
-
-/************************** Constant Definitions *****************************/
-
-
-/**************************** Type Definitions *******************************/
-
-
-/***************** Macros (Inline Functions) Definitions *********************/
-
-
-/************************** Variable Definitions *****************************/
-
-
-/************************** Function Prototypes ******************************/
-
-static void HandleDataBuffer(XSysAce * InstancePtr, u32 StatusReg);
-static void DataComplete(XSysAce * InstancePtr);
-
-
-/*****************************************************************************/
-/**
-*
-* Enable System ACE interrupts. There are three interrupts that can be enabled.
-* The error interrupt enable serves as the driver's means to determine whether
-* interrupts have been enabled or not. The configuration-done interrupt is not
-* enabled here, instead it is enabled during a reset - which can cause a
-* configuration process to start. The data-buffer-ready interrupt is not enabled
-* here either. It is enabled when a read or write operation is started. The
-* reason for not enabling the latter two interrupts are because the status bits
-* may be set as a leftover of an earlier occurrence of the interrupt.
-*
-* @param InstancePtr is a pointer to the XSysAce instance to work on.
-*
-* @return
-*
-* None.
-*
-* @note
-*
-* None.
-*
-******************************************************************************/
-void XSysAce_EnableInterrupt(XSysAce * InstancePtr)
-{
-	XASSERT_VOID(InstancePtr != NULL);
-	XASSERT_VOID(InstancePtr->IsReady == XCOMPONENT_IS_READY);
-
-	/* By default, enable only the error interrupt */
-	XSysAce_mOrControlReg(InstancePtr->BaseAddress, XSA_CR_ERRORIRQ_MASK);
-
-	/* Clear the reset on the interrupt line if it was in reset */
-	XSysAce_mAndControlReg(InstancePtr->BaseAddress, ~XSA_CR_RESETIRQ_MASK);
-}
-
-
-/*****************************************************************************/
-/**
-*
-* Disable all System ACE interrupts and hold the interrupt request line of
-* the device in reset.
-*
-* @param InstancePtr is a pointer to the XSysAce instance that just interrupted.
-*
-* @return
-*
-* None.
-*
-* @note
-*
-* None.
-*
-******************************************************************************/
-void XSysAce_DisableInterrupt(XSysAce * InstancePtr)
-{
-	XASSERT_VOID(InstancePtr != NULL);
-	XASSERT_VOID(InstancePtr->IsReady == XCOMPONENT_IS_READY);
-
-	/* Put the interrupt request line in reset */
-	XSysAce_mOrControlReg(InstancePtr->BaseAddress, XSA_CR_RESETIRQ_MASK);
-
-	/* Clear the interrupt enable bits */
-	XSysAce_mAndControlReg(InstancePtr->BaseAddress,
-			       ~(XSA_CR_DATARDYIRQ_MASK | XSA_CR_ERRORIRQ_MASK |
-				 XSA_CR_CFGDONEIRQ_MASK));
-}
-
-
-/*****************************************************************************/
-/**
-*
-* The interrupt handler for the System ACE driver. This handler must be
-* connected by the user to an interrupt controller or source. This function
-* does not save or restore context.
-*
-* This function continues reading or writing to the compact flash if such an
-* operation is in progress, and notifies the upper layer software through
-* the event handler once the operation is complete or an error occurs. On an
-* error, any command currently in progress is aborted.
-*
-* @param InstancePtr is a pointer to the XSysAce instance that just interrupted.
-*
-* @return
-*
-* None.
-*
-* @note
-*
-* None.
-*
-******************************************************************************/
-void XSysAce_InterruptHandler(void *InstancePtr)
-{
-	u32 StatusReg;
-	XSysAce *AcePtr = (XSysAce *) InstancePtr;
-
-	XASSERT_VOID(InstancePtr != NULL);
-
-	/*
-	 * Get the status in order to process each interrupt that has occurred
-	 */
-	StatusReg = XSysAce_mGetStatusReg(AcePtr->BaseAddress);
-
-	/*
-	 * Reset the interrupt line to effectively clear the interrupt conditions.
-	 * We need to set the bit to clear the interrupts, then clear the bit so
-	 * that new interrupts can be generated.
-	 */
-	XSysAce_mOrControlReg(AcePtr->BaseAddress, XSA_CR_RESETIRQ_MASK);
-	XSysAce_mAndControlReg(AcePtr->BaseAddress, ~XSA_CR_RESETIRQ_MASK);
-
-	/*
-	 * Check for data buffer ready, which means an operation (either read or
-	 * write) is in progress.
-	 */
-	if (StatusReg & XSA_SR_DATABUFRDY_MASK) {
-		/*
-		 * Handles the data buffer, and invokes the callback to the user for
-		 * data transfer completion.
-		 */
-		HandleDataBuffer(AcePtr, StatusReg);
-	}
-
-	/*
-	 * Check for completion of JTAG configuration and report the event up.
-	 * We only do this if the CFGDONE interrupt is enabled since the CFGDONE
-	 * status only gets cleared when the confguration controller is reset,
-	 * which we do not do unless requested by the user because it may cause
-	 * a configuration process to start. We could have gotten into this
-	 * interrupt handler by another interrupt, yet have a leftover CFGDONE
-	 * status from an earlier configuration process.
-	 */
-	if ((StatusReg & XSA_SR_CFGDONE_MASK) &&
-	    (XSysAce_mGetControlReg(AcePtr->BaseAddress) &
-	     XSA_CR_CFGDONEIRQ_MASK)) {
-		/*
-		 * Clear the bit indicating MPU is the source of configuration data
-		 * since we're done configuring from the MPU for now. Also clear the
-		 * force CFGMODE bit and the CFGSTART bit, basically undoing what was
-		 * done in XSysAce_ProgramChain(). Disable the interrupts since the
-		 * CFGDONE status does not get cleared unless a reset occurs - and in
-		 * the meantime we may get into this interrupt handler again.
-		 */
-		XSysAce_mAndControlReg(AcePtr->BaseAddress,
-				       ~(XSA_CR_CFGSEL_MASK |
-					 XSA_CR_CFGSTART_MASK |
-					 XSA_CR_CFGDONEIRQ_MASK |
-					 XSA_CR_DATARDYIRQ_MASK |
-					 XSA_CR_FORCECFGMODE_MASK));
-
-		AcePtr->EventHandler(AcePtr->EventRef, XSA_EVENT_CFG_DONE);
-	}
-
-	/*
-	 * Check for errors and report the event (the user is responsible for
-	 * retrieving and interpreting the errors). We only do this if the error
-	 * interrupt is enabled since the error status only gets cleared when the
-	 * CompactFlash or confguration controller is reset, which we do not do
-	 * because it may cause a configuration process to start. We could have
-	 * entered this interrupt handler by another interrupt and have a leftover
-	 * error status from a previous error.
-	 */
-	if ((StatusReg & (XSA_SR_CFGERROR_MASK | XSA_SR_CFCERROR_MASK)) &&
-	    (XSysAce_mGetControlReg(AcePtr->BaseAddress) &
-	     XSA_CR_ERRORIRQ_MASK)) {
-		/* Clear the transfer state to effectively abort the operation */
-		AcePtr->NumRequested = 0;
-		AcePtr->NumRemaining = 0;
-		AcePtr->BufferPtr = NULL;
-
-		/*
-		 * Disable the error interrupt since the only way to clear the
-		 * error status is to reset the CF or the configuration controller,
-		 * neither of which we want to do here since the consequences may
-		 * be undesirable (i.e., may cause a reconfiguration). The user
-		 * will need to perform the reset based on the error event.
-		 */
-		XSysAce_mAndControlReg(AcePtr->BaseAddress,
-				       ~XSA_CR_ERRORIRQ_MASK);
-
-		AcePtr->EventHandler(AcePtr->EventRef, XSA_EVENT_ERROR);
-	}
-}
-
-/*****************************************************************************/
-/**
-*
-* Set the callback function for handling events. The upper layer software
-* should call this function during initialization. The events are passed
-* asynchronously to the upper layer software. The events are described in
-* xsysace.h and are named XSA_EVENT_*.
-*
-* Note that the callback is invoked by the driver within interrupt context, so
-* it needs to do its job quickly. If there are potentially slow operations
-* within the callback, these should be done at task-level.
-*
-* @param InstancePtr is a pointer to the XSysAce instance to be worked on.
-* @param FuncPtr is the pointer to the callback function.
-* @param CallBackRef is a reference pointer to be passed back to the upper
-*        layer.
-*
-* @return
-*
-* None.
-*
-* @note
-*
-* None.
-*
-******************************************************************************/
-void XSysAce_SetEventHandler(XSysAce * InstancePtr,
-			     XSysAce_EventHandler FuncPtr, void *CallBackRef)
-{
-	XASSERT_VOID(InstancePtr != NULL);
-	XASSERT_VOID(FuncPtr != NULL);
-	XASSERT_VOID(InstancePtr->IsReady == XCOMPONENT_IS_READY);
-
-	InstancePtr->EventHandler = FuncPtr;
-	InstancePtr->EventRef = CallBackRef;
-}
-
-/*****************************************************************************/
-/**
-*
-* Handle a data-buffer-ready interrupt. If we get the interrupt when reading,
-* it means there is still data to read since the interrupt does not occur after
-* reading the last data buffer. If we get the interrupt when writing, there
-* may or may not be data left to write since the interrupt does occur after the
-* last data buffer is written.
-*
-* @param InstancePtr is a pointer to the XSysAce instance to be worked on.
-* @param StatusReg is the contents of the status register, read at the start
-*        of the interrupt service routine.
-*
-* @return
-*
-* None.
-*
-* @note
-*
-* None.
-*
-******************************************************************************/
-static void HandleDataBuffer(XSysAce * InstancePtr, u32 StatusReg)
-{
-	/* By default, transfer a whole data buffer */
-	int BytesToTransfer = XSA_DATA_BUFFER_SIZE;
-
-	/*
-	 * Check to see if number of bytes remaining is less than the data buffer
-	 * size. If it is, we need to adjust the remaining bytes to transfer.
-	 */
-	if (InstancePtr->NumRemaining < XSA_DATA_BUFFER_SIZE) {
-		BytesToTransfer = InstancePtr->NumRemaining;
-	}
-
-	/*
-	 * Transfer only one data buffer at a time, which is 32 bytes. Note that
-	 * errors will be handled by an error interrupt occurring, so no need to
-	 * check for them here.
-	 */
-	if (StatusReg & XSA_SR_DATABUFMODE_MASK) {
-		/*
-		 * A write operation in progress, so if there is data remaining then
-		 * write the buffer. If no data is remaining, clean up.
-		 */
-		if (InstancePtr->NumRemaining > 0) {
-			(void) XSysAce_WriteDataBuffer(InstancePtr->BaseAddress,
-						       InstancePtr->BufferPtr,
-						       BytesToTransfer);
-
-			/*
-			 * Decrement the number of bytes remaining to be transferred and
-			 * adjust the buffer pointer appropriately.
-			 */
-			InstancePtr->NumRemaining -= BytesToTransfer;
-			InstancePtr->BufferPtr += BytesToTransfer;
-		}
-		else {
-			/* Done writing data, so clean up */
-			DataComplete(InstancePtr);
-		}
-	}
-	else {
-		/* A read operation in progress, so read the buffer */
-		(void) XSysAce_ReadDataBuffer(InstancePtr->BaseAddress,
-					      InstancePtr->BufferPtr,
-					      BytesToTransfer);
-
-		/*
-		 * Decrement the number of bytes remaining to be transferred and
-		 * adjust the buffer pointer appropriately. If it was the last buffer,
-		 * we're done and we can cleanup.
-		 */
-		InstancePtr->NumRemaining -= BytesToTransfer;
-		InstancePtr->BufferPtr += BytesToTransfer;
-
-		if (InstancePtr->NumRemaining == 0) {
-			/* Done reading data, so clean up */
-			DataComplete(InstancePtr);
-		}
-	}
-}
-
-/*****************************************************************************/
-/**
-*
-* Handle cleanup when a data transfer is complete. This means intializing the
-* state variables, disabling the data-buffer-ready interrupt, and sending the
-* event to the user.
-*
-* @param InstancePtr is a pointer to the XSysAce instance to be worked on.
-*
-* @return
-*
-* None.
-*
-* @note
-*
-* None.
-*
-******************************************************************************/
-static void DataComplete(XSysAce * InstancePtr)
-{
-	InstancePtr->NumRequested = 0;
-	InstancePtr->NumRemaining = 0;
-	InstancePtr->BufferPtr = NULL;
-
-	/*
-	 * Disable the data-buffer-ready interrupt. This isn't necessary when
-	 * reading since the DATABUFRDY status bit is cleared by the ACE after
-	 * the last data buffer is read.  However, the ACE isn't currently
-	 * smart enough to clear the DATABUFRDY status bit after the last data
-	 * buffer is written during a write operation.  So, we need to use the
-	 * enable/disable interrupt bit to control its usefulness.
-	 */
-	XSysAce_mAndControlReg(InstancePtr->BaseAddress,
-			       ~XSA_CR_DATARDYIRQ_MASK);
-
-	/*
-	 * The same code is executed for JTAG configuration as well as CompactFlash
-	 * transfers, so we need to distinguish between JTAG config done and CF
-	 * data transfer done. We look at the CFGSEL value in the control register
-	 * to determine if an MPU JTAG config process has just completed. The
-	 * CFG_DONE event is passed up later by the main interrupt handler.
-	 */
-	if ((XSysAce_mGetControlReg(InstancePtr->BaseAddress)
-	     & XSA_CR_CFGSEL_MASK) == 0) {
-		/* no JTAG configuration in progress */
-		InstancePtr->EventHandler(InstancePtr->EventRef,
-					  XSA_EVENT_DATA_DONE);
-	}
-}
diff --git a/drivers/block/xilinx_sysace/xsysace_jtagcfg.c b/drivers/block/xilinx_sysace/xsysace_jtagcfg.c
deleted file mode 100644
index 3497f40..0000000
--- a/drivers/block/xilinx_sysace/xsysace_jtagcfg.c
+++ /dev/null
@@ -1,456 +0,0 @@
-/* $Id: xsysace_jtagcfg.c,v 1.1 2006/02/17 21:52:36 moleres Exp $ */
-/******************************************************************************
-*
-*       XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS"
-*       AS A COURTESY TO YOU, SOLELY FOR USE IN DEVELOPING PROGRAMS AND
-*       SOLUTIONS FOR XILINX DEVICES.  BY PROVIDING THIS DESIGN, CODE,
-*       OR INFORMATION AS ONE POSSIBLE IMPLEMENTATION OF THIS FEATURE,
-*       APPLICATION OR STANDARD, XILINX IS MAKING NO REPRESENTATION
-*       THAT THIS IMPLEMENTATION IS FREE FROM ANY CLAIMS OF INFRINGEMENT,
-*       AND YOU ARE RESPONSIBLE FOR OBTAINING ANY RIGHTS YOU MAY REQUIRE
-*       FOR YOUR IMPLEMENTATION.  XILINX EXPRESSLY DISCLAIMS ANY
-*       WARRANTY WHATSOEVER WITH RESPECT TO THE ADEQUACY OF THE
-*       IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OR
-*       REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE FROM CLAIMS OF
-*       INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
-*       FOR A PARTICULAR PURPOSE.
-*
-*       (c) Copyright 2002 Xilinx Inc.
-*       All rights reserved.
-* This program is free software; you can redistribute it and/or modify it
-* under the terms of the GNU General Public License as published by the
-* Free Software Foundation; either version 2 of the License, or (at your
-* option) any later version.
-*
-* You should have received a copy of the GNU General Public License
-* along with this program; if not, write to the Free Software
-* Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-*
-******************************************************************************/
-/*****************************************************************************/
-/**
-*
-* @file xsysace_jtagcfg.c
-*
-* Contains functions to control the configuration of the target FPGA chain on
-* the System ACE via the JTAG configuration port.
-*
-* <pre>
-* MODIFICATION HISTORY:
-*
-* Ver   Who  Date     Changes
-* ----- ---- -------- -----------------------------------------------
-* 1.00a rpm  06/17/02 work in progress
-* </pre>
-*
-******************************************************************************/
-
-/***************************** Include Files *********************************/
-
-#include "xsysace.h"
-#include "xsysace_l.h"
-
-/************************** Constant Definitions *****************************/
-
-
-/**************************** Type Definitions *******************************/
-
-
-/***************** Macros (Inline Functions) Definitions *********************/
-
-
-/************************** Function Prototypes ******************************/
-
-
-/************************** Variable Definitions *****************************/
-
-
-/*****************************************************************************/
-/**
-*
-* Reset the JTAG configuration controller. This comprises a reset of the JTAG
-* configuration controller and the CompactFlash controller (if it is currently
-* being accessed by the configuration controller). Note that the MPU controller
-* is not reset, meaning the MPU registers remain unchanged. The configuration
-* controller is reset then released from reset in this function.
-*
-* The CFGDONE status (and therefore interrupt) is cleared when the configuration
-* controller is reset. If interrupts have been enabled, we go ahead and enable
-* the CFGDONE interrupt here. This means that if and when a configuration
-* process starts as a result of this reset, an interrupt will be received when
-* it is complete.
-*
-* @param InstancePtr is a pointer to the XSysAce instance to be worked on.
-*
-* @return
-*
-* None.
-*
-* @note
-*
-* This function is not thread-safe.
-*
-******************************************************************************/
-void XSysAce_ResetCfg(XSysAce * InstancePtr)
-{
-	XASSERT_VOID(InstancePtr != NULL);
-	XASSERT_VOID(InstancePtr->IsReady == XCOMPONENT_IS_READY);
-
-	/* Reset the configuration controller */
-	XSysAce_mOrControlReg(InstancePtr->BaseAddress, XSA_CR_CFGRESET_MASK);
-
-	/*
-	 * If in interrupt mode, enable the CFGDONE and error interrupts.
-	 * A reset clears the CFGDONE and error statuses, so we're going to
-	 * re-enable the interrupts here so any new errors or CFGDONEs will be
-	 * caught.
-	 */
-	if (XSysAce_mIsIntrEnabled(InstancePtr->BaseAddress)) {
-		XSysAce_mOrControlReg(InstancePtr->BaseAddress,
-				      XSA_CR_CFGDONEIRQ_MASK |
-				      XSA_CR_ERRORIRQ_MASK);
-	}
-
-	/* Release the reset of the configuration controller */
-	XSysAce_mAndControlReg(InstancePtr->BaseAddress, ~XSA_CR_CFGRESET_MASK);
-}
-
-/*****************************************************************************/
-/**
-*
-* Select the configuration address (or file) from the CompactFlash to be used
-* for configuration of the target FPGA chain.
-*
-* @param InstancePtr is a pointer to the XSysAce instance to be worked on.
-* @param Address is the address or file number to be used as the bitstream to
-*        configure the target FPGA devices. There are 8 possible files, so
-*        the value of this parameter can range from 0 to 7.
-*
-* @return
-*
-* None.
-*
-* @note
-*
-* None.
-*
-******************************************************************************/
-void XSysAce_SetCfgAddr(XSysAce * InstancePtr, unsigned int Address)
-{
-	XASSERT_VOID(InstancePtr != NULL);
-	XASSERT_VOID(Address < 8);
-	XASSERT_VOID(InstancePtr->IsReady == XCOMPONENT_IS_READY);
-
-	/*
-	 * Set the control register with the address and the bit that forces
-	 * the use of the control register address bits instead of the address
-	 * pins on the device.
-	 */
-	XSysAce_mSetCfgAddr(InstancePtr->BaseAddress, Address);
-}
-
-/*****************************************************************************/
-/**
-*
-* Set the start mode for configuration of the target FPGA chain from
-* CompactFlash. The configuration process only starts after a reset. The
-* user can indicate that the configuration should start immediately after a
-* reset, or the configuration process can be delayed until the user commands
-* it to start (using this function). The configuration controller can be
-* reset using XSysAce_ResetCfg().
-*
-* The user can select which configuration file on the CompactFlash to use using
-* the XSysAce_SetCfgAddr() function. If the user intends to configure the target
-* FPGA chain directly from the MPU port, this function is not needed. Instead,
-* the user would simply call XSysAce_ProgramChain().
-*
-* The user can use XSysAce_IsCfgDone() when in polled mode to determine if
-* the configuration is complete. If in interrupt mode, the event
-* XSA_EVENT_CFG_DONE will be returned asynchronously to the user when the
-* configuration is complete. The user must call XSysAce_EnableInterrupt() to put
-* the device/driver into interrupt mode.
-*
-* @param InstancePtr is a pointer to the XSysAce instance to be worked on.
-* @param ImmedOnReset can be set to TRUE to indicate the configuration process
-*        will start immediately after a reset of the ACE configuration
-*        controller, or it can be set to FALSE to indicate the configuration
-*        process is delayed after a reset until the user starts it (using this
-*        function).
-* @param StartCfg is a boolean indicating whether to start the configuration
-*        process or not. When ImmedOnReset is set to TRUE, this value is
-*        ignored. When ImmedOnReset is set to FALSE, then this value controls
-*        when the configuration process is started. When set to TRUE the
-*        configuration process starts (assuming a reset of the device has
-*        occurred), and when set to FALSE the configuration process does not
-*        start.
-*
-* @return
-*
-* None.
-*
-* @note
-*
-* None.
-*
-******************************************************************************/
-void XSysAce_SetStartMode(XSysAce * InstancePtr, u32 ImmedOnReset, u32 StartCfg)
-{
-	u32 Control;
-
-	XASSERT_VOID(InstancePtr != NULL);
-	XASSERT_VOID(InstancePtr->IsReady == XCOMPONENT_IS_READY);
-
-	/* Get the current contents of the control register */
-	Control = XSysAce_mGetControlReg(InstancePtr->BaseAddress);
-
-	/*
-	 * Since the user has called this function, we want to tell the ACE
-	 * controller to look at the CFGMODE bit of the control register rather
-	 * than the CFGMODE pin of the device to determine when to start a
-	 * configuration process.
-	 */
-	Control |= XSA_CR_FORCECFGMODE_MASK;
-
-	/* Set or clear the CFGMODE bit of the control register */
-	if (ImmedOnReset) {
-		Control |= XSA_CR_CFGMODE_MASK;	/* immediate on reset */
-	}
-	else {
-		Control &= ~XSA_CR_CFGMODE_MASK;	/* wait for start bit */
-	}
-
-
-	/* Set or clear the CFGSTART bit of the control register */
-	if (StartCfg) {
-		Control |= XSA_CR_CFGSTART_MASK;
-	}
-	else {
-		Control &= ~XSA_CR_CFGSTART_MASK;
-	}
-
-	XSysAce_mSetControlReg(InstancePtr->BaseAddress, Control);
-}
-
-
-/*****************************************************************************/
-/**
-*
-* Program the target FPGA chain through the configuration JTAG port. This
-* allows the user to program the devices on the target FPGA chain from the MPU
-* port instead of from CompactFlash. The user specifies a buffer and the number
-* of bytes to write. The buffer should be equivalent to an ACE (.ace) file.
-*
-* Note that when loading the ACE file via the MPU port, the first sector of the
-* ACE file is discarded. The CF filesystem controller in the System ACE device
-* knows to skip the first sector when the ACE file comes from the CF, but the
-* CF filesystem controller is bypassed when the ACE file comes from the MPU
-* port. For this reason, this function skips the first sector of the buffer
-* passed in.
-*
-* In polled mode, the write is blocking. In interrupt mode, the write is
-* non-blocking and an event, XSA_EVENT_CFG_DONE, is returned to the user in
-* the asynchronous event handler when the configuration is complete.
-*
-* An MPU lock, obtained using XSysAce_Lock(), must be granted before calling
-* this function. If a lock has not been granted, no action is taken and an
-* error is returned.
-*
-* @param InstancePtr is a pointer to the XSysAce instance to be worked on.
-* @param BufferPtr is a pointer to a buffer that will be used to program
-*        the configuration JTAG devices.
-* @param NumBytes is the number of bytes in the buffer. We assume that there
-*        is at least one sector of data in the .ace file, which is the
-*        information sector.
-*
-* @return
-*
-* - XST_SUCCESS if the write was successful. In interrupt mode, this does not
-*   mean the write is complete, only that it has begun. An event is returned
-*   to the user when the write is complete.
-* - XST_SYSACE_NO_LOCK if no MPU lock has yet been granted
-* - XST_FAILURE if an error occurred during the write. The user should call
-*   XSysAce_GetErrors() to determine the cause of the error.
-*
-* @note
-*
-* None.
-*
-* @internal
-*
-* The System ACE controller has a 32-byte buffer which holds data. The entire
-* buffer must be written to ensure that it gets sent to the configuration
-* JTAG port. If the number of bytes specified by the user is not a multiple
-* of 32, the driver will pad the remaining bytes of the System ACE buffer with
-* zeroes in order to write the entire buffer.
-*
-******************************************************************************/
-int XSysAce_ProgramChain(XSysAce * InstancePtr, u8 *BufferPtr, int NumBytes)
-{
-	u32 ControlMask;
-	int BytesToSend;
-	int NumSent;
-
-	XASSERT_NONVOID(InstancePtr != NULL);
-	XASSERT_NONVOID(BufferPtr != NULL);
-	XASSERT_NONVOID(NumBytes > XSA_CF_SECTOR_SIZE);
-	XASSERT_NONVOID(InstancePtr->IsReady == XCOMPONENT_IS_READY);
-
-	/* If a lock has not been granted, return an error */
-	if (!XSysAce_mIsMpuLocked(InstancePtr->BaseAddress)) {
-		return XST_SYSACE_NO_LOCK;
-	}
-
-	/*
-	 * Set up the configuration controller to use the MPU port as the
-	 * source of configuration data (instead of the CF). The following
-	 * control flow comes directly from the System ACE specification, except
-	 * the reset was moved to after the other control register bits are set.
-	 * Putting it into reset before the bits are set seemed to produce
-	 * configuration errors occasionally.
-	 */
-	ControlMask = XSysAce_mGetControlReg(InstancePtr->BaseAddress);
-
-	/* Select MPU as the source */
-	ControlMask |= XSA_CR_CFGSEL_MASK;
-	XSysAce_mSetControlReg(InstancePtr->BaseAddress, ControlMask);
-
-	/* Tell controller to wait for start bit from MPU */
-	ControlMask |= XSA_CR_FORCECFGMODE_MASK;
-	ControlMask &= ~XSA_CR_CFGMODE_MASK;
-	XSysAce_mSetControlReg(InstancePtr->BaseAddress, ControlMask);
-
-	/* Set the start bit */
-	ControlMask |= XSA_CR_CFGSTART_MASK;
-	XSysAce_mSetControlReg(InstancePtr->BaseAddress, ControlMask);
-
-	/* Put the configuration controller into a reset condition */
-	ControlMask |= XSA_CR_CFGRESET_MASK;
-	XSysAce_mSetControlReg(InstancePtr->BaseAddress, ControlMask);
-
-	/* Clear the reset condition, which starts the process */
-	ControlMask &= ~XSA_CR_CFGRESET_MASK;
-	XSysAce_mSetControlReg(InstancePtr->BaseAddress, ControlMask);
-
-	/*
-	 * Set up number of bytes to send. Default to the entire buffer, which
-	 * will be true in polled mode. In interrupt mode, modify this value to
-	 * send only one data buffer of data.  Always skip the first sector per
-	 * the comment above.
-	 */
-	BytesToSend = NumBytes - XSA_CF_SECTOR_SIZE;
-
-	/*
-	 * The number of bytes to write depends on interrupt or polled mode
-	 */
-	if (XSysAce_mIsIntrEnabled(InstancePtr->BaseAddress)) {
-		/*
-		 * In interrupt mode, so enable the data-buffer-ready and
-		 * configuration-done interrupts. Also, set up the state variables for
-		 * the interrupt handler to transfer the remaining data after the
-		 * initial write below. We need to write one data buffer here in this
-		 * function in order to cause the data-buffer-ready interrupt to occur
-		 * for subsequent writes.
-		 */
-		ControlMask |= XSA_CR_DATARDYIRQ_MASK | XSA_CR_CFGDONEIRQ_MASK;
-		XSysAce_mSetControlReg(InstancePtr->BaseAddress, ControlMask);
-
-		/* Send only one data buffer to begin with (if there is that much) */
-		if (BytesToSend > XSA_DATA_BUFFER_SIZE) {
-			BytesToSend = XSA_DATA_BUFFER_SIZE;
-		}
-
-		/*
-		 * Setup state variables for the interrupt handler. Skip the first
-		 * sector per the comment above, and also skip the first data buffer
-		 * since it is written below.
-		 */
-		InstancePtr->NumRequested = NumBytes - XSA_CF_SECTOR_SIZE;
-		InstancePtr->BufferPtr =
-			BufferPtr + XSA_CF_SECTOR_SIZE + BytesToSend;
-		InstancePtr->NumRemaining =
-			NumBytes - XSA_CF_SECTOR_SIZE - BytesToSend;
-	}
-
-	NumSent = XSysAce_WriteDataBuffer(InstancePtr->BaseAddress,
-					  BufferPtr + XSA_CF_SECTOR_SIZE,
-					  BytesToSend);
-	if (NumSent != BytesToSend) {
-		/* an error occurred, report this to the user */
-		return XST_FAILURE;
-	}
-
-	/*
-	 * If in polled mode, restore the control register to the way it was
-	 */
-	if (!XSysAce_mIsIntrEnabled(InstancePtr->BaseAddress)) {
-		/*
-		 * Unselect MPU as the source, tell controller to use CFGMODE pin,
-		 * and clear the start bit.
-		 */
-		ControlMask &= ~(XSA_CR_CFGSEL_MASK | XSA_CR_FORCECFGMODE_MASK |
-				 XSA_CR_CFGSTART_MASK);
-		XSysAce_mSetControlReg(InstancePtr->BaseAddress, ControlMask);
-	}
-
-	return XST_SUCCESS;
-}
-
-/*****************************************************************************/
-/**
-*
-* Check to see if the configuration of the target FPGA chain is complete. This
-* function is typically only used in polled mode. In interrupt mode, an event
-* (XSA_EVENT_CFG_DONE) is returned to the user in the asynchronous event
-* handler.
-*
-* @param InstancePtr is a pointer to the XSysAce instance to be worked on.
-*
-* @return
-*
-* TRUE if the configuration is complete. FALSE otherwise.
-*
-* @note
-*
-* None.
-*
-******************************************************************************/
-u32 XSysAce_IsCfgDone(XSysAce * InstancePtr)
-{
-	XASSERT_NONVOID(InstancePtr != NULL);
-	XASSERT_NONVOID(InstancePtr->IsReady == XCOMPONENT_IS_READY);
-
-	/* Use the layer 0 macro by the same name */
-
-	return XSysAce_mIsCfgDone(InstancePtr->BaseAddress);
-}
-
-
-/*****************************************************************************/
-/**
-*
-* Get the sector ID of the CompactFlash sector being used for configuration of
-* the target FPGA chain. This sector ID (or logical block address) only affects
-* transfers between the ACE configuration logic and the CompactFlash card.
-* This function is typically used for debug purposes to determine which sector
-* was being accessed when an error occurred.
-*
-* @param InstancePtr is a pointer to the XSysAce instance to be worked on.
-*
-* @return
-*
-* The sector ID (logical block address) being used for data transfers between
-* the ACE configuration logic and the CompactFlash. Sector IDs range from 0
-* to 0x10000000.
-*
-* @note
-*
-* None.
-*
-******************************************************************************/
-u32 XSysAce_GetCfgSector(XSysAce * InstancePtr)
-{
-	XASSERT_NONVOID(InstancePtr != NULL);
-	XASSERT_NONVOID(InstancePtr->IsReady == XCOMPONENT_IS_READY);
-
-	return XSysAce_RegRead32(InstancePtr->BaseAddress + XSA_CLR_OFFSET);
-}
diff --git a/drivers/block/xilinx_sysace/xsysace_l.c b/drivers/block/xilinx_sysace/xsysace_l.c
deleted file mode 100644
index 5e4368e..0000000
--- a/drivers/block/xilinx_sysace/xsysace_l.c
+++ /dev/null
@@ -1,582 +0,0 @@
-/* $Id: xsysace_l.c,v 1.1 2006/02/17 21:52:36 moleres Exp $ */
-/******************************************************************************
-*
-*       XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS"
-*       AS A COURTESY TO YOU, SOLELY FOR USE IN DEVELOPING PROGRAMS AND
-*       SOLUTIONS FOR XILINX DEVICES.  BY PROVIDING THIS DESIGN, CODE,
-*       OR INFORMATION AS ONE POSSIBLE IMPLEMENTATION OF THIS FEATURE,
-*       APPLICATION OR STANDARD, XILINX IS MAKING NO REPRESENTATION
-*       THAT THIS IMPLEMENTATION IS FREE FROM ANY CLAIMS OF INFRINGEMENT,
-*       AND YOU ARE RESPONSIBLE FOR OBTAINING ANY RIGHTS YOU MAY REQUIRE
-*       FOR YOUR IMPLEMENTATION.  XILINX EXPRESSLY DISCLAIMS ANY
-*       WARRANTY WHATSOEVER WITH RESPECT TO THE ADEQUACY OF THE
-*       IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OR
-*       REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE FROM CLAIMS OF
-*       INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
-*       FOR A PARTICULAR PURPOSE.
-*
-*       (c) Copyright 2002 Xilinx Inc.
-*       All rights reserved.
-* This program is free software; you can redistribute it and/or modify it
-* under the terms of the GNU General Public License as published by the
-* Free Software Foundation; either version 2 of the License, or (at your
-* option) any later version.
-*
-* You should have received a copy of the GNU General Public License
-* along with this program; if not, write to the Free Software
-* Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-*
-******************************************************************************/
-/*****************************************************************************/
-/**
-*
-* @file xsysace_l.c
-*
-* This file contains low-level functions to read and write CompactFlash
-* sectors and ACE controller registers. These functions can be used when only
-* the low-level functionality of the driver is desired. The user would
-* typically use the high-level driver functions defined in xsysace.h.
-*
-* <pre>
-* MODIFICATION HISTORY:
-*
-* Ver   Who  Date     Changes
-* ----- ---- -------- -----------------------------------------------
-* 1.00a rpm  06/14/02 work in progress
-* 1.00a rpm  09/16/03 Added include of xparameters.h in order to get
-*                     the XPAR_XSYSACE_MEM_WIDTH definition.
-* 1.00a rpm  02/17/04 Fixed WriteSector function command
-* </pre>
-*
-******************************************************************************/
-
-/***************************** Include Files *********************************/
-
-#include "xsysace_l.h"
-
-/************************** Constant Definitions *****************************/
-
-/*
- * Set up the access width of the MPU registers based on compile-time constants.
- * If hardware requires 32-bit aligned addresses (XSA_ADDR_ALIGN=4) to access
- * the MPU registers, then access all of them as 32 bits. If hardware allows
- * 8-bit aligned addresses (XSA_ADDR_ALIGN=1, or not 4) to access the MPU
- * registers, access them as 8 or 16 bits depending on the bus mode of the ACE
- * controller.
- */
-#if (XSA_ADDR_ALIGN == 4)
-
-#define XIo_In   XIo_In32
-#define XIo_Out  XIo_Out32
-
-#else
-
-#if (XPAR_XSYSACE_MEM_WIDTH == 16)
-#define XIo_In   XIo_In16
-#define XIo_Out  XIo_Out16
-#else /* XPAR_XSYSACE_MEM_WIDTH */
-#define XIo_In   XIo_In8
-#define XIo_Out  XIo_Out8
-#endif /* XPAR_XSYSACE_MEM_WIDTH */
-
-#endif /* (XSA_ADDR_ALIGN == 4) */
-
-/**************************** Type Definitions *******************************/
-
-/***************** Macros (Inline Functions) Definitions *********************/
-
-/************************** Function Prototypes ******************************/
-
-/************************** Variable Definitions *****************************/
-
-/*****************************************************************************/
-/**
-*
-* Read a 32-bit value from the given address. Based on a compile-time
-* constant, do the read in two 16-bit reads or four 8-bit reads.
-*
-* @param    Address is the address to read from.
-*
-* @return   The 32-bit value of the address.
-*
-* @note     No need for endian conversion in 8-bit mode since this function
-*           gets the bytes into their proper lanes in the 32-bit word.
-*
-******************************************************************************/
-#if (XPAR_XSYSACE_MEM_WIDTH == 16)
-u32 XSysAce_RegRead32(u32 Address)
-{
-	u16 Data;
-	u16 ConvertedData;
-	u32 Value = 0;
-
-	/*
-	 * Need to endian convert each 32-bit value. The ACE registers are little-
-	 * endian, so we read the two LSBs first, endian convert, then put them
-	 * in the LSB lanes of the 32-bit word. etc...
-	 */
-	Data = (u16) XIo_In(Address);
-	XIo_FromLittleEndian16(Data, &ConvertedData);
-	Value = (u32) ConvertedData;
-
-	Data = (u16) XIo_In(Address + (2 * XSA_ADDR_ALIGN));
-	XIo_FromLittleEndian16(Data, &ConvertedData);
-	Value |= ((u32) ConvertedData << 16);
-
-	return Value;
-}
-#else
-u32 XSysAce_RegRead32(u32 Address)
-{
-	u32 Value = 0;
-
-	/*
-	 * The ACE registers are little-endian always. This code reads each 8-bit
-	 * register value, in order from LSB to MSB, and shifts it to the correct
-	 * byte lane of the 32-bit word. This code should work on both
-	 * little-endian and big-endian processors.
-	 */
-	Value = (u32) XIo_In(Address);
-	Value |= ((u32) XIo_In(Address + (1 * XSA_ADDR_ALIGN)) << 8);
-	Value |= ((u32) XIo_In(Address + (2 * XSA_ADDR_ALIGN)) << 16);
-	Value |= ((u32) XIo_In(Address + (3 * XSA_ADDR_ALIGN)) << 24);
-
-	return Value;
-}
-#endif
-
-
-/*****************************************************************************/
-/**
-*
-* Read a 16-bit value from the given address. Based on a compile-time
-* constant, do the read in one 16-bit read or two 8-bit reads.
-*
-* @param    Address is the address to read from.
-*
-* @return   The 16-bit value of the address.
-*
-* @note     No need for endian conversion in 8-bit mode since this function
-*           gets the bytes into their proper lanes in the 16-bit word.
-*
-******************************************************************************/
-#if (XPAR_XSYSACE_MEM_WIDTH == 16)
-u16 XSysAce_RegRead16(u32 Address)
-{
-	u16 Data;
-	u16 ConvertedData;
-
-	/*
-	 * Need to endian convert the 16-bit value. The ACE registers are little-
-	 * endian.
-	 */
-	Data = (u16) XIo_In(Address);
-	XIo_FromLittleEndian16(Data, &ConvertedData);
-	return ConvertedData;
-}
-#else
-u16 XSysAce_RegRead16(u32 Address)
-{
-	u16 Value = 0;
-
-	/*
-	 * The ACE registers are little-endian always. This code reads each 8-bit
-	 * register value, in order from LSB to MSB, and shifts it to the correct
-	 * byte lane of the 32-bit word. This code should work on both
-	 * little-endian and big-endian processors.
-	 */
-	Value = (u16) XIo_In(Address);
-	Value |= ((u16) XIo_In(Address + (1 * XSA_ADDR_ALIGN)) << 8);
-
-	return Value;
-}
-#endif
-
-
-/*****************************************************************************/
-/**
-*
-* Write a 32-bit value to the given address. Based on a compile-time
-* constant, do the write in two 16-bit writes or four 8-bit writes.
-*
-* @param    Address is the address to write to.
-* @param    Data is the value to write
-*
-* @return   None.
-*
-* @note     No need for endian conversion in 8-bit mode since this function
-*           writes the bytes into their proper lanes based on address.
-*
-******************************************************************************/
-#if (XPAR_XSYSACE_MEM_WIDTH == 16)
-void XSysAce_RegWrite32(u32 Address, u32 Data)
-{
-	u16 Hword;
-	u16 ConvertedData;
-
-	/*
-	 * The ACE registers are little-endian always. This code takes each 16-bit
-	 * value of the incoming 32-bit word and endian converts it, then writes it
-	 * to the ACE register.
-	 */
-	Hword = (u16) Data;
-	XIo_ToLittleEndian16(Hword, &ConvertedData);
-	XIo_Out(Address, ConvertedData);
-
-	Hword = (u16) (Data >> 16);
-	XIo_ToLittleEndian16(Hword, &ConvertedData);
-	XIo_Out(Address + (2 * XSA_ADDR_ALIGN), ConvertedData);
-}
-#else
-void XSysAce_RegWrite32(u32 Address, u32 Data)
-{
-	/*
-	 * The ACE registers are little-endian always. This code reads each 8-bit
-	 * register value, in order from LSB to MSB, and shifts it to the correct
-	 * byte lane of the 32-bit word. This code should work on both
-	 * little-endian and big-endian processors.
-	 */
-	XIo_Out(Address, (u8) Data);
-	XIo_Out(Address + (1 * XSA_ADDR_ALIGN), (u8) (Data >> 8));
-	XIo_Out(Address + (2 * XSA_ADDR_ALIGN), (u8) (Data >> 16));
-	XIo_Out(Address + (3 * XSA_ADDR_ALIGN), (u8) (Data >> 24));
-}
-#endif
-
-
-/*****************************************************************************/
-/**
-*
-* Write a 16-bit value to the given address. Based on a compile-time
-* constant, do the write in one 16-bit write or two 8-bit writes.
-*
-* @param    Address is the address to write to.
-* @param    Data is the value to write
-*
-* @return   None.
-*
-* @note     No need for endian conversion in 8-bit mode since this function
-*           writes the bytes into their proper lanes based on address.
-*
-******************************************************************************/
-#if (XPAR_XSYSACE_MEM_WIDTH == 16)
-void XSysAce_RegWrite16(u32 Address, u16 Data)
-{
-	u16 ConvertedData;
-
-	/*
-	 * The ACE registers are little-endian always. This code takes the incoming
-	 * 16-bit and endian converts it, then writes it to the ACE register.
-	 */
-	XIo_ToLittleEndian16(Data, &ConvertedData);
-	XIo_Out(Address, ConvertedData);
-}
-#else
-void XSysAce_RegWrite16(u32 Address, u16 Data)
-{
-	/*
-	 * The ACE registers are little-endian always. This code reads each 8-bit
-	 * register value, in order from LSB to MSB, and shifts it to the correct
-	 * byte lane of the 32-bit word. This code should work on both
-	 * little-endian and big-endian processors.
-	 */
-	XIo_Out(Address, (u8) Data);
-	XIo_Out(Address + (1 * XSA_ADDR_ALIGN), (u8) (Data >> 8));
-}
-#endif
-
-
-/*****************************************************************************/
-/**
-*
-* Read a CompactFlash sector. This is a blocking, low-level function which
-* does not return until the specified sector is read.
-*
-* @param BaseAddress is the base address of the device
-* @param SectorId is the id of the sector to read
-* @param BufferPtr is a pointer to a buffer where the data will be stored.
-*
-* @return
-*
-* The number of bytes read. If this number is not equal to the sector size,
-* 512 bytes, then an error occurred.
-*
-* @note
-*
-* None.
-*
-******************************************************************************/
-int XSysAce_ReadSector(u32 BaseAddress, u32 SectorId, u8 *BufferPtr)
-{
-	int NumRead;
-
-	/* Request and wait for the lock */
-	XSysAce_mWaitForLock(BaseAddress);
-
-	/* See if the CF is ready for a command */
-	if (!XSysAce_mIsReadyForCmd(BaseAddress)) {
-		return 0;
-	}
-
-	/* Write the sector ID (LBA) */
-	XSysAce_RegWrite32(BaseAddress + XSA_MLR_OFFSET, SectorId);
-
-	/* Send a read command of one sector to the controller */
-	XSysAce_RegWrite16(BaseAddress + XSA_SCCR_OFFSET,
-			   XSA_SCCR_READDATA_MASK | 1);
-
-	/* Reset configuration controller (be sure to keep the lock) */
-	XSysAce_mOrControlReg(BaseAddress, XSA_CR_CFGRESET_MASK);
-
-	/* Read a sector of data from the data buffer */
-	NumRead = XSysAce_ReadDataBuffer(BaseAddress, BufferPtr,
-					 XSA_CF_SECTOR_SIZE);
-
-	/* Clear reset of configuration controller and locks */
-	XSysAce_mAndControlReg(BaseAddress, ~(XSA_CR_CFGRESET_MASK |
-					      XSA_CR_LOCKREQ_MASK));
-
-	return NumRead;
-}
-
-/*****************************************************************************/
-/**
-*
-* Write a CompactFlash sector. This is a blocking, low-level function which
-* does not return until the specified sector is written in its entirety.
-*
-* @param BaseAddress is the base address of the device
-* @param SectorId is the id of the sector to write
-* @param BufferPtr is a pointer to a buffer used to write the sector.
-*
-* @return
-*
-* The number of bytes written. If this number is not equal to the sector size,
-* 512 bytes, then an error occurred.
-*
-* @note
-*
-* None.
-*
-******************************************************************************/
-int XSysAce_WriteSector(u32 BaseAddress, u32 SectorId, u8 *BufferPtr)
-{
-	int NumSent;
-
-	/* Get the lock */
-	XSysAce_mWaitForLock(BaseAddress);
-
-	/* See if the CF is ready for a command */
-	if (!XSysAce_mIsReadyForCmd(BaseAddress)) {
-		return 0;
-	}
-
-	/* Write the sector ID (LBA) */
-	XSysAce_RegWrite32(BaseAddress + XSA_MLR_OFFSET, SectorId);
-
-	/* Send a write command of one sector to the controller */
-	XSysAce_RegWrite16(BaseAddress + XSA_SCCR_OFFSET,
-			   XSA_SCCR_WRITEDATA_MASK | 1);
-
-	/* Reset configuration controller (be sure to keep the lock) */
-	XSysAce_mOrControlReg(BaseAddress, XSA_CR_CFGRESET_MASK);
-
-	/* Write a sector of data to the data buffer */
-	NumSent = XSysAce_WriteDataBuffer(BaseAddress, BufferPtr,
-					  XSA_CF_SECTOR_SIZE);
-
-	/* Clear reset of configuration controller and locks */
-	XSysAce_mAndControlReg(BaseAddress, ~(XSA_CR_CFGRESET_MASK |
-					      XSA_CR_LOCKREQ_MASK));
-
-	return NumSent;
-}
-
-
-/*****************************************************************************/
-/**
-*
-* Read the specified number of bytes from the data buffer of the ACE
-* controller. The data buffer, which is 32 bytes, can only be read two bytes
-* at a time.  Once the data buffer is read, we wait for it to be filled again
-* before reading the next buffer's worth of data.
-*
-* @param BaseAddress is the base address of the device
-* @param BufferPtr is a pointer to a buffer in which to store data.
-* @param Size is the number of bytes to read
-*
-* @return
-*
-* The total number of bytes read, or 0 if an error occurred.
-*
-* @note
-*
-* If Size is not aligned with the size of the data buffer (32 bytes), this
-* function will read the entire data buffer, dropping the extra bytes on the
-* floor since the user did not request them. This is necessary to get the
-* data buffer to be ready again.
-*
-******************************************************************************/
-int XSysAce_ReadDataBuffer(u32 BaseAddress, u8 *BufferPtr, int Size)
-{
-	int DataBytes;		/* number of data bytes written */
-	int BufferBytes;
-	u16 Data;
-
-	/*
-	 * Read data two bytes at a time. We need to wait for the data
-	 * buffer to be ready before reading the buffer.
-	 */
-	BufferBytes = 0;
-	for (DataBytes = 0; DataBytes < Size;) {
-		/*
-		 * If at any point during this read an error occurs, exit early
-		 */
-		if (XSysAce_mGetErrorReg(BaseAddress) != 0) {
-			return 0;
-		}
-
-		if (BufferBytes == 0) {
-			/*
-			 * Wait for CF data buffer to ready, then reset buffer byte count
-			 */
-			while ((XSysAce_mGetStatusReg(BaseAddress)
-				& XSA_SR_DATABUFRDY_MASK) == 0);
-
-			BufferBytes = XSA_DATA_BUFFER_SIZE;
-		}
-
-		/*
-		 * Need to read two bytes. Put the first one in the output buffer
-		 * because if we're here we know one more is needed. Put the second one
-		 * in the output buffer if there is still room, or just drop it on the
-		 * floor if the requested number of bytes have already been read.
-		 */
-		Data = XSysAce_RegRead16(BaseAddress + XSA_DBR_OFFSET);
-		*BufferPtr++ = (u8) Data;
-		DataBytes++;
-
-		if (DataBytes < Size) {
-			/* Still more room in the output buffer */
-			*BufferPtr++ = (u8) (Data >> 8);
-			DataBytes++;
-		}
-
-		BufferBytes -= 2;
-	}
-
-	/*
-	 * If a complete data buffer was not read, read and ignore the remaining
-	 * bytes
-	 */
-	while (BufferBytes != 0) {
-		/*
-		 * If at any point during this read an error occurs, exit early
-		 */
-		if (XSysAce_mGetErrorReg(BaseAddress) != 0) {
-			return 0;
-		}
-
-		(void) XSysAce_RegRead16(BaseAddress + XSA_DBR_OFFSET);
-		BufferBytes -= 2;
-	}
-
-	return DataBytes;
-}
-
-/*****************************************************************************/
-/**
-*
-* Write the specified number of bytes to the data buffer of the ACE controller.
-* The data buffer, which is 32 bytes, can only be written two bytes at a time.
-* Once the data buffer is written, we wait for it to be empty again before
-* writing the next buffer's worth of data. If the size of the incoming buffer
-* is not aligned with the System ACE data buffer size (32 bytes), then this
-* routine pads out the data buffer with zeros so the entire data buffer is
-* written. This is necessary for the ACE controller to process the data buffer.
-*
-* @param BaseAddress is the base address of the device
-* @param BufferPtr is a pointer to a buffer used to write to the controller.
-* @param Size is the number of bytes to write
-*
-* @return
-*
-* The total number of bytes written (not including pad bytes), or 0 if an
-* error occurs.
-*
-* @note
-*
-* None.
-*
-******************************************************************************/
-int XSysAce_WriteDataBuffer(u32 BaseAddress, u8 *BufferPtr, int Size)
-{
-	int DataBytes;		/* number of data bytes written */
-	int BufferBytes;
-	u16 Data;
-
-	/*
-	 * Write a sector two bytes at a time. We need to wait for the data
-	 * buffer to be ready before writing the buffer.
-	 */
-	BufferBytes = 0;
-	for (DataBytes = 0; DataBytes < Size;) {
-		/*
-		 * If at any point during this write an error occurs, exit early
-		 */
-		if (XSysAce_mGetErrorReg(BaseAddress) != 0) {
-			return 0;
-		}
-
-		if (BufferBytes == 0) {
-			/*
-			 * Wait for CF read data buffer to ready, then reset buffer byte
-			 * count
-			 */
-			while ((XSysAce_mGetStatusReg(BaseAddress)
-				& XSA_SR_DATABUFRDY_MASK) == 0);
-
-			BufferBytes = XSA_DATA_BUFFER_SIZE;
-		}
-
-		/*
-		 * Need to send two bytes. Grab the first one from the incoming buffer
-		 * because if we're here we know one more exists. Grab the second one
-		 * from the incoming buffer if there are still any bytes remaining, or
-		 * send a pad byte if the incoming buffer has been expired.
-		 */
-		Data = *BufferPtr++;
-		DataBytes++;
-
-		if (DataBytes < Size) {
-			/* Still more data in the incoming buffer */
-			Data |= ((u16) *BufferPtr++ << 8);
-			DataBytes++;
-		}
-		else {
-			/* No more data in the incoming buffer, send a pad byte of 0 */
-			Data |= ((u16) 0 << 8);
-		}
-
-		XSysAce_RegWrite16(BaseAddress + XSA_DBR_OFFSET, Data);
-
-		BufferBytes -= 2;
-	}
-
-	/*
-	 * If a complete data buffer was not filled, fill it with pad bytes (zeros)
-	 */
-	while (BufferBytes != 0) {
-		/*
-		 * If at any point during this write an error occurs, exit early
-		 */
-		if (XSysAce_mGetErrorReg(BaseAddress) != 0) {
-			return 0;
-		}
-
-		XSysAce_RegWrite16(BaseAddress + XSA_DBR_OFFSET, 0);
-		BufferBytes -= 2;
-	}
-
-	return DataBytes;
-}
diff --git a/drivers/block/xilinx_sysace/xsysace_l.h b/drivers/block/xilinx_sysace/xsysace_l.h
deleted file mode 100644
index 90f75ef..0000000
--- a/drivers/block/xilinx_sysace/xsysace_l.h
+++ /dev/null
@@ -1,523 +0,0 @@
-/* $Id: xsysace_l.h,v 1.1 2006/02/17 21:52:36 moleres Exp $ */
-/******************************************************************************
-*
-*       XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS"
-*       AS A COURTESY TO YOU, SOLELY FOR USE IN DEVELOPING PROGRAMS AND
-*       SOLUTIONS FOR XILINX DEVICES.  BY PROVIDING THIS DESIGN, CODE,
-*       OR INFORMATION AS ONE POSSIBLE IMPLEMENTATION OF THIS FEATURE,
-*       APPLICATION OR STANDARD, XILINX IS MAKING NO REPRESENTATION
-*       THAT THIS IMPLEMENTATION IS FREE FROM ANY CLAIMS OF INFRINGEMENT,
-*       AND YOU ARE RESPONSIBLE FOR OBTAINING ANY RIGHTS YOU MAY REQUIRE
-*       FOR YOUR IMPLEMENTATION.  XILINX EXPRESSLY DISCLAIMS ANY
-*       WARRANTY WHATSOEVER WITH RESPECT TO THE ADEQUACY OF THE
-*       IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OR
-*       REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE FROM CLAIMS OF
-*       INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
-*       FOR A PARTICULAR PURPOSE.
-*
-*       (c) Copyright 2002-2006 Xilinx Inc.
-*       All rights reserved.
-* This program is free software; you can redistribute it and/or modify it
-* under the terms of the GNU General Public License as published by the
-* Free Software Foundation; either version 2 of the License, or (at your
-* option) any later version.
-*
-* You should have received a copy of the GNU General Public License
-* along with this program; if not, write to the Free Software
-* Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-*
-******************************************************************************/
-/*****************************************************************************/
-/**
-*
-* @file xsysace_l.h
-*
-* Defines identifiers and low-level macros/functions for the XSysAce driver.
-* These identifiers include register offsets and bit masks. A high-level driver
-* interface is defined in xsysace.h.
-*
-* <pre>
-* MODIFICATION HISTORY:
-*
-* Ver   Who  Date     Changes
-* ----- ---- -------- -----------------------------------------------
-* 1.00a rpm  06/14/02 work in progress
-* 1.01a jvb  02/01/06 Added include of xparameters.h unless EXT_CONFIG is
-*                     defined at compile time (external configuration), in
-*                     which case it just defaults to 8-bit wide memory.
-* </pre>
-*
-******************************************************************************/
-
-#ifndef XSYSACE_L_H		/* prevent circular inclusions */
-#define XSYSACE_L_H		/* by using protection macros */
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-/***************************** Include Files *********************************/
-
-#ifdef EXT_CONFIG
-#define XPAR_XSYSACE_MEM_WIDTH 8
-#else
-#include "xparameters.h"
-#endif
-#include "xbasic_types.h"
-#include "xio.h"
-
-/************************** Constant Definitions *****************************/
-
-/*
- * Constant used to align the register offsets to the proper address. This was
- * used during development to handle both byte-addressable (alignment=1) and
- * word addressable (alignment=4) registers. The #ifndef allows the user to
- * modify this at compile-time.
- */
-#ifndef XSA_ADDR_ALIGN
-#define XSA_ADDR_ALIGN      1
-#endif
-
-/** @name Register Offsets
- * System ACE register offsets
- * @{
- */
-#define XSA_BMR_OFFSET   (XSA_ADDR_ALIGN * 0)  /**< Bus mode (BUSMODEREG) */
-#define XSA_SR_OFFSET    (XSA_ADDR_ALIGN * 4)  /**< Status (STATUSREG) */
-#define XSA_ER_OFFSET    (XSA_ADDR_ALIGN * 8)  /**< Error (ERRORREG) */
-#define XSA_CLR_OFFSET   (XSA_ADDR_ALIGN * 12) /**< Config LBA (CFGLBAREG) */
-#define XSA_MLR_OFFSET   (XSA_ADDR_ALIGN * 16) /**< MPU LBA (MPULBAREG) */
-#define XSA_SCCR_OFFSET  (XSA_ADDR_ALIGN * 20) /**< Sector cnt (SECCNTCMDREG) */
-#define XSA_VR_OFFSET    (XSA_ADDR_ALIGN * 22) /**< Version (VERSIONREG) */
-#define XSA_CR_OFFSET    (XSA_ADDR_ALIGN * 24) /**< Control (CONTROLREG) */
-#define XSA_FSR_OFFSET   (XSA_ADDR_ALIGN * 28) /**< FAT status (FATSTATREG) */
-#define XSA_DBR_OFFSET   (XSA_ADDR_ALIGN * 64) /**< Data buffer (DATABUFREG) */
-/*@}*/
-
-/*
- * Bus Mode Register masks
- */
-#define XSA_BMR_16BIT_MASK      0x0101	/**< 16-bit access to ACE controller */
-
-
-/** @name Status Values
- * Status Register masks
- * @{
- */
-#define XSA_SR_CFGLOCK_MASK     0x00000001  /**< Config port lock status */
-#define XSA_SR_MPULOCK_MASK     0x00000002  /**< MPU port lock status */
-#define XSA_SR_CFGERROR_MASK    0x00000004  /**< Config port error status */
-#define XSA_SR_CFCERROR_MASK    0x00000008  /**< CF error status */
-#define XSA_SR_CFDETECT_MASK    0x00000010  /**< CF detect flag */
-#define XSA_SR_DATABUFRDY_MASK  0x00000020  /**< Data buffer ready status */
-#define XSA_SR_DATABUFMODE_MASK 0x00000040  /**< Data buffer mode status */
-#define XSA_SR_CFGDONE_MASK     0x00000080  /**< Configuration done status */
-#define XSA_SR_RDYFORCMD_MASK   0x00000100  /**< Ready for CF command */
-#define XSA_SR_CFGMODE_MASK     0x00000200  /**< Configuration mode status */
-#define XSA_SR_CFGADDR_MASK     0x0000E000  /**< Configuration address  */
-#define XSA_SR_CFBSY_MASK       0x00020000  /**< CF busy (BSY bit) */
-#define XSA_SR_CFRDY_MASK       0x00040000  /**< CF ready (RDY bit) */
-#define XSA_SR_CFDWF_MASK       0x00080000  /**< CF data write fault (DWF bit) */
-#define XSA_SR_CFDSC_MASK       0x00100000  /**< CF ready (DSC bit) */
-#define XSA_SR_CFDRQ_MASK       0x00200000  /**< CF data request (DRQ) */
-#define XSA_SR_CFCORR_MASK      0x00400000  /**< CF correctable error (CORR bit) */
-#define XSA_SR_CFERR_MASK       0x00800000  /**< CF error (ERR bit) */
-/*@}*/
-
-
-/** @name Error Values
- * Error Register masks.
- * @{
- */
-#define XSA_ER_CARD_RESET    0x00000001	 /**< CF card failed to reset */
-#define XSA_ER_CARD_READY    0x00000002	 /**< CF card failed to ready */
-#define XSA_ER_CARD_READ     0x00000004	 /**< CF read command failed */
-#define XSA_ER_CARD_WRITE    0x00000008	 /**< CF write command failed */
-#define XSA_ER_SECTOR_READY  0x00000010	 /**< CF sector failed to ready */
-#define XSA_ER_CFG_ADDR      0x00000020	 /**< Cfg address is invalid */
-#define XSA_ER_CFG_FAIL      0x00000040	 /**< Failed to configure a device */
-#define XSA_ER_CFG_READ      0x00000080	 /**< Cfg read of CF failed */
-#define XSA_ER_CFG_INSTR     0x00000100	 /**< Invalid instruction during cfg */
-#define XSA_ER_CFG_INIT      0x00000200	 /**< CFGINIT pin error - did not
-                                          *   go high within 500ms of start */
-#define XSA_ER_RESERVED      0x00000400	 /**< reserved */
-#define XSA_ER_BAD_BLOCK     0x00000800	 /**< CF bad block detected */
-#define XSA_ER_UNCORRECTABLE 0x00001000	 /**< CF uncorrectable error */
-#define XSA_ER_SECTOR_ID     0x00002000	 /**< CF sector ID not found */
-#define XSA_ER_ABORT         0x00004000	 /**< CF command aborted */
-#define XSA_ER_GENERAL       0x00008000	 /**< CF general error */
-/*@}*/
-
-
-/**
- * Config LBA Register - address mask
- */
-#define XSA_CLR_LBA_MASK    0x0FFFFFFF	/* Logical Block Address mask */
-
-/**
- * MPU LBA Register - address mask
- */
-#define XSA_MLR_LBA_MASK    0x0FFFFFFF	/* Logical Block Address mask */
-
-
-/** @name Sector Cound/Command Values
- * Sector Count Command Register masks
- * @{
- */
-#define XSA_SCCR_COUNT_MASK     0x00FF	 /**< Sector count mask */
-#define XSA_SCCR_RESET_MASK     0x0100	 /**< Reset CF card command */
-#define XSA_SCCR_IDENTIFY_MASK  0x0200	 /**< Identify CF card command */
-#define XSA_SCCR_READDATA_MASK  0x0300	 /**< Read CF card command */
-#define XSA_SCCR_WRITEDATA_MASK 0x0400	 /**< Write CF card command */
-#define XSA_SCCR_ABORT_MASK     0x0600	 /**< Abort CF command */
-#define XSA_SCCR_CMD_MASK       0x0700	 /**< Command mask */
-/*@}*/
-
-
-/*
- * Version Register masks
- */
-#define XSA_VR_BUILD_MASK   0x00FF	/* Revision/build number */
-#define XSA_VR_MINOR_MASK   0x0F00	/* Minor version number */
-#define XSA_VR_MAJOR_MASK   0xF000	/* Major version number */
-
-
-/** @name Control Values
- * Control Register masks
- * @{
- */
-#define XSA_CR_FORCELOCK_MASK       0x00000001	/**< Force lock request */
-#define XSA_CR_LOCKREQ_MASK         0x00000002	/**< MPU lock request */
-#define XSA_CR_FORCECFGADDR_MASK    0x00000004	/**< Force CFG address */
-#define XSA_CR_FORCECFGMODE_MASK    0x00000008	/**< Force CFG mode */
-#define XSA_CR_CFGMODE_MASK         0x00000010	/**< CFG mode */
-#define XSA_CR_CFGSTART_MASK        0x00000020	/**< CFG start */
-#define XSA_CR_CFGSEL_MASK          0x00000040	/**< CFG select */
-#define XSA_CR_CFGRESET_MASK        0x00000080	/**< CFG reset */
-#define XSA_CR_DATARDYIRQ_MASK      0x00000100	/**< Enable data ready IRQ */
-#define XSA_CR_ERRORIRQ_MASK        0x00000200	/**< Enable error IRQ */
-#define XSA_CR_CFGDONEIRQ_MASK      0x00000400	/**< Enable CFG done IRQ */
-#define XSA_CR_RESETIRQ_MASK        0x00000800	/**< Reset IRQ line */
-#define XSA_CR_CFGPROG_MASK         0x00001000	/**< Inverted CFGPROG pin */
-#define XSA_CR_CFGADDR_MASK         0x0000E000	/**< Config address mask */
-#define XSA_CR_CFGADDR_SHIFT                13	/**< Config address shift */
-/*@}*/
-
-
-/** @name FAT Status
- *
- * FAT filesystem status masks. The first valid partition of the CF
- * is a FAT partition.
- * @{
- */
-#define XSA_FAT_VALID_BOOT_REC  0x0001	/**< Valid master boot record */
-#define XSA_FAT_VALID_PART_REC  0x0002	/**< Valid partition boot record */
-#define XSA_FAT_12_BOOT_REC     0x0004	/**< FAT12 in master boot rec */
-#define XSA_FAT_12_PART_REC     0x0008	/**< FAT12 in parition boot rec */
-#define XSA_FAT_16_BOOT_REC     0x0010	/**< FAT16 in master boot rec */
-#define XSA_FAT_16_PART_REC     0x0020	/**< FAT16 in partition boot rec */
-#define XSA_FAT_12_CALC         0x0040	/**< Calculated FAT12 from clusters */
-#define XSA_FAT_16_CALC         0x0080	/**< Calculated FAT16 from clusters */
-/*@}*/
-
-
-#define XSA_DATA_BUFFER_SIZE    32   /**< Size of System ACE data buffer */
-#define XSA_CF_SECTOR_SIZE     512   /**< Number of bytes in a CF sector */
-
-/**************************** Type Definitions *******************************/
-
-
-/***************** Macros (Inline Functions) Definitions *********************/
-
-/*****************************************************************************
-*
-* Low-level driver macros and functions. The list below provides signatures
-* to help the user use the macros.
-*
-* u32 XSysAce_mGetControlReg(u32 BaseAddress)
-* void XSysAce_mSetControlReg(u32 BaseAddress, u32 Data)
-* void XSysAce_mOrControlReg(u32 BaseAddress, u32 Data)
-* void XSysAce_mAndControlReg(u32 BaseAddress, u32 Data)
-* u32 XSysAce_mGetErrorReg(u32 BaseAddress)
-* u32 XSysAce_mGetStatusReg(u32 BaseAddress)
-*
-* void XSysAce_mSetCfgAddr(u32 BaseAddress, unsigned int Address)
-* void XSysAce_mWaitForLock(u32 BaseAddress)
-* void XSysAce_mEnableIntr(u32 BaseAddress, u32 Mask)
-* void XSysAce_mDisableIntr(u32 BaseAddress, u32 Mask)
-*
-* u32 XSysAce_mIsReadyForCmd(u32 BaseAddress)
-* u32 XSysAce_mIsCfgDone(u32 BaseAddress)
-* u32 XSysAce_mIsMpuLocked(u32 BaseAddress)
-* u32 XSysAce_mIsIntrEnabled(u32 BaseAddress)
-*
-*****************************************************************************/
-
-
-/*****************************************************************************/
-/**
-*
-* Get the contents of the control register.
-*
-* @param    BaseAddress is the base address of the device.
-*
-* @return   The 32-bit value of the control register.
-*
-* @note     None.
-*
-******************************************************************************/
-#define XSysAce_mGetControlReg(BaseAddress) \
-                XSysAce_RegRead32((BaseAddress) + XSA_CR_OFFSET)
-
-
-/*****************************************************************************/
-/**
-*
-* Set the contents of the control register.
-*
-* @param    BaseAddress is the base address of the device.
-* @param    Data is the 32-bit value to write to the register.
-*
-* @return   None.
-*
-* @note     None.
-*
-******************************************************************************/
-#define XSysAce_mSetControlReg(BaseAddress, Data) \
-                XSysAce_RegWrite32((BaseAddress) + XSA_CR_OFFSET, (Data))
-
-
-/*****************************************************************************/
-/**
-*
-* Set the contents of the control register to the value specified OR'ed with
-* its current contents.
-*
-* @param    BaseAddress is the base address of the device.
-* @param    Data is the 32-bit value to OR with the register.
-*
-* @return   None.
-*
-* @note     None.
-*
-******************************************************************************/
-#define XSysAce_mOrControlReg(BaseAddress, Data) \
-                XSysAce_mSetControlReg((BaseAddress), \
-                        XSysAce_mGetControlReg(BaseAddress) | (Data))
-
-
-/*****************************************************************************/
-/**
-*
-* Set the contents of the control register to the value specified AND'ed with
-* its current contents.
-*
-* @param    BaseAddress is the base address of the device.
-* @param    Data is the 32-bit value to AND with the register.
-*
-* @return   None.
-*
-* @note     None.
-*
-******************************************************************************/
-#define XSysAce_mAndControlReg(BaseAddress, Data) \
-                XSysAce_mSetControlReg((BaseAddress), \
-                        XSysAce_mGetControlReg(BaseAddress) & (Data))
-
-
-/*****************************************************************************/
-/**
-*
-* Get the contents of the error register.
-*
-* @param    BaseAddress is the base address of the device.
-*
-* @return   The 32-bit value of the register.
-*
-* @note     None.
-*
-******************************************************************************/
-#define XSysAce_mGetErrorReg(BaseAddress) \
-                XSysAce_RegRead32((BaseAddress) + XSA_ER_OFFSET)
-
-
-/*****************************************************************************/
-/**
-*
-* Get the contents of the status register.
-*
-* @param    BaseAddress is the base address of the device.
-*
-* @return   The 32-bit value of the register.
-*
-* @note     None.
-*
-******************************************************************************/
-#define XSysAce_mGetStatusReg(BaseAddress) \
-                XSysAce_RegRead32((BaseAddress) + XSA_SR_OFFSET)
-
-
-/*****************************************************************************/
-/**
-*
-* Set the configuration address, or file, of the CompactFlash. This address
-* indicates which .ace bitstream to use to configure the target FPGA chain.
-*
-* @param    BaseAddress is the base address of the device.
-* @param    Address ranges from 0 to 7 and represents the eight possible .ace
-*           bitstreams that can reside on the CompactFlash.
-*
-* @return   None.
-*
-* @note     Used cryptic var names to avoid conflict with caller's var names.
-*
-******************************************************************************/
-#define XSysAce_mSetCfgAddr(BaseAddress, Address)                             \
-{                                                                             \
-    u32 A66rMask = ((Address) << XSA_CR_CFGADDR_SHIFT) & XSA_CR_CFGADDR_MASK; \
-    u32 C0ntr0l = XSysAce_mGetControlReg(BaseAddress);                    \
-    C0ntr0l &= ~XSA_CR_CFGADDR_MASK;    /* clear current address */           \
-    C0ntr0l |= (A66rMask | XSA_CR_FORCECFGADDR_MASK);                         \
-    XSysAce_mSetControlReg((BaseAddress), C0ntr0l);                           \
-}
-
-
-/*****************************************************************************/
-/**
-*
-* Request then wait for the MPU lock. This is not a forced lock, so we must
-* contend with the configuration controller.
-*
-* @param    BaseAddress is the base address of the device.
-*
-* @return   None.
-*
-* @note     None.
-*
-******************************************************************************/
-#define XSysAce_mWaitForLock(BaseAddress)                                    \
-{                                                                            \
-    XSysAce_mOrControlReg((BaseAddress), XSA_CR_LOCKREQ_MASK);               \
-    while ((XSysAce_mGetStatusReg(BaseAddress) & XSA_SR_MPULOCK_MASK) == 0); \
-}
-
-/*****************************************************************************/
-/**
-*
-* Enable ACE controller interrupts.
-*
-* @param    BaseAddress is the base address of the device.
-*
-* @return   None.
-*
-* @note     None.
-*
-******************************************************************************/
-#define XSysAce_mEnableIntr(BaseAddress, Mask) \
-            XSysAce_mOrControlReg((BaseAddress), (Mask));
-
-
-/*****************************************************************************/
-/**
-*
-* Disable ACE controller interrupts.
-*
-* @param    BaseAddress is the base address of the device.
-*
-* @return   None.
-*
-* @note     None.
-*
-******************************************************************************/
-#define XSysAce_mDisableIntr(BaseAddress, Mask) \
-            XSysAce_mAndControlReg((BaseAddress), ~(Mask));
-
-
-/*****************************************************************************/
-/**
-*
-* Is the CompactFlash ready for a command?
-*
-* @param    BaseAddress is the base address of the device.
-*
-* @return   TRUE if it is ready, FALSE otherwise.
-*
-* @note     None.
-*
-******************************************************************************/
-#define XSysAce_mIsReadyForCmd(BaseAddress) \
-            (XSysAce_mGetStatusReg(BaseAddress) & XSA_SR_RDYFORCMD_MASK)
-
-
-/*****************************************************************************/
-/**
-*
-* Is the ACE controller locked for MPU access?
-*
-* @param    BaseAddress is the base address of the device.
-*
-* @return   TRUE if it is locked, FALSE otherwise.
-*
-* @note     None.
-*
-******************************************************************************/
-#define XSysAce_mIsMpuLocked(BaseAddress) \
-                (XSysAce_mGetStatusReg(BaseAddress) & XSA_SR_MPULOCK_MASK)
-
-
-/*****************************************************************************/
-/**
-*
-* Is the CompactFlash configuration of the target FPGA chain complete?
-*
-* @param    BaseAddress is the base address of the device.
-*
-* @return   TRUE if it is ready, FALSE otherwise.
-*
-* @note     None.
-*
-******************************************************************************/
-#define XSysAce_mIsCfgDone(BaseAddress) \
-            (XSysAce_mGetStatusReg(BaseAddress) & XSA_SR_CFGDONE_MASK)
-
-
-/*****************************************************************************/
-/**
-*
-* Have interrupts been enabled by the user? We look for the interrupt reset
-* bit to be clear (meaning interrupts are armed, even though none may be
-* individually enabled).
-*
-* @param    BaseAddress is the base address of the device.
-*
-* @return   TRUE if it is enabled, FALSE otherwise.
-*
-* @note     None.
-*
-******************************************************************************/
-#define XSysAce_mIsIntrEnabled(BaseAddress) \
-            ((XSysAce_mGetControlReg(BaseAddress) & XSA_CR_RESETIRQ_MASK) == 0)
-
-
-/************************** Function Prototypes ******************************/
-
-int XSysAce_ReadSector(u32 BaseAddress, u32 SectorId, u8 *BufferPtr);
-int XSysAce_WriteSector(u32 BaseAddress, u32 SectorId, u8 *BufferPtr);
-
-/*
- * Utility functions to read and write registers and data buffer
- */
-u32 XSysAce_RegRead32(u32 Address);
-u16 XSysAce_RegRead16(u32 Address);
-void XSysAce_RegWrite32(u32 Address, u32 Data);
-void XSysAce_RegWrite16(u32 Address, u16 Data);
-
-int XSysAce_ReadDataBuffer(u32 BaseAddress, u8 *BufferPtr, int NumBytes);
-int XSysAce_WriteDataBuffer(u32 BaseAddress, u8 *BufferPtr, int NumBytes);
-
-#ifdef __cplusplus
-}
-#endif
-
-
-#endif /* end of protection macro */
diff --git a/drivers/block/xilinx_sysace/xsysace_linux.c b/drivers/block/xilinx_sysace/xsysace_linux.c
deleted file mode 100644
index 9a13470..0000000
--- a/drivers/block/xilinx_sysace/xsysace_linux.c
+++ /dev/null
@@ -1,617 +0,0 @@
-/*
- * drivers/block/xilinx_sysace/xsysace_linux.c
- *
- * Xilinx System ACE xsysace component to interface System ACE to Linux
- *
- * Authors: Dmitry Chigirev  <chigirev@ru.mvista.com>
- *          Sergey Podstavin <spodstavin@ru.mvista.com>
- *
- * 2002-2005 (c) MontaVista Software, Inc. This file is licensed under
- * the terms of the GNU General Public License version 2. This program
- * is licensed "as is" without any warranty of any kind, whether express
- * or implied.
- */
-
-/*
- * Through System ACE, the processor can access the CompactFlash and the
- * JTAG chain.  In addition, the System ACE controls system reset and
- * which configuration will be loaded into the JTAG chain at that time.
- * This driver provides two different interfaces.  The first is handling
- * reset by tying into the system's reset code as well as providing a
- * /proc interface to read and write which configuration should be used
- * when the system is reset.  The second is to expose a block interface
- * to the CompactFlash.
- *
- * This driver is a bit unusual in that it is composed of two logical
- * parts where one part is the OS independent code and the other part is
- * the OS dependent code.  Xilinx provides their drivers split in this
- * fashion.  This file represents the Linux OS dependent part known as
- * the Linux xsysace.  The other files in this directory are the OS
- * independent files as provided by Xilinx with no changes made to them.
- * The names exported by those files begin with XSysAce_.  All functions
- * in this file that are called by Linux have names that begin with
- * xsysace_.  Any other functions are static helper functions.
- */
-
-#include <linux/module.h>
-#include <linux/init.h>
-#include <linux/proc_fs.h>
-#include <linux/hdreg.h>
-#include <linux/slab.h>
-#include <linux/blkpg.h>
-#include <linux/interrupt.h>
-#include <linux/blkdev.h>
-#include <linux/delay.h>
-#include <linux/xilinx_devices.h>
-#include <asm/io.h>
-#include <asm/irq.h>
-#include <asm/uaccess.h>
-#include <asm/machdep.h>
-#include "xbasic_types.h"
-#include "xsysace.h"
-
-static DEFINE_SPINLOCK(xsysace_lock);
-
-/* Use xsa_major to support non-devfs configuration */
-static int xsa_major = 125;
-
-#define MAJOR_NAME "xsa"
-#define DEVICE_NAME "System ACE"
-
-static u32 xsa_phys_addr;	/* Saved physical base address */
-static unsigned long xsa_remap_size;
-static int xsa_irq;
-
-static void (*old_restart) (char *cmd) = NULL;	/* old ppc_md.restart */
-
-static unsigned char heads;
-static unsigned char sectors;
-static unsigned short cylinders;
-
-struct gendisk *xsa_gendisk;
-
-static struct request *xsysace_req;	/* current request */
-static struct request_queue *xsysace_queue;	/* current queue */
-
-static void do_read_write(struct work_struct *work);
-static DECLARE_WORK(xsysace_read_write_work, do_read_write);
-
-/*
- * The underlying OS independent code needs space as well.  A pointer to
- * the following XSysAce structure will be passed to any XSysAce_
- * function that requires it.
- */
-static XSysAce SysAce;
-
-static void xsa_complete_request(int get_uptodate);
-
-/*req_fnc will be XSysAce_SectorRead or XSysAce_SectorWrite.  */
-static int (*req_fnc) (XSysAce * InstancePtr, u32 StartSector,
-		       int NumSectors, u8 *BufferPtr);
-
-/* req_str will be used for errors and will be either "reading" or "writing" */
-static char *req_str;
-
-/*******************************************************************************
- * This configuration stuff should become unnecessary after EDK version 8.x is
- * released.
- ******************************************************************************/
-
-static DECLARE_MUTEX(cfg_sem);
-
-/*
- * The following block of code implements the reset handling.  The first
- * part implements /proc/xsysace/cfgaddr.  When read, it will yield a
- * number from 0 to 7 that represents which configuration will be used
- * next (the configuration address).  Writing a number to it will change
- * the configuration address.  After that is the function that is hooked
- * into the system's reset handler.
- */
-#ifndef CONFIG_PROC_FS
-#define proc_init() 0
-#define proc_cleanup()
-#else
-#define CFGADDR_NAME "cfgaddr"
-static struct proc_dir_entry *xsysace_dir = NULL;
-static struct proc_dir_entry *cfgaddr_file = NULL;
-
-static unsigned int XSysAce_GetCfgAddr(XSysAce * InstancePtr)
-{
-	u32 Status;
-
-	XASSERT_NONVOID(InstancePtr != NULL);
-	XASSERT_NONVOID(InstancePtr->IsReady == XCOMPONENT_IS_READY);
-
-	Status = XSysAce_mGetControlReg(InstancePtr->BaseAddress);
-	if (!(Status & XSA_CR_FORCECFGADDR_MASK))
-		Status = XSysAce_mGetStatusReg(InstancePtr->BaseAddress);
-
-	return (unsigned int) ((Status & XSA_SR_CFGADDR_MASK) >>
-			       XSA_CR_CFGADDR_SHIFT);
-}
-
-static int cfgaddr_read(char *page, char **start,
-			off_t off, int count, int *eof, void *data)
-{
-	unsigned int cfgaddr;
-
-	/* Make sure we have room for a digit (0-7), a newline and a NULL */
-	if (count < 3)
-		return -EINVAL;
-
-	cfgaddr = XSysAce_GetCfgAddr(&SysAce);
-	count = sprintf(page + off, "%d\n", cfgaddr);
-	*eof = 1;
-	return count;
-}
-
-static int cfgaddr_write(struct file *file,
-			 const char *buffer, unsigned long count, void *data)
-{
-	char val[2];
-
-	if (count < 1 || count > 2)
-		return -EINVAL;
-
-	if (copy_from_user(val, buffer, count)) {
-		return -EFAULT;
-	}
-
-	if (val[0] < '0' || val[0] > '7' || (count == 2 && !(val[1] == '\n' ||
-							     val[1] == '\0'))) {
-		return -EINVAL;
-	}
-
-	XSysAce_SetCfgAddr(&SysAce, val[0] - '0');
-	return count;
-}
-
-static int proc_init(void)
-{
-	xsysace_dir = proc_mkdir(MAJOR_NAME, NULL);
-	if (!xsysace_dir)
-		return -ENOMEM;
-	xsysace_dir->owner = THIS_MODULE;
-
-	cfgaddr_file = create_proc_entry(CFGADDR_NAME, 0644, xsysace_dir);
-	if (!cfgaddr_file) {
-		remove_proc_entry(MAJOR_NAME, NULL);
-		return -ENOMEM;
-	}
-	cfgaddr_file->read_proc = cfgaddr_read;
-	cfgaddr_file->write_proc = cfgaddr_write;
-	cfgaddr_file->owner = THIS_MODULE;
-	return 0;
-}
-
-static void proc_cleanup(void)
-{
-	if (cfgaddr_file)
-		remove_proc_entry(CFGADDR_NAME, xsysace_dir);
-	if (xsysace_dir)
-		remove_proc_entry(MAJOR_NAME, NULL);
-}
-#endif /* CONFIG_PROC_FS */
-
-static void xsysace_restart(char *cmd)
-{
-	XSysAce_ResetCfg(&SysAce);
-
-	/* Wait for reset. */
-	for (;;);
-}
-
-/* Simple function that hands an interrupt to the Xilinx code. */
-static irqreturn_t xsysace_interrupt(int irq, void *dev_id)
-{
-	XSysAce_InterruptHandler(&SysAce);
-	return IRQ_HANDLED;
-}
-
-void xsysace_end_request(struct request *req, int uptodate)
-{
-	if (!end_that_request_first(req, uptodate, req->hard_cur_sectors)) {
-		blkdev_dequeue_request(req);
-		end_that_request_last(req, 1);
-	}
-}
-
-static void xsa_complete_request(int uptodate)
-{
-	XSysAce_Unlock(&SysAce);
-	spin_lock_irq(&xsysace_lock);
-	xsysace_end_request(xsysace_req, uptodate);
-	xsysace_req = 0;
-	spin_unlock_irq(&xsysace_lock);
-	schedule_work(&xsysace_read_write_work);
-}
-
-static void do_read_write(struct work_struct *work)
-{
-	int stat;
-	struct request *req;
-	request_queue_t *q;
-
-	q = xsysace_queue;
-	spin_lock_irq(&xsysace_lock);
-
-	if (blk_queue_plugged(q)) {
-		printk(KERN_ERR "XSysAce: Queue is plugged\n");
-		spin_unlock_irq(&xsysace_lock);
-		return;
-	}
-
-	while ((req = elv_next_request(q)) != NULL) {
-		if (!blk_fs_request(req)) {
-			printk(KERN_NOTICE "Skip non-fs request\n");
-			xsysace_end_request(req, 0);
-			continue;
-		}
-		if (rq_data_dir(req) == WRITE) {
-			req_str = "writing";
-			req_fnc = XSysAce_SectorWrite;
-		}
-		else {
-			req_str = "reading";
-			req_fnc = XSysAce_SectorRead;
-		}
-		xsysace_req = req;
-		break;
-	}
-	spin_unlock_irq(&xsysace_lock);
-
-	if (!req)
-		return;
-
-	/* We have a request. */
-	while ((stat = XSysAce_Lock(&SysAce, 0)) == XST_DEVICE_BUSY) {
-		msleep_interruptible(1);
-	}
-	if (stat != XST_SUCCESS) {
-		printk(KERN_ERR "%s: Error %d when locking.\n",
-		       DEVICE_NAME, stat);
-		xsa_complete_request(0);	/* Request failed. */
-	}
-
-	while ((stat = req_fnc(&SysAce, xsysace_req->sector,
-			       xsysace_req->current_nr_sectors,
-			       xsysace_req->buffer)) == XST_DEVICE_BUSY) {
-		msleep_interruptible(1);
-	}
-	/*
-	 * If the stat is XST_SUCCESS, we have successfully
-	 * gotten the request started on the hardware.  The
-	 * completion (or error) interrupt will unlock the
-	 * CompactFlash and complete the request, so we don't
-	 * need to do anything except just loop around and wait
-	 * for the next request.  If the status is not
-	 * XST_SUCCESS, we need to finish the request with an
-	 * error before waiting for the next request.
-	 */
-	if (stat != XST_SUCCESS) {
-		printk(KERN_ERR "%s: Error %d when %s sector %lu.\n",
-		       DEVICE_NAME, stat, req_str, xsysace_req->sector);
-		xsa_complete_request(0);	/* Request failed. */
-	}
-}
-
-static void xsysace_do_request(request_queue_t * q)
-{
-	/* We're already handling a request.  Don't accept another. */
-	if (xsysace_req)
-		return;
-	schedule_work(&xsysace_read_write_work);
-}
-
-/* Called by the Xilinx interrupt handler to give us an event. */
-static void EventHandler(void *CallbackRef, int Event)
-{
-	u32 ErrorMask;
-
-	switch (Event) {
-	case XSA_EVENT_DATA_DONE:
-		xsa_complete_request(1);	/* The request succeeded. */
-		break;
-
-	case XSA_EVENT_ERROR:
-		ErrorMask = XSysAce_GetErrors(&SysAce);
-		/* Print out what went wrong. */
-		if (ErrorMask & XSA_ER_CARD_RESET)
-			printk(KERN_ERR "CompactFlash failed to reset\n");
-		if (ErrorMask & XSA_ER_CARD_READY)
-			printk(KERN_ERR "CompactFlash failed to ready\n");
-		if (ErrorMask & XSA_ER_CARD_READ)
-			printk(KERN_ERR "CompactFlash read command failed\n");
-		if (ErrorMask & XSA_ER_CARD_WRITE)
-			printk(KERN_ERR "CompactFlash write command failed\n");
-		if (ErrorMask & XSA_ER_SECTOR_READY)
-			printk(KERN_ERR
-			       "CompactFlash sector failed to ready\n");
-		if (ErrorMask & XSA_ER_BAD_BLOCK)
-			printk(KERN_ERR "CompactFlash bad block detected\n");
-		if (ErrorMask & XSA_ER_UNCORRECTABLE)
-			printk(KERN_ERR "CompactFlash uncorrectable error\n");
-		if (ErrorMask & XSA_ER_SECTOR_ID)
-			printk(KERN_ERR "CompactFlash sector ID not found\n");
-		if (ErrorMask & XSA_ER_ABORT)
-			printk(KERN_ERR "CompactFlash command aborted\n");
-		if (ErrorMask & XSA_ER_GENERAL)
-			printk(KERN_ERR "CompactFlash general error\n");
-
-		if (ErrorMask & XSA_ER_CFG_READ)
-			printk(KERN_ERR
-			       "JTAG controller couldn't read configuration from the CompactFlash\n");
-		if (ErrorMask & XSA_ER_CFG_ADDR)
-			printk(KERN_ERR
-			       "Invalid address given to JTAG controller\n");
-		if (ErrorMask & XSA_ER_CFG_FAIL)
-			printk(KERN_ERR
-			       "JTAG controller failed to configure a device\n");
-		if (ErrorMask & XSA_ER_CFG_INSTR)
-			printk(KERN_ERR
-			       "Invalid instruction during JTAG configuration\n");
-		if (ErrorMask & XSA_ER_CFG_INIT)
-			printk(KERN_ERR "JTAG CFGINIT pin error\n");
-
-		/* Check for errors that should reset the CompactFlash */
-		if (ErrorMask & (XSA_ER_CARD_RESET |
-				 XSA_ER_CARD_READY |
-				 XSA_ER_CARD_READ |
-				 XSA_ER_CARD_WRITE |
-				 XSA_ER_SECTOR_READY |
-				 XSA_ER_BAD_BLOCK |
-				 XSA_ER_UNCORRECTABLE |
-				 XSA_ER_SECTOR_ID | XSA_ER_ABORT |
-				 XSA_ER_GENERAL)) {
-			if (XSysAce_ResetCF(&SysAce) != XST_SUCCESS)
-				printk(KERN_ERR
-				       "Could not reset CompactFlash\n");
-			xsa_complete_request(0);	/* The request failed. */
-		}
-		break;
-	case XSA_EVENT_CFG_DONE:
-		printk(KERN_WARNING "XSA_EVENT_CFG_DONE not handled yet.\n");
-		break;
-	default:
-		printk(KERN_ERR "%s: unrecognized event %d\n",
-		       DEVICE_NAME, Event);
-		break;
-	}
-}
-
-static int
-xsysace_ioctl(struct inode *inode, struct file *file,
-	      unsigned int cmd, unsigned long arg)
-{
-	struct hd_geometry __user *geo = (struct hd_geometry __user *) arg;
-	struct hd_geometry g;
-
-	switch (cmd) {
-	case HDIO_GETGEO:
-		{
-			g.heads = heads;
-			g.sectors = sectors;
-			g.cylinders = cylinders;
-			g.start = 0;
-			return copy_to_user(geo, &g, sizeof(g)) ? -EFAULT : 0;
-		}
-	default:
-		return -ENOTTY;
-	}
-}
-
-static struct block_device_operations xsysace_fops = {
-	.owner = THIS_MODULE,
-	.ioctl = xsysace_ioctl,
-};
-
-/******************************
- * The platform device driver *
- ******************************/
-
-/*
- * Currently the driver supports just one System ACE device.
- * Most of the code below could be easily extended to handle
- * several devices except for proc_init()/proc_cleanup() and
- * ppc_md.restart handling.
- */
-
-#define DRIVER_NAME		"xsysace"
-
-static int xsysace_probe(struct device *dev)
-{
-	XSysAce_Config xsysace_cfg;
-	struct platform_device *pdev = to_platform_device(dev);
-	struct resource *irq_res, *regs_res;
-	unsigned long remap_size;
-	int stat;
-	long size;
-	XSysAce_CFParameters ident;
-	int retval;
-
-	if (!dev)
-		return -EINVAL;
-
-	/* Find irq number, map the control registers in */
-	irq_res = platform_get_resource(pdev, IORESOURCE_IRQ, 0);
-	regs_res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
-	if (!regs_res || !irq_res) {
-		printk(KERN_ERR "%s #%d: IO resource(s) not found\n",
-		       DRIVER_NAME, pdev->id);
-		retval = -EFAULT;
-		goto failed1;
-	}
-	xsa_irq = irq_res->start;
-	xsa_phys_addr = regs_res->start;
-	remap_size = regs_res->end - regs_res->start + 1;
-	if (!request_mem_region(regs_res->start, remap_size, DRIVER_NAME)) {
-		printk(KERN_ERR
-		       "%s #%d: Couldn't lock memory region at 0x%08X\n",
-		       DRIVER_NAME, pdev->id, regs_res->start);
-		retval = -EBUSY;
-		goto failed1;
-	}
-
-	/* Fill in cfg data and add them to the list */
-	xsa_remap_size = remap_size;
-	xsysace_cfg.DeviceId = pdev->id;
-	xsysace_cfg.BaseAddress = (u32) ioremap(regs_res->start, remap_size);
-	if (xsysace_cfg.BaseAddress == 0) {
-		printk(KERN_ERR
-		       "%s #%d: Couldn't ioremap memory at 0x%08X\n",
-		       DRIVER_NAME, pdev->id, regs_res->start);
-		retval = -EFAULT;
-		goto failed2;
-	}
-
-	/* Tell the Xilinx code to bring this SystemACE interface up. */
-	down(&cfg_sem);
-	if (XSysAce_CfgInitialize
-	    (&SysAce, &xsysace_cfg, xsysace_cfg.BaseAddress) != XST_SUCCESS) {
-		up(&cfg_sem);
-		printk(KERN_ERR
-		       "%s #%d: Could not initialize device.\n",
-		       DRIVER_NAME, pdev->id);
-		retval = -ENODEV;
-		goto failed3;
-	}
-	up(&cfg_sem);
-
-	retval = request_irq(xsa_irq, xsysace_interrupt, 0, DEVICE_NAME, NULL);
-	if (retval) {
-		printk(KERN_ERR
-		       "%s #%d: Couldn't allocate interrupt %d.\n",
-		       DRIVER_NAME, pdev->id, xsa_irq);
-		goto failed3;
-	}
-
-	XSysAce_SetEventHandler(&SysAce, EventHandler, (void *) NULL);
-	XSysAce_EnableInterrupt(&SysAce);
-
-	/* Time to identify the drive. */
-	while (XSysAce_Lock(&SysAce, 0) == XST_DEVICE_BUSY);
-	while ((stat = XSysAce_IdentifyCF(&SysAce, &ident)) == XST_DEVICE_BUSY);
-	XSysAce_Unlock(&SysAce);
-	if (stat != XST_SUCCESS) {
-		printk(KERN_ERR "%s: Could not send identify command.\n",
-		       DEVICE_NAME);
-		retval = -ENODEV;
-		goto failed4;
-	}
-
-	/* Fill in what we learned. */
-	heads = ident.NumHeads;
-	sectors = ident.NumSectorsPerTrack;
-	cylinders = ident.NumCylinders;
-	size = (long) cylinders *(long) heads *(long) sectors;
-
-	xsysace_queue = blk_init_queue(xsysace_do_request, &xsysace_lock);
-	if (!xsysace_queue) {
-		retval = -ENODEV;
-		goto failed4;
-	}
-
-	if (register_blkdev(xsa_major, MAJOR_NAME)) {
-		retval = -EBUSY;
-		goto failed5;
-	}
-
-	xsa_gendisk = alloc_disk(16);
-	if (!xsa_gendisk) {
-		retval = -ENODEV;
-		goto failed6;
-	}
-
-	strcpy(xsa_gendisk->disk_name, MAJOR_NAME);
-	xsa_gendisk->fops = &xsysace_fops;
-	xsa_gendisk->major = xsa_major;
-	xsa_gendisk->first_minor = 0;
-	xsa_gendisk->minors = 16;
-	xsa_gendisk->queue = xsysace_queue;
-
-	set_capacity(xsa_gendisk, size);
-
-	printk(KERN_INFO
-	       "%s at 0x%08X mapped to 0x%08X, irq=%d, %ldKB\n",
-	       DEVICE_NAME, xsa_phys_addr, SysAce.BaseAddress, xsa_irq,
-	       size / 2);
-
-	/* Hook our reset function into system's restart code. */
-	if (old_restart == NULL) {
-		old_restart = ppc_md.restart;
-		ppc_md.restart = xsysace_restart;
-	}
-
-	if (proc_init())
-		printk(KERN_WARNING "%s: could not register /proc interface.\n",
-		       DEVICE_NAME);
-
-	add_disk(xsa_gendisk);
-
-	return 0;		/* success */
-
-      failed6:
-	unregister_blkdev(xsa_major, MAJOR_NAME);
-
-      failed5:
-	blk_cleanup_queue(xsysace_queue);
-
-      failed4:
-	XSysAce_DisableInterrupt(&SysAce);
-	free_irq(xsa_irq, NULL);
-
-      failed3:
-	iounmap((void *) (xsysace_cfg.BaseAddress));
-
-      failed2:
-	release_mem_region(regs_res->start, remap_size);
-
-      failed1:
-	return retval;
-}
-
-static int xsysace_remove(struct device *dev)
-{
-	if (!dev)
-		return -EINVAL;
-
-	proc_cleanup();
-
-	if (old_restart)
-		ppc_md.restart = old_restart;
-
-	unregister_blkdev(xsa_major, MAJOR_NAME);
-	del_gendisk(xsa_gendisk);
-	blk_cleanup_queue(xsysace_queue);
-	XSysAce_DisableInterrupt(&SysAce);
-	free_irq(xsa_irq, NULL);
-	iounmap((void *) (SysAce.BaseAddress));
-	release_mem_region(xsa_phys_addr, xsa_remap_size);
-
-	return 0;		/* success */
-}
-
-static struct device_driver xsysace_driver = {
-	.name = DRIVER_NAME,
-	.bus = &platform_bus_type,
-	.probe = xsysace_probe,
-	.remove = xsysace_remove
-};
-
-static int __init xsysace_init(void)
-{
-	return driver_register(&xsysace_driver);
-}
-
-static void __exit xsysace_cleanup(void)
-{
-	driver_unregister(&xsysace_driver);
-}
-
-module_init(xsysace_init);
-module_exit(xsysace_cleanup);
-
-MODULE_AUTHOR
-	("Dmitry Chigirev  <chigirev@ru.mvista.com>, Sergey Podstavin <spodstavin@ru.mvista.com>");
-MODULE_DESCRIPTION("Xilinx System ACE block driver");
-MODULE_LICENSE("GPL");
diff --git a/drivers/block/xilinx_sysace/xsysace_selftest.c b/drivers/block/xilinx_sysace/xsysace_selftest.c
deleted file mode 100644
index d2d1073..0000000
--- a/drivers/block/xilinx_sysace/xsysace_selftest.c
+++ /dev/null
@@ -1,155 +0,0 @@
-/* $Id: xsysace_selftest.c,v 1.1 2006/02/17 21:52:36 moleres Exp $ */
-/******************************************************************************
-*
-*       XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS"
-*       AS A COURTESY TO YOU, SOLELY FOR USE IN DEVELOPING PROGRAMS AND
-*       SOLUTIONS FOR XILINX DEVICES.  BY PROVIDING THIS DESIGN, CODE,
-*       OR INFORMATION AS ONE POSSIBLE IMPLEMENTATION OF THIS FEATURE,
-*       APPLICATION OR STANDARD, XILINX IS MAKING NO REPRESENTATION
-*       THAT THIS IMPLEMENTATION IS FREE FROM ANY CLAIMS OF INFRINGEMENT,
-*       AND YOU ARE RESPONSIBLE FOR OBTAINING ANY RIGHTS YOU MAY REQUIRE
-*       FOR YOUR IMPLEMENTATION.  XILINX EXPRESSLY DISCLAIMS ANY
-*       WARRANTY WHATSOEVER WITH RESPECT TO THE ADEQUACY OF THE
-*       IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OR
-*       REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE FROM CLAIMS OF
-*       INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
-*       FOR A PARTICULAR PURPOSE.
-*
-*       (c) Copyright 2002 Xilinx Inc.
-*       All rights reserved.
-* This program is free software; you can redistribute it and/or modify it
-* under the terms of the GNU General Public License as published by the
-* Free Software Foundation; either version 2 of the License, or (at your
-* option) any later version.
-*
-* You should have received a copy of the GNU General Public License
-* along with this program; if not, write to the Free Software
-* Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-*
-******************************************************************************/
-/*****************************************************************************/
-/**
-*
-* @file xsysace_selftest.c
-*
-* Contains diagnostic functions for the System ACE device and driver. This
-* includes a self-test to make sure communication to the device is possible
-* and the ability to retrieve the ACE controller version.
-*
-* <pre>
-* MODIFICATION HISTORY:
-*
-* Ver   Who  Date     Changes
-* ----- ---- -------- -----------------------------------------------
-* 1.00a rpm  06/17/02 work in progress
-* </pre>
-*
-******************************************************************************/
-
-/***************************** Include Files *********************************/
-
-#include "xsysace.h"
-#include "xsysace_l.h"
-
-/************************** Constant Definitions *****************************/
-
-
-/**************************** Type Definitions *******************************/
-
-
-/***************** Macros (Inline Functions) Definitions *********************/
-
-
-/************************** Function Prototypes ******************************/
-
-
-/************************** Variable Definitions *****************************/
-
-
-/*****************************************************************************/
-/**
-*
-* A self-test that simply proves communication to the ACE controller from the
-* device driver by obtaining an MPU lock, verifying it, then releasing it.
-*
-* @param InstancePtr is a pointer to the XSysAce instance to be worked on.
-*
-* @return
-*
-* XST_SUCCESS if self-test passes, or XST_FAILURE if an error occurs.
-*
-* @note
-*
-* None.
-*
-******************************************************************************/
-int XSysAce_SelfTest(XSysAce * InstancePtr)
-{
-	int Result;
-
-	XASSERT_NONVOID(InstancePtr != NULL);
-	XASSERT_NONVOID(InstancePtr->IsReady == XCOMPONENT_IS_READY);
-
-	/*
-	 * Grab a lock (expect immediate success)
-	 */
-	Result = XSysAce_Lock(InstancePtr, TRUE);
-	if (Result != XST_SUCCESS) {
-		return Result;
-	}
-
-	/*
-	 * Verify the lock was retrieved
-	 */
-	if (!XSysAce_mIsMpuLocked(InstancePtr->BaseAddress)) {
-		return XST_FAILURE;
-	}
-
-	/*
-	 * Release the lock
-	 */
-	XSysAce_Unlock(InstancePtr);
-
-	/*
-	 * Verify the lock was released
-	 */
-	if (XSysAce_mIsMpuLocked(InstancePtr->BaseAddress)) {
-		return XST_FAILURE;
-	}
-
-	/*
-	 * If there are currently any errors on the device, fail self-test
-	 */
-	if (XSysAce_mGetErrorReg(InstancePtr->BaseAddress) != 0) {
-		return XST_FAILURE;
-	}
-
-	return XST_SUCCESS;
-}
-
-
-/*****************************************************************************/
-/**
-*
-* Retrieve the version of the System ACE device.
-*
-* @param InstancePtr is a pointer to the XSysAce instance to be worked on.
-*
-* @return
-*
-* A 16-bit version where the 4 most significant bits are the major version
-* number, the next four bits are the minor version number, and the least
-* significant 8 bits are the revision or build number.
-*
-* @note
-*
-* None.
-*
-******************************************************************************/
-u16 XSysAce_GetVersion(XSysAce * InstancePtr)
-{
-	XASSERT_NONVOID(InstancePtr != NULL);
-	XASSERT_NONVOID(InstancePtr->IsReady == XCOMPONENT_IS_READY);
-
-	return XSysAce_RegRead16(InstancePtr->BaseAddress + XSA_VR_OFFSET);
-}
diff --git a/drivers/block/xilinx_sysace/xsysace_sinit.c b/drivers/block/xilinx_sysace/xsysace_sinit.c
deleted file mode 100644
index 81ed53c..0000000
--- a/drivers/block/xilinx_sysace/xsysace_sinit.c
+++ /dev/null
@@ -1,146 +0,0 @@
-/* $Id: xsysace_sinit.c,v 1.1 2006/02/17 21:52:36 moleres Exp $ */
-/******************************************************************************
-*
-*       XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS"
-*       AS A COURTESY TO YOU, SOLELY FOR USE IN DEVELOPING PROGRAMS AND
-*       SOLUTIONS FOR XILINX DEVICES.  BY PROVIDING THIS DESIGN, CODE,
-*       OR INFORMATION AS ONE POSSIBLE IMPLEMENTATION OF THIS FEATURE,
-*       APPLICATION OR STANDARD, XILINX IS MAKING NO REPRESENTATION
-*       THAT THIS IMPLEMENTATION IS FREE FROM ANY CLAIMS OF INFRINGEMENT,
-*       AND YOU ARE RESPONSIBLE FOR OBTAINING ANY RIGHTS YOU MAY REQUIRE
-*       FOR YOUR IMPLEMENTATION.  XILINX EXPRESSLY DISCLAIMS ANY
-*       WARRANTY WHATSOEVER WITH RESPECT TO THE ADEQUACY OF THE
-*       IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OR
-*       REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE FROM CLAIMS OF
-*       INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
-*       FOR A PARTICULAR PURPOSE.
-*
-*       (c) Copyright 2005 Xilinx Inc.
-*       All rights reserved.
-* This program is free software; you can redistribute it and/or modify it
-* under the terms of the GNU General Public License as published by the
-* Free Software Foundation; either version 2 of the License, or (at your
-* option) any later version.
-*
-* You should have received a copy of the GNU General Public License
-* along with this program; if not, write to the Free Software
-* Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-*
-******************************************************************************/
-/*****************************************************************************/
-/**
-*
-* @file xsysace_sinit.c
-
-* The implementation of the XSysAce component's static initialzation
-* functionality.
-*
-* <pre>
-* MODIFICATION HISTORY:
-*
-* Ver   Who  Date     Changes
-* ----- ---- -------- -----------------------------------------------
-* 1.01a jvb  10/13/05 First release
-* </pre>
-*
-******************************************************************************/
-
-/***************************** Include Files *********************************/
-
-#include "xstatus.h"
-#include "xparameters.h"
-#include "xsysace.h"
-
-/************************** Constant Definitions *****************************/
-
-
-/**************************** Type Definitions *******************************/
-
-
-/***************** Macros (Inline Functions) Definitions *********************/
-
-
-/************************** Function Prototypes ******************************/
-
-
-/************************** Variable Definitions *****************************/
-
-/*****************************************************************************/
-/**
-*
-* Looks up the device configuration based on the unique device ID. The table
-* XSysAce_ConfigTable contains the configuration info for each device in the
-* system.
-*
-* @param DeviceId is the unique device ID to look for.
-*
-* @return
-*
-* A pointer to the configuration data for the device, or NULL if no match is
-* found.
-*
-* @note
-*
-* None.
-*
-******************************************************************************/
-XSysAce_Config *XSysAce_LookupConfig(u16 DeviceId)
-{
-	extern XSysAce_Config XSysAce_ConfigTable[];
-	XSysAce_Config *CfgPtr = NULL;
-	int i;
-
-	for (i = 0; i < XPAR_XSYSACE_NUM_INSTANCES; i++) {
-		if (XSysAce_ConfigTable[i].DeviceId == DeviceId) {
-			CfgPtr = &XSysAce_ConfigTable[i];
-			break;
-		}
-	}
-
-	return CfgPtr;
-}
-
-/*****************************************************************************/
-/**
-*
-* Initialize a specific XSysAce instance. The configuration information for
-* the given device ID is found and the driver instance data is initialized
-* appropriately.
-*
-* @param InstancePtr is a pointer to the XSysAce instance to be worked on.
-* @param DeviceId is the unique id of the device controlled by this XSysAce
-*        instance.
-*
-* @return
-*
-* XST_SUCCESS if successful, or XST_DEVICE_NOT_FOUND if the device was not
-* found in the configuration table in xsysace_g.c.
-*
-* @note
-*
-* We do not want to reset the configuration controller here since this could
-* cause a reconfiguration of the JTAG target chain, depending on how the
-* CFGMODEPIN of the device is wired.
-*
-******************************************************************************/
-int XSysAce_Initialize(XSysAce * InstancePtr, u16 DeviceId)
-{
-	XSysAce_Config *ConfigPtr;
-
-	XASSERT_NONVOID(InstancePtr != NULL);
-
-	InstancePtr->IsReady = 0;
-
-	/*
-	 * Lookup configuration data in the device configuration table.
-	 * Use this configuration info down below when initializing this component.
-	 */
-	ConfigPtr = XSysAce_LookupConfig(DeviceId);
-
-	if (ConfigPtr == (XSysAce_Config *) NULL) {
-		return XST_DEVICE_NOT_FOUND;
-	}
-
-	return XSysAce_CfgInitialize(InstancePtr, ConfigPtr,
-				     ConfigPtr->BaseAddress);
-}
-- 
1.7.1

