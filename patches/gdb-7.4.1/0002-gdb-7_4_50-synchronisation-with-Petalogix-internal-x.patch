From fd7a31a1a513fcd3a30434097a5cf71b9c7f8786 Mon Sep 17 00:00:00 2001
From: Stephan Linz <linz@li-pro.net>
Date: Sun, 14 Jul 2013 19:47:56 +0200
Subject: [PATCH] gdb-7_4_50: synchronisation with Petalogix internal xils005

    git diff gdb-7_4_50-microblaze-branchpoint..gdb-7_4_50-microblaze-xils005-mergepoint >gdb-7_4_50-xils005.patch
    git apply --whitespace=nowarn gdb-7_4_50-xils005.patch
    rm gdb-7_4_50-xils005.patch
    git add/rm/commit

Signed-off-by: Stephan Linz <linz@li-pro.net>
---
 bfd/bfd-in2.h                        |   56 ++-
 bfd/config.bfd                       |    6 +
 bfd/configure                        |    1 +
 bfd/configure.in                     |    1 +
 bfd/elf32-microblaze.c               |  994 +++++++++++++++++++++++++++-------
 bfd/targets.c                        |    2 +
 config.sub                           |    9 +-
 gdb-environment.csh                  |   30 +
 gdb-environment.sh                   |   15 +
 gdb/blockframe.c                     |    3 +-
 gdb/gdbserver/Makefile.in            |    7 +
 gdb/gdbserver/configure.srv          |    5 +
 gdb/gdbserver/linux-microblaze-low.c |  134 +++++
 gdb/inline-frame.c                   |    3 +
 gdb/microblaze-tdep.c                |  134 +++++-
 gdb/microblaze-tdep.h                |    7 +-
 gdb/regformats/reg-microblaze.dat    |   39 ++
 include/elf/microblaze.h             |    9 +
 opcodes/microblaze-dis.c             |   23 +-
 opcodes/microblaze-opc.h             |   34 +-
 opcodes/microblaze-opcm.h            |   16 +-
 sim/configure                        |    2 +-
 sim/configure.tgt                    |    2 +-
 23 files changed, 1303 insertions(+), 229 deletions(-)
 create mode 100644 gdb-environment.csh
 create mode 100644 gdb-environment.sh
 create mode 100644 gdb/gdbserver/linux-microblaze-low.c
 create mode 100644 gdb/regformats/reg-microblaze.dat
 mode change 100644 => 100755 opcodes/microblaze-opc.h
 mode change 100644 => 100755 opcodes/microblaze-opcm.h

diff --git a/bfd/bfd-in2.h b/bfd/bfd-in2.h
index 07898be..513ce60 100644
--- a/bfd/bfd-in2.h
+++ b/bfd/bfd-in2.h
@@ -1390,6 +1390,21 @@ typedef struct bfd_section
   /* Bits used by various backends.  The generic code doesn't touch
      these fields.  */
 
+  /* Nonzero if this section has TLS related relocations.  */
+  unsigned int has_tls_reloc:1;
+
+  /* Nonzero if this section has a call to __tls_get_addr.  */
+  unsigned int has_tls_get_addr_call:1;
+
+  /* Nonzero if this section has a gp reloc.  */
+  unsigned int has_gp_reloc:1;
+
+  /* Nonzero if this section needs the relax finalize pass.  */
+  unsigned int need_finalize_relax:1;
+
+  /* Whether relocations have been processed.  */
+  unsigned int reloc_done : 1;
+
   unsigned int sec_flg0:1;
   unsigned int sec_flg1:1;
   unsigned int sec_flg2:1;
@@ -1669,14 +1684,17 @@ extern asection bfd_ind_section;
   /* linker_mark, linker_has_input, gc_mark, decompress_status,    */  \
      0,           0,                1,       0,                        \
                                                                        \
-  /* segment_mark, sec_info_type, use_rela_p,                      */  \
+  /* segment_mark, sec_info_type, use_rela_p, has_tls_reloc,       */  \
+     0,            0,             0,          0,                       \
+                                                                       \
+  /* has_tls_get_addr_call, has_gp_reloc, need_finalize_relax,     */  \
      0,            0,             0,                                   \
                                                                        \
   /* sec_flg0, sec_flg1, sec_flg2, sec_flg3, sec_flg4, sec_flg5,   */  \
      0,        0,        0,        0,        0,        0,              \
                                                                        \
-  /* vma, lma, size, rawsize, compressed_size, relax, relax_count, */  \
-     0,   0,   0,    0,       0,               0,     0,               \
+  /* reloc_done, vma, lma, size, rawsize, compressed_size, relax, relax_count, */  \
+     0,   0,   0,   0,    0,       0,               0,     0,               \
                                                                        \
   /* output_offset, output_section,              alignment_power,  */  \
      0,             (struct bfd_section *) &SEC, 0,                    \
@@ -4890,6 +4908,7 @@ expressions of the form "Symbol Op Symbol"  */
 /* This is a 64 bit reloc that stores the 32 bit pc relative 
 value in two words (with an imm instruction).  No relocation is 
 done here - only used for relaxing  */
+  BFD_RELOC_MICROBLAZE_32_NONE,
   BFD_RELOC_MICROBLAZE_64_NONE,
 
 /* This is a 64 bit reloc that stores the 32 bit pc relative 
@@ -4920,6 +4939,37 @@ value in a word.  The relocation is relative offset from  */
 the dynamic object into the runtime process image.  */
   BFD_RELOC_MICROBLAZE_COPY,
 
+/* Unused Reloc  */
+  BFD_RELOC_MICROBLAZE_64_TLS,
+
+/* This is a 64 bit reloc that stores the 32 bit GOT relative value
+of the GOT TLS GD info entry in two words (with an imm instruction). The 
+relocation is GOT offset.  */
+  BFD_RELOC_MICROBLAZE_64_TLSGD,
+
+/* This is a 64 bit reloc that stores the 32 bit GOT relative value
+of the GOT TLS LD info entry in two words (with an imm instruction). The 
+relocation is GOT offset.  */
+  BFD_RELOC_MICROBLAZE_64_TLSLD,
+
+/* This is a 32 bit reloc that stores the Module ID to GOT(n).  */
+  BFD_RELOC_MICROBLAZE_32_TLSDTPMOD,
+
+/* This is a 32 bit reloc that stores TLS offset to GOT(n+1).  */
+  BFD_RELOC_MICROBLAZE_32_TLSDTPREL,
+
+/* This is a 32 bit reloc for storing TLS offset to two words (uses imm 
+instruction)  */
+  BFD_RELOC_MICROBLAZE_64_TLSDTPREL,
+
+/* This is a 64 bit reloc that stores 32-bit thread pointer relative offset
+to two words (uses imm instruction).  */
+  BFD_RELOC_MICROBLAZE_64_TLSGOTTPREL,
+
+/* This is a 64 bit reloc that stores 32-bit thread pointer relative offset
+to two words (uses imm instruction).  */
+  BFD_RELOC_MICROBLAZE_64_TLSTPREL,
+
 /* Tilera TILEPro Relocations.  */
   BFD_RELOC_TILEPRO_COPY,
   BFD_RELOC_TILEPRO_GLOB_DAT,
diff --git a/bfd/config.bfd b/bfd/config.bfd
index e84ba58..59f1978 100644
--- a/bfd/config.bfd
+++ b/bfd/config.bfd
@@ -879,8 +879,14 @@ case "${targ}" in
     targ_selvecs=bfd_elf32_mep_little_vec
     ;;
 
+  microblazeel-*)
+    targ_defvec=bfd_elf32_microblazeel_vec
+    targ_selvecs=bfd_elf32_microblaze_vec
+    ;;
+
   microblaze*-*)
     targ_defvec=bfd_elf32_microblaze_vec
+    targ_selvecs=bfd_elf32_microblazeel_vec
     ;;
 
   mips*-big-*)
diff --git a/bfd/configure b/bfd/configure
index 58a57ba..8765781 100755
--- a/bfd/configure
+++ b/bfd/configure
@@ -15262,6 +15262,7 @@ do
     bfd_elf32_mcore_little_vec)	tb="$tb elf32-mcore.lo elf32.lo $elf" ;;
     bfd_elf32_mep_vec)		tb="$tb elf32-mep.lo elf32.lo $elf" ;;
     bfd_elf32_mep_little_vec)	tb="$tb elf32-mep.lo elf32.lo $elf" ;;
+    bfd_elf32_microblazeel_vec)	tb="$tb elf32-microblaze.lo elf32.lo $elf" ;;
     bfd_elf32_microblaze_vec)	tb="$tb elf32-microblaze.lo elf32.lo $elf" ;;
     bfd_elf32_mn10200_vec)	tb="$tb elf-m10200.lo elf32.lo $elf" ;;
     bfd_elf32_mn10300_vec)	tb="$tb elf-m10300.lo elf32.lo $elf" ;;
diff --git a/bfd/configure.in b/bfd/configure.in
index f443915..3543db9 100644
--- a/bfd/configure.in
+++ b/bfd/configure.in
@@ -748,6 +748,7 @@ do
     bfd_elf32_mcore_little_vec)	tb="$tb elf32-mcore.lo elf32.lo $elf" ;;
     bfd_elf32_mep_vec)		tb="$tb elf32-mep.lo elf32.lo $elf" ;;
     bfd_elf32_mep_little_vec)	tb="$tb elf32-mep.lo elf32.lo $elf" ;;
+    bfd_elf32_microblazeel_vec)	tb="$tb elf32-microblaze.lo elf32.lo $elf" ;;
     bfd_elf32_microblaze_vec)	tb="$tb elf32-microblaze.lo elf32.lo $elf" ;;
     bfd_elf32_mn10200_vec)	tb="$tb elf-m10200.lo elf32.lo $elf" ;;
     bfd_elf32_mn10300_vec)	tb="$tb elf-m10300.lo elf32.lo $elf" ;;
diff --git a/bfd/elf32-microblaze.c b/bfd/elf32-microblaze.c
index a58f7b3..4563086 100644
--- a/bfd/elf32-microblaze.c
+++ b/bfd/elf32-microblaze.c
@@ -177,6 +177,20 @@ static reloc_howto_type microblaze_elf_howto_raw[] =
           FALSE), 		/* PC relative offset?  */
 
    /* This reloc does nothing.  Used for relaxation.  */
+   HOWTO (R_MICROBLAZE_32_NONE,	/* Type.  */
+          0,			/* Rightshift.  */
+          2,			/* Size (0 = byte, 1 = short, 2 = long).  */
+          32,			/* Bitsize.  */
+          TRUE,			/* PC_relative.  */
+          0,			/* Bitpos.  */
+          complain_overflow_bitfield,  /* Complain on overflow.  */
+          NULL,                  /* Special Function.  */
+          "R_MICROBLAZE_32_NONE",/* Name.  */
+          FALSE,		/* Partial Inplace.  */
+          0,			/* Source Mask.  */
+          0,			/* Dest Mask.  */
+          FALSE),		/* PC relative offset?  */
+
    HOWTO (R_MICROBLAZE_64_NONE,	/* Type.  */
           0,			/* Rightshift.  */
           2,			/* Size (0 = byte, 1 = short, 2 = long).  */
@@ -370,6 +384,132 @@ static reloc_howto_type microblaze_elf_howto_raw[] =
           0,			/* Source Mask.  */
           0x0000ffff,		/* Dest Mask.  */
           FALSE), 		/* PC relative offset?  */
+
+  /* Marker relocs for TLS.  */
+  HOWTO (R_MICROBLAZE_TLS,
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 32,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_dont, /* complain_on_overflow */
+	 bfd_elf_generic_reloc,	/* special_function */
+	 "R_MICROBLAZE_TLS",		/* name */
+	 FALSE,			/* partial_inplace */
+	 0,			/* src_mask */
+	 0x0000ffff,			/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  HOWTO (R_MICROBLAZE_TLSGD,
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 32,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_dont, /* complain_on_overflow */
+	 bfd_elf_generic_reloc, /* special_function */
+	 "R_MICROBLAZE_TLSGD",		/* name */
+	 FALSE,			/* partial_inplace */
+	 0,			/* src_mask */
+	 0x0000ffff,			/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  HOWTO (R_MICROBLAZE_TLSLD,
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 32,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_dont, /* complain_on_overflow */
+	 bfd_elf_generic_reloc, /* special_function */
+	 "R_MICROBLAZE_TLSLD",		/* name */
+	 FALSE,			/* partial_inplace */
+	 0,			/* src_mask */
+	 0x0000ffff,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  /* Computes the load module index of the load module that contains the
+     definition of its TLS sym.  */
+  HOWTO (R_MICROBLAZE_TLSDTPMOD32,
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 32,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_dont, /* complain_on_overflow */
+	 bfd_elf_generic_reloc, /* special_function */
+	 "R_MICROBLAZE_TLSDTPMOD32",	/* name */
+	 FALSE,			/* partial_inplace */
+	 0,			/* src_mask */
+	 0x0000ffff,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  /* Computes a dtv-relative displacement, the difference between the value
+     of sym+add and the base address of the thread-local storage block that
+     contains the definition of sym, minus 0x8000.  Used for initializing GOT */
+  HOWTO (R_MICROBLAZE_TLSDTPREL32,
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 32,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_dont, /* complain_on_overflow */
+	 bfd_elf_generic_reloc, /* special_function */
+	 "R_MICROBLAZE_TLSDTPREL32",	/* name */
+	 FALSE,			/* partial_inplace */
+	 0,			/* src_mask */
+	 0x0000ffff,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  /* Computes a dtv-relative displacement, the difference between the value
+     of sym+add and the base address of the thread-local storage block that
+     contains the definition of sym, minus 0x8000.  */
+  HOWTO (R_MICROBLAZE_TLSDTPREL64,
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 32,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_dont, /* complain_on_overflow */
+	 bfd_elf_generic_reloc, /* special_function */
+	 "R_MICROBLAZE_TLSDTPREL64",	/* name */
+	 FALSE,			/* partial_inplace */
+	 0,			/* src_mask */
+	 0x0000ffff,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  /* Computes a tp-relative displacement, the difference between the value of
+     sym+add and the value of the thread pointer (r13).  */
+  HOWTO (R_MICROBLAZE_TLSGOTTPREL32,
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 32,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_dont, /* complain_on_overflow */
+	 bfd_elf_generic_reloc, /* special_function */
+	 "R_MICROBLAZE_TLSGOTTPREL32",	/* name */
+	 FALSE,			/* partial_inplace */
+	 0,			/* src_mask */
+	 0x0000ffff,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
+  /* Computes a tp-relative displacement, the difference between the value of
+     sym+add and the value of the thread pointer (r13).  */
+  HOWTO (R_MICROBLAZE_TLSTPREL32,
+	 0,			/* rightshift */
+	 2,			/* size (0 = byte, 1 = short, 2 = long) */
+	 32,			/* bitsize */
+	 FALSE,			/* pc_relative */
+	 0,			/* bitpos */
+	 complain_overflow_dont, /* complain_on_overflow */
+	 bfd_elf_generic_reloc, /* special_function */
+	 "R_MICROBLAZE_TLSTPREL32",	/* name */
+	 FALSE,			/* partial_inplace */
+	 0,			/* src_mask */
+	 0x0000ffff,		/* dst_mask */
+	 FALSE),		/* pcrel_offset */
+
 };
 
 #ifndef NUM_ELEM
@@ -406,7 +546,10 @@ microblaze_elf_reloc_type_lookup (bfd * abfd ATTRIBUTE_UNUSED,
     case BFD_RELOC_NONE:
       microblaze_reloc = R_MICROBLAZE_NONE;
       break;
-    case BFD_RELOC_MICROBLAZE_64_NONE:
+    case BFD_RELOC_MICROBLAZE_32_NONE:
+      microblaze_reloc = R_MICROBLAZE_32_NONE;
+      break;
+     case BFD_RELOC_MICROBLAZE_64_NONE:
       microblaze_reloc = R_MICROBLAZE_64_NONE;
       break;
     case BFD_RELOC_32:
@@ -461,6 +604,27 @@ microblaze_elf_reloc_type_lookup (bfd * abfd ATTRIBUTE_UNUSED,
     case BFD_RELOC_MICROBLAZE_32_GOTOFF:
       microblaze_reloc = R_MICROBLAZE_GOTOFF_32;
       break;
+    case BFD_RELOC_MICROBLAZE_64_TLSGD:
+      microblaze_reloc = R_MICROBLAZE_TLSGD;
+      break;
+    case BFD_RELOC_MICROBLAZE_64_TLSLD:
+      microblaze_reloc = R_MICROBLAZE_TLSLD;
+      break;
+    case BFD_RELOC_MICROBLAZE_32_TLSDTPREL:
+      microblaze_reloc = R_MICROBLAZE_TLSDTPREL32;
+      break;
+    case BFD_RELOC_MICROBLAZE_64_TLSDTPREL:
+      microblaze_reloc = R_MICROBLAZE_TLSDTPREL64;
+      break;
+    case BFD_RELOC_MICROBLAZE_32_TLSDTPMOD:
+      microblaze_reloc = R_MICROBLAZE_TLSDTPMOD32;
+      break;
+    case BFD_RELOC_MICROBLAZE_64_TLSGOTTPREL:
+      microblaze_reloc = R_MICROBLAZE_TLSGOTTPREL32;
+      break;
+    case BFD_RELOC_MICROBLAZE_64_TLSTPREL:
+      microblaze_reloc = R_MICROBLAZE_TLSTPREL32;
+      break;
     case BFD_RELOC_MICROBLAZE_COPY:
       microblaze_reloc = R_MICROBLAZE_COPY;
       break;
@@ -550,8 +714,21 @@ struct elf32_mb_link_hash_entry
   /* Track dynamic relocs copied for this symbol.  */
   struct elf32_mb_dyn_relocs *dyn_relocs;
 
+  /* TLS Reference Types for the symbol; Updated by check_relocs */
+#define TLS_GD		 1	/* GD reloc. */
+#define TLS_LD		 2	/* LD reloc. */
+#define TLS_TPREL	 4	/* TPREL reloc, => IE. */
+#define TLS_DTPREL	 8	/* DTPREL reloc, => LD. */
+#define TLS_TLS		16	/* Any TLS reloc.  */
+  unsigned char tls_mask;
+
 };
 
+#define IS_TLS_GD(x)   (x == (TLS_TLS | TLS_GD))
+#define IS_TLS_LD(x)   (x == (TLS_TLS | TLS_LD))
+#define IS_TLS_DTPREL(x)   (x == (TLS_TLS | TLS_DTPREL))
+#define IS_TLS_NONE(x) (x == 0)
+
 #define elf32_mb_hash_entry(ent) ((struct elf32_mb_link_hash_entry *)(ent))
 
 /* ELF linker hash table.  */
@@ -571,6 +748,12 @@ struct elf32_mb_link_hash_table
 
   /* Small local sym to section mapping cache.  */
   struct sym_cache sym_sec;
+
+  /* TLS Local Dynamic GOT Entry */
+  union {
+    bfd_signed_vma refcount;
+    bfd_vma offset;
+  } tlsld_got;
 };
 
 /* Get the ELF linker hash table from a link_info structure.  */
@@ -604,6 +787,7 @@ link_hash_newfunc (struct bfd_hash_entry *entry,
 
       eh = (struct elf32_mb_link_hash_entry *) entry;
       eh->dyn_relocs = NULL;
+      eh->tls_mask = 0;
     }
 
   return entry;
@@ -654,6 +838,79 @@ microblaze_elf_final_sdp (struct bfd_link_info *info)
                              + h->u.def.section->output_offset);
 }
 
+static bfd_vma
+dtprel_base (struct bfd_link_info *info)
+{
+  /* If tls_sec is NULL, we should have signalled an error already.  */
+  if (elf_hash_table (info)->tls_sec == NULL)
+    return 0;
+  return elf_hash_table (info)->tls_sec->vma; 
+}
+
+/* The size of the thread control block.  */
+#define TCB_SIZE	8
+
+#if 0
+static bfd_vma
+tprel_base (struct bfd_link_info *info)
+{
+  bfd_vma base;
+
+  /* If tls_sec is NULL, we should have signalled an error already.  */
+  if (elf_hash_table (info)->tls_sec == NULL)
+    return 0;
+  base = align_power ((bfd_vma) TCB_SIZE, elf_hash_table(info)->tls_sec->alignment_power);
+
+  return elf_hash_table (info)->tls_sec->vma - base;
+}
+#endif
+
+static void
+check_unique_offset(bfd_vma offset, int tls_type, bfd_vma v)
+{
+  static bfd_vma offsets[1000];
+  static bfd_vma values[1000];
+
+  static int noffsets = 0;
+  int scan1;
+
+  return;
+
+  for (scan1 = 0; scan1 < noffsets; scan1++)
+  {
+	if (offsets[scan1] == offset)
+	  {
+		fprintf (stderr, "Duplicate Offset: %lx type: %x Old: %lx New: %lx \n", offset, tls_type, values[scan1], v);
+	  }
+  }
+  fprintf (stderr, "%d Registered Offset: %lx Value: %lx type: %x\n", noffsets, offset, v, tls_type);
+  offsets[noffsets] = offset;
+  values[noffsets++] = v;
+}
+
+/* Output a simple dynamic relocation into SRELOC.  */
+
+static void
+microblaze_elf_output_dynamic_relocation (bfd *output_bfd,
+				    asection *sreloc,
+				    unsigned long reloc_index,
+				    unsigned long indx,
+				    int r_type,
+				    bfd_vma offset,
+				    bfd_vma addend
+                                    )
+{
+
+  Elf_Internal_Rela rel;
+
+  rel.r_info = ELF32_R_INFO (indx, r_type);
+  rel.r_offset = offset;
+  rel.r_addend = addend;
+
+  bfd_elf32_swap_reloca_out (output_bfd, &rel, 
+              (sreloc->contents + reloc_index * sizeof (Elf32_External_Rela)));
+}
+
 /* This code is taken from elf32-m32r.c
    There is some attempt to make this function usable for many architectures,
    both USE_REL and USE_RELA ['twould be nice if such a critter existed],
@@ -702,10 +959,12 @@ microblaze_elf_relocate_section (bfd *output_bfd,
   Elf_Internal_Shdr *symtab_hdr = &elf_tdata (input_bfd)->symtab_hdr;
   struct elf_link_hash_entry **sym_hashes = elf_sym_hashes (input_bfd);
   Elf_Internal_Rela *rel, *relend;
+  int endian = !bfd_little_endian (output_bfd) * 2;
   /* Assume success.  */
   bfd_boolean ret = TRUE;
   asection *sreloc;
   bfd_vma *local_got_offsets;
+  unsigned int tls_type;
 
   if (!microblaze_elf_howto_table[R_MICROBLAZE_max-1])
     microblaze_elf_howto_init ();
@@ -737,6 +996,8 @@ microblaze_elf_relocate_section (bfd *output_bfd,
 
       h = NULL;
       r_type = ELF32_R_TYPE (rel->r_info);
+      tls_type = 0;
+
       if (r_type < 0 || r_type >= (int) R_MICROBLAZE_max)
 	{
 	  (*_bfd_error_handler) (_("%s: unknown relocation type %d"),
@@ -933,9 +1194,9 @@ microblaze_elf_relocate_section (bfd *output_bfd,
 			     + offset + INST_WORD_SIZE);
 	      relocation += addend;
 	      bfd_put_16 (input_bfd, (relocation >> 16) & 0xffff,
-			  contents + offset + 2);
+			  contents + offset + endian);
 	      bfd_put_16 (input_bfd, relocation & 0xffff,
-			  contents + offset + 2 + INST_WORD_SIZE);
+			  contents + offset + endian + INST_WORD_SIZE);
 	      break;
 
 	    case (int) R_MICROBLAZE_PLT_64:
@@ -952,9 +1213,9 @@ microblaze_elf_relocate_section (bfd *output_bfd,
 					      + input_section->output_offset
 					      + offset + INST_WORD_SIZE);
 		    bfd_put_16 (input_bfd, (immediate >> 16) & 0xffff,
-				contents + offset + 2);
+				contents + offset + endian);
 		    bfd_put_16 (input_bfd, immediate & 0xffff,
-				contents + offset + 2 + INST_WORD_SIZE);
+				contents + offset + endian + INST_WORD_SIZE);
 		  }
 		else
 		  {
@@ -963,77 +1224,215 @@ microblaze_elf_relocate_section (bfd *output_bfd,
 				   + offset + INST_WORD_SIZE);
 		    immediate = relocation;
 		    bfd_put_16 (input_bfd, (immediate >> 16) & 0xffff,
-				contents + offset + 2);
+				contents + offset + endian);
 		    bfd_put_16 (input_bfd, immediate & 0xffff,
-				contents + offset + 2 + INST_WORD_SIZE);
+				contents + offset + endian + INST_WORD_SIZE);
 		  }
 		break;
 	      }
 
+	    case (int) R_MICROBLAZE_TLSGD:
+		tls_type = (TLS_TLS | TLS_GD);
+		goto dogot;
+	    case (int) R_MICROBLAZE_TLSLD:
+		tls_type = (TLS_TLS | TLS_LD);
+		dogot:
 	    case (int) R_MICROBLAZE_GOT_64:
 	      {
+	        bfd_vma *offp;
+                bfd_vma off, off2;
+	        unsigned long indx;
+		bfd_vma static_value;
+
+		bfd_boolean need_relocs = FALSE;
+
 		if (htab->sgot == NULL)
 		  abort ();
-		if (h == NULL)
-		  {
-		    bfd_vma off;
+
+	        indx = 0;
+	        offp = NULL;
+
+                /* 1. Identify GOT Offset; 
+                   2. Compute Static Values 
+                   3. Process Module Id, Process Offset
+                   4. Fixup Relocation with GOT offset value 
+                 */
+                   
+                /* 1. Determine GOT Offset to use : TLS_LD, global, local */
+	        if ( IS_TLS_LD (tls_type) )
+	          offp = &htab->tlsld_got.offset;
+                else if (h != NULL)
+	          {
+		    if (htab->sgotplt != NULL && h->got.offset != (bfd_vma) -1)
+		       offp = &h->got.offset;
+                    else
+		      abort ();
+	          }
+	        else
+	          {
 		    if (local_got_offsets == NULL)
 		      abort ();
-		    off = local_got_offsets[r_symndx];
-		    /* The LSB indicates whether we've already
-		       created relocation.  */
-		    if (off & 1)
-		      off &= ~1;
-		    else
-		      {
-			bfd_put_32 (output_bfd, relocation + addend,
-				    htab->sgot->contents + off);
-
-			if (info->shared)
-			  {
-			    Elf_Internal_Rela outrel;
-			    bfd_byte *loc;
-			    if (htab->srelgot == NULL)
-			      abort ();
-			    outrel.r_offset = (htab->sgot->output_section->vma
-					       + htab->sgot->output_offset
-					       + off);
-			    outrel.r_info = ELF32_R_INFO (0, R_MICROBLAZE_REL);
-			    outrel.r_addend = relocation + addend;
-			    loc = htab->srelgot->contents;
-			    loc += htab->srelgot->reloc_count++
-			      * sizeof (Elf32_External_Rela);
-			    bfd_elf32_swap_reloca_out (output_bfd, &outrel, loc);
-			  }
-			local_got_offsets[r_symndx] |= 1;
-		      }
-		    relocation = htab->sgot->output_section->vma
-		      + htab->sgot->output_offset + off
-		      - htab->sgotplt->output_section->vma
-		      - htab->sgotplt->output_offset;
-		    unresolved_reloc = FALSE;
-		  }
-		else
-		  {
-		    if (htab->sgotplt != NULL && h != NULL
-			&& h->got.offset != (bfd_vma) -1)
-		      {
-			bfd_put_32 (output_bfd, relocation + addend,
-				    htab->sgot->contents + h->got.offset);
-			relocation = htab->sgot->output_section->vma
-			  + htab->sgot->output_offset
-			  + h->got.offset
-			  - htab->sgotplt->output_section->vma
-			  - htab->sgotplt->output_offset;
-			unresolved_reloc = FALSE;
-		      }
-		    else
-		      abort (); /* ??? */
-		  }
+		    offp = &local_got_offsets[r_symndx];
+	          }
+
+                if ( !offp ) abort();
+
+                off = (*offp) & ~1;
+                off2 = off;
+
+                if (IS_TLS_LD(tls_type) || IS_TLS_GD(tls_type))
+                  off2 = off + 4;
+
+                /* Symbol index to use for relocs */
+                if (h != NULL)
+                  {
+                    bfd_boolean dyn = 
+                      elf_hash_table (info)->dynamic_sections_created;
+
+                    if (WILL_CALL_FINISH_DYNAMIC_SYMBOL (dyn, info->shared, h)
+	                && (!info->shared || 
+                            !SYMBOL_REFERENCES_LOCAL (info, h)))
+	              indx = h->dynindx;
+                  }
+
+                /* Need to generate relocs ? */ 
+                if ((info->shared || indx != 0)
+                    && (h == NULL
+	                || ELF_ST_VISIBILITY (h->other) == STV_DEFAULT
+	                || h->root.type != bfd_link_hash_undefweak))
+                  need_relocs = TRUE;
+
+		/* 2. Compute/Emit Static value of r-expression */
+		static_value = relocation + addend;
+
+		/* 3. Process module-id and offset */
+                if (! ((*offp) & 1) )
+                  {
+		     bfd_vma got_offset;
+
+ 		     got_offset = (htab->sgot->output_section->vma
+    				       + htab->sgot->output_offset
+    				       + off);
+
+                    /* Process module-id */
+                    if (IS_TLS_LD(tls_type))
+                      {
+
+                        if ( ! info->shared )
+                          {
+                            check_unique_offset( off, tls_type, 1);
+
+    		            bfd_put_32 (output_bfd, 1,
+    			         htab->sgot->contents + off);
+                          }
+                        else
+                          {
+                            check_unique_offset( off, tls_type, 0xDDDDDDDD);
+
+                            microblaze_elf_output_dynamic_relocation (
+                                  output_bfd, htab->srelgot,
+    			      htab->srelgot->reloc_count++,
+    			      /* symindex= */ 0,
+    			      R_MICROBLAZE_TLSDTPMOD32,
+    			      got_offset, 0);
+                          }
+                      }
+                    else if (IS_TLS_GD(tls_type))
+                      {
+                        if ( ! need_relocs )
+                          {
+                            check_unique_offset( off, tls_type, 1);
+
+    		            bfd_put_32 (output_bfd, 1,
+    			         htab->sgot->contents + off);
+                          }
+                        else
+                          {
+                            check_unique_offset( off, tls_type, 0);
+
+                            microblaze_elf_output_dynamic_relocation (
+                                  output_bfd, htab->srelgot,
+    			      htab->srelgot->reloc_count++,
+    			      /* symindex= */ indx,
+    			      R_MICROBLAZE_TLSDTPMOD32,
+    			      got_offset, indx ? 0 : static_value);
+                          }
+                      }
+    
+                    /* Process Offset */
+    		    if (htab->srelgot == NULL)
+    		      abort ();
+    
+    		    got_offset = (htab->sgot->output_section->vma
+    					       + htab->sgot->output_offset
+    					       + off2);
+                    if (IS_TLS_LD(tls_type))
+                      {
+                        /* For LD, offset should be 0 */
+                        *offp |= 1;
+    		        bfd_put_32 (output_bfd, 0, htab->sgot->contents + off2);
+                      }
+                    else if (IS_TLS_GD(tls_type))
+                      {
+     		        *offp |= 1;
+                        static_value -= dtprel_base(info);
+                        if (need_relocs)
+                          {
+                            check_unique_offset(off2, tls_type, indx ? 0 : static_value + 1);
+                            microblaze_elf_output_dynamic_relocation (
+                                  output_bfd, htab->srelgot,
+    			      htab->srelgot->reloc_count++,
+    			      /* symindex= */ indx,
+    			      R_MICROBLAZE_TLSDTPREL32,
+    			      got_offset, indx ? 0 : static_value);
+                          }
+                        else
+                          {
+                            check_unique_offset(off2, tls_type, static_value);
+
+    		            bfd_put_32 (output_bfd, static_value,
+    				    htab->sgot->contents + off2);
+                          }
+                      }
+                    else
+                      {
+    		         bfd_put_32 (output_bfd, static_value,
+    			    htab->sgot->contents + off2);
+    
+                         /* Relocs for dyn symbols generated by
+                            finish_dynamic_symbols */
+                         if (info->shared && h == NULL)
+                           {
+     		              *offp |= 1;
+
+                              check_unique_offset(off2, tls_type, static_value);
+
+                              microblaze_elf_output_dynamic_relocation (
+                                output_bfd, htab->srelgot,
+    			        htab->srelgot->reloc_count++,
+    			        /* symindex= */ indx,
+    			        R_MICROBLAZE_REL,
+    			        got_offset, static_value);
+                           }
+                      }
+                  }
+
+                /* 4. Fixup Relocation with GOT offset value */
+                /* Compute relative address of GOT entry for applying
+                         the current relocation */
+		relocation = htab->sgot->output_section->vma
+		    + htab->sgot->output_offset
+		    + off
+		    - htab->sgotplt->output_section->vma
+		    - htab->sgotplt->output_offset;
+
+                /* Apply Current Relocation */
 		bfd_put_16 (input_bfd, (relocation >> 16) & 0xffff,
-			    contents + offset + 2);
+			    contents + offset + endian);
 		bfd_put_16 (input_bfd, relocation & 0xffff,
-			    contents + offset + 2 + INST_WORD_SIZE);
+			    contents + offset + endian + INST_WORD_SIZE);
+
+		unresolved_reloc = FALSE;
 		break;
 	      }
 
@@ -1048,8 +1447,8 @@ microblaze_elf_relocate_section (bfd *output_bfd,
 		immediate = relocation;
 		lo = immediate & 0x0000ffff;
 		high = (immediate >> 16) & 0x0000ffff;
-		bfd_put_16 (input_bfd, high, contents + offset + 2);
-		bfd_put_16 (input_bfd, lo, contents + offset + INST_WORD_SIZE + 2);
+		bfd_put_16 (input_bfd, high, contents + offset + endian);
+		bfd_put_16 (input_bfd, lo, contents + offset + INST_WORD_SIZE + endian);
 		break;
 	      }
 
@@ -1063,6 +1462,14 @@ microblaze_elf_relocate_section (bfd *output_bfd,
 		break;
 	      }
 
+	    case (int) R_MICROBLAZE_TLSDTPREL64:
+		 relocation += addend;
+                 relocation -= dtprel_base(info);
+		 bfd_put_16 (input_bfd, (relocation >> 16) & 0xffff,
+				    contents + offset + 2);
+		 bfd_put_16 (input_bfd, relocation & 0xffff,
+				    contents + offset + 2 + INST_WORD_SIZE);
+		break;
 	    case (int) R_MICROBLAZE_64_PCREL :
 	    case (int) R_MICROBLAZE_64:
 	    case (int) R_MICROBLAZE_32:
@@ -1081,10 +1488,11 @@ microblaze_elf_relocate_section (bfd *output_bfd,
 			  relocation -= (input_section->output_section->vma
 					 + input_section->output_offset
 					 + offset + INST_WORD_SIZE);
+
 			bfd_put_16 (input_bfd, (relocation >> 16) & 0xffff,
-				    contents + offset + 2);
+				    contents + offset + endian);
 			bfd_put_16 (input_bfd, relocation & 0xffff,
-				    contents + offset + 2 + INST_WORD_SIZE);
+				    contents + offset + endian + INST_WORD_SIZE);
 		      }
 		    break;
 		  }
@@ -1176,9 +1584,9 @@ microblaze_elf_relocate_section (bfd *output_bfd,
 					 + input_section->output_offset
 					 + offset + INST_WORD_SIZE);
 			bfd_put_16 (input_bfd, (relocation >> 16) & 0xffff,
-				    contents + offset + 2);
+				    contents + offset + endian);
 			bfd_put_16 (input_bfd, relocation & 0xffff,
-				    contents + offset + 2 + INST_WORD_SIZE);
+				    contents + offset + endian + INST_WORD_SIZE);
 		      }
 		    break;
 		  }
@@ -1253,9 +1661,49 @@ microblaze_elf_relocate_section (bfd *output_bfd,
 
   return ret;
 }
+
+/* Merge backend specific data from an object file to the output
+   object file when linking.  
+
+   Note: We only use this hook to catch endian mismatches */
+static bfd_boolean
+microblaze_elf_merge_private_bfd_data (bfd * ibfd, bfd * obfd)
+{
+  /* Check if we have the same endianess.  */
+  if (! _bfd_generic_verify_endian_match (ibfd, obfd))
+    return FALSE;
+
+  return TRUE;
+}
+
 
 /* Calculate fixup value for reference.  */
 
+#define D(x)
+
+static int
+calc_size_fixup (bfd_vma start, bfd_vma size, asection *sec)
+{
+  bfd_vma end = start + size;
+  int i, fixup = 0;
+
+  if (sec == NULL || sec->relax == NULL)
+    return 0;
+
+  /* Look for addr in relax table, total fixup value.  */
+  for (i = 0; i < sec->relax_count; i++)
+    {
+      D(fprintf(stderr, "%s: start=%x end=%x reladdr=%x relsize=%d\n", __func__,
+		start, end, sec->relax[i].addr, sec->relax[i].size));
+      if (end < sec->relax[i].addr)
+        break;
+      if (start > sec->relax[i].addr)
+        continue;
+      fixup += sec->relax[i].size;
+    }
+  return fixup;
+}
+
 static int
 calc_fixup (bfd_vma addr, asection *sec)
 {
@@ -1275,6 +1723,36 @@ calc_fixup (bfd_vma addr, asection *sec)
   return fixup;
 }
 
+/* Read-modify-write into the bfd, an immediate value into appropriate fields of a 32-bit
+ * instruction. */
+static void
+microblaze_bfd_write_imm_value_32 (bfd *abfd, bfd_byte *bfd_addr, bfd_vma val) 
+{
+    unsigned long instr = bfd_get_32 (abfd, bfd_addr);
+    instr &= ~0x0000ffff;
+    instr |= (val & 0x0000ffff);
+    bfd_put_32 (abfd, instr, bfd_addr);
+}
+
+/* Read-modify-write into the bfd, an immediate value into appropriate fields of
+ * two consecutive 32-bit instructions. */
+static void 
+microblaze_bfd_write_imm_value_64 (bfd *abfd, bfd_byte *bfd_addr, bfd_vma val)
+{
+    unsigned long instr_hi;
+    unsigned long instr_lo;
+
+    instr_hi = bfd_get_32 (abfd, bfd_addr);
+    instr_hi &= ~0x0000ffff;
+    instr_hi |= ((val >> 16) & 0x0000ffff);           
+    bfd_put_32 (abfd, instr_hi, bfd_addr);
+
+    instr_lo = bfd_get_32 (abfd, bfd_addr + INST_WORD_SIZE);
+    instr_lo &= ~0x0000ffff;
+    instr_lo |= (val & 0x0000ffff);           
+    bfd_put_32 (abfd, instr_lo, bfd_addr + INST_WORD_SIZE);   
+}
+
 static bfd_boolean
 microblaze_elf_relax_section (bfd *abfd,
 			      asection *sec,
@@ -1305,7 +1783,8 @@ microblaze_elf_relax_section (bfd *abfd,
   /* Only do this for a text section.  */
   if (link_info->relocatable
       || (sec->flags & SEC_RELOC) == 0
-      || (sec->reloc_count == 0))
+      || (sec->reloc_count == 0)
+      || (sec->flags & SEC_CODE) == 0)
     return TRUE;
 
   BFD_ASSERT ((sec->size > 0) || (sec->rawsize > 0));
@@ -1338,6 +1817,7 @@ microblaze_elf_relax_section (bfd *abfd,
 
   irelend = internal_relocs + sec->reloc_count;
   rel_count = 0;
+  D(fprintf (stderr, "%s:%s\n", abfd->filename, sec->name));
   for (irel = internal_relocs; irel < irelend; irel++, rel_count++)
     {
       bfd_vma symval;
@@ -1475,17 +1955,26 @@ microblaze_elf_relax_section (bfd *abfd,
 	        }
 	      break;
 	    case R_MICROBLAZE_NONE:
+	    case R_MICROBLAZE_32_NONE:
 	      {
 	        /* This was a PC-relative instruction that was
  		   completely resolved.  */
 	        int sfix, efix;
+		unsigned int val;
 	        bfd_vma target_address;
 	        target_address = irel->r_addend + irel->r_offset;
 	        sfix = calc_fixup (irel->r_offset, sec);
 	        efix = calc_fixup (target_address, sec);
+
+                /* Validate the in-band val.  */
+                val = bfd_get_32 (abfd, contents + irel->r_offset);
+                if (val != irel->r_addend && ELF32_R_TYPE (irel->r_info) == R_MICROBLAZE_32_NONE) {
+                    fprintf(stderr, "%d: CORRUPT relax reloc %x %lx\n", __LINE__, val, irel->r_addend);
+                }
 	        irel->r_addend -= (efix - sfix);
 	        /* Should use HOWTO.  */
-	        bfd_put_16 (abfd, irel->r_addend, contents + irel->r_offset + 2);
+                microblaze_bfd_write_imm_value_32 (abfd, contents + irel->r_offset,
+                                                   irel->r_addend);
 	      }
 	      break;
 	    case R_MICROBLAZE_64_NONE:
@@ -1498,8 +1987,9 @@ microblaze_elf_relax_section (bfd *abfd,
 		sfix = calc_fixup (irel->r_offset + INST_WORD_SIZE, sec);
 		efix = calc_fixup (target_address, sec);
 		irel->r_addend -= (efix - sfix);
-		bfd_put_16 (abfd, irel->r_addend, contents + irel->r_offset
-			    + INST_WORD_SIZE + 2);
+                microblaze_bfd_write_imm_value_32 (abfd,
+                                               contents + irel->r_offset + INST_WORD_SIZE,
+                                               irel->r_addend);
 	      }
 	      break;
 	    }
@@ -1529,6 +2019,49 @@ microblaze_elf_relax_section (bfd *abfd,
           irelscanend = irelocs + o->reloc_count;
           for (irelscan = irelocs; irelscan < irelscanend; irelscan++)
             {
+              if (1 && ELF32_R_TYPE (irelscan->r_info) == (int) R_MICROBLAZE_32_NONE)
+                {
+                  unsigned int val;
+
+                  isym = isymbuf + ELF32_R_SYM (irelscan->r_info);
+
+                  /* hax: We only do the following fixup for debug location lists.  */
+                  if (strcmp(".debug_loc", o->name))
+                    continue;
+
+                  /* This was a PC-relative instruction that was completely resolved.  */
+                  if (ocontents == NULL)
+                    {
+		      if (elf_section_data (o)->this_hdr.contents != NULL)
+		          ocontents = elf_section_data (o)->this_hdr.contents;
+		      else
+		        {
+		          /* We always cache the section contents.
+			     Perhaps, if info->keep_memory is FALSE, we
+			     should free them, if we are permitted to.  */
+
+		          if (o->rawsize == 0)
+			      o->rawsize = o->size;
+		          ocontents = (bfd_byte *) bfd_malloc (o->rawsize);
+		          if (ocontents == NULL)
+			      goto error_return;
+		          if (!bfd_get_section_contents (abfd, o, ocontents,
+                                                         (file_ptr) 0,
+                                                         o->rawsize))
+                              goto error_return;
+		          elf_section_data (o)->this_hdr.contents = ocontents;
+		        }
+		    }
+
+                  val = bfd_get_32 (abfd, ocontents + irelscan->r_offset);
+                  if (val != irelscan->r_addend) {
+			fprintf(stderr, "%d: CORRUPT relax reloc! %x %lx\n", __LINE__, val, irelscan->r_addend);
+                  }
+
+                  irelscan->r_addend -= calc_fixup (irelscan->r_addend, sec);
+                  microblaze_bfd_write_imm_value_32 (abfd, ocontents + irelscan->r_offset,
+                                                     irelscan->r_addend);
+              }
               if (ELF32_R_TYPE (irelscan->r_info) == (int) R_MICROBLAZE_32)
                 {
 	          isym = isymbuf + ELF32_R_SYM (irelscan->r_info);
@@ -1588,7 +2121,7 @@ microblaze_elf_relax_section (bfd *abfd,
 			      elf_section_data (o)->this_hdr.contents = ocontents;
 			    }
 			}
-		      irelscan->r_addend -= calc_fixup (irel->r_addend
+		      irelscan->r_addend -= calc_fixup (irelscan->r_addend
 							+ isym->st_value,
 							sec);
 		    }
@@ -1627,13 +2160,13 @@ microblaze_elf_relax_section (bfd *abfd,
 			    }
 			}
 
-		      immediate = (unsigned short) bfd_get_16 (abfd, ocontents +
-							       irelscan->r_offset + 2);
+                      unsigned long instr = bfd_get_32 (abfd, ocontents + irelscan->r_offset);
+                      immediate = instr & 0x0000ffff;
 		      target_address = immediate;
 		      offset = calc_fixup (target_address, sec);
 		      immediate -= offset;
 		      irelscan->r_addend -= offset;
-		      bfd_put_16 (abfd, immediate, ocontents + irelscan->r_offset + 2);
+                      microblaze_bfd_write_imm_value_32 (abfd, ocontents + irelscan->r_offset, irelscan->r_addend);
 		    }
 		}
 
@@ -1669,15 +2202,10 @@ microblaze_elf_relax_section (bfd *abfd,
 			      elf_section_data (o)->this_hdr.contents = ocontents;
 			    }
 			}
-		      immediate = (unsigned short) (bfd_get_16 (abfd, ocontents
-								+ irelscan->r_offset
-								+ 2) << 16)
-			& 0xffff0000;
-		      immediate += (unsigned short) (bfd_get_16 (abfd, ocontents
-								 + irelscan->r_offset
-								 + INST_WORD_SIZE + 2))
-			& 0x0000ffff;
-
+                      unsigned long instr_hi =  bfd_get_32 (abfd, ocontents + irelscan->r_offset);
+                      unsigned long instr_lo =  bfd_get_32 (abfd, ocontents + irelscan->r_offset + INST_WORD_SIZE);
+                      immediate = (instr_hi & 0x0000ffff) << 16;
+                      immediate |= (instr_lo & 0x0000ffff);
 		      offset = calc_fixup (irelscan->r_addend, sec);
 		      immediate -= offset;
 		      irelscan->r_addend -= offset;
@@ -1715,22 +2243,15 @@ microblaze_elf_relax_section (bfd *abfd,
 			      elf_section_data (o)->this_hdr.contents = ocontents;
 			    }
 			}
-
-		      immediate = (unsigned short)
-			(bfd_get_16 (abfd, ocontents + irelscan->r_offset + 2) << 16)
-			& 0xffff0000;
-		      immediate += (unsigned short)
-			(bfd_get_16 (abfd, ocontents + irelscan->r_offset
-				     + INST_WORD_SIZE + 2))
-			& 0x0000ffff;
+                      unsigned long instr_hi =  bfd_get_32 (abfd, ocontents + irelscan->r_offset);
+                      unsigned long instr_lo =  bfd_get_32 (abfd, ocontents + irelscan->r_offset + INST_WORD_SIZE);
+                      immediate = (instr_hi & 0x0000ffff) << 16;
+                      immediate |= (instr_lo & 0x0000ffff);
 		      target_address = immediate;
 		      offset = calc_fixup (target_address, sec);
 		      immediate -= offset;
 		      irelscan->r_addend -= offset;
-		      bfd_put_16 (abfd, ((immediate >> 16) & 0x0000ffff),
-				  ocontents + irelscan->r_offset + 2);
-		      bfd_put_16 (abfd, (immediate & 0x0000ffff),
-				  ocontents + irelscan->r_offset + INST_WORD_SIZE + 2);
+                      microblaze_bfd_write_imm_value_64 (abfd, ocontents + irelscan->r_offset, immediate);
 		    }
 		}
             }
@@ -1740,23 +2261,38 @@ microblaze_elf_relax_section (bfd *abfd,
       isymend = isymbuf + symtab_hdr->sh_info;
       for (isym = isymbuf; isym < isymend; isym++)
         {
-          if (isym->st_shndx == shndx)
-	    isym->st_value =- calc_fixup (isym->st_value, sec);
+          if (isym->st_shndx == shndx) {
+            int count, count_size;
+
+            count = calc_fixup (isym->st_value, sec);
+            count_size = calc_size_fixup (isym->st_value, isym->st_size, sec);
+            D(fprintf(stderr, "local adjust loc=%x.%d size=%d.%d \n",
+			isym->st_value, -count,
+			isym->st_size, -count_size));
+            isym->st_value -= count;
+            isym->st_size -= count_size;
+          }
         }
 
       /* Now adjust the global symbols defined in this section.  */
       isym = isymbuf + symtab_hdr->sh_info;
-      isymend = isymbuf + (symtab_hdr->sh_size / sizeof (Elf32_External_Sym));
-      for (sym_index = 0; isym < isymend; isym++, sym_index++)
+      symcount =  (symtab_hdr->sh_size / sizeof (Elf32_External_Sym)) - symtab_hdr->sh_info;
+      for (sym_index = 0; sym_index < symcount; sym_index++)
         {
           sym_hash = elf_sym_hashes (abfd)[sym_index];
-          if (isym->st_shndx == shndx
-              && (sym_hash->root.type == bfd_link_hash_defined
+          if ((sym_hash->root.type == bfd_link_hash_defined
                   || sym_hash->root.type == bfd_link_hash_defweak)
               && sym_hash->root.u.def.section == sec)
 	    {
-	      sym_hash->root.u.def.value -= calc_fixup (sym_hash->root.u.def.value,
-						        sec);
+              int count, count_size;
+
+              count = calc_fixup (sym_hash->root.u.def.value, sec);
+              count_size = calc_size_fixup (sym_hash->root.u.def.value, sym_hash->size, sec);
+              D(fprintf(stderr, "adjust loc=%x.%d size=%d.%d \n",
+			sym_hash->root.u.def.value, -count,
+			 sym_hash->size, -count_size));
+              sym_hash->root.u.def.value -= count;
+              sym_hash->size -= count_size;
 	    }
 	}
 
@@ -1771,6 +2307,8 @@ microblaze_elf_relax_section (bfd *abfd,
           memmove (contents + dest, contents + src, len);
           sec->size -= sec->relax[i].size;
           dest += len;
+          D(fprintf(stderr, "relax %x to %x relaxsize=%d secsize=%d\n",
+		src, dest, sec->relax[i].size, sec->size));
         }
 
       elf_section_data (sec)->relocs = internal_relocs;
@@ -1800,9 +2338,12 @@ microblaze_elf_relax_section (bfd *abfd,
 
   if (sec->relax_count == 0)
     {
+      *again = FALSE;
       free (sec->relax);
       sec->relax = NULL;
     }
+  else
+    *again = TRUE;
   return TRUE;
 
  error_return:
@@ -1894,6 +2435,34 @@ create_got_section (bfd *dynobj, struct bfd_link_info *info)
   return TRUE;
 }
 
+static bfd_boolean
+update_local_sym_info (bfd *abfd,
+		       Elf_Internal_Shdr *symtab_hdr,
+		       unsigned long r_symndx,
+		       unsigned int tls_type)
+{
+  bfd_signed_vma *local_got_refcounts = elf_local_got_refcounts (abfd);
+  unsigned char *local_got_tls_masks;
+
+  if (local_got_refcounts == NULL)
+    {
+      bfd_size_type size = symtab_hdr->sh_info;
+
+      size *= (sizeof (*local_got_refcounts)
+	       + sizeof (*local_got_tls_masks));
+      local_got_refcounts = bfd_zalloc (abfd, size);
+      if (local_got_refcounts == NULL)
+	return FALSE;
+      elf_local_got_refcounts (abfd) = local_got_refcounts;
+    }
+
+  local_got_tls_masks = 
+         (unsigned char *) (local_got_refcounts + symtab_hdr->sh_info);
+  local_got_tls_masks[r_symndx] |= tls_type;
+  local_got_refcounts[r_symndx] += 1;
+
+  return TRUE;
+}
 /* Look through the relocs for a section during the first phase.  */
 
 static bfd_boolean
@@ -1930,6 +2499,7 @@ microblaze_elf_check_relocs (bfd * abfd,
       unsigned int r_type;
       struct elf_link_hash_entry * h;
       unsigned long r_symndx;
+      unsigned char tls_type = 0;
 
       r_symndx = ELF32_R_SYM (rel->r_info);
       r_type = ELF32_R_TYPE (rel->r_info);
@@ -1965,6 +2535,13 @@ microblaze_elf_check_relocs (bfd * abfd,
           break;
 
 	  /* This relocation requires .got entry.  */
+        case R_MICROBLAZE_TLSGD:
+		tls_type |= (TLS_TLS | TLS_GD);	
+		goto dogottls;
+        case R_MICROBLAZE_TLSLD:
+		tls_type |= (TLS_TLS | TLS_LD);	
+	dogottls:
+	  sec->has_tls_reloc = 1;
         case R_MICROBLAZE_GOT_64:
           if (htab->sgot == NULL)
             {
@@ -1976,25 +2553,12 @@ microblaze_elf_check_relocs (bfd * abfd,
           if (h != NULL)
 	    {
 	      h->got.refcount += 1;
+	      elf32_mb_hash_entry (h)->tls_mask |= tls_type;
 	    }
           else
 	    {
-	      bfd_signed_vma *local_got_refcounts;
-
-	      /* This is a global offset table entry for a local symbol.  */
-	      local_got_refcounts = elf_local_got_refcounts (abfd);
-	      if (local_got_refcounts == NULL)
-		{
-		  bfd_size_type size;
-
-		  size = symtab_hdr->sh_info;
-		  size *= sizeof (bfd_signed_vma);
-		  local_got_refcounts = bfd_zalloc (abfd, size);
-		  if (local_got_refcounts == NULL)
-		    return FALSE;
-		  elf_local_got_refcounts (abfd) = local_got_refcounts;
-		}
-	      local_got_refcounts[r_symndx] += 1;
+              if (! update_local_sym_info(abfd, symtab_hdr, r_symndx, tls_type) )
+		return FALSE;
 	    }
           break;
 
@@ -2007,7 +2571,7 @@ microblaze_elf_check_relocs (bfd * abfd,
 		/* we may need a copy reloc.  */
 		h->non_got_ref = 1;
 
-		/* we may also need a .plt entry.  */
+	        /* we may also need a .plt entry.  */
 		h->plt.refcount += 1;
 		if (ELF32_R_TYPE (rel->r_info) != R_MICROBLAZE_64_PCREL)
 		  h->pointer_equality_needed = 1;
@@ -2058,44 +2622,17 @@ microblaze_elf_check_relocs (bfd * abfd,
 
 		if (sreloc == NULL)
 		  {
-		    const char *name;
 		    bfd *dynobj;
-		    unsigned int strndx = elf_elfheader (abfd)->e_shstrndx;
-		    unsigned int shnam = _bfd_elf_single_rel_hdr (sec)->sh_name;
-
-		    name = bfd_elf_string_from_elf_section (abfd, strndx, shnam);
-		    if (name == NULL)
-		      return FALSE;
-
-		    if (strncmp (name, ".rela", 5) != 0
-			|| strcmp (bfd_get_section_name (abfd, sec),
-				   name + 5) != 0)
-		      {
-			(*_bfd_error_handler)
-			  (_("%B: bad relocation section name `%s\'"),
-			   abfd, name);
-		      }
 
 		    if (htab->elf.dynobj == NULL)
 		      htab->elf.dynobj = abfd;
+
 		    dynobj = htab->elf.dynobj;
 
-		    sreloc = bfd_get_section_by_name (dynobj, name);
+	            sreloc = _bfd_elf_make_dynamic_reloc_section
+		                     (sec, dynobj, 2, abfd, 1);
 		    if (sreloc == NULL)
-		      {
-			flagword flags;
-
-			sreloc = bfd_make_section (dynobj, name);
-			flags = (SEC_HAS_CONTENTS | SEC_READONLY
-				 | SEC_IN_MEMORY | SEC_LINKER_CREATED);
-			if ((sec->flags & SEC_ALLOC) != 0)
-			  flags |= SEC_ALLOC | SEC_LOAD;
-			if (sreloc == NULL
-			    || ! bfd_set_section_flags (dynobj, sreloc, flags)
-			    || ! bfd_set_section_alignment (dynobj, sreloc, 2))
-			  return FALSE;
-		      }
-		    elf_section_data (sec)->sreloc = sreloc;
+		      return FALSE;
 		  }
 
 		/* If this is a global symbol, we count the number of
@@ -2226,6 +2763,8 @@ microblaze_elf_copy_indirect_symbol (struct bfd_link_info *info,
       eind->dyn_relocs = NULL;
     }
 
+   edir->tls_mask |= eind->tls_mask;
+
   _bfd_elf_link_hash_copy_indirect (info, dir, ind);
 }
 
@@ -2444,8 +2983,10 @@ allocate_dynrelocs (struct elf_link_hash_entry *h, void * dat)
       h->needs_plt = 0;
     }
 
+  eh = (struct elf32_mb_link_hash_entry *) h;
   if (h->got.refcount > 0)
     {
+      unsigned int need;
       asection *s;
 
       /* Make sure this symbol is output as a dynamic symbol.
@@ -2456,16 +2997,43 @@ allocate_dynrelocs (struct elf_link_hash_entry *h, void * dat)
           if (! bfd_elf_link_record_dynamic_symbol (info, h))
             return FALSE;
         }
-
-      s = htab->sgot;
-      h->got.offset = s->size;
-      s->size += 4;
-      htab->srelgot->size += sizeof (Elf32_External_Rela);
+      need = 0;
+      if ((eh->tls_mask & TLS_TLS) != 0)
+	{
+          /* Handle TLS Symbol */ 
+	  if ((eh->tls_mask & TLS_LD) != 0)
+	    {
+	      if (!eh->elf.def_dynamic)
+		/* We'll just use htab->tlsld_got.offset.  This should
+		   always be the case.  It's a little odd if we have
+		   a local dynamic reloc against a non-local symbol.  */
+		htab->tlsld_got.refcount += 1;
+	      else
+		need += 8;
+	    }
+	  if ((eh->tls_mask & TLS_GD) != 0)
+	    need += 8;
+	}
+      else 
+	{
+          /* Regular (non-TLS) symbol */
+	  need += 4;
+	}
+      if (need == 0)
+        {
+          h->got.offset = (bfd_vma) -1;
+        }
+      else 
+        {
+          s = htab->sgot;
+          h->got.offset = s->size;
+          s->size += need;
+          htab->srelgot->size += need * (sizeof (Elf32_External_Rela) / 4);
+        }
     }
   else
     h->got.offset = (bfd_vma) -1;
 
-  eh = (struct elf32_mb_link_hash_entry *) h;
   if (eh->dyn_relocs == NULL)
     return TRUE;
 
@@ -2563,6 +3131,7 @@ microblaze_elf_size_dynamic_sections (bfd *output_bfd ATTRIBUTE_UNUSED,
       bfd_signed_vma *end_local_got;
       bfd_size_type locsymcount;
       Elf_Internal_Shdr *symtab_hdr;
+      unsigned char *lgot_masks;
       asection *srel;
 
       if (bfd_get_flavour (ibfd) != bfd_target_elf_flavour)
@@ -2602,17 +3171,36 @@ microblaze_elf_size_dynamic_sections (bfd *output_bfd ATTRIBUTE_UNUSED,
       symtab_hdr = &elf_tdata (ibfd)->symtab_hdr;
       locsymcount = symtab_hdr->sh_info;
       end_local_got = local_got + locsymcount;
+      lgot_masks = (unsigned char *) end_local_got;
       s = htab->sgot;
       srel = htab->srelgot;
 
-      for (; local_got < end_local_got; ++local_got)
+      for (; local_got < end_local_got; ++local_got, ++lgot_masks)
         {
           if (*local_got > 0)
             {
-              *local_got = s->size;
-              s->size += 4;
-              if (info->shared)
-                srel->size += sizeof (Elf32_External_Rela);
+	      unsigned int need = 0;
+	      if ((*lgot_masks & TLS_TLS) != 0)
+	        {
+		  if ((*lgot_masks & TLS_GD) != 0)
+		    need += 8;
+		  if ((*lgot_masks & TLS_LD) != 0)
+		    htab->tlsld_got.refcount += 1;
+	        }
+	      else
+	        need += 4;
+
+              if (need == 0)
+                {
+                  *local_got = (bfd_vma) -1;
+                }
+              else
+                {
+                  *local_got = s->size;
+                  s->size += need;
+                  if (info->shared)
+                    srel->size += need * ( sizeof (Elf32_External_Rela) / 4 );
+                }
             }
           else
             *local_got = (bfd_vma) -1;
@@ -2623,6 +3211,16 @@ microblaze_elf_size_dynamic_sections (bfd *output_bfd ATTRIBUTE_UNUSED,
      sym dynamic relocs.  */
   elf_link_hash_traverse (elf_hash_table (info), allocate_dynrelocs, info);
 
+  if (htab->tlsld_got.refcount > 0)
+    {
+      htab->tlsld_got.offset = htab->sgot->size;
+      htab->sgot->size += 8;
+      if (info->shared)
+	htab->srelgot->size += sizeof (Elf32_External_Rela);
+    }
+  else
+    htab->tlsld_got.offset = (bfd_vma) -1;
+
   if (elf_hash_table (info)->dynamic_sections_created)
     {
       /* Make space for the trailing nop in .plt.  */
@@ -2741,6 +3339,7 @@ microblaze_elf_finish_dynamic_symbol (bfd *output_bfd,
 				      Elf_Internal_Sym *sym)
 {
   struct elf32_mb_link_hash_table *htab;
+  struct elf32_mb_link_hash_entry *eh = elf32_mb_hash_entry(h);
 
   htab = elf32_mb_hash_table (info);
   if (htab == NULL)
@@ -2812,12 +3411,14 @@ microblaze_elf_finish_dynamic_symbol (bfd *output_bfd,
         }
     }
 
-  if (h->got.offset != (bfd_vma) -1)
+  /* h->got.refcount to be checked ? */
+  if (h->got.offset != (bfd_vma) -1 && 
+      ! ((h->got.offset & 1) || 
+        IS_TLS_LD(eh->tls_mask) || IS_TLS_GD(eh->tls_mask)))
     {
       asection *sgot;
       asection *srela;
-      Elf_Internal_Rela rela;
-      bfd_byte *loc;
+      bfd_vma offset;
 
       /* This symbol has an entry in the global offset table.  Set it
          up.  */
@@ -2826,36 +3427,36 @@ microblaze_elf_finish_dynamic_symbol (bfd *output_bfd,
       srela = htab->srelgot;
       BFD_ASSERT (sgot != NULL && srela != NULL);
 
-      rela.r_offset = (sgot->output_section->vma
-                       + sgot->output_offset
+      offset = (sgot->output_section->vma + sgot->output_offset
                        + (h->got.offset &~ (bfd_vma) 1));
 
-      /* If this is a -Bsymbolic link, and the symbol is defined
-         locally, we just want to emit a RELATIVE reloc.  Likewise if
-         the symbol was forced to be local because of a version file.
-         The entry in the global offset table will already have been
-         initialized in the relocate_section function.  */
-      if (info->shared
-          && (info->symbolic || h->dynindx == -1)
-          && h->def_regular)
-        {
-          asection *sec = h->root.u.def.section;
-          rela.r_info = ELF32_R_INFO (0, R_MICROBLAZE_REL);
-          rela.r_addend = (h->root.u.def.value
-                           + sec->output_section->vma
-                           + sec->output_offset);
-        }
-      else
-        {
-          rela.r_info = ELF32_R_INFO (h->dynindx, R_MICROBLAZE_GLOB_DAT);
-          rela.r_addend = 0;
-        }
+       {
+         /* If this is a -Bsymbolic link, and the symbol is defined
+            locally, we just want to emit a RELATIVE reloc.  Likewise if
+            the symbol was forced to be local because of a version file.
+            The entry in the global offset table will already have been
+            initialized in the relocate_section function.  */
+          if (info->shared && (info->symbolic || h->dynindx == -1)
+            && h->def_regular)
+          {
+            asection *sec = h->root.u.def.section;
+            microblaze_elf_output_dynamic_relocation ( output_bfd, 
+              srela, srela->reloc_count++, /* symindex= */ 0,
+   	      R_MICROBLAZE_REL, offset, 
+              h->root.u.def.value + sec->output_section->vma 
+              + sec->output_offset);
+          }
+        else
+          {
+            microblaze_elf_output_dynamic_relocation ( output_bfd, 
+              srela, srela->reloc_count++,
+	      h->dynindx, R_MICROBLAZE_GLOB_DAT, offset, 0);
+          }
+       }
 
-      bfd_put_32 (output_bfd, (bfd_vma) 0,
+        bfd_put_32 (output_bfd, (bfd_vma) 0,
                   sgot->contents + (h->got.offset &~ (bfd_vma) 1));
-      loc = srela->contents;
-      loc += srela->reloc_count++ * sizeof (Elf32_External_Rela);
-      bfd_elf32_swap_reloca_out (output_bfd, &rela, loc);
+
     }
 
   if (h->needs_copy)
@@ -3016,6 +3617,8 @@ microblaze_elf_add_symbol_hook (bfd *abfd,
   return TRUE;
 }
 
+#define TARGET_LITTLE_SYM      bfd_elf32_microblazeel_vec
+#define TARGET_LITTLE_NAME     "elf32-microblazeel"
 
 #define TARGET_BIG_SYM          bfd_elf32_microblaze_vec
 #define TARGET_BIG_NAME		"elf32-microblaze"
@@ -3024,7 +3627,7 @@ microblaze_elf_add_symbol_hook (bfd *abfd,
 #define ELF_TARGET_ID		MICROBLAZE_ELF_DATA
 #define ELF_MACHINE_CODE	EM_MICROBLAZE
 #define ELF_MACHINE_ALT1	EM_MICROBLAZE_OLD
-#define ELF_MAXPAGESIZE		0x4   		/* 4k, if we ever have 'em.  */
+#define ELF_MAXPAGESIZE		0x1000   		/* 4k, if we ever have 'em.  */
 #define elf_info_to_howto	microblaze_elf_info_to_howto
 #define elf_info_to_howto_rel	NULL
 
@@ -3032,6 +3635,7 @@ microblaze_elf_add_symbol_hook (bfd *abfd,
 #define bfd_elf32_bfd_is_local_label_name       microblaze_elf_is_local_label_name
 #define elf_backend_relocate_section		microblaze_elf_relocate_section
 #define bfd_elf32_bfd_relax_section             microblaze_elf_relax_section
+#define bfd_elf32_bfd_merge_private_bfd_data    microblaze_elf_merge_private_bfd_data
 #define bfd_elf32_bfd_reloc_name_lookup		microblaze_elf_reloc_name_lookup
 
 #define elf_backend_gc_mark_hook		microblaze_elf_gc_mark_hook
diff --git a/bfd/targets.c b/bfd/targets.c
index 112ac12..3103565 100644
--- a/bfd/targets.c
+++ b/bfd/targets.c
@@ -651,6 +651,7 @@ extern const bfd_target bfd_elf32_mcore_big_vec;
 extern const bfd_target bfd_elf32_mcore_little_vec;
 extern const bfd_target bfd_elf32_mep_vec;
 extern const bfd_target bfd_elf32_mep_little_vec;
+extern const bfd_target bfd_elf32_microblazeel_vec;
 extern const bfd_target bfd_elf32_microblaze_vec;
 extern const bfd_target bfd_elf32_mn10200_vec;
 extern const bfd_target bfd_elf32_mn10300_vec;
@@ -1022,6 +1023,7 @@ static const bfd_target * const _bfd_target_vector[] =
 	&bfd_elf32_mcore_big_vec,
 	&bfd_elf32_mcore_little_vec,
 	&bfd_elf32_mep_vec,
+	&bfd_elf32_microblazeel_vec,
 	&bfd_elf32_microblaze_vec,
 	&bfd_elf32_mn10200_vec,
 	&bfd_elf32_mn10300_vec,
diff --git a/config.sub b/config.sub
index 78176a4..eb61d26 100755
--- a/config.sub
+++ b/config.sub
@@ -154,7 +154,7 @@ case $os in
 	-convergent* | -ncr* | -news | -32* | -3600* | -3100* | -hitachi* |\
 	-c[123]* | -convex* | -sun | -crds | -omron* | -dg | -ultra | -tti* | \
 	-harris | -dolphin | -highlevel | -gould | -cbm | -ns | -masscomp | \
-	-apple | -axis | -knuth | -cray | -microblaze)
+	-apple | -axis | -knuth | -cray | -microblaze*)
 		os=
 		basic_machine=$1
 		;;
@@ -264,7 +264,7 @@ case $basic_machine in
 	| le32 | le64 \
 	| lm32 \
 	| m32c | m32r | m32rle | m68000 | m68k | m88k \
-	| maxq | mb | microblaze | mcore | mep | metag \
+	| maxq | mb | microblaze | microblazeel | mcore | mep | metag \
 	| mips | mipsbe | mipseb | mipsel | mipsle \
 	| mips16 \
 	| mips64 | mips64el \
@@ -377,7 +377,8 @@ case $basic_machine in
 	| lm32-* \
 	| m32c-* | m32r-* | m32rle-* \
 	| m68000-* | m680[012346]0-* | m68360-* | m683?2-* | m68k-* \
-	| m88110-* | m88k-* | maxq-* | mcore-* | metag-* | microblaze-* \
+	| m88110-* | m88k-* | maxq-* | mcore-* | metag-* \
+	| microblaze-* | microblazeel-* \
 	| mips-* | mipsbe-* | mipseb-* | mipsel-* | mipsle-* \
 	| mips16-* \
 	| mips64-* | mips64el-* \
@@ -777,7 +778,7 @@ case $basic_machine in
 		basic_machine=ns32k-utek
 		os=-sysv
 		;;
-	microblaze)
+	microblaze*)
 		basic_machine=microblaze-xilinx
 		;;
 	mingw32)
diff --git a/gdb-environment.csh b/gdb-environment.csh
new file mode 100644
index 0000000..bf769b3
--- /dev/null
+++ b/gdb-environment.csh
@@ -0,0 +1,30 @@
+# GDB related environment variables settings
+foreach l ($PETALINUX/tools/linux-i386/microblaze-unknown-linux-gnu/share/tcl*.*)
+	if ( -f $l/init.tcl ) then
+		setenv TCL_LIBRARY $l
+		break
+	endif
+end
+
+foreach l ($PETALINUX/tools/linux-i386/microblaze-unknown-linux-gnu/share/tk*.*)
+	if ( -d $l ) then
+		setenv TK_LIBRARY $l
+		break
+	endif
+end
+
+setenv REDHAT_GUI_LIBRARY $PETALINUX/tools/linux-i386/microblaze-unknown-linux-gnu/share/redhat/gui;
+
+foreach l ($PETALINUX/tools/linux-i386/microblaze-unknown-linux-gnu/share/insight*.*)
+	if ( -d $l ) then
+		setenv GDBTK_LIBRARY $l
+		break
+	endif
+end
+
+foreach l ($PETALINUX/tools/linux-i386/microblaze-unknown-linux-gnu/share/iwidgets*.*)
+	if ( -d $l ) then
+		setenv INSIGHT_PLUGINS $l
+		break
+	endif
+end
diff --git a/gdb-environment.sh b/gdb-environment.sh
new file mode 100644
index 0000000..cabf77a
--- /dev/null
+++ b/gdb-environment.sh
@@ -0,0 +1,15 @@
+# GDB related environment variables settings
+for l in $PETALINUX/tools/linux-i386/microblaze-unknown-linux-gnu/share/tcl*.*; do
+[ -f $l/init.tcl ] && TCL_LIBRARY=$l && break
+done
+for l in $PETALINUX/tools/linux-i386/microblaze-unknown-linux-gnu/share/tk*.*; do
+[ -d $l ] && TK_LIBRARY=$l && break;
+done
+REDHAT_GUI_LIBRARY=$PETALINUX/tools/linux-i386/microblaze-unknown-linux-gnu/share/redhat/gui;
+for l in $PETALINUX/tools/linux-i386/microblaze-unknown-linux-gnu/share/insight*.*; do
+[ -d $l ] && GDBTK_LIBRARY=$l && break;
+done
+for l in $PETALINUX/tools/linux-i386/microblaze-unknown-linux-gnu/share/iwidgets*.*; do
+[ -d $l ] && INSIGHT_PLUGINS=$l && break;
+done
+export TCL_LIBRARY TK_LIBRARY REDHAT_GUI_LIBRARY INSIGHT_PLUGINS
diff --git a/gdb/blockframe.c b/gdb/blockframe.c
index ba755a1..3563312 100644
--- a/gdb/blockframe.c
+++ b/gdb/blockframe.c
@@ -78,7 +78,8 @@ get_frame_block (struct frame_info *frame, CORE_ADDR *addr_in_block)
 	inline_count--;
 
       bl = BLOCK_SUPERBLOCK (bl);
-      gdb_assert (bl != NULL);
+      if (!bl)
+        return NULL;
     }
 
   return bl;
diff --git a/gdb/gdbserver/Makefile.in b/gdb/gdbserver/Makefile.in
index 6d77ce2..c42b1f2 100644
--- a/gdb/gdbserver/Makefile.in
+++ b/gdb/gdbserver/Makefile.in
@@ -115,6 +115,7 @@ SFILES=	$(srcdir)/gdbreplay.c $(srcdir)/inferiors.c $(srcdir)/dll.c \
 	$(srcdir)/linux-ia64-low.c $(srcdir)/linux-low.c \
 	$(srcdir)/linux-m32r-low.c \
 	$(srcdir)/linux-m68k-low.c $(srcdir)/linux-mips-low.c \
+	$(srcdir)/linux-microblaze-low.c \
 	$(srcdir)/linux-ppc-low.c \
 	$(srcdir)/linux-s390-low.c \
 	$(srcdir)/linux-sh-low.c $(srcdir)/linux-sparc-low.c \
@@ -284,6 +285,7 @@ clean:
 	rm -f i386-avx.c i386-avx-linux.c
 	rm -f amd64-avx.c amd64-avx-linux.c
 	rm -f i386-mmx.c i386-mmx-linux.c
+	rm -f reg-microblaze.c
 
 maintainer-clean realclean distclean: clean
 	rm -f nm.h tm.h xm.h config.status config.h stamp-h config.log
@@ -472,6 +474,8 @@ linux-ia64-low.o: linux-ia64-low.c $(linux_low_h) $(server_h)
 linux-m32r-low.o: linux-m32r-low.c $(linux_low_h) $(server_h)
 linux-mips-low.o: linux-mips-low.c $(linux_low_h) $(server_h) \
 	$(gdb_proc_service_h)
+linux-microblaze-low.o: linux-microblaze-low.c $(linux_low_h) $(server_h) \
+	$(gdb_proc_service_h)
 linux-ppc-low.o: linux-ppc-low.c $(linux_low_h) $(server_h)
 linux-s390-low.o: linux-s390-low.c $(linux_low_h) $(server_h)
 linux-sh-low.o: linux-sh-low.c $(linux_low_h) $(server_h)
@@ -557,6 +561,9 @@ mips-dsp-linux.c : $(srcdir)/../regformats/mips-dsp-linux.dat $(regdat_sh)
 mips64-linux.o : mips64-linux.c $(regdef_h)
 mips64-linux.c : $(srcdir)/../regformats/mips64-linux.dat $(regdat_sh)
 	$(SHELL) $(regdat_sh) $(srcdir)/../regformats/mips64-linux.dat mips64-linux.c
+reg-microblaze.o : reg-microblaze.c $(regdef_h)
+reg-microblaze.c : $(srcdir)/../regformats/reg-microblaze.dat $(regdat_sh)
+	$(SHELL) $(regdat_sh) $(srcdir)/../regformats/reg-microblaze.dat reg-microblaze.c
 mips64-dsp-linux.o : mips64-dsp-linux.c $(regdef_h)
 mips64-dsp-linux.c : $(srcdir)/../regformats/mips64-dsp-linux.dat $(regdat_sh)
 	$(SHELL) $(regdat_sh) $(srcdir)/../regformats/mips64-dsp-linux.dat mips64-dsp-linux.c
diff --git a/gdb/gdbserver/configure.srv b/gdb/gdbserver/configure.srv
index bdd9916..bf2c2a0 100644
--- a/gdb/gdbserver/configure.srv
+++ b/gdb/gdbserver/configure.srv
@@ -182,6 +182,11 @@ case "${target}" in
 			srv_linux_usrregs=yes
 			srv_linux_thread_db=yes
 			;;
+  microblaze*-*-linux*)	srv_regobj=reg-microblaze.o
+			srv_tgtobj="linux-low.o linux-osdata.o linux-microblaze-low.o linux-procfs.o"
+			srv_linux_usrregs=yes
+			srv_linux_thread_db=yes
+			;;
   powerpc*-*-linux*)	srv_regobj="powerpc-32l.o"
 			srv_regobj="${srv_regobj} powerpc-altivec32l.o"
 			srv_regobj="${srv_regobj} powerpc-cell32l.o"
diff --git a/gdb/gdbserver/linux-microblaze-low.c b/gdb/gdbserver/linux-microblaze-low.c
new file mode 100644
index 0000000..57e5c69
--- /dev/null
+++ b/gdb/gdbserver/linux-microblaze-low.c
@@ -0,0 +1,134 @@
+/* GNU/Linux/PowerPC specific low level interface, for the remote server for
+   GDB.
+   Copyright (C) 1995, 1996, 1998, 1999, 2000, 2001, 2002, 2005
+   Free Software Foundation, Inc.
+
+   This file is part of GDB.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street, Fifth Floor,
+   Boston, MA 02110-1301, USA.  */
+
+#include "server.h"
+#include "linux-low.h"
+
+#include <asm/ptrace.h>
+
+#include "gdb_proc_service.h"
+
+static int microblaze_regmap[] =
+ {       -1,     PT_GPR(1),     PT_GPR(2),     PT_GPR(3),
+  PT_GPR(4),     PT_GPR(5),     PT_GPR(6),     PT_GPR(7),
+  PT_GPR(8),     PT_GPR(9),     PT_GPR(10),    PT_GPR(11),
+  PT_GPR(12),    PT_GPR(13),    PT_GPR(14),    PT_GPR(15),
+  PT_GPR(16),    PT_GPR(17),    PT_GPR(18),    PT_GPR(19),
+  PT_GPR(20),    PT_GPR(21),    PT_GPR(22),    PT_GPR(23),
+  PT_GPR(24),    PT_GPR(25),    PT_GPR(26),    PT_GPR(27),
+  PT_GPR(28),    PT_GPR(29),    PT_GPR(30),    PT_GPR(31),
+  PT_PC,         PT_MSR,        PT_EAR,        PT_ESR,
+  PT_FSR
+  };
+
+#define microblaze_num_regs (sizeof microblaze_regmap / sizeof microblaze_regmap[0])
+
+/* Defined in auto-generated file reg-microblaze.c.  */
+void init_registers_microblaze (void);
+
+static int
+microblaze_cannot_store_register (int regno)
+{
+  if (microblaze_regmap[regno] == -1)
+    return 1;
+
+  return 0;
+}
+
+static int
+microblaze_cannot_fetch_register (int regno)
+{
+  if (find_regno ("r0") == regno)
+    return 1;
+  return 0;
+}
+
+static CORE_ADDR
+microblaze_get_pc (struct regcache *regcache)
+{
+  unsigned long pc;
+
+  collect_register_by_name (regcache, "pc", &pc);
+  return (CORE_ADDR) pc;
+}
+
+static void
+microblaze_set_pc (struct regcache *regcache, CORE_ADDR pc)
+{
+  unsigned long newpc = pc;
+
+  supply_register_by_name (regcache, "pc", &newpc);
+}
+
+/* dbtrap insn */
+/* brki r16, 0x18; */
+static const unsigned long microblaze_breakpoint = 0xba0c0018;
+#define microblaze_breakpoint_len 4
+
+static int
+microblaze_breakpoint_at (CORE_ADDR where)
+{
+  unsigned long insn;
+
+  (*the_target->read_memory) (where, (unsigned char *) &insn, 4);
+  if (insn == microblaze_breakpoint)
+    return 1;
+  /* If necessary, recognize more trap instructions here.  GDB only uses the
+     one.  */
+  return 0;
+}
+
+/* Provide only a fill function for the general register set.  ps_lgetregs
+   will use this for NPTL support.  */
+
+static void microblaze_fill_gregset (struct regcache *regcache, void *buf)
+{
+  int i;
+
+  for (i = 0; i < 32; i++)
+    collect_register (regcache, i, (char *) buf + microblaze_regmap[i]);
+}
+
+static CORE_ADDR
+microblaze_reinsert_addr (struct regcache *regcache)
+{
+  unsigned long pc;
+  collect_register_by_name (regcache, "r15", &pc);
+  return pc;
+}
+
+struct linux_target_ops the_low_target = {
+  init_registers_microblaze,
+  microblaze_num_regs,
+  microblaze_regmap,
+  NULL,
+  microblaze_cannot_fetch_register,
+  microblaze_cannot_store_register,
+  NULL, /* fetch_register */
+  microblaze_get_pc,
+  microblaze_set_pc,
+  (const unsigned char *) &microblaze_breakpoint,
+  microblaze_breakpoint_len,
+  microblaze_reinsert_addr,
+  0,
+  microblaze_breakpoint_at,
+};
diff --git a/gdb/inline-frame.c b/gdb/inline-frame.c
index 06de5b0..4644727 100644
--- a/gdb/inline-frame.c
+++ b/gdb/inline-frame.c
@@ -230,6 +230,9 @@ inline_frame_sniffer (const struct frame_unwind *self,
       cur_block = BLOCK_SUPERBLOCK (cur_block);
     }
 
+  if (depth == 0)
+    return 0;
+
   /* Check how many inlined functions already have frames.  */
   for (next_frame = get_next_frame (this_frame);
        next_frame && get_frame_type (next_frame) == INLINE_FRAME;
diff --git a/gdb/microblaze-tdep.c b/gdb/microblaze-tdep.c
index 3ce3d1c..9ceee25 100644
--- a/gdb/microblaze-tdep.c
+++ b/gdb/microblaze-tdep.c
@@ -74,7 +74,8 @@ static const char *microblaze_register_names[] =
   "rpc",  "rmsr", "rear", "resr", "rfsr", "rbtr",
   "rpvr0", "rpvr1", "rpvr2", "rpvr3", "rpvr4", "rpvr5", "rpvr6",
   "rpvr7", "rpvr8", "rpvr9", "rpvr10", "rpvr11",
-  "redr", "rpid", "rzpr", "rtlbx", "rtlbsx", "rtlblo", "rtlbhi"
+  "redr", "rpid", "rzpr", "rtlbx", "rtlbsx", "rtlblo", "rtlbhi",
+  "rslr", "rshr"
 };
 
 #define MICROBLAZE_NUM_REGS ARRAY_SIZE (microblaze_register_names)
@@ -161,10 +162,15 @@ static const gdb_byte *
 microblaze_breakpoint_from_pc (struct gdbarch *gdbarch, CORE_ADDR *pc, 
 			       int *len)
 {
+  enum bfd_endian byte_order = gdbarch_byte_order (gdbarch);
   static gdb_byte break_insn[] = MICROBLAZE_BREAKPOINT;
+  static gdb_byte break_insn_le[] = MICROBLAZE_BREAKPOINT_LE;
 
   *len = sizeof (break_insn);
-  return break_insn;
+  if (byte_order == BFD_ENDIAN_BIG)
+    return break_insn;
+  else
+    return break_insn_le;
 }
 
 /* Allocate and initialize a frame cache.  */
@@ -236,6 +242,8 @@ microblaze_analyze_prologue (struct gdbarch *gdbarch, CORE_ADDR pc,
   int flags = 0;
   int save_hidden_pointer_found = 0;
   int non_stack_instruction_found = 0;
+  int n_insns;
+  unsigned int *insn_block;
 
   /* Find the start of this function.  */
   find_pc_partial_function (pc, &name, &func_addr, &func_end);
@@ -275,11 +283,18 @@ microblaze_analyze_prologue (struct gdbarch *gdbarch, CORE_ADDR pc,
 		    name, paddress (gdbarch, func_addr), 
 		    paddress (gdbarch, stop));
 
+/* Do a block read to minimize the transaction with the Debug Agent */
+  n_insns = (stop == func_addr) ? 1 : ((stop - func_addr) / INST_WORD_SIZE);
+  insn_block = calloc(n_insns, sizeof(unsigned long));
+
+  target_read_memory (func_addr, (void*) insn_block, n_insns * INST_WORD_SIZE );
+
   for (addr = func_addr; addr < stop; addr += INST_WORD_SIZE)
     {
-      insn = microblaze_fetch_instruction (addr);
+     //insn = microblaze_fetch_instruction (addr);
+      insn = insn_block[(addr - func_addr) / INST_WORD_SIZE];
       op = microblaze_decode_insn (insn, &rd, &ra, &rb, &imm);
-      microblaze_debug ("%s %08lx\n", paddress (gdbarch, pc), insn);
+      microblaze_debug ("%s %08lx op=%x r%d r%d imm=%d\n", paddress (gdbarch, addr), insn, op, rd, ra, imm);
 
       /* This code is very sensitive to what functions are present in the
 	 prologue.  It assumes that the (addi, addik, swi, sw) can be the 
@@ -403,8 +418,8 @@ microblaze_analyze_prologue (struct gdbarch *gdbarch, CORE_ADDR pc,
      part of the prologue.  */
   if (save_hidden_pointer_found)
     prologue_end_addr -= INST_WORD_SIZE;
-
-  return prologue_end_addr;
+    free(insn_block);
+    return prologue_end_addr;
 }
 
 static CORE_ADDR
@@ -461,7 +476,7 @@ microblaze_frame_cache (struct frame_info *next_frame, void **this_cache)
 {
   struct microblaze_frame_cache *cache;
   struct gdbarch *gdbarch = get_frame_arch (next_frame);
-  CORE_ADDR func, pc, fp;
+  CORE_ADDR func;
   int rn;
 
   if (*this_cache)
@@ -477,6 +492,7 @@ microblaze_frame_cache (struct frame_info *next_frame, void **this_cache)
 
   func = get_frame_func (next_frame);
 
+  cache->base = get_frame_register_unsigned (next_frame, gdbarch_sp_regnum (gdbarch));
   cache->pc = get_frame_address_in_block (next_frame);
 
   return cache;
@@ -493,7 +509,7 @@ microblaze_frame_this_id (struct frame_info *next_frame, void **this_cache,
   if (cache->base == 0)
     return;
 
-  (*this_id) = frame_id_build (cache->base, cache->pc);
+  (*this_id) = frame_id_build (cache->base, get_frame_pc (next_frame));
 }
 
 static struct value *
@@ -630,6 +646,107 @@ microblaze_stabs_argument_has_addr (struct gdbarch *gdbarch, struct type *type)
   return (TYPE_LENGTH (type) == 16);
 }
 
+int
+microblaze_software_single_step (struct frame_info *frame)
+{
+  struct gdbarch *arch = get_frame_arch (frame);
+  struct address_space *aspace = get_frame_address_space (frame);
+  struct gdbarch_tdep *tdep = gdbarch_tdep (arch);
+  static char le_breakp[] = MICROBLAZE_BREAKPOINT_LE;
+  static char be_breakp[] = MICROBLAZE_BREAKPOINT;
+  enum bfd_endian byte_order = gdbarch_byte_order (arch);
+  char *breakp = byte_order == BFD_ENDIAN_BIG ? be_breakp : le_breakp;
+  int ret = 0;
+
+  /* Save the address and the values of the next_pc and the target */
+  static struct sstep_breaks
+  {
+    CORE_ADDR address;
+    bfd_boolean valid;
+    /* Shadow contents.  */
+    char data[INST_WORD_SIZE];
+  } stepbreaks[2];
+  int ii;
+
+  if (1)
+    {
+      CORE_ADDR pc;
+      long insn;
+      enum microblaze_instr minstr;
+      bfd_boolean isunsignednum;
+      enum microblaze_instr_type insn_type;
+      short delay_slots;
+      int imm;
+      bfd_boolean immfound = FALSE;
+
+      /* Set a breakpoint at the next instruction */
+      /* If the current instruction is an imm, set it at the inst after */
+      /* If the instruction has a delay slot, skip the delay slot */
+      pc = get_frame_pc (frame);
+      insn = microblaze_fetch_instruction (pc);
+      minstr = get_insn_microblaze (insn, &isunsignednum, &insn_type, &delay_slots);
+      if (insn_type == immediate_inst)
+	{
+	  int rd, ra, rb;
+	  immfound = TRUE;
+	  minstr = microblaze_decode_insn (insn, &rd, &ra, &rb, &imm);
+	  pc = pc + INST_WORD_SIZE;
+	  insn = microblaze_fetch_instruction (pc);
+	  minstr = get_insn_microblaze (insn, &isunsignednum, &insn_type, &delay_slots);
+	}
+      stepbreaks[0].address = pc + (delay_slots * INST_WORD_SIZE) + INST_WORD_SIZE;
+      if (insn_type != return_inst) {
+	stepbreaks[0].valid = TRUE;
+      } else {
+	stepbreaks[0].valid = FALSE;
+      }
+
+      microblaze_debug ("single-step insn_type=%x insn=%x\n", insn_type, insn);
+      /* Now check for branch or return instructions */
+      if (insn_type == branch_inst || insn_type == return_inst) {
+	int limm;
+	int lrd, lra, lrb;
+	int ra, rb;
+	bfd_boolean targetvalid;
+	bfd_boolean unconditionalbranch;
+	microblaze_decode_insn(insn, &lrd, &lra, &lrb, &limm);
+	if (lra >= 0 && lra < MICROBLAZE_NUM_REGS)
+	  ra = get_frame_register_unsigned (frame, lra);
+	else
+	  ra = 0;
+	if (lrb >= 0 && lrb < MICROBLAZE_NUM_REGS)
+	  rb = get_frame_register_unsigned (frame, lrb);
+	else
+	  rb = 0;
+	stepbreaks[1].address = microblaze_get_target_address (insn, immfound, imm, pc, ra, rb, &targetvalid, &unconditionalbranch);
+        microblaze_debug ("single-step uncondbr=%d targetvalid=%d target=%x\n", unconditionalbranch, targetvalid, stepbreaks[1].address);
+	if (unconditionalbranch)
+	  stepbreaks[0].valid = FALSE; /* This is a unconditional branch: will not come to the next address */
+	if (targetvalid && (stepbreaks[0].valid == FALSE ||
+			    (stepbreaks[0].address != stepbreaks[1].address))
+	                && (stepbreaks[1].address != pc)) {
+	  stepbreaks[1].valid = TRUE;
+	} else {
+	  stepbreaks[1].valid = FALSE;
+	}
+      } else {
+	stepbreaks[1].valid = FALSE;
+      }
+
+      /* Insert the breakpoints */
+      for (ii = 0; ii < 2; ++ii)
+        {
+
+          /* ignore invalid breakpoint. */
+          if (stepbreaks[ii].valid) {
+            insert_single_step_breakpoint (arch, aspace, stepbreaks[ii].address);
+            ret = 1;
+	  }
+	}
+    }
+    return ret;
+}
+
 static void
 microblaze_write_pc (struct regcache *regcache, CORE_ADDR pc)
 {
@@ -709,6 +826,7 @@ microblaze_gdbarch_init (struct gdbarch_info info, struct gdbarch_list *arches)
   set_gdbarch_inner_than (gdbarch, core_addr_lessthan);
 
   set_gdbarch_breakpoint_from_pc (gdbarch, microblaze_breakpoint_from_pc);
+  set_gdbarch_software_single_step (gdbarch, microblaze_software_single_step);
 
   set_gdbarch_frame_args_skip (gdbarch, 8);
 
diff --git a/gdb/microblaze-tdep.h b/gdb/microblaze-tdep.h
index b0362b1..4165d03 100644
--- a/gdb/microblaze-tdep.h
+++ b/gdb/microblaze-tdep.h
@@ -42,7 +42,7 @@ struct microblaze_frame_cache
   int fp_regnum;
 
   /* Offsets to saved registers.  */
-  int register_offsets[57];	/* Must match MICROBLAZE_NUM_REGS.  */
+  int register_offsets[59];	/* Must match MICROBLAZE_NUM_REGS.  */
 
   /* Table of saved registers.  */
   struct trad_frame_saved_reg *saved_regs;
@@ -107,7 +107,9 @@ enum microblaze_regnum
   MICROBLAZE_RTLBX_REGNUM,
   MICROBLAZE_RTLBSX_REGNUM,
   MICROBLAZE_RTLBLO_REGNUM,
-  MICROBLAZE_RTLBHI_REGNUM
+  MICROBLAZE_RTLBHI_REGNUM,
+  MICROBLAZE_SLR_REGNUM,
+  MICROBLAZE_SHR_REGNUM
 };
 
 /* All registers are 32 bits.  */
@@ -116,5 +118,6 @@ enum microblaze_regnum
 /* MICROBLAZE_BREAKPOINT defines the breakpoint that should be used.
    Only used for native debugging.  */
 #define MICROBLAZE_BREAKPOINT {0xb9, 0xcc, 0x00, 0x60}
+#define MICROBLAZE_BREAKPOINT_LE {0x60, 0x00, 0xcc, 0xb9}
 
 #endif /* microblaze-tdep.h */
diff --git a/gdb/regformats/reg-microblaze.dat b/gdb/regformats/reg-microblaze.dat
new file mode 100644
index 0000000..a5dd0a0
--- /dev/null
+++ b/gdb/regformats/reg-microblaze.dat
@@ -0,0 +1,39 @@
+name:microblaze
+expedite:r1,pc
+32:r0
+32:r1
+32:r2
+32:r3
+32:r4
+32:r5
+32:r6
+32:r7
+32:r8
+32:r9
+32:r10
+32:r11
+32:r12
+32:r13
+32:r14
+32:r15
+32:r16
+32:r17
+32:r18
+32:r19
+32:r20
+32:r21
+32:r22
+32:r23
+32:r24
+32:r25
+32:r26
+32:r27
+32:r28
+32:r29
+32:r30
+32:r31
+32:pc
+32:msr
+32:ear
+32:esr
+32:fsr
diff --git a/include/elf/microblaze.h b/include/elf/microblaze.h
index d392231..f59d925 100644
--- a/include/elf/microblaze.h
+++ b/include/elf/microblaze.h
@@ -50,6 +50,15 @@ START_RELOC_NUMBERS (elf_microblaze_reloc_type)
   RELOC_NUMBER (R_MICROBLAZE_GOTOFF_64, 19) /* Offset relative to GOT.  */
   RELOC_NUMBER (R_MICROBLAZE_GOTOFF_32, 20) /* Offset relative to GOT.  */
   RELOC_NUMBER (R_MICROBLAZE_COPY, 21)      /* Runtime copy.  */
+  RELOC_NUMBER (R_MICROBLAZE_TLS, 22)       /* TLS Reloc */
+  RELOC_NUMBER (R_MICROBLAZE_TLSGD, 23)     /* TLS General Dynamic */
+  RELOC_NUMBER (R_MICROBLAZE_TLSLD, 24)     /* TLS Local Dynamic */
+  RELOC_NUMBER (R_MICROBLAZE_TLSDTPMOD32, 25)  /* TLS Module ID */
+  RELOC_NUMBER (R_MICROBLAZE_TLSDTPREL32, 26)  /* TLS Offset Within TLS Block */
+  RELOC_NUMBER (R_MICROBLAZE_TLSDTPREL64, 27)  /* TLS Offset Within TLS Block */
+  RELOC_NUMBER (R_MICROBLAZE_TLSGOTTPREL32, 28)   /* TLS Offset From Thread Pointer */
+  RELOC_NUMBER (R_MICROBLAZE_TLSTPREL32, 29)   /* TLS Offset From Thread Pointer */
+  RELOC_NUMBER (R_MICROBLAZE_32_NONE, 30)
    
 END_RELOC_NUMBERS (R_MICROBLAZE_max)
 
diff --git a/opcodes/microblaze-dis.c b/opcodes/microblaze-dis.c
index 1bbeead..4e5686b 100644
--- a/opcodes/microblaze-dis.c
+++ b/opcodes/microblaze-dis.c
@@ -65,6 +65,15 @@ get_field_imm5 (long instr)
 }
 
 static char *
+get_field_imm5_mbar (long instr)
+{
+  char tmpstr[25];
+
+  sprintf(tmpstr, "%d", (short)((instr & IMM5_MBAR_MASK) >> IMM_MBAR));
+  return(strdup(tmpstr));
+}
+
+static char *
 get_field_rfsl (long instr)
 {
   char tmpstr[25];
@@ -130,6 +139,12 @@ get_field_special (long instr, struct op_code_struct * op)
     case REG_TLBSX_MASK :
       strcpy (spr, "tlbsx");
       break;
+    case REG_SHR_MASK :
+      strcpy (spr, "shr");
+      break;
+    case REG_SLR_MASK :
+      strcpy (spr, "slr");
+      break;
     default :
       if (((((instr & IMM_MASK) >> IMM_LOW) ^ op->immval_mask) & 0xE000)
           == REG_PVR_MASK)
@@ -368,12 +383,16 @@ print_insn_microblaze (bfd_vma memaddr, struct disassemble_info * info)
 	case INST_TYPE_R1:
 	  print_func (stream, "\t%s", get_field_r1 (inst));
 	  break;
-	case INST_TYPE_RD_R1_SPECIAL:
-	  print_func (stream, "\t%s, %s", get_field_rd (inst), get_field_r2 (inst));
+	case INST_TYPE_R1_R2_SPECIAL:
+	  print_func (stream, "\t%s, %s", get_field_r1 (inst), get_field_r2 (inst));
 	  break;
 	case INST_TYPE_RD_IMM15:
 	  print_func (stream, "\t%s, %s", get_field_rd (inst), get_field_imm15 (inst));
 	  break;
+        /* For mbar insn.  */
+        case INST_TYPE_IMM5:
+          print_func (stream, "\t%s", get_field_imm5_mbar (inst));
+          break;
 	/* For tuqula instruction */
 	case INST_TYPE_RD:
 	  print_func (stream, "\t%s", get_field_rd (inst));
diff --git a/opcodes/microblaze-opc.h b/opcodes/microblaze-opc.h
old mode 100644
new mode 100755
index 02ac83f..4bb2f6b
--- a/opcodes/microblaze-opc.h
+++ b/opcodes/microblaze-opc.h
@@ -45,7 +45,7 @@
 #define INST_TYPE_R1_RFSL    15
 
 /* New insn type for insn cache.  */
-#define INST_TYPE_RD_R1_SPECIAL 16
+#define INST_TYPE_R1_R2_SPECIAL 16
 
 /* New insn type for msrclr, msrset insns.  */
 #define INST_TYPE_RD_IMM15    17
@@ -56,6 +56,9 @@
 /* New insn type for t*put.  */
 #define INST_TYPE_RFSL  19
 
+/* For mbar.  */
+#define INST_TYPE_IMM5 20
+
 #define INST_TYPE_NONE 25
 
 
@@ -76,8 +79,8 @@
 #define OPCODE_MASK_H2  0xFC1F0000  /* High 6 and bits 20-16.  */
 #define OPCODE_MASK_H12 0xFFFF0000  /* High 16.  */
 #define OPCODE_MASK_H4  0xFC0007FF  /* High 6 and low 11 bits.  */
-#define OPCODE_MASK_H13S 0xFFE0EFF0 /* High 11 and 15:1 bits and last 
-				       nibble of last byte for spr.  */
+#define OPCODE_MASK_H13S 0xFFE0E7F0 /* High 11 16:18 21:27 bits, 19:20 bits
+                                       and last nibble of last byte for spr.  */
 #define OPCODE_MASK_H23S 0xFC1FC000 /* High 6, 20-16 and 15:1 bits and last 
 				       nibble of last byte for spr.  */
 #define OPCODE_MASK_H34 0xFC00FFFF  /* High 6 and low 16 bits.  */
@@ -92,11 +95,13 @@
 
 /* New Mask for msrset, msrclr insns.  */
 #define OPCODE_MASK_H23N  0xFC1F8000 /* High 6 and bits 11 - 16.  */
+/* Mask for mbar insn.  */
+#define OPCODE_MASK_HN 0xFC020004 /* High 6 bits and bits 14, 29.  */
 
 #define DELAY_SLOT 1
 #define NO_DELAY_SLOT 0
 
-#define MAX_OPCODES 280
+#define MAX_OPCODES 286
 
 struct op_code_struct
 {
@@ -166,10 +171,11 @@ struct op_code_struct
   {"srl",   INST_TYPE_RD_R1, INST_NO_OFFSET, NO_DELAY_SLOT, IMMVAL_MASK_NON_SPECIAL, 0x90000041, OPCODE_MASK_H34, srl, logical_inst },
   {"sext8", INST_TYPE_RD_R1, INST_NO_OFFSET, NO_DELAY_SLOT, IMMVAL_MASK_NON_SPECIAL, 0x90000060, OPCODE_MASK_H34, sext8, logical_inst },
   {"sext16",INST_TYPE_RD_R1, INST_NO_OFFSET, NO_DELAY_SLOT, IMMVAL_MASK_NON_SPECIAL, 0x90000061, OPCODE_MASK_H34, sext16, logical_inst },
-  {"wic",   INST_TYPE_RD_R1_SPECIAL, INST_NO_OFFSET, NO_DELAY_SLOT, IMMVAL_MASK_NON_SPECIAL, 0x90000068, OPCODE_MASK_H34B, wic, special_inst },
-  {"wdc",   INST_TYPE_RD_R1_SPECIAL, INST_NO_OFFSET, NO_DELAY_SLOT, IMMVAL_MASK_NON_SPECIAL, 0x90000064, OPCODE_MASK_H34B, wdc, special_inst },
-  {"wdc.clear", INST_TYPE_RD_R1_SPECIAL, INST_NO_OFFSET, NO_DELAY_SLOT, IMMVAL_MASK_NON_SPECIAL, 0x90000066, OPCODE_MASK_H34B, wdcclear, special_inst },    
-  {"wdc.flush", INST_TYPE_RD_R1_SPECIAL, INST_NO_OFFSET, NO_DELAY_SLOT, IMMVAL_MASK_NON_SPECIAL, 0x90000074, OPCODE_MASK_H34B, wdcflush, special_inst },
+  {"wic",   INST_TYPE_R1_R2_SPECIAL, INST_NO_OFFSET, NO_DELAY_SLOT, IMMVAL_MASK_NON_SPECIAL, 0x90000068, OPCODE_MASK_H34B, wic, special_inst },
+  {"wdc",   INST_TYPE_R1_R2_SPECIAL, INST_NO_OFFSET, NO_DELAY_SLOT, IMMVAL_MASK_NON_SPECIAL, 0x90000064, OPCODE_MASK_H34B, wdc, special_inst },
+  {"mbar",  INST_TYPE_IMM5, INST_PC_OFFSET, NO_DELAY_SLOT, IMMVAL_MASK_NON_SPECIAL, 0xB8020004, OPCODE_MASK_HN, mbar, special_inst },
+  {"wdc.clear", INST_TYPE_R1_R2_SPECIAL, INST_NO_OFFSET, NO_DELAY_SLOT, IMMVAL_MASK_NON_SPECIAL, 0x90000066, OPCODE_MASK_H34B, wdcclear, special_inst },    
+  {"wdc.flush", INST_TYPE_R1_R2_SPECIAL, INST_NO_OFFSET, NO_DELAY_SLOT, IMMVAL_MASK_NON_SPECIAL, 0x90000074, OPCODE_MASK_H34B, wdcflush, special_inst },
   {"mts",   INST_TYPE_SPECIAL_R1, INST_NO_OFFSET, NO_DELAY_SLOT, IMMVAL_MASK_MTS, 0x9400C000, OPCODE_MASK_H13S, mts, special_inst },
   {"mfs",   INST_TYPE_RD_SPECIAL, INST_NO_OFFSET, NO_DELAY_SLOT, IMMVAL_MASK_MFS, 0x94008000, OPCODE_MASK_H23S, mfs, special_inst },
   {"br",    INST_TYPE_R2, INST_PC_OFFSET, NO_DELAY_SLOT, IMMVAL_MASK_NON_SPECIAL, 0x98000000, OPCODE_MASK_H124, br, branch_inst },
@@ -220,12 +226,18 @@ struct op_code_struct
   {"bgei",  INST_TYPE_R1_IMM, INST_PC_OFFSET, NO_DELAY_SLOT, IMMVAL_MASK_NON_SPECIAL, 0xBCA00000, OPCODE_MASK_H1, bgei, branch_inst },
   {"bgeid", INST_TYPE_R1_IMM, INST_PC_OFFSET, DELAY_SLOT, IMMVAL_MASK_NON_SPECIAL, 0xBEA00000, OPCODE_MASK_H1, bgeid, branch_inst },
   {"lbu",   INST_TYPE_RD_R1_R2, INST_NO_OFFSET, NO_DELAY_SLOT, IMMVAL_MASK_NON_SPECIAL, 0xC0000000, OPCODE_MASK_H4, lbu, memory_load_inst },
+  {"lbur",  INST_TYPE_RD_R1_R2, INST_NO_OFFSET, NO_DELAY_SLOT, IMMVAL_MASK_NON_SPECIAL, 0xC0000200, OPCODE_MASK_H4, lbur, memory_load_inst },
   {"lhu",   INST_TYPE_RD_R1_R2, INST_NO_OFFSET, NO_DELAY_SLOT, IMMVAL_MASK_NON_SPECIAL, 0xC4000000, OPCODE_MASK_H4, lhu, memory_load_inst },
+  {"lhur",  INST_TYPE_RD_R1_R2, INST_NO_OFFSET, NO_DELAY_SLOT, IMMVAL_MASK_NON_SPECIAL, 0xC4000200, OPCODE_MASK_H4, lhur, memory_load_inst },
   {"lw",    INST_TYPE_RD_R1_R2, INST_NO_OFFSET, NO_DELAY_SLOT, IMMVAL_MASK_NON_SPECIAL, 0xC8000000, OPCODE_MASK_H4, lw, memory_load_inst },
+  {"lwr",   INST_TYPE_RD_R1_R2, INST_NO_OFFSET, NO_DELAY_SLOT, IMMVAL_MASK_NON_SPECIAL, 0xC8000200, OPCODE_MASK_H4, lwr, memory_load_inst },
   {"lwx",   INST_TYPE_RD_R1_R2, INST_NO_OFFSET, NO_DELAY_SLOT, IMMVAL_MASK_NON_SPECIAL, 0xC8000400, OPCODE_MASK_H4, lwx, memory_load_inst },
   {"sb",    INST_TYPE_RD_R1_R2, INST_NO_OFFSET, NO_DELAY_SLOT, IMMVAL_MASK_NON_SPECIAL, 0xD0000000, OPCODE_MASK_H4, sb, memory_store_inst },
+  {"sbr",   INST_TYPE_RD_R1_R2, INST_NO_OFFSET, NO_DELAY_SLOT, IMMVAL_MASK_NON_SPECIAL, 0xD0000200, OPCODE_MASK_H4, sbr, memory_store_inst },
   {"sh",    INST_TYPE_RD_R1_R2, INST_NO_OFFSET, NO_DELAY_SLOT, IMMVAL_MASK_NON_SPECIAL, 0xD4000000, OPCODE_MASK_H4, sh, memory_store_inst },
+  {"shr",   INST_TYPE_RD_R1_R2, INST_NO_OFFSET, NO_DELAY_SLOT, IMMVAL_MASK_NON_SPECIAL, 0xD4000200, OPCODE_MASK_H4, shr, memory_store_inst },
   {"sw",    INST_TYPE_RD_R1_R2, INST_NO_OFFSET, NO_DELAY_SLOT, IMMVAL_MASK_NON_SPECIAL, 0xD8000000, OPCODE_MASK_H4, sw, memory_store_inst },
+  {"swr",   INST_TYPE_RD_R1_R2, INST_NO_OFFSET, NO_DELAY_SLOT, IMMVAL_MASK_NON_SPECIAL, 0xD8000200, OPCODE_MASK_H4, swr, memory_store_inst },
   {"swx",   INST_TYPE_RD_R1_R2, INST_NO_OFFSET, NO_DELAY_SLOT, IMMVAL_MASK_NON_SPECIAL, 0xD8000400, OPCODE_MASK_H4, swx, memory_store_inst },
   {"lbui",  INST_TYPE_RD_R1_IMM, INST_NO_OFFSET, NO_DELAY_SLOT, IMMVAL_MASK_NON_SPECIAL, 0xE0000000, OPCODE_MASK_H, lbui, memory_load_inst },
   {"lhui",  INST_TYPE_RD_R1_IMM, INST_NO_OFFSET, NO_DELAY_SLOT, IMMVAL_MASK_NON_SPECIAL, 0xE4000000, OPCODE_MASK_H, lhui, memory_load_inst },
@@ -256,6 +268,8 @@ struct op_code_struct
   {"fcmp.ge", INST_TYPE_RD_R1_R2, INST_NO_OFFSET, NO_DELAY_SLOT, IMMVAL_MASK_NON_SPECIAL, 0x58000260, OPCODE_MASK_H4, fcmp_ge, arithmetic_inst },
   {"fcmp.un", INST_TYPE_RD_R1_R2, INST_NO_OFFSET, NO_DELAY_SLOT, IMMVAL_MASK_NON_SPECIAL, 0x58000200, OPCODE_MASK_H4, fcmp_un, arithmetic_inst },
   {"flt",   INST_TYPE_RD_R1, INST_NO_OFFSET, NO_DELAY_SLOT, IMMVAL_MASK_NON_SPECIAL, 0x58000280, OPCODE_MASK_H4, flt,   arithmetic_inst },
+  {"swapb",   INST_TYPE_RD_R1, INST_NO_OFFSET, NO_DELAY_SLOT, IMMVAL_MASK_NON_SPECIAL, 0x900001E0, OPCODE_MASK_H4, swapb,   arithmetic_inst },
+  {"swaph",   INST_TYPE_RD_R1, INST_NO_OFFSET, NO_DELAY_SLOT, IMMVAL_MASK_NON_SPECIAL, 0x900001E2, OPCODE_MASK_H4, swaph,   arithmetic_inst },
   {"fint",  INST_TYPE_RD_R1, INST_NO_OFFSET, NO_DELAY_SLOT, IMMVAL_MASK_NON_SPECIAL, 0x58000300, OPCODE_MASK_H4, fint,  arithmetic_inst },
   {"fsqrt", INST_TYPE_RD_R1, INST_NO_OFFSET, NO_DELAY_SLOT, IMMVAL_MASK_NON_SPECIAL, 0x58000380, OPCODE_MASK_H4, fsqrt, arithmetic_inst },
   {"tget",   INST_TYPE_RD_RFSL, INST_NO_OFFSET, NO_DELAY_SLOT, IMMVAL_MASK_NON_SPECIAL, 0x6C001000, OPCODE_MASK_H32, tget,   anyware_inst },
@@ -388,6 +402,7 @@ struct op_code_struct
   {"tneaputd",  INST_TYPE_R2,    INST_NO_OFFSET, NO_DELAY_SLOT, IMMVAL_MASK_NON_SPECIAL, 0x4C0006E0, OPCODE_MASK_H34C, tneaputd,  anyware_inst },
   {"necaputd",  INST_TYPE_R1_R2, INST_NO_OFFSET, NO_DELAY_SLOT, IMMVAL_MASK_NON_SPECIAL, 0x4C000760, OPCODE_MASK_H34C, necaputd,  anyware_inst },
   {"tnecaputd", INST_TYPE_R2,    INST_NO_OFFSET, NO_DELAY_SLOT, IMMVAL_MASK_NON_SPECIAL, 0x4C0007E0, OPCODE_MASK_H34C, tnecaputd, anyware_inst },
+  {"clz",      INST_TYPE_RD_R1, INST_NO_OFFSET, NO_DELAY_SLOT, IMMVAL_MASK_NON_SPECIAL, 0x900000E0, OPCODE_MASK_H34, clz, special_inst },
   {"", 0, 0, 0, 0, 0, 0, 0, 0},
 };
 
@@ -405,5 +420,8 @@ char pvr_register_prefix[] = "rpvr";
 #define MIN_IMM15 ((int) 0x0000)
 #define MAX_IMM15 ((int) 0x7fff)
 
+#define MIN_IMM5  ((int) 0x00000000)
+#define MAX_IMM5  ((int) 0x0000001f)
+
 #endif /* MICROBLAZE_OPC */
 
diff --git a/opcodes/microblaze-opcm.h b/opcodes/microblaze-opcm.h
old mode 100644
new mode 100755
index 10acacf..71de752
--- a/opcodes/microblaze-opcm.h
+++ b/opcodes/microblaze-opcm.h
@@ -25,18 +25,18 @@
 
 enum microblaze_instr
 {
-  add, rsub, addc, rsubc, addk, rsubk, addkc, rsubkc, cmp, cmpu,
+  add, rsub, addc, rsubc, addk, rsubk, addkc, rsubkc, clz, cmp, cmpu,
   addi, rsubi, addic, rsubic, addik, rsubik, addikc, rsubikc, mul, 
-  mulh, mulhu, mulhsu,
+  mulh, mulhu, mulhsu,swapb,swaph,
   idiv, idivu, bsll, bsra, bsrl, get, put, nget, nput, cget, cput,
   ncget, ncput, muli, bslli, bsrai, bsrli, mului, or, and, xor,
   andn, pcmpbf, pcmpbc, pcmpeq, pcmpne, sra, src, srl, sext8, sext16, 
-  wic, wdc, wdcclear, wdcflush, mts, mfs, br, brd,
+  wic, wdc, wdcclear, wdcflush, mts, mfs, mbar, br, brd,
   brld, bra, brad, brald, microblaze_brk, beq, beqd, bne, bned, blt,
   bltd, ble, bled, bgt, bgtd, bge, bged, ori, andi, xori, andni,
   imm, rtsd, rtid, rtbd, rted, bri, brid, brlid, brai, braid, bralid,
   brki, beqi, beqid, bnei, bneid, blti, bltid, blei, bleid, bgti,
-  bgtid, bgei, bgeid, lbu, lhu, lw, lwx, sb, sh, sw, swx, lbui, lhui, lwi,
+  bgtid, bgei, bgeid, lbu, lbur, lhu, lhur, lw, lwr, lwx, sb, sbr, sh, shr, sw, swr, swx, lbui, lhui, lwi,
   sbi, shi, swi, msrset, msrclr, tuqula, fadd, frsub, fmul, fdiv, 
   fcmp_lt, fcmp_eq, fcmp_le, fcmp_gt, fcmp_ne, fcmp_ge, fcmp_un, flt, 
   fint, fsqrt, 
@@ -78,6 +78,8 @@ enum microblaze_instr_type
 #define REG_BTR_MASK 0x800b
 #define REG_EDR_MASK 0x800d
 #define REG_PVR_MASK 0xa000
+#define REG_SLR_MASK 0x8800
+#define REG_SHR_MASK 0x8802
 
 #define REG_PID_MASK   0x9000
 #define REG_ZPR_MASK   0x9001
@@ -99,6 +101,8 @@ enum microblaze_instr_type
 #define REG_FSR 39 /* FPU Status reg.  */
 #define REG_BTR 43 /* Branch Target reg.  */
 #define REG_EDR 45 /* Exception reg.  */
+#define REG_SHR 50 /* Stack High reg.  */
+#define REG_SLR 51 /* Stack Low reg.  */
 #define REG_PVR 40960 /* Program Verification reg.  */
 
 #define REG_PID   36864 /* MMU: Process ID reg.  */
@@ -121,6 +125,7 @@ enum microblaze_instr_type
 #define RA_LOW  16 /* Low bit for RA.  */
 #define RB_LOW  11 /* Low bit for RB.  */
 #define IMM_LOW  0 /* Low bit for immediate.  */
+#define IMM_MBAR 21 /* low bit for mbar instruction.  */
 
 #define RD_MASK 0x03E00000
 #define RA_MASK 0x001F0000
@@ -130,6 +135,9 @@ enum microblaze_instr_type
 /* Imm mask for barrel shifts.  */
 #define IMM5_MASK 0x0000001F
 
+/* Imm mask for mbar.  */
+#define IMM5_MBAR_MASK 0x03E00000
+
 /* FSL imm mask for get, put instructions.  */
 #define  RFSL_MASK 0x000000F
 
diff --git a/sim/configure b/sim/configure
index 8fb62cb..117f1b3 100755
--- a/sim/configure
+++ b/sim/configure
@@ -3735,7 +3735,7 @@ subdirs="$subdirs arm"
 
        sim_testsuite=yes
        ;;
-   microblaze-*-*)
+   microblaze*-*-*)
 
   sim_arch=microblaze
   subdirs="$subdirs microblaze"
diff --git a/sim/configure.tgt b/sim/configure.tgt
index a12319d..c888ff1 100644
--- a/sim/configure.tgt
+++ b/sim/configure.tgt
@@ -69,7 +69,7 @@ case "${target}" in
        SIM_ARCH(mcore)
        sim_testsuite=yes
        ;;
-   microblaze-*-*)
+   microblaze*-*-*)
        SIM_ARCH(microblaze)
        sim_testsuite=yes
        ;;
-- 
1.7.1

